/*!-----------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.8.0(3397234a858a6eced8f36cef8a16c75c32aab619)
 * Released under the MIT license
 * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt
 *-----------------------------------------------------------*/

(function() {
var __m = ["exports","require","vs/editor/common/editorCommon","vs/base/common/lifecycle","vs/editor/common/core/range","vs/css!vs/editor/editor.main","vs/base/common/winjs.base","vs/nls","vs/nls!vs/editor/editor.main","vs/base/common/strings","vs/base/common/errors","vs/base/browser/dom","vs/base/common/event","vs/editor/common/editorCommonExtensions","vs/platform/instantiation/common/instantiation","vs/editor/common/modes","vs/editor/common/core/position","vs/base/common/async","vs/platform/contextkey/common/contextkey","vs/base/common/platform","vs/editor/common/core/selection","vs/editor/browser/editorBrowser","vs/platform/commands/common/commands","vs/base/browser/browser","vs/base/common/types","vs/base/common/eventEmitter","vs/editor/browser/editorBrowserExtensions","vs/base/common/uri","vs/base/common/arrays","vs/base/browser/styleMutator","vs/base/common/severity","vs/editor/browser/view/viewPart","vs/base/common/keyCodes","vs/base/browser/builder","vs/base/browser/mouseEvent","vs/platform/platform","vs/base/common/objects","vs/editor/common/modes/languageConfigurationRegistry","vs/base/common/scrollable","vs/base/common/paths","vs/base/browser/ui/widget","vs/editor/common/controller/cursorCommon","vs/platform/keybinding/common/keybinding","vs/editor/common/services/modelService","vs/editor/common/config/defaultConfig","vs/editor/common/services/codeEditorService","vs/editor/common/core/editOperation","vs/editor/common/viewModel/viewEventHandler","vs/editor/browser/view/dynamicViewOverlay","vs/platform/message/common/message","vs/base/common/actions","vs/base/browser/keyboardEvent","vs/editor/common/services/editorWorkerService","vs/platform/telemetry/common/telemetry","vs/editor/common/modes/languageConfiguration","vs/editor/browser/config/configuration","vs/platform/configuration/common/configuration","vs/platform/editor/common/editor","vs/platform/contextview/browser/contextView","vs/platform/actions/common/actions","vs/base/browser/ui/scrollbar/scrollableElement","vs/base/browser/touch","vs/editor/common/commands/replaceCommand","vs/base/common/assert","vs/editor/common/modes/nullMode","vs/editor/common/core/characterClassifier","vs/editor/common/services/resolverService","vs/base/common/events","vs/platform/keybinding/common/keybindingsRegistry","vs/base/browser/ui/actionbar/actionbar","vs/base/common/network","vs/platform/opener/common/opener","vs/platform/markers/common/markers","vs/editor/common/modes/supports/richEditBrackets","vs/editor/common/model/wordHelper","vs/editor/common/model/modelLine","vs/editor/common/core/lineTokens","vs/editor/common/core/viewLineToken","vs/editor/common/services/standaloneColorService","vs/platform/instantiation/common/serviceCollection","vs/editor/common/core/uint","vs/editor/common/modes/supports","vs/editor/common/core/token","vs/editor/common/view/renderingContext","vs/base/parts/quickopen/common/quickOpen","vs/editor/common/viewModel/prefixSumComputer","vs/base/common/filters","vs/base/parts/tree/browser/treeDefaults","vs/base/common/iterator","vs/editor/common/services/modeService","vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/base/common/collections","vs/editor/contrib/referenceSearch/browser/referencesModel","vs/editor/contrib/snippet/common/snippet","vs/editor/common/model/textModel","vs/base/common/diff/diff","vs/editor/common/controller/cursorMoveOperations","vs/platform/workspace/common/workspace","vs/base/browser/ui/sash/sash","vs/base/browser/ui/aria/aria","vs/base/browser/ui/inputbox/inputBox","vs/editor/browser/viewParts/glyphMargin/glyphMargin","vs/base/browser/globalMouseMoveMonitor","vs/base/browser/htmlContentRenderer","vs/editor/browser/editorDom","vs/base/parts/quickopen/browser/quickOpenModel","vs/editor/common/config/editorZoom","vs/editor/common/config/fontInfo","vs/base/common/map","vs/base/common/htmlContent","vs/base/browser/ui/highlightedlabel/highlightedLabel","vs/editor/common/modes/modesRegistry","vs/editor/common/config/commonEditorConfig","vs/base/common/idGenerator","vs/base/browser/ui/scrollbar/scrollbarArrow","vs/editor/browser/standalone/simpleServices","vs/editor/common/viewLayout/viewLineParts","vs/editor/common/viewLayout/viewLineRenderer","vs/editor/contrib/quickOpen/browser/editorQuickOpen","vs/editor/contrib/suggest/common/suggest","vs/editor/browser/codeEditor","vs/base/browser/event","vs/editor/contrib/diffNavigator/common/diffNavigator","vs/editor/common/controller/cursorDeleteOperations","vs/editor/common/controller/cursorWordOperations","vs/editor/common/controller/oneCursor","vs/editor/common/model/model","vs/css!vs/base/browser/ui/progressbar/progressbar","vs/editor/common/services/editorWorkerServiceImpl","vs/editor/browser/viewParts/overviewRuler/overviewRulerImpl","vs/editor/common/viewModel/splitLinesCollection","vs/base/browser/ui/scrollbar/scrollbarState","vs/base/common/keybinding","vs/editor/common/modes/textToHtmlTokenizer","vs/editor/browser/controller/mouseTarget","vs/editor/browser/view/viewLayer","vs/editor/common/standalone/standaloneBase","vs/editor/contrib/find/common/findModel","vs/base/common/cancellation","vs/base/parts/tree/browser/treeImpl","vs/base/browser/ui/scrollbar/abstractScrollbar","vs/editor/common/model/tokensBinaryEncoding","vs/platform/keybinding/common/keybindingResolver","vs/platform/instantiation/common/descriptors","vs/editor/browser/standalone/colorizer","vs/base/common/marshalling","vs/editor/common/viewModel/viewModel","vs/editor/contrib/comment/common/blockCommentCommand","vs/base/common/worker/simpleWorker","vs/editor/common/modes/snippetsRegistry","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/platform/extensions/common/extensionsRegistry","vs/platform/configuration/common/configurationRegistry","vs/editor/contrib/hover/browser/hoverOperation","vs/editor/contrib/hover/browser/hoverWidgets","vs/base/browser/iframe","vs/base/common/labels","vs/editor/common/config/config","vs/platform/progress/common/progress","vs/platform/storage/common/storage","vs/editor/contrib/zoneWidget/browser/zoneWidget","vs/editor/common/editorAction","vs/editor/contrib/find/common/findController","vs/editor/contrib/parameterHints/common/parameterHints","vs/base/common/glob","vs/editor/contrib/snippet/common/snippetController","vs/editor/common/controller/textAreaState","vs/editor/browser/widget/codeEditorWidget","vs/editor/common/modes/monarch/monarchCommon","vs/editor/browser/widget/diffEditorWidget","vs/editor/browser/widget/embeddedCodeEditorWidget","vs/base/browser/ui/contextview/contextview","vs/base/browser/ui/iconLabel/iconLabel","vs/editor/browser/standalone/standaloneServices","vs/editor/contrib/referenceSearch/browser/referencesController","vs/base/parts/quickopen/browser/quickOpenViewer","vs/nls!vs/base/common/keybinding","vs/editor/common/modes/abstractMode","vs/base/parts/tree/browser/tree","vs/editor/common/modes/languageSelector","vs/editor/common/modes/languageFeatureRegistry","vs/base/parts/tree/browser/treeDnd","vs/editor/common/modes/linkComputer","vs/base/parts/tree/browser/treeModel","vs/editor/common/modes/monarch/monarchCompile","vs/base/parts/tree/browser/treeViewModel","vs/editor/common/modes/monarch/monarchLexer","vs/base/worker/defaultWorkerFactory","vs/editor/common/modes/supports/characterPair","vs/editor/common/modes/supports/inplaceReplaceSupport","vs/editor/common/modes/supports/onEnter","vs/css!vs/base/browser/builder","vs/editor/common/modes/supports/electricCharacter","vs/base/browser/ui/list/rangeMap","vs/editor/common/modes/supports/tokenization","vs/base/common/functional","vs/editor/common/services/abstractCodeEditorService","vs/css!vs/base/browser/ui/actionbar/actionbar","vs/editor/common/standalone/themes","vs/editor/browser/services/standaloneColorServiceImpl","vs/css!vs/base/browser/ui/aria/aria","vs/editor/browser/viewParts/lines/rangeUtil","vs/editor/common/view/viewContext","vs/css!vs/base/browser/ui/checkbox/checkbox","vs/base/browser/ui/checkbox/checkbox","vs/css!vs/base/browser/ui/contextview/contextview","vs/editor/browser/viewParts/lines/viewLine","vs/editor/common/viewLayout/viewLinesViewportData","vs/editor/common/viewLayout/whitespaceComputer","vs/editor/common/viewLayout/verticalObjects","vs/editor/common/viewLayout/linesLayout","vs/base/common/hash","vs/editor/common/model/mirrorModel2","vs/editor/common/services/editorSimpleWorker","vs/css!vs/base/browser/ui/countBadge/countBadge","vs/editor/contrib/caretOperations/common/moveCaretCommand","vs/base/browser/ui/countBadge/countBadge","vs/editor/contrib/comment/common/lineCommentCommand","vs/css!vs/base/browser/ui/findinput/findInput","vs/editor/contrib/find/common/findState","vs/editor/contrib/find/common/replaceAllCommand","vs/editor/contrib/find/common/replacePattern","vs/editor/contrib/folding/common/folding","vs/editor/contrib/folding/common/indentFoldStrategy","vs/editor/contrib/format/common/formatCommand","vs/css!vs/base/browser/ui/iconLabel/iconlabel","vs/editor/contrib/referenceSearch/browser/referenceSearch","vs/editor/contrib/inPlaceReplace/common/inPlaceReplaceCommand","vs/editor/contrib/linesOperations/common/copyLinesCommand","vs/editor/contrib/linesOperations/common/deleteLinesCommand","vs/editor/contrib/linesOperations/common/moveLinesCommand","vs/editor/contrib/linesOperations/common/sortLinesCommand","vs/editor/contrib/quickFix/browser/quickFixWidget","vs/css!vs/base/browser/ui/inputbox/inputBox","vs/editor/contrib/smartSelect/common/tokenTree","vs/editor/contrib/snippet/browser/snippet","vs/editor/contrib/snippet/common/snippetParser","vs/css!vs/base/browser/ui/leftRightWidget/leftRightWidget","vs/editor/contrib/snippet/common/snippetVariables","vs/editor/contrib/suggest/common/completionModel","vs/base/browser/ui/leftRightWidget/leftRightWidget","vs/nls!vs/base/browser/ui/actionbar/actionbar","vs/css!vs/base/browser/ui/list/list","vs/css!vs/base/browser/ui/menu/menu","vs/base/common/marked/marked","vs/base/browser/ui/menu/menu","vs/nls!vs/base/browser/ui/aria/aria","vs/base/browser/ui/progressbar/progressbar","vs/nls!vs/base/browser/ui/findinput/findInput","vs/nls!vs/base/browser/ui/inputbox/inputBox","vs/css!vs/base/browser/ui/sash/sash","vs/base/browser/ui/findinput/findInput","vs/nls!vs/base/common/json","vs/base/common/json","vs/base/common/callbackList","vs/css!vs/base/browser/ui/scrollbar/media/scrollbars","vs/nls!vs/base/common/severity","vs/editor/browser/editor.all","vs/editor/contrib/quickFix/browser/lightBulbWidget","vs/nls!vs/base/parts/quickopen/browser/quickOpenModel","vs/nls!vs/base/parts/quickopen/browser/quickOpenWidget","vs/nls!vs/base/parts/tree/browser/treeDefaults","vs/base/browser/ui/list/listView","vs/base/browser/ui/list/listWidget","vs/base/parts/tree/browser/treeView","vs/base/parts/quickopen/browser/quickOpenWidget","vs/editor/contrib/quickOpen/browser/quickOpenEditorWidget","vs/nls!vs/editor/common/config/commonEditorConfig","vs/nls!vs/editor/common/config/defaultConfig","vs/css!vs/base/browser/ui/selectBox/selectBox","vs/base/browser/ui/selectBox/selectBox","vs/nls!vs/editor/common/controller/cursor","vs/nls!vs/editor/common/model/textModelWithTokens","vs/nls!vs/editor/common/modes/modesRegistry","vs/nls!vs/editor/common/modes/snippetsRegistry","vs/nls!vs/editor/common/services/bulkEdit","vs/editor/common/services/bulkEdit","vs/nls!vs/editor/common/services/modeServiceImpl","vs/nls!vs/editor/common/services/modelServiceImpl","vs/nls!vs/editor/contrib/bracketMatching/common/bracketMatching","vs/nls!vs/editor/contrib/caretOperations/common/caretOperations","vs/nls!vs/editor/contrib/clipboard/browser/clipboard","vs/nls!vs/editor/contrib/comment/common/comment","vs/nls!vs/editor/contrib/contextmenu/browser/contextmenu","vs/nls!vs/editor/contrib/find/browser/findWidget","vs/nls!vs/editor/contrib/find/common/findController","vs/nls!vs/editor/contrib/folding/browser/folding","vs/nls!vs/editor/contrib/format/common/formatActions","vs/nls!vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/nls!vs/editor/contrib/gotoError/browser/gotoError","vs/nls!vs/editor/contrib/hover/browser/hover","vs/nls!vs/editor/contrib/hover/browser/modesContentHover","vs/nls!vs/editor/contrib/inPlaceReplace/common/inPlaceReplace","vs/nls!vs/editor/contrib/inspectTokens/browser/inspectTokens","vs/nls!vs/editor/contrib/linesOperations/common/linesOperations","vs/nls!vs/editor/contrib/links/browser/links","vs/nls!vs/editor/contrib/multicursor/common/multicursor","vs/nls!vs/editor/contrib/parameterHints/browser/parameterHints","vs/nls!vs/editor/contrib/parameterHints/browser/parameterHintsWidget","vs/nls!vs/editor/contrib/quickFix/browser/quickFix","vs/nls!vs/editor/contrib/quickOpen/browser/gotoLine","vs/nls!vs/editor/contrib/quickOpen/browser/quickCommand","vs/nls!vs/editor/contrib/quickOpen/browser/quickOutline","vs/nls!vs/editor/contrib/referenceSearch/browser/referenceSearch","vs/nls!vs/editor/contrib/referenceSearch/browser/referencesController","vs/nls!vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/nls!vs/editor/contrib/rename/browser/rename","vs/nls!vs/editor/contrib/rename/browser/renameInputField","vs/editor/contrib/rename/browser/renameInputField","vs/nls!vs/editor/contrib/rename/common/rename","vs/nls!vs/editor/contrib/smartSelect/common/smartSelect","vs/nls!vs/editor/contrib/suggest/browser/suggestController","vs/nls!vs/editor/contrib/suggest/browser/suggestWidget","vs/nls!vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode","vs/nls!vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/nls!vs/platform/configuration/common/configurationRegistry","vs/nls!vs/platform/extensions/common/extensionsRegistry","vs/nls!vs/platform/keybinding/common/abstractKeybindingService","vs/nls!vs/platform/message/common/message","vs/platform/contextview/browser/contextMenuHandler","vs/platform/contextview/browser/contextMenuService","vs/css!vs/base/parts/quickopen/browser/quickopen","vs/css!vs/base/parts/tree/browser/tree","vs/css!vs/editor/browser/standalone/media/standalone-tokens","vs/css!vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight","vs/css!vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight","vs/css!vs/editor/browser/viewParts/decorations/decorations","vs/css!vs/editor/browser/viewParts/glyphMargin/glyphMargin","vs/editor/contrib/smartSelect/common/tokenSelectionSupport","vs/css!vs/editor/browser/viewParts/indentGuides/indentGuides","vs/editor/contrib/links/common/links","vs/css!vs/editor/browser/viewParts/lineNumbers/lineNumbers","vs/css!vs/editor/browser/viewParts/lines/viewLines","vs/css!vs/editor/browser/viewParts/linesDecorations/linesDecorations","vs/css!vs/editor/browser/viewParts/marginDecorations/marginDecorations","vs/css!vs/editor/browser/viewParts/overlayWidgets/overlayWidgets","vs/editor/browser/services/codeEditorServiceImpl","vs/editor/browser/view/viewController","vs/css!vs/editor/browser/viewParts/rulers/rulers","vs/editor/common/controller/textAreaHandler","vs/editor/common/core/editorState","vs/editor/common/model/textModelSearch","vs/css!vs/editor/browser/viewParts/scrollDecoration/scrollDecoration","vs/css!vs/editor/browser/viewParts/selections/selections","vs/editor/common/commands/shiftCommand","vs/editor/common/controller/cursorColumnSelection","vs/css!vs/editor/browser/viewParts/viewCursors/viewCursors","vs/css!vs/editor/browser/widget/media/diffEditor","vs/editor/common/controller/cursorTypeOperations","vs/css!vs/editor/browser/widget/media/editor","vs/css!vs/editor/browser/widget/media/tokens","vs/editor/common/controller/cursorCollection","vs/editor/common/controller/cursor","vs/editor/common/model/textModelWithTokens","vs/editor/common/model/textModelWithMarkers","vs/editor/common/model/textModelWithDecorations","vs/editor/common/model/editableTextModel","vs/css!vs/editor/contrib/bracketMatching/browser/bracketMatching","vs/editor/common/modes/editorModeContext","vs/css!vs/editor/contrib/clipboard/browser/clipboard","vs/css!vs/editor/contrib/codelens/browser/codelens","vs/editor/common/services/webWorker","vs/editor/common/view/overviewZoneManager","vs/css!vs/editor/contrib/find/browser/findWidget","vs/editor/common/viewLayout/editorLayoutProvider","vs/css!vs/editor/contrib/folding/browser/folding","vs/editor/common/viewModel/characterHardWrappingLineMapper","vs/css!vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/css!vs/editor/contrib/gotoError/browser/gotoError","vs/css!vs/editor/contrib/hover/browser/hover","vs/css!vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard","vs/editor/browser/controller/mouseHandler","vs/editor/browser/controller/pointerHandler","vs/css!vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace","vs/editor/browser/view/viewOutgoingEvents","vs/editor/browser/viewLayout/scrollManager","vs/editor/browser/viewLayout/layoutProvider","vs/editor/browser/viewParts/contentWidgets/contentWidgets","vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight","vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight","vs/editor/browser/viewParts/decorations/decorations","vs/css!vs/editor/contrib/inspectTokens/browser/inspectTokens","vs/editor/browser/viewParts/indentGuides/indentGuides","vs/editor/browser/viewParts/lineNumbers/lineNumbers","vs/editor/browser/viewParts/linesDecorations/linesDecorations","vs/editor/browser/viewParts/margin/margin","vs/editor/browser/viewParts/marginDecorations/marginDecorations","vs/editor/browser/viewParts/overlayWidgets/overlayWidgets","vs/editor/browser/viewParts/overviewRuler/overviewRuler","vs/editor/browser/viewParts/rulers/rulers","vs/editor/browser/viewParts/scrollDecoration/scrollDecoration","vs/editor/browser/viewParts/selections/selections","vs/editor/browser/viewParts/viewZones/viewZones","vs/editor/common/viewModel/viewModelCursors","vs/editor/common/viewModel/viewModelDecorations","vs/editor/common/viewModel/viewModelImpl","vs/editor/contrib/find/common/findDecorations","vs/css!vs/editor/contrib/links/browser/links","vs/editor/contrib/folding/common/foldingModel","vs/platform/actions/common/menu","vs/css!vs/editor/contrib/parameterHints/browser/parameterHints","vs/css!vs/editor/contrib/quickFix/browser/lightBulbWidget","vs/platform/files/common/files","vs/css!vs/editor/contrib/quickOpen/browser/gotoLine","vs/editor/common/commonCodeEditor","vs/platform/instantiation/common/instantiationService","vs/platform/keybinding/common/abstractKeybindingService","vs/css!vs/editor/contrib/quickOpen/browser/quickOutline","vs/css!vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/platform/contextkey/browser/contextKeyService","vs/platform/markers/common/markerService","vs/css!vs/editor/contrib/rename/browser/renameInputField","vs/css!vs/editor/contrib/snippet/browser/snippet","vs/platform/opener/browser/openerService","vs/css!vs/editor/contrib/suggest/browser/suggest","vs/editor/contrib/hover/browser/modesGlyphHover","vs/css!vs/editor/contrib/wordHighlighter/browser/wordHighlighter","vs/css!vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/css!vs/editor/contrib/zoneWidget/browser/zoneWidget","vs/css!vs/platform/contextview/browser/contextMenuHandler","vs/editor/common/services/languagesRegistry","vs/editor/common/services/modelServiceImpl","vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard","vs/editor/contrib/multicursor/browser/menuPreventer","vs/editor/browser/config/charWidthReader","vs/editor/browser/config/elementSizeObserver","vs/editor/common/services/modeServiceImpl","vs/editor/browser/controller/input/textAreaWrapper","vs/base/common/decorators","vs/base/common/scorer","vs/editor/browser/controller/keyboardHandler","vs/editor/browser/view/viewOverlays","vs/editor/browser/viewParts/lines/viewLines","vs/editor/browser/viewParts/viewCursors/viewCursor","vs/editor/browser/viewParts/viewCursors/viewCursors","vs/platform/configuration/common/model","vs/editor/browser/view/viewEventDispatcher","vs/base/common/set","vs/base/common/history","vs/base/common/stopwatch","vs/base/browser/ui/list/rowCache","vs/editor/common/commands/trimTrailingWhitespaceCommand","vs/base/browser/ui/scrollbar/scrollbarVisibilityController","vs/editor/contrib/bracketMatching/common/bracketMatching","vs/editor/contrib/caretOperations/common/caretOperations","vs/editor/contrib/clipboard/browser/clipboard","vs/editor/contrib/codelens/common/codelens","vs/editor/contrib/codelens/browser/codelens","vs/editor/contrib/comment/common/comment","vs/editor/contrib/contextmenu/browser/contextmenu","vs/base/common/diff/diffChange","vs/editor/contrib/find/browser/findWidget","vs/editor/contrib/find/browser/find","vs/editor/contrib/folding/browser/folding","vs/editor/contrib/format/common/format","vs/editor/contrib/format/common/formatActions","vs/editor/contrib/goToDeclaration/common/goToDeclaration","vs/editor/contrib/gotoError/browser/gotoError","vs/editor/contrib/hover/common/hover","vs/editor/contrib/hover/browser/modesContentHover","vs/editor/contrib/hover/browser/hover","vs/editor/contrib/inPlaceReplace/common/inPlaceReplace","vs/editor/contrib/inspectTokens/browser/inspectTokens","vs/editor/contrib/linesOperations/common/linesOperations","vs/editor/contrib/links/browser/links","vs/editor/contrib/multicursor/common/multicursor","vs/editor/common/commands/surroundSelectionCommand","vs/editor/contrib/parameterHints/browser/parameterHintsWidget","vs/editor/contrib/parameterHints/browser/parameterHints","vs/editor/contrib/quickFix/common/quickFix","vs/editor/contrib/quickFix/common/quickFixModel","vs/editor/contrib/quickFix/browser/quickFix","vs/base/common/graph","vs/editor/contrib/quickOpen/browser/gotoLine","vs/editor/contrib/quickOpen/browser/quickCommand","vs/editor/contrib/quickOpen/common/quickOpen","vs/editor/contrib/quickOpen/browser/quickOutline","vs/editor/contrib/referenceSearch/common/referenceSearch","vs/editor/contrib/rename/common/rename","vs/editor/contrib/rename/browser/rename","vs/editor/contrib/smartSelect/common/smartSelect","vs/base/browser/ui/octiconLabel/octiconLabel","vs/editor/contrib/suggest/browser/tabCompletion","vs/base/browser/ui/scrollbar/horizontalScrollbar","vs/editor/contrib/suggest/browser/suggestWidget","vs/editor/contrib/suggest/common/suggestModel","vs/editor/contrib/suggest/browser/suggestController","vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode","vs/editor/contrib/wordHighlighter/common/wordHighlighter","vs/platform/contextview/browser/contextViewService","vs/platform/theme/common/themes","vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler","vs/editor/browser/view/viewImpl","vs/base/browser/ui/scrollbar/verticalScrollbar","vs/editor/common/diff/diffComputer","vs/editor/common/model/editStack","vs/editor/browser/standalone/standaloneCodeEditor","vs/editor/common/model/indentRanges","vs/editor/common/model/indentationGuesser","vs/editor/common/model/tokenIterator","vs/base/common/mime","vs/editor/browser/standalone/standaloneEditor","vs/editor/browser/standalone/standaloneLanguages","vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/base/common/comparers","vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/base/common/winjs.base.raw","vs/base/common/marked/raw.marked","vs/editor/edcore.main"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *--------------------------------------------------------------------------------------------*/
'use strict';
var _cssPluginGlobal = this;
var CSSLoaderPlugin;
(function (CSSLoaderPlugin) {
    var global = _cssPluginGlobal || {};
    /**
     * Known issue:
     * - In IE there is no way to know if the CSS file loaded successfully or not.
     */
    var BrowserCSSLoader = (function () {
        function BrowserCSSLoader() {
            this._pendingLoads = 0;
        }
        BrowserCSSLoader.prototype.attachListeners = function (name, linkNode, callback, errorback) {
            var unbind = function () {
                linkNode.removeEventListener('load', loadEventListener);
                linkNode.removeEventListener('error', errorEventListener);
            };
            var loadEventListener = function (e) {
                unbind();
                callback();
            };
            var errorEventListener = function (e) {
                unbind();
                errorback(e);
            };
            linkNode.addEventListener('load', loadEventListener);
            linkNode.addEventListener('error', errorEventListener);
        };
        BrowserCSSLoader.prototype._onLoad = function (name, callback) {
            this._pendingLoads--;
            callback();
        };
        BrowserCSSLoader.prototype._onLoadError = function (name, errorback, err) {
            this._pendingLoads--;
            errorback(err);
        };
        BrowserCSSLoader.prototype._insertLinkNode = function (linkNode) {
            this._pendingLoads++;
            var head = document.head || document.getElementsByTagName('head')[0];
            var other = head.getElementsByTagName('link') || document.head.getElementsByTagName('script');
            if (other.length > 0) {
                head.insertBefore(linkNode, other[other.length - 1]);
            }
            else {
                head.appendChild(linkNode);
            }
        };
        BrowserCSSLoader.prototype.createLinkTag = function (name, cssUrl, externalCallback, externalErrorback) {
            var _this = this;
            var linkNode = document.createElement('link');
            linkNode.setAttribute('rel', 'stylesheet');
            linkNode.setAttribute('type', 'text/css');
            linkNode.setAttribute('data-name', name);
            var callback = function () { return _this._onLoad(name, externalCallback); };
            var errorback = function (err) { return _this._onLoadError(name, externalErrorback, err); };
            this.attachListeners(name, linkNode, callback, errorback);
            linkNode.setAttribute('href', cssUrl);
            return linkNode;
        };
        BrowserCSSLoader.prototype._linkTagExists = function (name, cssUrl) {
            var i, len, nameAttr, hrefAttr, links = document.getElementsByTagName('link');
            for (i = 0, len = links.length; i < len; i++) {
                nameAttr = links[i].getAttribute('data-name');
                hrefAttr = links[i].getAttribute('href');
                if (nameAttr === name || hrefAttr === cssUrl) {
                    return true;
                }
            }
            return false;
        };
        BrowserCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {
            if (this._linkTagExists(name, cssUrl)) {
                externalCallback();
                return;
            }
            var linkNode = this.createLinkTag(name, cssUrl, externalCallback, externalErrorback);
            this._insertLinkNode(linkNode);
        };
        return BrowserCSSLoader;
    }());
    var NodeCSSLoader = (function () {
        function NodeCSSLoader() {
            this.fs = require.nodeRequire('fs');
        }
        NodeCSSLoader.prototype.load = function (name, cssUrl, externalCallback, externalErrorback) {
            var contents = this.fs.readFileSync(cssUrl, 'utf8');
            // Remove BOM
            if (contents.charCodeAt(0) === NodeCSSLoader.BOM_CHAR_CODE) {
                contents = contents.substring(1);
            }
            externalCallback(contents);
        };
        return NodeCSSLoader;
    }());
    NodeCSSLoader.BOM_CHAR_CODE = 65279;
    // ------------------------------ Finally, the plugin
    var CSSPlugin = (function () {
        function CSSPlugin(cssLoader) {
            this.cssLoader = cssLoader;
        }
        CSSPlugin.prototype.load = function (name, req, load, config) {
            config = config || {};
            var myConfig = config['vs/css'] || {};
            global.inlineResources = myConfig.inlineResources;
            var cssUrl = req.toUrl(name + '.css');
            this.cssLoader.load(name, cssUrl, function (contents) {
                // Contents has the CSS file contents if we are in a build
                if (config.isBuild) {
                    CSSPlugin.BUILD_MAP[name] = contents;
                    CSSPlugin.BUILD_PATH_MAP[name] = cssUrl;
                }
                load({});
            }, function (err) {
                if (typeof load.error === 'function') {
                    load.error('Could not find ' + cssUrl + ' or it was empty');
                }
            });
        };
        CSSPlugin.prototype.write = function (pluginName, moduleName, write) {
            // getEntryPoint is a Monaco extension to r.js
            var entryPoint = write.getEntryPoint();
            // r.js destroys the context of this plugin between calling 'write' and 'writeFile'
            // so the only option at this point is to leak the data to a global
            global.cssPluginEntryPoints = global.cssPluginEntryPoints || {};
            global.cssPluginEntryPoints[entryPoint] = global.cssPluginEntryPoints[entryPoint] || [];
            global.cssPluginEntryPoints[entryPoint].push({
                moduleName: moduleName,
                contents: CSSPlugin.BUILD_MAP[moduleName],
                fsPath: CSSPlugin.BUILD_PATH_MAP[moduleName],
            });
            write.asModule(pluginName + '!' + moduleName, 'define([\'vs/css!' + entryPoint + '\'], {});');
        };
        CSSPlugin.prototype.writeFile = function (pluginName, moduleName, req, write, config) {
            if (global.cssPluginEntryPoints && global.cssPluginEntryPoints.hasOwnProperty(moduleName)) {
                var fileName = req.toUrl(moduleName + '.css');
                var contents = [
                    '/*---------------------------------------------------------',
                    ' * Copyright (c) Microsoft Corporation. All rights reserved.',
                    ' *--------------------------------------------------------*/'
                ], entries = global.cssPluginEntryPoints[moduleName];
                for (var i = 0; i < entries.length; i++) {
                    if (global.inlineResources) {
                        contents.push(Utilities.rewriteOrInlineUrls(entries[i].fsPath, entries[i].moduleName, moduleName, entries[i].contents, global.inlineResources === 'base64'));
                    }
                    else {
                        contents.push(Utilities.rewriteUrls(entries[i].moduleName, moduleName, entries[i].contents));
                    }
                }
                write(fileName, contents.join('\r\n'));
            }
        };
        CSSPlugin.prototype.getInlinedResources = function () {
            return global.cssInlinedResources || [];
        };
        return CSSPlugin;
    }());
    CSSPlugin.BUILD_MAP = {};
    CSSPlugin.BUILD_PATH_MAP = {};
    CSSLoaderPlugin.CSSPlugin = CSSPlugin;
    var Utilities = (function () {
        function Utilities() {
        }
        Utilities.startsWith = function (haystack, needle) {
            return haystack.length >= needle.length && haystack.substr(0, needle.length) === needle;
        };
        /**
         * Find the path of a file.
         */
        Utilities.pathOf = function (filename) {
            var lastSlash = filename.lastIndexOf('/');
            if (lastSlash !== -1) {
                return filename.substr(0, lastSlash + 1);
            }
            else {
                return '';
            }
        };
        /**
         * A conceptual a + b for paths.
         * Takes into account if `a` contains a protocol.
         * Also normalizes the result: e.g.: a/b/ + ../c => a/c
         */
        Utilities.joinPaths = function (a, b) {
            function findSlashIndexAfterPrefix(haystack, prefix) {
                if (Utilities.startsWith(haystack, prefix)) {
                    return Math.max(prefix.length, haystack.indexOf('/', prefix.length));
                }
                return 0;
            }
            var aPathStartIndex = 0;
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, '//');
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'http://');
            aPathStartIndex = aPathStartIndex || findSlashIndexAfterPrefix(a, 'https://');
            function pushPiece(pieces, piece) {
                if (piece === './') {
                    // Ignore
                    return;
                }
                if (piece === '../') {
                    var prevPiece = (pieces.length > 0 ? pieces[pieces.length - 1] : null);
                    if (prevPiece && prevPiece === '/') {
                        // Ignore
                        return;
                    }
                    if (prevPiece && prevPiece !== '../') {
                        // Pop
                        pieces.pop();
                        return;
                    }
                }
                // Push
                pieces.push(piece);
            }
            function push(pieces, path) {
                while (path.length > 0) {
                    var slashIndex = path.indexOf('/');
                    var piece = (slashIndex >= 0 ? path.substring(0, slashIndex + 1) : path);
                    path = (slashIndex >= 0 ? path.substring(slashIndex + 1) : '');
                    pushPiece(pieces, piece);
                }
            }
            var pieces = [];
            push(pieces, a.substr(aPathStartIndex));
            if (b.length > 0 && b.charAt(0) === '/') {
                pieces = [];
            }
            push(pieces, b);
            return a.substring(0, aPathStartIndex) + pieces.join('');
        };
        Utilities.commonPrefix = function (str1, str2) {
            var len = Math.min(str1.length, str2.length);
            for (var i = 0; i < len; i++) {
                if (str1.charCodeAt(i) !== str2.charCodeAt(i)) {
                    break;
                }
            }
            return str1.substring(0, i);
        };
        Utilities.commonFolderPrefix = function (fromPath, toPath) {
            var prefix = Utilities.commonPrefix(fromPath, toPath);
            var slashIndex = prefix.lastIndexOf('/');
            if (slashIndex === -1) {
                return '';
            }
            return prefix.substring(0, slashIndex + 1);
        };
        Utilities.relativePath = function (fromPath, toPath) {
            if (Utilities.startsWith(toPath, '/') || Utilities.startsWith(toPath, 'http://') || Utilities.startsWith(toPath, 'https://')) {
                return toPath;
            }
            // Ignore common folder prefix
            var prefix = Utilities.commonFolderPrefix(fromPath, toPath);
            fromPath = fromPath.substr(prefix.length);
            toPath = toPath.substr(prefix.length);
            var upCount = fromPath.split('/').length;
            var result = '';
            for (var i = 1; i < upCount; i++) {
                result += '../';
            }
            return result + toPath;
        };
        Utilities._replaceURL = function (contents, replacer) {
            // Use ")" as the terminator as quotes are oftentimes not used at all
            return contents.replace(/url\(\s*([^\)]+)\s*\)?/g, function (_) {
                var matches = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    matches[_i - 1] = arguments[_i];
                }
                var url = matches[0];
                // Eliminate starting quotes (the initial whitespace is not captured)
                if (url.charAt(0) === '"' || url.charAt(0) === '\'') {
                    url = url.substring(1);
                }
                // The ending whitespace is captured
                while (url.length > 0 && (url.charAt(url.length - 1) === ' ' || url.charAt(url.length - 1) === '\t')) {
                    url = url.substring(0, url.length - 1);
                }
                // Eliminate ending quotes
                if (url.charAt(url.length - 1) === '"' || url.charAt(url.length - 1) === '\'') {
                    url = url.substring(0, url.length - 1);
                }
                if (!Utilities.startsWith(url, 'data:') && !Utilities.startsWith(url, 'http://') && !Utilities.startsWith(url, 'https://')) {
                    url = replacer(url);
                }
                return 'url(' + url + ')';
            });
        };
        Utilities.rewriteUrls = function (originalFile, newFile, contents) {
            return this._replaceURL(contents, function (url) {
                var absoluteUrl = Utilities.joinPaths(Utilities.pathOf(originalFile), url);
                return Utilities.relativePath(newFile, absoluteUrl);
            });
        };
        Utilities.rewriteOrInlineUrls = function (originalFileFSPath, originalFile, newFile, contents, forceBase64) {
            var fs = require.nodeRequire('fs');
            var path = require.nodeRequire('path');
            return this._replaceURL(contents, function (url) {
                if (/\.(svg|png)$/.test(url)) {
                    var fsPath = path.join(path.dirname(originalFileFSPath), url);
                    var fileContents = fs.readFileSync(fsPath);
                    if (fileContents.length < 5000) {
                        global.cssInlinedResources = global.cssInlinedResources || [];
                        var normalizedFSPath = fsPath.replace(/\\/g, '/');
                        if (global.cssInlinedResources.indexOf(normalizedFSPath) >= 0) {
                            console.warn('CSS INLINING IMAGE AT ' + fsPath + ' MORE THAN ONCE. CONSIDER CONSOLIDATING CSS RULES');
                        }
                        global.cssInlinedResources.push(normalizedFSPath);
                        var MIME = /\.svg$/.test(url) ? 'image/svg+xml' : 'image/png';
                        var DATA = ';base64,' + fileContents.toString('base64');
                        if (!forceBase64 && /\.svg$/.test(url)) {
                            // .svg => url encode as explained at https://codepen.io/tigt/post/optimizing-svgs-in-data-uris
                            var newText = fileContents.toString()
                                .replace(/"/g, '\'')
                                .replace(/</g, '%3C')
                                .replace(/>/g, '%3E')
                                .replace(/&/g, '%26')
                                .replace(/#/g, '%23')
                                .replace(/\s+/g, ' ');
                            var encodedData = ',' + newText;
                            if (encodedData.length < DATA.length) {
                                DATA = encodedData;
                            }
                        }
                        return '"data:' + MIME + DATA + '"';
                    }
                }
                var absoluteUrl = Utilities.joinPaths(Utilities.pathOf(originalFile), url);
                return Utilities.relativePath(newFile, absoluteUrl);
            });
        };
        return Utilities;
    }());
    CSSLoaderPlugin.Utilities = Utilities;
    (function () {
        var cssLoader = null;
        var isElectron = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions['electron'] !== 'undefined');
        if (typeof process !== 'undefined' && process.versions && !!process.versions.node && !isElectron) {
            cssLoader = new NodeCSSLoader();
        }
        else {
            cssLoader = new BrowserCSSLoader();
        }
        define('vs/css', new CSSPlugin(cssLoader));
    })();
})(CSSLoaderPlugin || (CSSLoaderPlugin = {}));

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 * Please make sure to make edits in the .ts file at https://github.com/Microsoft/vscode-loader/
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *---------------------------------------------------------------------------------------------
 *--------------------------------------------------------------------------------------------*/
'use strict';
var _nlsPluginGlobal = this;
var NLSLoaderPlugin;
(function (NLSLoaderPlugin) {
    var global = _nlsPluginGlobal || {};
    var Resources = global.Plugin && global.Plugin.Resources ? global.Plugin.Resources : undefined;
    var DEFAULT_TAG = 'i-default';
    var IS_PSEUDO = (global && global.document && global.document.location && global.document.location.hash.indexOf('pseudo=true') >= 0);
    var slice = Array.prototype.slice;
    function _format(message, args) {
        var result;
        if (args.length === 0) {
            result = message;
        }
        else {
            result = message.replace(/\{(\d+)\}/g, function (match, rest) {
                var index = rest[0];
                return typeof args[index] !== 'undefined' ? args[index] : match;
            });
        }
        if (IS_PSEUDO) {
            // FF3B and FF3D is the Unicode zenkaku representation for [ and ]
            result = '\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\uFF3D';
        }
        return result;
    }
    function findLanguageForModule(config, name) {
        var result = config[name];
        if (result)
            return result;
        result = config['*'];
        if (result)
            return result;
        return null;
    }
    function localize(data, message) {
        var args = [];
        for (var _i = 0; _i < (arguments.length - 2); _i++) {
            args[_i] = arguments[_i + 2];
        }
        return _format(message, args);
    }
    function createScopedLocalize(scope) {
        return function (idx, defaultValue) {
            var restArgs = slice.call(arguments, 2);
            return _format(scope[idx], restArgs);
        };
    }
    var NLSPlugin = (function () {
        function NLSPlugin() {
            this.localize = localize;
        }
        NLSPlugin.prototype.setPseudoTranslation = function (value) {
            IS_PSEUDO = value;
        };
        NLSPlugin.prototype.create = function (key, data) {
            return {
                localize: createScopedLocalize(data[key])
            };
        };
        NLSPlugin.prototype.load = function (name, req, load, config) {
            config = config || {};
            if (!name || name.length === 0) {
                load({
                    localize: localize
                });
            }
            else {
                var suffix = void 0;
                if (Resources && Resources.getString) {
                    suffix = '.nls.keys';
                    req([name + suffix], function (keyMap) {
                        load({
                            localize: function (moduleKey, index) {
                                if (!keyMap[moduleKey])
                                    return 'NLS error: unknown key ' + moduleKey;
                                var mk = keyMap[moduleKey].keys;
                                if (index >= mk.length)
                                    return 'NLS error unknow index ' + index;
                                var subKey = mk[index];
                                var args = [];
                                args[0] = moduleKey + '_' + subKey;
                                for (var _i = 0; _i < (arguments.length - 2); _i++) {
                                    args[_i + 1] = arguments[_i + 2];
                                }
                                return Resources.getString.apply(Resources, args);
                            }
                        });
                    });
                }
                else {
                    if (config.isBuild) {
                        req([name + '.nls', name + '.nls.keys'], function (messages, keys) {
                            NLSPlugin.BUILD_MAP[name] = messages;
                            NLSPlugin.BUILD_MAP_KEYS[name] = keys;
                            load(messages);
                        });
                    }
                    else {
                        var pluginConfig = config['vs/nls'] || {};
                        var language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;
                        suffix = '.nls';
                        if (language !== null && language !== DEFAULT_TAG) {
                            suffix = suffix + '.' + language;
                        }
                        req([name + suffix], function (messages) {
                            if (Array.isArray(messages)) {
                                messages.localize = createScopedLocalize(messages);
                            }
                            else {
                                messages.localize = createScopedLocalize(messages[name]);
                            }
                            load(messages);
                        });
                    }
                }
            }
        };
        NLSPlugin.prototype._getEntryPointsMap = function () {
            global.nlsPluginEntryPoints = global.nlsPluginEntryPoints || {};
            return global.nlsPluginEntryPoints;
        };
        NLSPlugin.prototype.write = function (pluginName, moduleName, write) {
            // getEntryPoint is a Monaco extension to r.js
            var entryPoint = write.getEntryPoint();
            // r.js destroys the context of this plugin between calling 'write' and 'writeFile'
            // so the only option at this point is to leak the data to a global
            var entryPointsMap = this._getEntryPointsMap();
            entryPointsMap[entryPoint] = entryPointsMap[entryPoint] || [];
            entryPointsMap[entryPoint].push(moduleName);
            if (moduleName !== entryPoint) {
                write.asModule(pluginName + '!' + moduleName, 'define([\'vs/nls\', \'vs/nls!' + entryPoint + '\'], function(nls, data) { return nls.create("' + moduleName + '", data); });');
            }
        };
        NLSPlugin.prototype.writeFile = function (pluginName, moduleName, req, write, config) {
            var entryPointsMap = this._getEntryPointsMap();
            if (entryPointsMap.hasOwnProperty(moduleName)) {
                var fileName = req.toUrl(moduleName + '.nls.js');
                var contents = [
                    '/*---------------------------------------------------------',
                    ' * Copyright (c) Microsoft Corporation. All rights reserved.',
                    ' *--------------------------------------------------------*/'
                ], entries = entryPointsMap[moduleName];
                var data = {};
                for (var i = 0; i < entries.length; i++) {
                    data[entries[i]] = NLSPlugin.BUILD_MAP[entries[i]];
                }
                contents.push('define("' + moduleName + '.nls", ' + JSON.stringify(data, null, '\t') + ');');
                write(fileName, contents.join('\r\n'));
            }
        };
        NLSPlugin.prototype.finishBuild = function (write) {
            write('nls.metadata.json', JSON.stringify({
                keys: NLSPlugin.BUILD_MAP_KEYS,
                messages: NLSPlugin.BUILD_MAP,
                bundles: this._getEntryPointsMap()
            }, null, '\t'));
        };
        ;
        return NLSPlugin;
    }());
    NLSPlugin.BUILD_MAP = {};
    NLSPlugin.BUILD_MAP_KEYS = {};
    NLSLoaderPlugin.NLSPlugin = NLSPlugin;
    (function () {
        define('vs/nls', new NLSPlugin());
    })();
})(NLSLoaderPlugin || (NLSLoaderPlugin = {}));

define(__m[155/*vs/base/browser/iframe*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasDifferentOriginAncestorFlag = false;
    var sameOriginWindowChainCache = null;
    function getParentWindowIfSameOrigin(w) {
        if (!w.parent || w.parent === w) {
            return null;
        }
        // Cannot really tell if we have access to the parent window unless we try to access something in it
        try {
            var location_1 = w.location;
            var parentLocation = w.parent.location;
            if (location_1.protocol !== parentLocation.protocol || location_1.hostname !== parentLocation.hostname || location_1.port !== parentLocation.port) {
                hasDifferentOriginAncestorFlag = true;
                return null;
            }
        }
        catch (e) {
            hasDifferentOriginAncestorFlag = true;
            return null;
        }
        return w.parent;
    }
    function findIframeElementInParentWindow(parentWindow, childWindow) {
        var parentWindowIframes = parentWindow.document.getElementsByTagName('iframe');
        var iframe;
        for (var i = 0, len = parentWindowIframes.length; i < len; i++) {
            iframe = parentWindowIframes[i];
            if (iframe.contentWindow === childWindow) {
                return iframe;
            }
        }
        return null;
    }
    var IframeUtils = (function () {
        function IframeUtils() {
        }
        /**
         * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
         * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
         * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
         */
        IframeUtils.getSameOriginWindowChain = function () {
            if (!sameOriginWindowChainCache) {
                sameOriginWindowChainCache = [];
                var w = window, parent_1;
                do {
                    parent_1 = getParentWindowIfSameOrigin(w);
                    if (parent_1) {
                        sameOriginWindowChainCache.push({
                            window: w,
                            iframeElement: findIframeElementInParentWindow(parent_1, w)
                        });
                    }
                    else {
                        sameOriginWindowChainCache.push({
                            window: w,
                            iframeElement: null
                        });
                    }
                    w = parent_1;
                } while (w);
            }
            return sameOriginWindowChainCache.slice(0);
        };
        /**
         * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
         * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
         */
        IframeUtils.hasDifferentOriginAncestor = function () {
            if (!sameOriginWindowChainCache) {
                this.getSameOriginWindowChain();
            }
            return hasDifferentOriginAncestorFlag;
        };
        /**
         * Returns the position of `childWindow` relative to `ancestorWindow`
         */
        IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow = function (childWindow, ancestorWindow) {
            if (!ancestorWindow || childWindow === ancestorWindow) {
                return {
                    top: 0,
                    left: 0
                };
            }
            var top = 0, left = 0;
            var windowChain = this.getSameOriginWindowChain();
            for (var i = 0; i < windowChain.length; i++) {
                var windowChainEl = windowChain[i];
                if (windowChainEl.window === ancestorWindow) {
                    break;
                }
                if (!windowChainEl.iframeElement) {
                    break;
                }
                var boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
                top += boundingRect.top;
                left += boundingRect.left;
            }
            return {
                top: top,
                left: left
            };
        };
        return IframeUtils;
    }());
    exports.IframeUtils = IframeUtils;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[193/*vs/base/browser/ui/list/rangeMap*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    /**
     * Returns the intersection between two ranges as a range itself.
     * Returns `null` if the intersection is empty.
     */
    function intersect(one, other) {
        if (one.start >= other.end || other.start >= one.end) {
            return null;
        }
        var start = Math.max(one.start, other.start);
        var end = Math.min(one.end, other.end);
        if (end - start <= 0) {
            return null;
        }
        return { start: start, end: end };
    }
    exports.intersect = intersect;
    function isEmpty(range) {
        return range.end - range.start <= 0;
    }
    exports.isEmpty = isEmpty;
    function relativeComplement(one, other) {
        var result = [];
        var first = { start: one.start, end: Math.min(other.start, one.end) };
        var second = { start: Math.max(other.end, one.start), end: one.end };
        if (!isEmpty(first)) {
            result.push(first);
        }
        if (!isEmpty(second)) {
            result.push(second);
        }
        return result;
    }
    exports.relativeComplement = relativeComplement;
    function each(range, fn) {
        for (var i = range.start; i < range.end; i++) {
            fn(i);
        }
    }
    exports.each = each;
    /**
     * Returns the intersection between a ranged group and a range.
     * Returns `[]` if the intersection is empty.
     */
    function groupIntersect(range, groups) {
        var result = [];
        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
            var r = groups_1[_i];
            if (range.start >= r.range.end) {
                continue;
            }
            if (range.end < r.range.start) {
                break;
            }
            var intersection = intersect(range, r.range);
            if (!intersection) {
                continue;
            }
            result.push({
                range: intersection,
                size: r.size
            });
        }
        return result;
    }
    exports.groupIntersect = groupIntersect;
    /**
     * Shifts a range by that `much`.
     */
    function shift(_a, much) {
        var start = _a.start, end = _a.end;
        return { start: start + much, end: end + much };
    }
    /**
     * Consolidates a collection of ranged groups.
     *
     * Consolidation is the process of merging consecutive ranged groups
     * that share the same `size`.
     */
    function consolidate(groups) {
        var result = [];
        var previousGroup = null;
        for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {
            var group = groups_2[_i];
            var start = group.range.start;
            var end = group.range.end;
            var size = group.size;
            if (previousGroup && size === previousGroup.size) {
                previousGroup.range.end = end;
                continue;
            }
            previousGroup = { range: { start: start, end: end }, size: size };
            result.push(previousGroup);
        }
        return result;
    }
    exports.consolidate = consolidate;
    /**
     * Concatenates several collections of ranged groups into a single
     * collection.
     */
    function concat() {
        var groups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            groups[_i] = arguments[_i];
        }
        return consolidate(groups.reduce(function (r, g) { return r.concat(g); }, []));
    }
    var RangeMap = (function () {
        function RangeMap() {
            this.groups = [];
            this._size = 0;
        }
        RangeMap.prototype.splice = function (index, deleteCount) {
            var items = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                items[_i - 2] = arguments[_i];
            }
            var diff = items.length - deleteCount;
            var before = groupIntersect({ start: 0, end: index }, this.groups);
            var after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)
                .map(function (g) { return ({ range: shift(g.range, diff), size: g.size }); });
            var middle = items.map(function (item, i) { return ({
                range: { start: index + i, end: index + i + 1 },
                size: item.size
            }); });
            this.groups = concat(before, middle, after);
            this._size = this.groups.reduce(function (t, g) { return t + (g.size * (g.range.end - g.range.start)); }, 0);
        };
        Object.defineProperty(RangeMap.prototype, "count", {
            /**
             * Returns the number of items in the range map.
             */
            get: function () {
                var len = this.groups.length;
                if (!len) {
                    return 0;
                }
                return this.groups[len - 1].range.end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeMap.prototype, "size", {
            /**
             * Returns the sum of the sizes of all items in the range map.
             */
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the index of the item at the given position.
         */
        RangeMap.prototype.indexAt = function (position) {
            if (position < 0) {
                return -1;
            }
            var index = 0;
            var size = 0;
            for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
                var group = _a[_i];
                var count = group.range.end - group.range.start;
                var newSize = size + (count * group.size);
                if (position < newSize) {
                    return index + Math.floor((position - size) / group.size);
                }
                index += count;
                size = newSize;
            }
            return index;
        };
        /**
         * Returns the index of the item right after the item at the
         * index of the given position.
         */
        RangeMap.prototype.indexAfter = function (position) {
            return Math.min(this.indexAt(position) + 1, this.count);
        };
        /**
         * Returns the start position of the item at the given index.
         */
        RangeMap.prototype.positionAt = function (index) {
            if (index < 0) {
                return -1;
            }
            var position = 0;
            var count = 0;
            for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
                var group = _a[_i];
                var groupCount = group.range.end - group.range.start;
                var newCount = count + groupCount;
                if (index < newCount) {
                    return position + ((index - count) * group.size);
                }
                position += groupCount * group.size;
                count = newCount;
            }
            return -1;
        };
        RangeMap.prototype.dispose = function () {
            this.groups = null;
        };
        return RangeMap;
    }());
    exports.RangeMap = RangeMap;
});

define(__m[131/*vs/base/browser/ui/scrollbar/scrollbarState*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.
     */
    var MINIMUM_SLIDER_SIZE = 20;
    var ScrollbarState = (function () {
        function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize) {
            this._scrollbarSize = Math.round(scrollbarSize);
            this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
            this._arrowSize = Math.round(arrowSize);
            this._visibleSize = 0;
            this._scrollSize = 0;
            this._scrollPosition = 0;
            this._computedAvailableSize = 0;
            this._computedRepresentableSize = 0;
            this._computedRatio = 0.1;
            this._computedIsNeeded = false;
            this._computedSliderSize = 0;
            this._computedSliderPosition = 0;
            this._refreshComputedValues();
        }
        ScrollbarState.prototype.setVisibleSize = function (visibleSize) {
            var iVisibleSize = Math.round(visibleSize);
            if (this._visibleSize !== iVisibleSize) {
                this._visibleSize = iVisibleSize;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype.setScrollSize = function (scrollSize) {
            var iScrollSize = Math.round(scrollSize);
            if (this._scrollSize !== iScrollSize) {
                this._scrollSize = iScrollSize;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {
            var iScrollPosition = Math.round(scrollPosition);
            if (this._scrollPosition !== iScrollPosition) {
                this._scrollPosition = iScrollPosition;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype._refreshComputedValues = function () {
            var oppositeScrollbarSize = this._oppositeScrollbarSize;
            var arrowSize = this._arrowSize;
            var visibleSize = this._visibleSize;
            var scrollSize = this._scrollSize;
            var scrollPosition = this._scrollPosition;
            var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
            var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
            var computedRatio = scrollSize > 0 ? (computedRepresentableSize / scrollSize) : 0;
            var computedIsNeeded = (scrollSize > visibleSize);
            var computedSliderSize;
            var computedSliderPosition;
            if (!computedIsNeeded) {
                computedSliderSize = computedRepresentableSize;
                computedSliderPosition = 0;
            }
            else {
                computedSliderSize = Math.floor(visibleSize * computedRatio);
                computedSliderPosition = Math.floor(scrollPosition * computedRatio);
                if (computedSliderSize < MINIMUM_SLIDER_SIZE) {
                    // We must artificially increase the size of the slider, since the slider would be too small otherwise
                    // The effort is to keep the slider centered around the original position, but we must take into
                    // account the cases when the slider is too close to the top or too close to the bottom
                    var sliderArtificialOffset = (MINIMUM_SLIDER_SIZE - computedSliderSize) / 2;
                    computedSliderSize = MINIMUM_SLIDER_SIZE;
                    computedSliderPosition -= sliderArtificialOffset;
                    if (computedSliderPosition + computedSliderSize > computedRepresentableSize) {
                        // Slider is too close to the bottom, so we glue it to the bottom
                        computedSliderPosition = computedRepresentableSize - computedSliderSize;
                    }
                    if (computedSliderPosition < 0) {
                        // Slider is too close to the top, so we glue it to the top
                        computedSliderPosition = 0;
                    }
                }
            }
            this._computedAvailableSize = Math.round(computedAvailableSize);
            this._computedRepresentableSize = Math.round(computedRepresentableSize);
            this._computedRatio = computedRatio;
            this._computedIsNeeded = computedIsNeeded;
            this._computedSliderSize = Math.round(computedSliderSize);
            this._computedSliderPosition = Math.round(computedSliderPosition);
        };
        ScrollbarState.prototype.getArrowSize = function () {
            return this._arrowSize;
        };
        ScrollbarState.prototype.getRectangleLargeSize = function () {
            return this._computedAvailableSize;
        };
        ScrollbarState.prototype.getRectangleSmallSize = function () {
            return this._scrollbarSize;
        };
        ScrollbarState.prototype.isNeeded = function () {
            return this._computedIsNeeded;
        };
        ScrollbarState.prototype.getSliderSize = function () {
            return this._computedSliderSize;
        };
        ScrollbarState.prototype.getSliderPosition = function () {
            return this._computedSliderPosition;
        };
        ScrollbarState.prototype.convertSliderPositionToScrollPosition = function (desiredSliderPosition) {
            return desiredSliderPosition / this._computedRatio;
        };
        ScrollbarState.prototype.validateScrollPosition = function (desiredScrollPosition) {
            desiredScrollPosition = Math.round(desiredScrollPosition);
            desiredScrollPosition = Math.max(desiredScrollPosition, 0);
            desiredScrollPosition = Math.min(desiredScrollPosition, this._scrollSize - this._visibleSize);
            return desiredScrollPosition;
        };
        return ScrollbarState;
    }());
    exports.ScrollbarState = ScrollbarState;
});

define(__m[28/*vs/base/common/arrays*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default ist zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirst(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirst = findFirst;
    /**
     * Returns the top N elements from the array.
     *
     * Faster than sorting the entire array when the array is a lot larger than N.
     *
     * @param array The unsorted array.
     * @param compare A sort function for the elements.
     * @param n The number of elements to return.
     * @return The first n elemnts from array when sorted with compare.
     */
    function top(array, compare, n) {
        if (n === 0) {
            return [];
        }
        var result = array.slice(0, n).sort(compare);
        var _loop_1 = function (i, m) {
            var element = array[i];
            if (compare(element, result[n - 1]) < 0) {
                result.pop();
                var j = findFirst(result, function (e) { return compare(element, e) < 0; });
                result.splice(j, 0, element);
            }
        };
        for (var i = n, m = array.length; i < m; i++) {
            _loop_1(i, m);
        }
        return result;
    }
    exports.top = top;
    /**
     * @returns a new array with all undefined or null values removed. The original array is not modified at all.
     */
    function coalesce(array) {
        if (!array) {
            return array;
        }
        return array.filter(function (e) { return !!e; });
    }
    exports.coalesce = coalesce;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return arr.reduce(function (r, v) { return r.concat(v); }, []);
    }
    exports.flatten = flatten;
    function range(to, from) {
        if (from === void 0) { from = 0; }
        var result = [];
        for (var i = from; i < to; i++) {
            result.push(i);
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer, merger) {
        if (merger === void 0) { merger = function (t) { return t; }; }
        return array.reduce(function (r, t) {
            var key = indexer(t);
            r[key] = merger(t, r[key]);
            return r;
        }, Object.create(null));
    }
    exports.index = index;
    /**
     * Inserts an element into an array. Returns a function which, when
     * called, will remove that element from the array.
     */
    function insert(array, element) {
        array.push(element);
        return function () {
            var index = array.indexOf(element);
            if (index > -1) {
                array.splice(index, 1);
            }
        };
    }
    exports.insert = insert;
});

define(__m[63/*vs/base/common/assert*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

define(__m[91/*vs/base/common/collections*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function values(from) {
        var result = [];
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                result.push(from[key]);
            }
        }
        return result;
    }
    exports.values = values;
    function forEach(from, callback) {
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                var result = callback({ key: key, value: from[key] }, function () {
                    delete from[key];
                });
                if (result === false) {
                    return;
                }
            }
        }
    }
    exports.forEach = forEach;
    function remove(from, key) {
        if (!hasOwnProperty.call(from, key)) {
            return false;
        }
        delete from[key];
        return true;
    }
    exports.remove = remove;
    /**
     * Groups the collection into a dictionary based on the provided
     * group function.
     */
    function groupBy(data, groupFn) {
        var result = Object.create(null);
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var element = data_1[_i];
            var key = groupFn(element);
            var target = result[key];
            if (!target) {
                target = result[key] = [];
            }
            target.push(element);
        }
        return result;
    }
    exports.groupBy = groupBy;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[428/*vs/base/common/decorators*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    function memoize(target, key, descriptor) {
        var fnKey = null;
        var fn = null;
        if (typeof descriptor.value === 'function') {
            fnKey = 'value';
            fn = descriptor.value;
        }
        else if (typeof descriptor.get === 'function') {
            fnKey = 'get';
            fn = descriptor.get;
        }
        if (!fn) {
            throw new Error('not supported');
        }
        var memoizeKey = "$memoize$" + key;
        descriptor[fnKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this.hasOwnProperty(memoizeKey)) {
                Object.defineProperty(this, memoizeKey, {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: fn.apply(this, args)
                });
            }
            return this[memoizeKey];
        };
    }
    exports.memoize = memoize;
});

define(__m[450/*vs/base/common/diff/diffChange*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.DifferenceType = {
        Add: 0,
        Remove: 1,
        Change: 2
    };
    /**
     * Represents information about a specific difference between two sequences.
     */
    var DiffChange = (function () {
        /**
         * Constructs a new DiffChange with the given sequence information
         * and content.
         */
        function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {
            //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
            this.originalStart = originalStart;
            this.originalLength = originalLength;
            this.modifiedStart = modifiedStart;
            this.modifiedLength = modifiedLength;
        }
        /**
         * The type of difference.
         */
        DiffChange.prototype.getChangeType = function () {
            if (this.originalLength === 0) {
                return exports.DifferenceType.Add;
            }
            else if (this.modifiedLength === 0) {
                return exports.DifferenceType.Remove;
            }
            else {
                return exports.DifferenceType.Change;
            }
        };
        /**
         * The end point (exclusive) of the change in the original sequence.
         */
        DiffChange.prototype.getOriginalEnd = function () {
            return this.originalStart + this.originalLength;
        };
        /**
         * The end point (exclusive) of the change in the modified sequence.
         */
        DiffChange.prototype.getModifiedEnd = function () {
            return this.modifiedStart + this.modifiedLength;
        };
        return DiffChange;
    }());
    exports.DiffChange = DiffChange;
});

define(__m[95/*vs/base/common/diff/diff*/], __M([1/*require*/,0/*exports*/,450/*vs/base/common/diff/diffChange*/]), function (require, exports, diffChange_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createStringSequence(a) {
        return {
            getLength: function () { return a.length; },
            getElementHash: function (pos) { return a[pos]; }
        };
    }
    function stringDiff(original, modified) {
        return new LcsDiff(createStringSequence(original), createStringSequence(modified)).ComputeDiff();
    }
    exports.stringDiff = stringDiff;
    //
    // The code below has been ported from a C# implementation in VS
    //
    var Debug = (function () {
        function Debug() {
        }
        Debug.Assert = function (condition, message) {
            if (!condition) {
                throw new Error(message);
            }
        };
        return Debug;
    }());
    exports.Debug = Debug;
    var MyArray = (function () {
        function MyArray() {
        }
        /**
         * Copies a range of elements from an Array starting at the specified source index and pastes
         * them to another Array starting at the specified destination index. The length and the indexes
         * are specified as 64-bit integers.
         * sourceArray:
         *		The Array that contains the data to copy.
         * sourceIndex:
         *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
         * destinationArray:
         *		The Array that receives the data.
         * destinationIndex:
         *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
         * length:
         *		A 64-bit integer that represents the number of elements to copy.
         */
        MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return MyArray;
    }());
    exports.MyArray = MyArray;
    //*****************************************************************************
    // LcsDiff.cs
    //
    // An implementation of the difference algorithm described in
    // "An O(ND) Difference Algorithm and its letiations" by Eugene W. Myers
    //
    // Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve
    //*****************************************************************************
    // Our total memory usage for storing history is (worst-case):
    // 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)
    // 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB
    var MaxDifferencesHistory = 1447;
    //let MaxDifferencesHistory = 100;
    /**
     * A utility class which helps to create the set of DiffChanges from
     * a difference operation. This class accepts original DiffElements and
     * modified DiffElements that are involved in a particular change. The
     * MarktNextChange() method can be called to mark the separation between
     * distinct changes. At the end, the Changes property can be called to retrieve
     * the constructed changes.
     */
    var DiffChangeHelper = (function () {
        /**
         * Constructs a new DiffChangeHelper for the given DiffSequences.
         */
        function DiffChangeHelper() {
            this.m_changes = [];
            this.m_originalStart = Number.MAX_VALUE;
            this.m_modifiedStart = Number.MAX_VALUE;
            this.m_originalCount = 0;
            this.m_modifiedCount = 0;
        }
        /**
         * Marks the beginning of the next change in the set of differences.
         */
        DiffChangeHelper.prototype.MarkNextChange = function () {
            // Only add to the list if there is something to add
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Add the new change to our list
                this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
            }
            // Reset for the next change
            this.m_originalCount = 0;
            this.m_modifiedCount = 0;
            this.m_originalStart = Number.MAX_VALUE;
            this.m_modifiedStart = Number.MAX_VALUE;
        };
        /**
         * Adds the original element at the given position to the elements
         * affected by the current change. The modified index gives context
         * to the change position with respect to the original sequence.
         * @param originalIndex The index of the original element to add.
         * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
         */
        DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {
            // The 'true' start index is the smallest of the ones we've seen
            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
            this.m_originalCount++;
        };
        /**
         * Adds the modified element at the given position to the elements
         * affected by the current change. The original index gives context
         * to the change position with respect to the modified sequence.
         * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
         * @param modifiedIndex The index of the modified element to add.
         */
        DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {
            // The 'true' start index is the smallest of the ones we've seen
            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
            this.m_modifiedCount++;
        };
        /**
         * Retrieves all of the changes marked by the class.
         */
        DiffChangeHelper.prototype.getChanges = function () {
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Finish up on whatever is left
                this.MarkNextChange();
            }
            return this.m_changes;
        };
        /**
         * Retrieves all of the changes marked by the class in the reverse order
         */
        DiffChangeHelper.prototype.getReverseChanges = function () {
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Finish up on whatever is left
                this.MarkNextChange();
            }
            this.m_changes.reverse();
            return this.m_changes;
        };
        return DiffChangeHelper;
    }());
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * An implementation of the difference algorithm described in
     * "An O(ND) Difference Algorithm and its letiations" by Eugene W. Myers
     */
    var LcsDiff = (function () {
        /**
         * Constructs the DiffFinder
         */
        function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {
            if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }
            this.OriginalSequence = originalSequence;
            this.ModifiedSequence = newSequence;
            this.ContinueProcessingPredicate = continueProcessingPredicate;
            this.m_originalIds = [];
            this.m_modifiedIds = [];
            this.m_forwardHistory = [];
            this.m_reverseHistory = [];
            this.ComputeUniqueIdentifiers();
        }
        LcsDiff.prototype.ComputeUniqueIdentifiers = function () {
            var originalSequenceLength = this.OriginalSequence.getLength();
            var modifiedSequenceLength = this.ModifiedSequence.getLength();
            this.m_originalIds = new Array(originalSequenceLength);
            this.m_modifiedIds = new Array(modifiedSequenceLength);
            // Create a new hash table for unique elements from the original
            // sequence.
            var hashTable = {};
            var currentUniqueId = 1;
            var i;
            // Fill up the hash table for unique elements
            for (i = 0; i < originalSequenceLength; i++) {
                var originalElementHash = this.OriginalSequence.getElementHash(i);
                if (!hasOwnProperty.call(hashTable, originalElementHash)) {
                    // No entry in the hashtable so this is a new unique element.
                    // Assign the element a new unique identifier and add it to the
                    // hash table
                    this.m_originalIds[i] = currentUniqueId++;
                    hashTable[originalElementHash] = this.m_originalIds[i];
                }
                else {
                    this.m_originalIds[i] = hashTable[originalElementHash];
                }
            }
            // Now match up modified elements
            for (i = 0; i < modifiedSequenceLength; i++) {
                var modifiedElementHash = this.ModifiedSequence.getElementHash(i);
                if (!hasOwnProperty.call(hashTable, modifiedElementHash)) {
                    this.m_modifiedIds[i] = currentUniqueId++;
                    hashTable[modifiedElementHash] = this.m_modifiedIds[i];
                }
                else {
                    this.m_modifiedIds[i] = hashTable[modifiedElementHash];
                }
            }
        };
        LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {
            return this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];
        };
        LcsDiff.prototype.ComputeDiff = function () {
            return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);
        };
        /**
         * Computes the differences between the original and modified input
         * sequences on the bounded range.
         * @returns An array of the differences between the two input sequences.
         */
        LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd) {
            var quitEarlyArr = [false];
            return this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        };
        /**
         * Private helper method which computes the differences on the bounded range
         * recursively.
         * @returns An array of the differences between the two input sequences.
         */
        LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
            quitEarlyArr[0] = false;
            // Find the start of the differences
            while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
                originalStart++;
                modifiedStart++;
            }
            // Find the end of the differences
            while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
                originalEnd--;
                modifiedEnd--;
            }
            // In the special case where we either have all insertions or all deletions or the sequences are identical
            if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
                var changes = void 0;
                if (modifiedStart <= modifiedEnd) {
                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                    // All insertions
                    changes = [
                        new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
                else if (originalStart <= originalEnd) {
                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                    // All deletions
                    changes = [
                        new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                    ];
                }
                else {
                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                    // Identical sequences - No differences
                    changes = [];
                }
                return changes;
            }
            // This problem can be solved using the Divide-And-Conquer technique.
            var midOriginalArr = [0], midModifiedArr = [0];
            var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
            var midOriginal = midOriginalArr[0];
            var midModified = midModifiedArr[0];
            if (result !== null) {
                // Result is not-null when there was enough memory to compute the changes while
                // searching for the recursion point
                return result;
            }
            else if (!quitEarlyArr[0]) {
                // We can break the problem down recursively by finding the changes in the
                // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
                // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
                // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
                var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
                var rightChanges = [];
                if (!quitEarlyArr[0]) {
                    rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
                }
                else {
                    // We did't have time to finish the first half, so we don't have time to compute this half.
                    // Consider the entire rest of the sequence different.
                    rightChanges = [
                        new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                    ];
                }
                return this.ConcatenateChanges(leftChanges, rightChanges);
            }
            // If we hit here, we quit early, and so can't return anything meaningful
            return [
                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
        };
        LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
            var forwardChanges = null, reverseChanges = null;
            // First, walk backward through the forward diagonals history
            var changeHelper = new DiffChangeHelper();
            var diagonalMin = diagonalForwardStart;
            var diagonalMax = diagonalForwardEnd;
            var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
            var lastOriginalIndex = Number.MIN_VALUE;
            var historyIndex = this.m_forwardHistory.length - 1;
            var diagonal;
            do {
                // Get the diagonal index from the relative diagonal number
                diagonal = diagonalRelative + diagonalForwardBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    // Vertical line (the element is an insert)
                    originalIndex = forwardPoints[diagonal + 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                    if (originalIndex < lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                    diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
                }
                else {
                    // Horizontal line (the element is a deletion)
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                    if (originalIndex < lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex - 1;
                    changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    forwardPoints = this.m_forwardHistory[historyIndex];
                    diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = forwardPoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // Ironically, we get the forward changes as the reverse of the
            // order we added them since we technically added them backwards
            forwardChanges = changeHelper.getReverseChanges();
            if (quitEarlyArr[0]) {
                // TODO: Calculate a partial from the reverse diagonals.
                //       For now, just assume everything after the midOriginal/midModified point is a diff
                var originalStartPoint = midOriginalArr[0] + 1;
                var modifiedStartPoint = midModifiedArr[0] + 1;
                if (forwardChanges !== null && forwardChanges.length > 0) {
                    var lastForwardChange = forwardChanges[forwardChanges.length - 1];
                    originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                    modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
                }
                reverseChanges = [
                    new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
                ];
            }
            else {
                // Now walk backward through the reverse diagonals history
                changeHelper = new DiffChangeHelper();
                diagonalMin = diagonalReverseStart;
                diagonalMax = diagonalReverseEnd;
                diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
                lastOriginalIndex = Number.MAX_VALUE;
                historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
                do {
                    // Get the diagonal index from the relative diagonal number
                    diagonal = diagonalRelative + diagonalReverseBase;
                    // Figure out where we came from
                    if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                        // Horizontal line (the element is a deletion))
                        originalIndex = reversePoints[diagonal + 1] - 1;
                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                        if (originalIndex > lastOriginalIndex) {
                            changeHelper.MarkNextChange();
                        }
                        lastOriginalIndex = originalIndex + 1;
                        changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                        diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                    }
                    else {
                        // Vertical line (the element is an insertion)
                        originalIndex = reversePoints[diagonal - 1];
                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                        if (originalIndex > lastOriginalIndex) {
                            changeHelper.MarkNextChange();
                        }
                        lastOriginalIndex = originalIndex;
                        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                        diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                    }
                    if (historyIndex >= 0) {
                        reversePoints = this.m_reverseHistory[historyIndex];
                        diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                        diagonalMin = 1;
                        diagonalMax = reversePoints.length - 1;
                    }
                } while (--historyIndex >= -1);
                // There are cases where the reverse history will find diffs that
                // are correct, but not intuitive, so we need shift them.
                reverseChanges = changeHelper.getChanges();
            }
            return this.ConcatenateChanges(forwardChanges, reverseChanges);
        };
        /**
         * Given the range to compute the diff on, this method finds the point:
         * (midOriginal, midModified)
         * that exists in the middle of the LCS of the two sequences and
         * is the point at which the LCS problem may be broken down recursively.
         * This method will try to keep the LCS trace in memory. If the LCS recursion
         * point is calculated and the full trace is available in memory, then this method
         * will return the change list.
         * @param originalStart The start bound of the original sequence range
         * @param originalEnd The end bound of the original sequence range
         * @param modifiedStart The start bound of the modified sequence range
         * @param modifiedEnd The end bound of the modified sequence range
         * @param midOriginal The middle point of the original sequence range
         * @param midModified The middle point of the modified sequence range
         * @returns The diff changes, if available, otherwise null
         */
        LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
            var originalIndex, modifiedIndex;
            var diagonalForwardStart = 0, diagonalForwardEnd = 0;
            var diagonalReverseStart = 0, diagonalReverseEnd = 0;
            var numDifferences;
            // To traverse the edit graph and produce the proper LCS, our actual
            // start position is just outside the given boundary
            originalStart--;
            modifiedStart--;
            // We set these up to make the compiler happy, but they will
            // be replaced before we return with the actual recursion point
            midOriginalArr[0] = 0;
            midModifiedArr[0] = 0;
            // Clear out the history
            this.m_forwardHistory = [];
            this.m_reverseHistory = [];
            // Each cell in the two arrays corresponds to a diagonal in the edit graph.
            // The integer value in the cell represents the originalIndex of the furthest
            // reaching point found so far that ends in that diagonal.
            // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
            var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
            var numDiagonals = maxDifferences + 1;
            var forwardPoints = new Array(numDiagonals);
            var reversePoints = new Array(numDiagonals);
            // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
            // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
            var diagonalForwardBase = (modifiedEnd - modifiedStart);
            var diagonalReverseBase = (originalEnd - originalStart);
            // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
            //    diagonal number (relative to diagonalForwardBase)
            // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
            //    diagonal number (relative to diagonalReverseBase)
            var diagonalForwardOffset = (originalStart - modifiedStart);
            var diagonalReverseOffset = (originalEnd - modifiedEnd);
            // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
            //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
            // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
            var delta = diagonalReverseBase - diagonalForwardBase;
            var deltaIsEven = (delta % 2 === 0);
            // Here we set up the start and end points as the furthest points found so far
            // in both the forward and reverse directions, respectively
            forwardPoints[diagonalForwardBase] = originalStart;
            reversePoints[diagonalReverseBase] = originalEnd;
            // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
            quitEarlyArr[0] = false;
            // A couple of points:
            // --With this method, we iterate on the number of differences between the two sequences.
            //   The more differences there actually are, the longer this will take.
            // --Also, as the number of differences increases, we have to search on diagonals further
            //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
            // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
            //   is even and odd diagonals only when numDifferences is odd.
            var diagonal, tempOriginalIndex;
            for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
                var furthestOriginalIndex = 0;
                var furthestModifiedIndex = 0;
                // Run the algorithm in the forward direction
                diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
                diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
                for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                    // STEP 1: We extend the furthest reaching point in the present diagonal
                    // by looking at the diagonals above and below and picking the one whose point
                    // is further away from the start point (originalStart, modifiedStart)
                    if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                        originalIndex = forwardPoints[diagonal + 1];
                    }
                    else {
                        originalIndex = forwardPoints[diagonal - 1] + 1;
                    }
                    modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                    // Save the current originalIndex so we can test for false overlap in step 3
                    tempOriginalIndex = originalIndex;
                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                    // so long as the elements are equal.
                    while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                        originalIndex++;
                        modifiedIndex++;
                    }
                    forwardPoints[diagonal] = originalIndex;
                    if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                        furthestOriginalIndex = originalIndex;
                        furthestModifiedIndex = modifiedIndex;
                    }
                    // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                    // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                    // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                    // then check for overlap.
                    if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                        if (originalIndex >= reversePoints[diagonal]) {
                            midOriginalArr[0] = originalIndex;
                            midModifiedArr[0] = modifiedIndex;
                            if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                                // BINGO! We overlapped, and we have the full trace in memory!
                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                            }
                            else {
                                // Either false overlap, or we didn't have enough memory for the full trace
                                // Just return the recursion point
                                return null;
                            }
                        }
                    }
                }
                // Check to see if we should be quitting early, before moving on to the next iteration.
                var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
                if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {
                    // We can't finish, so skip ahead to generating a result from what we have.
                    quitEarlyArr[0] = true;
                    // Use the furthest distance we got in the forward direction.
                    midOriginalArr[0] = furthestOriginalIndex;
                    midModifiedArr[0] = furthestModifiedIndex;
                    if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                        // Enough of the history is in memory to walk it backwards
                        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                    }
                    else {
                        // We didn't actually remember enough of the history.
                        //Since we are quiting the diff early, we need to shift back the originalStart and modified start
                        //back into the boundary limits since we decremented their value above beyond the boundary limit.
                        originalStart++;
                        modifiedStart++;
                        return [
                            new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                        ];
                    }
                }
                // Run the algorithm in the reverse direction
                diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
                diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
                for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                    // STEP 1: We extend the furthest reaching point in the present diagonal
                    // by looking at the diagonals above and below and picking the one whose point
                    // is further away from the start point (originalEnd, modifiedEnd)
                    if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                        originalIndex = reversePoints[diagonal + 1] - 1;
                    }
                    else {
                        originalIndex = reversePoints[diagonal - 1];
                    }
                    modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                    // Save the current originalIndex so we can test for false overlap
                    tempOriginalIndex = originalIndex;
                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                    // as long as the elements are equal.
                    while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                        originalIndex--;
                        modifiedIndex--;
                    }
                    reversePoints[diagonal] = originalIndex;
                    // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                    // and diagonal is in the range of forward diagonals computed for numDifferences
                    // then check for overlap.
                    if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                        if (originalIndex <= forwardPoints[diagonal]) {
                            midOriginalArr[0] = originalIndex;
                            midModifiedArr[0] = modifiedIndex;
                            if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                                // BINGO! We overlapped, and we have the full trace in memory!
                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                            }
                            else {
                                // Either false overlap, or we didn't have enough memory for the full trace
                                // Just return the recursion point
                                return null;
                            }
                        }
                    }
                }
                // Save current vectors to history before the next iteration
                if (numDifferences <= MaxDifferencesHistory) {
                    // We are allocating space for one extra int, which we fill with
                    // the index of the diagonal base index
                    var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);
                    temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                    MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                    this.m_forwardHistory.push(temp);
                    temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);
                    temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                    MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                    this.m_reverseHistory.push(temp);
                }
            }
            // If we got here, then we have the full trace in history. We just have to convert it to a change list
            // NOTE: This part is a bit messy
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        };
        /**
         * Concatenates the two input DiffChange lists and returns the resulting
         * list.
         * @param The left changes
         * @param The right changes
         * @returns The concatenated list
         */
        LcsDiff.prototype.ConcatenateChanges = function (left, right) {
            var mergedChangeArr = [];
            var result = null;
            if (left.length === 0 || right.length === 0) {
                return (right.length > 0) ? right : left;
            }
            else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
                // Since we break the problem down recursively, it is possible that we
                // might recurse in the middle of a change thereby splitting it into
                // two changes. Here in the combining stage, we detect and fuse those
                // changes back together
                result = new Array(left.length + right.length - 1);
                MyArray.Copy(left, 0, result, 0, left.length - 1);
                result[left.length - 1] = mergedChangeArr[0];
                MyArray.Copy(right, 1, result, left.length, right.length - 1);
                return result;
            }
            else {
                result = new Array(left.length + right.length);
                MyArray.Copy(left, 0, result, 0, left.length);
                MyArray.Copy(right, 0, result, left.length, right.length);
                return result;
            }
        };
        /**
         * Returns true if the two changes overlap and can be merged into a single
         * change
         * @param left The left change
         * @param right The right change
         * @param mergedChange The merged change if the two overlap, null otherwise
         * @returns True if the two changes overlap
         */
        LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {
            Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
            Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
            if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                var originalStart = left.originalStart;
                var originalLength = left.originalLength;
                var modifiedStart = left.modifiedStart;
                var modifiedLength = left.modifiedLength;
                if (left.originalStart + left.originalLength >= right.originalStart) {
                    originalLength = right.originalStart + right.originalLength - left.originalStart;
                }
                if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                    modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
                }
                mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
                return true;
            }
            else {
                mergedChangeArr[0] = null;
                return false;
            }
        };
        /**
         * Helper method used to clip a diagonal index to the range of valid
         * diagonals. This also decides whether or not the diagonal index,
         * if it exceeds the boundary, should be clipped to the boundary or clipped
         * one inside the boundary depending on the Even/Odd status of the boundary
         * and numDifferences.
         * @param diagonal The index of the diagonal to clip.
         * @param numDifferences The current number of differences being iterated upon.
         * @param diagonalBaseIndex The base reference diagonal.
         * @param numDiagonals The total number of diagonals.
         * @returns The clipped diagonal index.
         */
        LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
            if (diagonal >= 0 && diagonal < numDiagonals) {
                // Nothing to clip, its in range
                return diagonal;
            }
            // diagonalsBelow: The number of diagonals below the reference diagonal
            // diagonalsAbove: The number of diagonals above the reference diagonal
            var diagonalsBelow = diagonalBaseIndex;
            var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
            var diffEven = (numDifferences % 2 === 0);
            if (diagonal < 0) {
                var lowerBoundEven = (diagonalsBelow % 2 === 0);
                return (diffEven === lowerBoundEven) ? 0 : 1;
            }
            else {
                var upperBoundEven = (diagonalsAbove % 2 === 0);
                return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
            }
        };
        return LcsDiff;
    }());
    exports.LcsDiff = LcsDiff;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(__m[67/*vs/base/common/events*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event = (function () {
        function Event(originalEvent) {
            this.time = (new Date()).getTime();
            this.originalEvent = originalEvent;
            this.source = null;
        }
        return Event;
    }());
    exports.Event = Event;
    var PropertyChangeEvent = (function (_super) {
        __extends(PropertyChangeEvent, _super);
        function PropertyChangeEvent(key, oldValue, newValue, originalEvent) {
            var _this = _super.call(this, originalEvent) || this;
            _this.key = key;
            _this.oldValue = oldValue;
            _this.newValue = newValue;
            return _this;
        }
        return PropertyChangeEvent;
    }(Event));
    exports.PropertyChangeEvent = PropertyChangeEvent;
    var ViewerEvent = (function (_super) {
        __extends(ViewerEvent, _super);
        function ViewerEvent(element, originalEvent) {
            var _this = _super.call(this, originalEvent) || this;
            _this.element = element;
            return _this;
        }
        return ViewerEvent;
    }(Event));
    exports.ViewerEvent = ViewerEvent;
    exports.EventType = {
        PROPERTY_CHANGED: 'propertyChanged',
        SELECTION: 'selection',
        FOCUS: 'focus',
        BLUR: 'blur',
        HIGHLIGHT: 'highlight',
        EXPAND: 'expand',
        COLLAPSE: 'collapse',
        TOGGLE: 'toggle',
        BEFORE_RUN: 'beforeRun',
        RUN: 'run',
        EDIT: 'edit',
        SAVE: 'save',
        CANCEL: 'cancel',
        CHANGE: 'change',
        DISPOSE: 'dispose',
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[195/*vs/base/common/functional*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    function not(fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !fn.apply(void 0, args);
        };
    }
    exports.not = not;
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
});

define(__m[211/*vs/base/common/hash*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Return a hash value for an object.
     */
    function hash(obj, hashVal) {
        if (hashVal === void 0) { hashVal = 0; }
        switch (typeof obj) {
            case 'object':
                if (obj === null) {
                    return numberHash(349, hashVal);
                }
                else if (Array.isArray(obj)) {
                    return arrayHash(obj, hashVal);
                }
                return objectHash(obj, hashVal);
            case 'string':
                return stringHash(obj, hashVal);
            case 'boolean':
                return booleanHash(obj, hashVal);
            case 'number':
                return numberHash(obj, hashVal);
            case 'undefined':
                return numberHash(obj, 937);
            default:
                return numberHash(obj, 617);
        }
    }
    exports.hash = hash;
    function numberHash(val, initialHashVal) {
        return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
    }
    function booleanHash(b, initialHashVal) {
        return numberHash(b ? 433 : 863, initialHashVal);
    }
    function stringHash(s, hashVal) {
        hashVal = numberHash(149417, hashVal);
        for (var i = 0, length_1 = s.length; i < length_1; i++) {
            hashVal = numberHash(s.charCodeAt(i), hashVal);
        }
        return hashVal;
    }
    function arrayHash(arr, initialHashVal) {
        initialHashVal = numberHash(104579, initialHashVal);
        return arr.reduce(function (hashVal, item) { return hash(item, hashVal); }, initialHashVal);
    }
    function objectHash(obj, initialHashVal) {
        initialHashVal = numberHash(181387, initialHashVal);
        return Object.keys(obj).sort().reduce(function (hashVal, key) {
            hashVal = stringHash(key, hashVal);
            return hash(obj[key], hashVal);
        }, initialHashVal);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[109/*vs/base/common/htmlContent*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    function markedStringsEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        if (Array.isArray(a)) {
            if (!Array.isArray(b)) {
                return false;
            }
            return markedStringArrEquals(a, b);
        }
        return markedStringEqual(a, b);
    }
    exports.markedStringsEquals = markedStringsEquals;
    function markedStringArrEquals(a, b) {
        var aLen = a.length, bLen = b.length;
        if (aLen !== bLen) {
            return false;
        }
        for (var i = 0; i < aLen; i++) {
            if (!markedStringEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    function markedStringEqual(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        if (typeof a === 'string') {
            return typeof b === 'string' && a === b;
        }
        return (a['language'] === b['language']
            && a['value'] === b['value']);
    }
    function textToMarkedString(text) {
        return text.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    exports.textToMarkedString = textToMarkedString;
    function removeMarkdownEscapes(text) {
        if (!text) {
            return text;
        }
        return text.replace(/\\([\\`*_{}[\]()#+\-.!])/g, '$1');
    }
    exports.removeMarkdownEscapes = removeMarkdownEscapes;
    function htmlContentElementCodeEqual(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.language === b.language
            && a.value === b.value);
    }
    function htmlContentElementEqual(a, b) {
        return (a.formattedText === b.formattedText
            && a.text === b.text
            && a.className === b.className
            && a.style === b.style
            && a.customStyle === b.customStyle
            && a.tagName === b.tagName
            && a.isText === b.isText
            && a.role === b.role
            && a.markdown === b.markdown
            && htmlContentElementCodeEqual(a.code, b.code)
            && htmlContentElementArrEquals(a.children, b.children));
    }
    function htmlContentElementArrEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        var aLen = a.length, bLen = b.length;
        if (aLen !== bLen) {
            return false;
        }
        for (var i = 0; i < aLen; i++) {
            if (!htmlContentElementEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    exports.htmlContentElementArrEquals = htmlContentElementArrEquals;
});

define(__m[113/*vs/base/common/idGenerator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var IdGenerator = (function () {
        function IdGenerator(prefix) {
            this._prefix = prefix;
            this._lastId = 0;
        }
        IdGenerator.prototype.nextId = function () {
            return this._prefix + (++this._lastId);
        };
        return IdGenerator;
    }());
    exports.IdGenerator = IdGenerator;
    exports.defaultGenerator = new IdGenerator('id#');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[88/*vs/base/common/iterator*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    var ArrayIterator = (function () {
        function ArrayIterator(items, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = items.length; }
            this.items = items;
            this.start = start;
            this.end = end;
            this.index = start - 1;
        }
        ArrayIterator.prototype.first = function () {
            this.index = this.start;
            return this.current();
        };
        ArrayIterator.prototype.next = function () {
            this.index = Math.min(this.index + 1, this.end);
            return this.current();
        };
        ArrayIterator.prototype.current = function () {
            if (this.index === this.start - 1 || this.index === this.end) {
                return null;
            }
            return this.items[this.index];
        };
        return ArrayIterator;
    }());
    exports.ArrayIterator = ArrayIterator;
    var ArrayNavigator = (function (_super) {
        __extends(ArrayNavigator, _super);
        function ArrayNavigator(items, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = items.length; }
            return _super.call(this, items, start, end) || this;
        }
        ArrayNavigator.prototype.current = function () {
            return _super.prototype.current.call(this);
        };
        ArrayNavigator.prototype.previous = function () {
            this.index = Math.max(this.index - 1, this.start - 1);
            return this.current();
        };
        ArrayNavigator.prototype.first = function () {
            this.index = this.start;
            return this.current();
        };
        ArrayNavigator.prototype.last = function () {
            this.index = this.end - 1;
            return this.current();
        };
        ArrayNavigator.prototype.parent = function () {
            return null;
        };
        return ArrayNavigator;
    }(ArrayIterator));
    exports.ArrayNavigator = ArrayNavigator;
    var MappedIterator = (function () {
        function MappedIterator(iterator, fn) {
            this.iterator = iterator;
            this.fn = fn;
            // noop
        }
        MappedIterator.prototype.next = function () { return this.fn(this.iterator.next()); };
        return MappedIterator;
    }());
    exports.MappedIterator = MappedIterator;
    var MappedNavigator = (function (_super) {
        __extends(MappedNavigator, _super);
        function MappedNavigator(navigator, fn) {
            var _this = _super.call(this, navigator, fn) || this;
            _this.navigator = navigator;
            return _this;
        }
        MappedNavigator.prototype.current = function () { return this.fn(this.navigator.current()); };
        MappedNavigator.prototype.previous = function () { return this.fn(this.navigator.previous()); };
        MappedNavigator.prototype.parent = function () { return this.fn(this.navigator.parent()); };
        MappedNavigator.prototype.first = function () { return this.fn(this.navigator.first()); };
        MappedNavigator.prototype.last = function () { return this.fn(this.navigator.last()); };
        return MappedNavigator;
    }(MappedIterator));
    exports.MappedNavigator = MappedNavigator;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[32/*vs/base/common/keyCodes*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
     * But these are "more general", as they should work across browsers & OS`s.
     */
    var KeyCode;
    (function (KeyCode) {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
        KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
        KeyCode[KeyCode["Tab"] = 2] = "Tab";
        KeyCode[KeyCode["Enter"] = 3] = "Enter";
        KeyCode[KeyCode["Shift"] = 4] = "Shift";
        KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
        KeyCode[KeyCode["Alt"] = 6] = "Alt";
        KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
        KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
        KeyCode[KeyCode["Escape"] = 9] = "Escape";
        KeyCode[KeyCode["Space"] = 10] = "Space";
        KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
        KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
        KeyCode[KeyCode["End"] = 13] = "End";
        KeyCode[KeyCode["Home"] = 14] = "Home";
        KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
        KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
        KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
        KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
        KeyCode[KeyCode["Insert"] = 19] = "Insert";
        KeyCode[KeyCode["Delete"] = 20] = "Delete";
        KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
        KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
        KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
        KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
        KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
        KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
        KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
        KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
        KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
        KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
        KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
        KeyCode[KeyCode["Meta"] = 57] = "Meta";
        KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
        KeyCode[KeyCode["F1"] = 59] = "F1";
        KeyCode[KeyCode["F2"] = 60] = "F2";
        KeyCode[KeyCode["F3"] = 61] = "F3";
        KeyCode[KeyCode["F4"] = 62] = "F4";
        KeyCode[KeyCode["F5"] = 63] = "F5";
        KeyCode[KeyCode["F6"] = 64] = "F6";
        KeyCode[KeyCode["F7"] = 65] = "F7";
        KeyCode[KeyCode["F8"] = 66] = "F8";
        KeyCode[KeyCode["F9"] = 67] = "F9";
        KeyCode[KeyCode["F10"] = 68] = "F10";
        KeyCode[KeyCode["F11"] = 69] = "F11";
        KeyCode[KeyCode["F12"] = 70] = "F12";
        KeyCode[KeyCode["F13"] = 71] = "F13";
        KeyCode[KeyCode["F14"] = 72] = "F14";
        KeyCode[KeyCode["F15"] = 73] = "F15";
        KeyCode[KeyCode["F16"] = 74] = "F16";
        KeyCode[KeyCode["F17"] = 75] = "F17";
        KeyCode[KeyCode["F18"] = 76] = "F18";
        KeyCode[KeyCode["F19"] = 77] = "F19";
        KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
        KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
        KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
        KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
        KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
        KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
        KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
        KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
        KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
        KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
        KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
        KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
        KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
        KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
        KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
        KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
        KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        KeyCode[KeyCode["MAX_VALUE"] = 109] = "MAX_VALUE";
    })(KeyCode = exports.KeyCode || (exports.KeyCode = {}));
    var Mapping = (function () {
        function Mapping(fromKeyCode, toKeyCode) {
            this._fromKeyCode = fromKeyCode;
            this._toKeyCode = toKeyCode;
        }
        Mapping.prototype.fromKeyCode = function (keyCode) {
            return this._fromKeyCode[keyCode];
        };
        Mapping.prototype.toKeyCode = function (str) {
            if (this._toKeyCode.hasOwnProperty(str)) {
                return this._toKeyCode[str];
            }
            return 0 /* Unknown */;
        };
        return Mapping;
    }());
    exports.Mapping = Mapping;
    function createMapping(fill1, fill2) {
        var MAP = [];
        fill1(MAP);
        var REVERSE_MAP = {};
        for (var i = 0, len = MAP.length; i < len; i++) {
            if (!MAP[i]) {
                continue;
            }
            REVERSE_MAP[MAP[i]] = i;
        }
        fill2(REVERSE_MAP);
        var FINAL_REVERSE_MAP = {};
        for (var entry in REVERSE_MAP) {
            if (REVERSE_MAP.hasOwnProperty(entry)) {
                FINAL_REVERSE_MAP[entry] = REVERSE_MAP[entry];
                FINAL_REVERSE_MAP[entry.toLowerCase()] = REVERSE_MAP[entry];
            }
        }
        return new Mapping(MAP, FINAL_REVERSE_MAP);
    }
    var STRING = createMapping(function (TO_STRING_MAP) {
        TO_STRING_MAP[0 /* Unknown */] = 'unknown';
        TO_STRING_MAP[1 /* Backspace */] = 'Backspace';
        TO_STRING_MAP[2 /* Tab */] = 'Tab';
        TO_STRING_MAP[3 /* Enter */] = 'Enter';
        TO_STRING_MAP[4 /* Shift */] = 'Shift';
        TO_STRING_MAP[5 /* Ctrl */] = 'Ctrl';
        TO_STRING_MAP[6 /* Alt */] = 'Alt';
        TO_STRING_MAP[7 /* PauseBreak */] = 'PauseBreak';
        TO_STRING_MAP[8 /* CapsLock */] = 'CapsLock';
        TO_STRING_MAP[9 /* Escape */] = 'Escape';
        TO_STRING_MAP[10 /* Space */] = 'Space';
        TO_STRING_MAP[11 /* PageUp */] = 'PageUp';
        TO_STRING_MAP[12 /* PageDown */] = 'PageDown';
        TO_STRING_MAP[13 /* End */] = 'End';
        TO_STRING_MAP[14 /* Home */] = 'Home';
        TO_STRING_MAP[15 /* LeftArrow */] = 'LeftArrow';
        TO_STRING_MAP[16 /* UpArrow */] = 'UpArrow';
        TO_STRING_MAP[17 /* RightArrow */] = 'RightArrow';
        TO_STRING_MAP[18 /* DownArrow */] = 'DownArrow';
        TO_STRING_MAP[19 /* Insert */] = 'Insert';
        TO_STRING_MAP[20 /* Delete */] = 'Delete';
        TO_STRING_MAP[21 /* KEY_0 */] = '0';
        TO_STRING_MAP[22 /* KEY_1 */] = '1';
        TO_STRING_MAP[23 /* KEY_2 */] = '2';
        TO_STRING_MAP[24 /* KEY_3 */] = '3';
        TO_STRING_MAP[25 /* KEY_4 */] = '4';
        TO_STRING_MAP[26 /* KEY_5 */] = '5';
        TO_STRING_MAP[27 /* KEY_6 */] = '6';
        TO_STRING_MAP[28 /* KEY_7 */] = '7';
        TO_STRING_MAP[29 /* KEY_8 */] = '8';
        TO_STRING_MAP[30 /* KEY_9 */] = '9';
        TO_STRING_MAP[31 /* KEY_A */] = 'A';
        TO_STRING_MAP[32 /* KEY_B */] = 'B';
        TO_STRING_MAP[33 /* KEY_C */] = 'C';
        TO_STRING_MAP[34 /* KEY_D */] = 'D';
        TO_STRING_MAP[35 /* KEY_E */] = 'E';
        TO_STRING_MAP[36 /* KEY_F */] = 'F';
        TO_STRING_MAP[37 /* KEY_G */] = 'G';
        TO_STRING_MAP[38 /* KEY_H */] = 'H';
        TO_STRING_MAP[39 /* KEY_I */] = 'I';
        TO_STRING_MAP[40 /* KEY_J */] = 'J';
        TO_STRING_MAP[41 /* KEY_K */] = 'K';
        TO_STRING_MAP[42 /* KEY_L */] = 'L';
        TO_STRING_MAP[43 /* KEY_M */] = 'M';
        TO_STRING_MAP[44 /* KEY_N */] = 'N';
        TO_STRING_MAP[45 /* KEY_O */] = 'O';
        TO_STRING_MAP[46 /* KEY_P */] = 'P';
        TO_STRING_MAP[47 /* KEY_Q */] = 'Q';
        TO_STRING_MAP[48 /* KEY_R */] = 'R';
        TO_STRING_MAP[49 /* KEY_S */] = 'S';
        TO_STRING_MAP[50 /* KEY_T */] = 'T';
        TO_STRING_MAP[51 /* KEY_U */] = 'U';
        TO_STRING_MAP[52 /* KEY_V */] = 'V';
        TO_STRING_MAP[53 /* KEY_W */] = 'W';
        TO_STRING_MAP[54 /* KEY_X */] = 'X';
        TO_STRING_MAP[55 /* KEY_Y */] = 'Y';
        TO_STRING_MAP[56 /* KEY_Z */] = 'Z';
        TO_STRING_MAP[58 /* ContextMenu */] = 'ContextMenu';
        TO_STRING_MAP[59 /* F1 */] = 'F1';
        TO_STRING_MAP[60 /* F2 */] = 'F2';
        TO_STRING_MAP[61 /* F3 */] = 'F3';
        TO_STRING_MAP[62 /* F4 */] = 'F4';
        TO_STRING_MAP[63 /* F5 */] = 'F5';
        TO_STRING_MAP[64 /* F6 */] = 'F6';
        TO_STRING_MAP[65 /* F7 */] = 'F7';
        TO_STRING_MAP[66 /* F8 */] = 'F8';
        TO_STRING_MAP[67 /* F9 */] = 'F9';
        TO_STRING_MAP[68 /* F10 */] = 'F10';
        TO_STRING_MAP[69 /* F11 */] = 'F11';
        TO_STRING_MAP[70 /* F12 */] = 'F12';
        TO_STRING_MAP[71 /* F13 */] = 'F13';
        TO_STRING_MAP[72 /* F14 */] = 'F14';
        TO_STRING_MAP[73 /* F15 */] = 'F15';
        TO_STRING_MAP[74 /* F16 */] = 'F16';
        TO_STRING_MAP[75 /* F17 */] = 'F17';
        TO_STRING_MAP[76 /* F18 */] = 'F18';
        TO_STRING_MAP[77 /* F19 */] = 'F19';
        TO_STRING_MAP[78 /* NumLock */] = 'NumLock';
        TO_STRING_MAP[79 /* ScrollLock */] = 'ScrollLock';
        TO_STRING_MAP[80 /* US_SEMICOLON */] = ';';
        TO_STRING_MAP[81 /* US_EQUAL */] = '=';
        TO_STRING_MAP[82 /* US_COMMA */] = ',';
        TO_STRING_MAP[83 /* US_MINUS */] = '-';
        TO_STRING_MAP[84 /* US_DOT */] = '.';
        TO_STRING_MAP[85 /* US_SLASH */] = '/';
        TO_STRING_MAP[86 /* US_BACKTICK */] = '`';
        TO_STRING_MAP[87 /* US_OPEN_SQUARE_BRACKET */] = '[';
        TO_STRING_MAP[88 /* US_BACKSLASH */] = '\\';
        TO_STRING_MAP[89 /* US_CLOSE_SQUARE_BRACKET */] = ']';
        TO_STRING_MAP[90 /* US_QUOTE */] = '\'';
        TO_STRING_MAP[91 /* OEM_8 */] = 'OEM_8';
        TO_STRING_MAP[92 /* OEM_102 */] = 'OEM_102';
        TO_STRING_MAP[93 /* NUMPAD_0 */] = 'NumPad0';
        TO_STRING_MAP[94 /* NUMPAD_1 */] = 'NumPad1';
        TO_STRING_MAP[95 /* NUMPAD_2 */] = 'NumPad2';
        TO_STRING_MAP[96 /* NUMPAD_3 */] = 'NumPad3';
        TO_STRING_MAP[97 /* NUMPAD_4 */] = 'NumPad4';
        TO_STRING_MAP[98 /* NUMPAD_5 */] = 'NumPad5';
        TO_STRING_MAP[99 /* NUMPAD_6 */] = 'NumPad6';
        TO_STRING_MAP[100 /* NUMPAD_7 */] = 'NumPad7';
        TO_STRING_MAP[101 /* NUMPAD_8 */] = 'NumPad8';
        TO_STRING_MAP[102 /* NUMPAD_9 */] = 'NumPad9';
        TO_STRING_MAP[103 /* NUMPAD_MULTIPLY */] = 'NumPad_Multiply';
        TO_STRING_MAP[104 /* NUMPAD_ADD */] = 'NumPad_Add';
        TO_STRING_MAP[105 /* NUMPAD_SEPARATOR */] = 'NumPad_Separator';
        TO_STRING_MAP[106 /* NUMPAD_SUBTRACT */] = 'NumPad_Subtract';
        TO_STRING_MAP[107 /* NUMPAD_DECIMAL */] = 'NumPad_Decimal';
        TO_STRING_MAP[108 /* NUMPAD_DIVIDE */] = 'NumPad_Divide';
        // for (let i = 0; i < KeyCode.MAX_VALUE; i++) {
        // 	if (!TO_STRING_MAP[i]) {
        // 		console.warn('Missing string representation for ' + KeyCode[i]);
        // 	}
        // }
    }, function (FROM_STRING_MAP) {
        FROM_STRING_MAP['\r'] = 3 /* Enter */;
    });
    exports.USER_SETTINGS = createMapping(function (TO_USER_SETTINGS_MAP) {
        for (var i = 0, len = STRING._fromKeyCode.length; i < len; i++) {
            TO_USER_SETTINGS_MAP[i] = STRING._fromKeyCode[i];
        }
        TO_USER_SETTINGS_MAP[15 /* LeftArrow */] = 'Left';
        TO_USER_SETTINGS_MAP[16 /* UpArrow */] = 'Up';
        TO_USER_SETTINGS_MAP[17 /* RightArrow */] = 'Right';
        TO_USER_SETTINGS_MAP[18 /* DownArrow */] = 'Down';
    }, function (FROM_USER_SETTINGS_MAP) {
        FROM_USER_SETTINGS_MAP['OEM_1'] = 80 /* US_SEMICOLON */;
        FROM_USER_SETTINGS_MAP['OEM_PLUS'] = 81 /* US_EQUAL */;
        FROM_USER_SETTINGS_MAP['OEM_COMMA'] = 82 /* US_COMMA */;
        FROM_USER_SETTINGS_MAP['OEM_MINUS'] = 83 /* US_MINUS */;
        FROM_USER_SETTINGS_MAP['OEM_PERIOD'] = 84 /* US_DOT */;
        FROM_USER_SETTINGS_MAP['OEM_2'] = 85 /* US_SLASH */;
        FROM_USER_SETTINGS_MAP['OEM_3'] = 86 /* US_BACKTICK */;
        FROM_USER_SETTINGS_MAP['OEM_4'] = 87 /* US_OPEN_SQUARE_BRACKET */;
        FROM_USER_SETTINGS_MAP['OEM_5'] = 88 /* US_BACKSLASH */;
        FROM_USER_SETTINGS_MAP['OEM_6'] = 89 /* US_CLOSE_SQUARE_BRACKET */;
        FROM_USER_SETTINGS_MAP['OEM_7'] = 90 /* US_QUOTE */;
        FROM_USER_SETTINGS_MAP['OEM_8'] = 91 /* OEM_8 */;
        FROM_USER_SETTINGS_MAP['OEM_102'] = 92 /* OEM_102 */;
    });
    var KeyCodeUtils;
    (function (KeyCodeUtils) {
        function toString(key) {
            return STRING.fromKeyCode(key);
        }
        KeyCodeUtils.toString = toString;
        function fromString(key) {
            return STRING.toKeyCode(key);
        }
        KeyCodeUtils.fromString = fromString;
    })(KeyCodeUtils = exports.KeyCodeUtils || (exports.KeyCodeUtils = {}));
    /**
     * Binary encoding strategy:
     * ```
     *    1111 11
     *    5432 1098 7654 3210
     *    ---- CSAW KKKK KKKK
     *  C = bit 11 = ctrlCmd flag
     *  S = bit 10 = shift flag
     *  A = bit 9 = alt flag
     *  W = bit 8 = winCtrl flag
     *  K = bits 0-7 = key code
     * ```
     */
    var BinaryKeybindingsMask;
    (function (BinaryKeybindingsMask) {
        BinaryKeybindingsMask[BinaryKeybindingsMask["CtrlCmd"] = 2048] = "CtrlCmd";
        BinaryKeybindingsMask[BinaryKeybindingsMask["Shift"] = 1024] = "Shift";
        BinaryKeybindingsMask[BinaryKeybindingsMask["Alt"] = 512] = "Alt";
        BinaryKeybindingsMask[BinaryKeybindingsMask["WinCtrl"] = 256] = "WinCtrl";
        BinaryKeybindingsMask[BinaryKeybindingsMask["KeyCode"] = 255] = "KeyCode";
        BinaryKeybindingsMask[BinaryKeybindingsMask["ModifierMask"] = 3840] = "ModifierMask";
    })(BinaryKeybindingsMask || (BinaryKeybindingsMask = {}));
    var KeyMod;
    (function (KeyMod) {
        KeyMod[KeyMod["CtrlCmd"] = 2048] = "CtrlCmd";
        KeyMod[KeyMod["Shift"] = 1024] = "Shift";
        KeyMod[KeyMod["Alt"] = 512] = "Alt";
        KeyMod[KeyMod["WinCtrl"] = 256] = "WinCtrl";
    })(KeyMod = exports.KeyMod || (exports.KeyMod = {}));
    function KeyChord(firstPart, secondPart) {
        var chordPart = ((secondPart & 0x0000ffff) << 16) >>> 0;
        return (firstPart | chordPart) >>> 0;
    }
    exports.KeyChord = KeyChord;
    var BinaryKeybindings = (function () {
        function BinaryKeybindings() {
        }
        BinaryKeybindings.extractFirstPart = function (keybinding) {
            return (keybinding & 0x0000ffff) >>> 0;
        };
        BinaryKeybindings.extractChordPart = function (keybinding) {
            return (keybinding & 0xffff0000) >>> 16;
        };
        BinaryKeybindings.hasChord = function (keybinding) {
            return (this.extractChordPart(keybinding) !== 0);
        };
        BinaryKeybindings.hasCtrlCmd = function (keybinding) {
            return (keybinding & 2048 /* CtrlCmd */ ? true : false);
        };
        BinaryKeybindings.hasShift = function (keybinding) {
            return (keybinding & 1024 /* Shift */ ? true : false);
        };
        BinaryKeybindings.hasAlt = function (keybinding) {
            return (keybinding & 512 /* Alt */ ? true : false);
        };
        BinaryKeybindings.hasWinCtrl = function (keybinding) {
            return (keybinding & 256 /* WinCtrl */ ? true : false);
        };
        BinaryKeybindings.isModifierKey = function (keybinding) {
            if ((keybinding & 3840 /* ModifierMask */) === keybinding) {
                return true;
            }
            var keyCode = this.extractKeyCode(keybinding);
            return (keyCode === 5 /* Ctrl */
                || keyCode === 57 /* Meta */
                || keyCode === 6 /* Alt */
                || keyCode === 4 /* Shift */);
        };
        BinaryKeybindings.extractKeyCode = function (keybinding) {
            return (keybinding & 255 /* KeyCode */);
        };
        return BinaryKeybindings;
    }());
    exports.BinaryKeybindings = BinaryKeybindings;
    var Keybinding = (function () {
        function Keybinding(keybinding) {
            this.value = keybinding;
        }
        Keybinding.prototype.equals = function (other) {
            return this.value === other.value;
        };
        Keybinding.prototype.hasCtrlCmd = function () {
            return BinaryKeybindings.hasCtrlCmd(this.value);
        };
        Keybinding.prototype.hasShift = function () {
            return BinaryKeybindings.hasShift(this.value);
        };
        Keybinding.prototype.hasAlt = function () {
            return BinaryKeybindings.hasAlt(this.value);
        };
        Keybinding.prototype.hasWinCtrl = function () {
            return BinaryKeybindings.hasWinCtrl(this.value);
        };
        Keybinding.prototype.isModifierKey = function () {
            return BinaryKeybindings.isModifierKey(this.value);
        };
        Keybinding.prototype.getKeyCode = function () {
            return BinaryKeybindings.extractKeyCode(this.value);
        };
        return Keybinding;
    }());
    exports.Keybinding = Keybinding;
});






define(__m[3/*vs/base/common/lifecycle*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.empty = Object.freeze({
        dispose: function () { }
    });
    function dispose(first) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (Array.isArray(first)) {
            first.forEach(function (d) { return d && d.dispose(); });
            return [];
        }
        else if (rest.length === 0) {
            if (first) {
                first.dispose();
                return first;
            }
        }
        else {
            dispose(first);
            dispose(rest);
            return [];
        }
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i] = arguments[_i];
        }
        return combinedDisposable(fns.map(function (fn) { return ({ dispose: fn }); }));
    }
    exports.toDisposable = toDisposable;
    var Disposable = (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Disposables = (function (_super) {
        __extends(Disposables, _super);
        function Disposables() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Disposables.prototype.add = function (arg) {
            if (!Array.isArray(arg)) {
                return this._register(arg);
            }
            else {
                for (var _i = 0, arg_1 = arg; _i < arg_1.length; _i++) {
                    var element = arg_1[_i];
                    return this._register(element);
                }
            }
        };
        return Disposables;
    }(Disposable));
    exports.Disposables = Disposables;
    var OneDisposable = (function () {
        function OneDisposable() {
        }
        Object.defineProperty(OneDisposable.prototype, "value", {
            set: function (value) {
                if (this._value) {
                    this._value.dispose();
                }
                this._value = value;
            },
            enumerable: true,
            configurable: true
        });
        OneDisposable.prototype.dispose = function () {
            this.value = null;
        };
        return OneDisposable;
    }());
    exports.OneDisposable = OneDisposable;
    var ReferenceCollection = (function () {
        function ReferenceCollection() {
            this.references = Object.create(null);
        }
        ReferenceCollection.prototype.acquire = function (key) {
            var _this = this;
            var reference = this.references[key];
            if (!reference) {
                reference = this.references[key] = { counter: 0, object: this.createReferencedObject(key) };
            }
            var object = reference.object;
            var dispose = function () {
                if (--reference.counter === 0) {
                    _this.destroyReferencedObject(reference.object);
                    delete _this.references[key];
                }
            };
            reference.counter++;
            return { object: object, dispose: dispose };
        };
        return ReferenceCollection;
    }());
    exports.ReferenceCollection = ReferenceCollection;
    var ImmortalReference = (function () {
        function ImmortalReference(object) {
            this.object = object;
        }
        ImmortalReference.prototype.dispose = function () { };
        return ImmortalReference;
    }());
    exports.ImmortalReference = ImmortalReference;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[108/*vs/base/common/map*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    /**
     * A simple map to store value by a key object. Key can be any object that has toString() function to get
     * string value of the key.
     */
    var LinkedMap = (function () {
        function LinkedMap() {
            this.map = Object.create(null);
            this._size = 0;
        }
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.get = function (k) {
            var value = this.peek(k);
            return value ? value : null;
        };
        LinkedMap.prototype.getOrSet = function (k, t) {
            var res = this.get(k);
            if (res) {
                return res;
            }
            this.set(k, t);
            return t;
        };
        LinkedMap.prototype.keys = function () {
            var keys = [];
            for (var key in this.map) {
                keys.push(this.map[key].key);
            }
            return keys;
        };
        LinkedMap.prototype.values = function () {
            var values = [];
            for (var key in this.map) {
                values.push(this.map[key].value);
            }
            return values;
        };
        LinkedMap.prototype.entries = function () {
            var entries = [];
            for (var key in this.map) {
                entries.push(this.map[key]);
            }
            return entries;
        };
        LinkedMap.prototype.set = function (k, t) {
            if (this.get(k)) {
                return false; // already present!
            }
            this.push(k, t);
            return true;
        };
        LinkedMap.prototype.delete = function (k) {
            var value = this.get(k);
            if (value) {
                this.pop(k);
                return value;
            }
            return null;
        };
        LinkedMap.prototype.has = function (k) {
            return !!this.get(k);
        };
        LinkedMap.prototype.clear = function () {
            this.map = Object.create(null);
            this._size = 0;
        };
        LinkedMap.prototype.push = function (key, value) {
            var entry = { key: key, value: value };
            this.map[key.toString()] = entry;
            this._size++;
        };
        LinkedMap.prototype.pop = function (k) {
            delete this.map[k.toString()];
            this._size--;
        };
        LinkedMap.prototype.peek = function (k) {
            var entry = this.map[k.toString()];
            return entry ? entry.value : null;
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
    /**
     * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,
     * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,
     * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).
     */
    var BoundedLinkedMap = (function () {
        function BoundedLinkedMap(limit, ratio) {
            if (limit === void 0) { limit = Number.MAX_VALUE; }
            if (ratio === void 0) { ratio = 1; }
            this.limit = limit;
            this.map = Object.create(null);
            this._size = 0;
            this.ratio = limit * ratio;
        }
        Object.defineProperty(BoundedLinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        BoundedLinkedMap.prototype.set = function (key, value) {
            if (this.map[key]) {
                return false; // already present!
            }
            var entry = { key: key, value: value };
            this.push(entry);
            if (this._size > this.limit) {
                this.trim();
            }
            return true;
        };
        BoundedLinkedMap.prototype.get = function (key) {
            var entry = this.map[key];
            return entry ? entry.value : null;
        };
        BoundedLinkedMap.prototype.getOrSet = function (k, t) {
            var res = this.get(k);
            if (res) {
                return res;
            }
            this.set(k, t);
            return t;
        };
        BoundedLinkedMap.prototype.delete = function (key) {
            var entry = this.map[key];
            if (entry) {
                this.map[key] = void 0;
                this._size--;
                if (entry.next) {
                    entry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]
                }
                else {
                    this.head = entry.prev; // [A]-[x] = [A]
                }
                if (entry.prev) {
                    entry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]
                }
                else {
                    this.tail = entry.next; // [x]-[A] = [A]
                }
                return entry.value;
            }
            return null;
        };
        BoundedLinkedMap.prototype.has = function (key) {
            return !!this.map[key];
        };
        BoundedLinkedMap.prototype.clear = function () {
            this.map = Object.create(null);
            this._size = 0;
            this.head = null;
            this.tail = null;
        };
        BoundedLinkedMap.prototype.push = function (entry) {
            if (this.head) {
                // [A]-[B] = [A]-[B]->[X]
                entry.prev = this.head;
                this.head.next = entry;
            }
            if (!this.tail) {
                this.tail = entry;
            }
            this.head = entry;
            this.map[entry.key] = entry;
            this._size++;
        };
        BoundedLinkedMap.prototype.trim = function () {
            if (this.tail) {
                // Remove all elements until ratio is reached
                if (this.ratio < this.limit) {
                    var index = 0;
                    var current = this.tail;
                    while (current.next) {
                        // Remove the entry
                        this.map[current.key] = void 0;
                        this._size--;
                        // if we reached the element that overflows our ratio condition
                        // make its next element the new tail of the Map and adjust the size
                        if (index === this.ratio) {
                            this.tail = current.next;
                            this.tail.prev = null;
                            break;
                        }
                        // Move on
                        current = current.next;
                        index++;
                    }
                }
                else {
                    this.map[this.tail.key] = void 0;
                    this._size--;
                    // [x]-[B] = [B]
                    this.tail = this.tail.next;
                    this.tail.prev = null;
                }
            }
        };
        return BoundedLinkedMap;
    }());
    exports.BoundedLinkedMap = BoundedLinkedMap;
    /**
     * A subclass of Map<T> that makes an entry the MRU entry as soon
     * as it is being accessed. In combination with the limit for the
     * maximum number of elements in the cache, it helps to remove those
     * entries from the cache that are LRU.
     */
    var LRUCache = (function (_super) {
        __extends(LRUCache, _super);
        function LRUCache(limit) {
            return _super.call(this, limit) || this;
        }
        LRUCache.prototype.get = function (key) {
            // Upon access of an entry, make it the head of
            // the linked map so that it is the MRU element
            var entry = this.map[key];
            if (entry) {
                this.delete(key);
                this.push(entry);
                return entry.value;
            }
            return null;
        };
        return LRUCache;
    }(BoundedLinkedMap));
    exports.LRUCache = LRUCache;
    // --- trie'ish datastructure
    var Node = (function () {
        function Node() {
            this.children = new Map();
        }
        return Node;
    }());
    /**
     * A trie map that allows for fast look up when keys are substrings
     * to the actual search keys (dir/subdir-problem).
     */
    var TrieMap = (function () {
        function TrieMap(splitter) {
            this._root = new Node();
            this._splitter = splitter;
        }
        TrieMap.prototype.insert = function (path, element) {
            var parts = this._splitter(path);
            var i = 0;
            // find insertion node
            var node = this._root;
            for (; i < parts.length; i++) {
                var child = node.children[parts[i]];
                if (child) {
                    node = child;
                    continue;
                }
                break;
            }
            // create new nodes
            var newNode;
            for (; i < parts.length; i++) {
                newNode = new Node();
                node.children[parts[i]] = newNode;
                node = newNode;
            }
            node.element = element;
        };
        TrieMap.prototype.lookUp = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                var part = parts_1[_i];
                node = children[part];
                if (!node) {
                    return;
                }
                children = node.children;
            }
            return node.element;
        };
        TrieMap.prototype.findSubstr = function (path) {
            var parts = this._splitter(path);
            var lastNode;
            var children = this._root.children;
            for (var _i = 0, parts_2 = parts; _i < parts_2.length; _i++) {
                var part = parts_2[_i];
                var node = children[part];
                if (!node) {
                    break;
                }
                if (node.element) {
                    lastNode = node;
                }
                children = node.children;
            }
            // return the last matching node
            // that had an element
            if (lastNode) {
                return lastNode.element;
            }
        };
        TrieMap.prototype.findSuperstr = function (path) {
            var parts = this._splitter(path);
            var children = this._root.children;
            var node;
            for (var _i = 0, parts_3 = parts; _i < parts_3.length; _i++) {
                var part = parts_3[_i];
                node = children[part];
                if (!node) {
                    return;
                }
                children = node.children;
            }
            var result = new TrieMap(this._splitter);
            result._root = node;
            return result;
        };
        return TrieMap;
    }());
    TrieMap.PathSplitter = function (s) { return s.split(/[\\/]/).filter(function (s) { return !!s; }); };
    exports.TrieMap = TrieMap;
});


/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

// TODO MonacoChange: we have our own way of defining modules
// ;(function() {
// END MonacoChange

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */
// TODO MonacoChange: Our build fails over the following lines if they are not commented out
InlineLexer.prototype.smartypants = function(text) {
	return text;
//  if (!this.options.smartypants) return text;
//  return text
//    // em-dashes
//    .replace(/--/g, '\u2014')
//    // opening singles
//    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
//    // closing singles & apostrophes
//    .replace(/'/g, '\u2019')
//    // opening doubles
//    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
//    // closing doubles
//    .replace(/"/g, '\u201d')
//    // ellipses
//    .replace(/\.{3}/g, '\u2026');
// END MonacoChange
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

// TODO MonacoChange: we have our own way of defining modules
define("vs/base/common/marked/raw.marked", [], function() {
  return marked;
});
//if (typeof module !== 'undefined' && typeof exports === 'object') {
//  module.exports = marked;
//} else if (typeof define === 'function' && define.amd) {
//  define(function() { return marked; });
//} else {
//  this.marked = marked;
//}
//
//}).call(function() {
//  return this || (typeof window !== 'undefined' ? window : global);
//}());
// END MonacoChange
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define(__m[244/*vs/base/common/marked/marked*/], __M([507/*vs/base/common/marked/raw.marked*/]), function (marked) {
	return {
		marked: marked
	};
});
define(__m[19/*vs/base/common/platform*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isRootUser = false;
    var _isNative = false;
    var _isWeb = false;
    var _isQunit = false;
    var _locale = undefined;
    var _language = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    // OS detection
    if (typeof process === 'object') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _isRootUser = !_isWindows && (process.getuid() === 0);
        var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
        if (rawNlsConfig) {
            try {
                var nlsConfig = JSON.parse(rawNlsConfig);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
        _isQunit = !!self.QUnit;
    }
    var Platform;
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(Platform = exports.Platform || (exports.Platform = {}));
    exports._platform = Platform.Web;
    if (_isNative) {
        if (_isMacintosh) {
            exports._platform = Platform.Mac;
        }
        else if (_isWindows) {
            exports._platform = Platform.Windows;
        }
        else if (_isLinux) {
            exports._platform = Platform.Linux;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isRootUser = _isRootUser;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.isQunit = _isQunit;
    exports.platform = exports._platform;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    var _globals = (typeof self === 'object' ? self : global);
    exports.globals = _globals;
    function hasWebWorkerSupport() {
        return typeof _globals.Worker !== 'undefined';
    }
    exports.hasWebWorkerSupport = hasWebWorkerSupport;
    exports.setTimeout = _globals.setTimeout.bind(_globals);
    exports.clearTimeout = _globals.clearTimeout.bind(_globals);
    exports.setInterval = _globals.setInterval.bind(_globals);
    exports.clearInterval = _globals.clearInterval.bind(_globals);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[429/*vs/base/common/scorer*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    // Based on material from:
    /*!
    BEGIN THIRD PARTY
    */
    /*!
    * string_score.js: String Scoring Algorithm 0.1.22
    *
    * http://joshaven.com/string_score
    * https://github.com/joshaven/string_score
    *
    * Copyright (C) 2009-2014 Joshaven Potter <yourtech@gmail.com>
    * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
    * MIT License: http://opensource.org/licenses/MIT
    *
    * Date: Tue Mar 1 2011
    * Updated: Tue Mar 10 2015
    */
    /**
     * Compute a score for the given string and the given query.
     *
     * Rules:
     * Character score: 1
     * Same case bonus: 1
     * Upper case bonus: 1
     * Consecutive match bonus: 5
     * Start of word/path bonus: 7
     * Start of string bonus: 8
     */
    var wordPathBoundary = ['-', '_', ' ', '/', '\\', '.'];
    function score(target, query, cache) {
        if (!target || !query) {
            return 0; // return early if target or query are undefined
        }
        var hash = target + query;
        var cached = cache && cache[hash];
        if (typeof cached === 'number') {
            return cached;
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var queryLower = query.toLowerCase();
        var index = 0;
        var startAt = 0;
        var score = 0;
        var _loop_1 = function () {
            var indexOf = targetLower.indexOf(queryLower[index], startAt);
            if (indexOf < 0) {
                score = 0; // This makes sure that the query is contained in the target
                return "break";
            }
            // Character match bonus
            score += 1;
            // Consecutive match bonus
            if (startAt === indexOf) {
                score += 5;
            }
            // Same case bonus
            if (target[indexOf] === query[indexOf]) {
                score += 1;
            }
            // Start of word bonus
            if (indexOf === 0) {
                score += 8;
            }
            else if (wordPathBoundary.some(function (w) { return w === target[indexOf - 1]; })) {
                score += 7;
            }
            else if (isUpper(target.charCodeAt(indexOf))) {
                score += 1;
            }
            startAt = indexOf + 1;
            index++;
        };
        while (index < queryLen) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        if (cache) {
            cache[hash] = score;
        }
        return score;
    }
    exports.score = score;
    function isUpper(code) {
        return 65 <= code && code <= 90;
    }
    /**
     * A fast method to check if a given string would produce a score > 0 for the given query.
     */
    function matches(target, queryLower) {
        if (!target || !queryLower) {
            return false; // return early if target or query are undefined
        }
        var queryLen = queryLower.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(queryLower[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.matches = matches;
});
/*!
END THIRD PARTY
*/ 

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[437/*vs/base/common/set*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    var ArraySet = (function () {
        function ArraySet(elements) {
            if (elements === void 0) { elements = []; }
            this._elements = elements.slice();
        }
        Object.defineProperty(ArraySet.prototype, "size", {
            get: function () {
                return this._elements.length;
            },
            enumerable: true,
            configurable: true
        });
        ArraySet.prototype.set = function (element) {
            this.unset(element);
            this._elements.push(element);
        };
        ArraySet.prototype.contains = function (element) {
            return this._elements.indexOf(element) > -1;
        };
        ArraySet.prototype.unset = function (element) {
            var index = this._elements.indexOf(element);
            if (index > -1) {
                this._elements.splice(index, 1);
            }
        };
        Object.defineProperty(ArraySet.prototype, "elements", {
            get: function () {
                return this._elements.slice();
            },
            enumerable: true,
            configurable: true
        });
        return ArraySet;
    }());
    exports.ArraySet = ArraySet;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[438/*vs/base/common/history*/], __M([1/*require*/,0/*exports*/,437/*vs/base/common/set*/,88/*vs/base/common/iterator*/]), function (require, exports, set_1, iterator_1) {
    "use strict";
    var HistoryNavigator = (function () {
        function HistoryNavigator(history, limit) {
            if (history === void 0) { history = []; }
            if (limit === void 0) { limit = 10; }
            this._history = new set_1.ArraySet(history);
            this._limit = limit;
            this._onChange();
        }
        HistoryNavigator.prototype.add = function (t) {
            this._history.set(t);
            this._onChange();
        };
        HistoryNavigator.prototype.next = function () {
            if (this._navigator.next()) {
                return this._navigator.current();
            }
            this.last();
            return null;
        };
        HistoryNavigator.prototype.previous = function () {
            if (this._navigator.previous()) {
                return this._navigator.current();
            }
            this.first();
            return null;
        };
        HistoryNavigator.prototype.current = function () {
            return this._navigator.current();
        };
        HistoryNavigator.prototype.parent = function () {
            return null;
        };
        HistoryNavigator.prototype.first = function () {
            return this._navigator.first();
        };
        HistoryNavigator.prototype.last = function () {
            return this._navigator.last();
        };
        HistoryNavigator.prototype._onChange = function () {
            this._reduceToLimit();
            this._navigator = new iterator_1.ArrayNavigator(this._history.elements);
            this._navigator.last();
        };
        HistoryNavigator.prototype._reduceToLimit = function () {
            var data = this._history.elements;
            if (data.length > this._limit) {
                this._history = new set_1.ArraySet(data.slice(data.length - this._limit));
            }
        };
        return HistoryNavigator;
    }());
    exports.HistoryNavigator = HistoryNavigator;
});

define(__m[439/*vs/base/common/stopwatch*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasPerformanceNow = (platform_1.globals.performance && typeof platform_1.globals.performance.now === 'function');
    var StopWatch = (function () {
        function StopWatch(highResolution) {
            this._highResolution = hasPerformanceNow && highResolution;
            this._startTime = this._now();
            this._stopTime = -1;
        }
        StopWatch.create = function (highResolution) {
            if (highResolution === void 0) { highResolution = true; }
            return new StopWatch(highResolution);
        };
        StopWatch.prototype.stop = function () {
            this._stopTime = this._now();
        };
        StopWatch.prototype.elapsed = function () {
            if (this._stopTime !== -1) {
                return this._stopTime - this._startTime;
            }
            return this._now() - this._startTime;
        };
        StopWatch.prototype._now = function () {
            return this._highResolution ? platform_1.globals.performance.now() : new Date().getTime();
        };
        return StopWatch;
    }());
    exports.StopWatch = StopWatch;
});

define(__m[9/*vs/base/common/strings*/], __M([1/*require*/,0/*exports*/,108/*vs/base/common/map*/]), function (require, exports, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The empty string.
     */
    exports.empty = '';
    function isFalsyOrWhitespace(str) {
        if (!str || typeof str !== 'string') {
            return true;
        }
        return str.trim().length === 0;
    }
    exports.isFalsyOrWhitespace = isFalsyOrWhitespace;
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.indexOf(needle, diff) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function indexOfIgnoreCase(haystack, needle, position) {
        if (position === void 0) { position = 0; }
        var index = haystack.indexOf(needle, position);
        if (index < 0) {
            if (position > 0) {
                haystack = haystack.substr(position);
            }
            needle = escapeRegExpCharacters(needle);
            index = haystack.search(new RegExp(needle, 'i'));
        }
        return index;
    }
    exports.indexOfIgnoreCase = indexOfIgnoreCase;
    function createRegExp(searchString, isRegex, options) {
        if (options === void 0) { options = {}; }
        if (searchString === '') {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = searchString.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
        }
        if (options.wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (options.global) {
            modifiers += 'g';
        }
        if (!options.matchCase) {
            modifiers += 'i';
        }
        if (options.multiline) {
            modifiers += 'm';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    var normalizedCache = new map_1.BoundedLinkedMap(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize('NFC');
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
    exports.normalizeNFC = normalizeNFC;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return str.substring(0, i);
            }
        }
        return str;
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            var chCode = str.charCodeAt(i);
            if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function compare(a, b) {
        if (a < b) {
            return -1;
        }
        else if (a > b) {
            return 1;
        }
        else {
            return 0;
        }
    }
    exports.compare = compare;
    function isAsciiLetter(code) {
        return (code >= 97 /* a */ && code <= 122 /* z */) || (code >= 65 /* A */ && code <= 90 /* Z */);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a.length, len2 = b.length;
        if (len1 !== len2) {
            return false;
        }
        for (var i = 0; i < len1; i++) {
            var codeA = a.charCodeAt(i), codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            else if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            else {
                if (String.fromCharCode(codeA).toLocaleLowerCase() !== String.fromCharCode(codeB).toLocaleLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    function isHighSurrogate(charCode) {
        return (0xD800 <= charCode && charCode <= 0xDBFF);
    }
    exports.isHighSurrogate = isHighSurrogate;
    function isLowSurrogate(charCode) {
        return (0xDC00 <= charCode && charCode <= 0xDFFF);
    }
    exports.isLowSurrogate = isLowSurrogate;
    /**
     * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
     */
    var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
    /**
     * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
     */
    function containsRTL(str) {
        return CONTAINS_RTL.test(str);
    }
    exports.containsRTL = containsRTL;
    var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
    /**
     * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
     */
    function isBasicASCII(str) {
        return IS_BASIC_ASCII.test(str);
    }
    exports.isBasicASCII = isBasicASCII;
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80 — 2EFF   CJK Radicals Supplement
        //          2F00 — 2FDF   Kangxi Radicals
        //          2FF0 — 2FFF   Ideographic Description Characters
        //          3000 — 303F   CJK Symbols and Punctuation
        //          3040 — 309F   Hiragana
        //          30A0 — 30FF   Katakana
        //          3100 — 312F   Bopomofo
        //          3130 — 318F   Hangul Compatibility Jamo
        //          3190 — 319F   Kanbun
        //          31A0 — 31BF   Bopomofo Extended
        //          31F0 — 31FF   Katakana Phonetic Extensions
        //          3200 — 32FF   Enclosed CJK Letters and Months
        //          3300 — 33FF   CJK Compatibility
        //          3400 — 4DBF   CJK Unified Ideographs Extension A
        //          4DC0 — 4DFF   Yijing Hexagram Symbols
        //          4E00 — 9FFF   CJK Unified Ideographs
        //          A000 — A48F   Yi Syllables
        //          A490 — A4CF   Yi Radicals
        //          AC00 — D7AF   Hangul Syllables
        // [IGNORE] D800 — DB7F   High Surrogates
        // [IGNORE] DB80 — DBFF   High Private Use Surrogates
        // [IGNORE] DC00 — DFFF   Low Surrogates
        // [IGNORE] E000 — F8FF   Private Use Area
        //          F900 — FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00 — FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50 — FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00 — FE0F   Variation Selectors
        // [IGNORE] FE20 — FE2F   Combining Half Marks
        // [IGNORE] FE30 — FE4F   CJK Compatibility Forms
        // [IGNORE] FE50 — FE6F   Small Form Variants
        // [IGNORE] FE70 — FEFF   Arabic Presentation Forms-B
        //          FF00 — FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0 — FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Computes the difference score for two strings. More similar strings have a higher score.
     * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.
     * Strings that have a large length difference will get a bad default score 0.
     * Complexity - both time and space O(first.length * second.length)
     * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
     *
     * @param first a string
     * @param second a string
     */
    function difference(first, second, maxLenDelta) {
        if (maxLenDelta === void 0) { maxLenDelta = 4; }
        var lengthDifference = Math.abs(first.length - second.length);
        // We only compute score if length of the currentWord and length of entry.name are similar.
        if (lengthDifference > maxLenDelta) {
            return 0;
        }
        // Initialize LCS (largest common subsequence) matrix.
        var LCS = [];
        var zeroArray = [];
        var i, j;
        for (i = 0; i < second.length + 1; ++i) {
            zeroArray.push(0);
        }
        for (i = 0; i < first.length + 1; ++i) {
            LCS.push(zeroArray);
        }
        for (i = 1; i < first.length + 1; ++i) {
            for (j = 1; j < second.length + 1; ++j) {
                if (first[i - 1] === second[j - 1]) {
                    LCS[i][j] = LCS[i - 1][j - 1] + 1;
                }
                else {
                    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
                }
            }
        }
        return LCS[first.length][second.length] - Math.sqrt(lengthDifference);
    }
    exports.difference = difference;
    /**
     * Returns an array in which every entry is the offset of a
     * line. There is always one entry which is zero.
     */
    function computeLineStarts(text) {
        var regexp = /\r\n|\r|\n/g, ret = [0], match;
        while ((match = regexp.exec(text))) {
            ret.push(regexp.lastIndex);
        }
        return ret;
    }
    exports.computeLineStarts = computeLineStarts;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var segments = text.split(/\b/), count = 0;
        for (var i = segments.length - 1; i >= 0; i--) {
            count += segments[i].length;
            if (count > n) {
                segments.splice(0, i);
                break;
            }
        }
        return segments.join(exports.empty).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    /**
     * Appends two strings. If the appended result is longer than maxLength,
     * trims the start of the result and replaces it with '...'.
     */
    function appendWithLimit(first, second, maxLength) {
        var newLength = first.length + second.length;
        if (newLength > maxLength) {
            first = '...' + first.substr(newLength - maxLength);
        }
        if (second.length > maxLength) {
            first += second.substr(second.length - maxLength);
        }
        else {
            first += second;
        }
        return first;
    }
    exports.appendWithLimit = appendWithLimit;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
});

define(__m[481/*vs/base/browser/ui/octiconLabel/octiconLabel*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/]), function (require, exports, strings_1) {
    "use strict";
    function expand(text) {
        return text;
    }
    var MockOcticonLabel = (function () {
        function MockOcticonLabel(container) {
            this._container = container;
        }
        Object.defineProperty(MockOcticonLabel.prototype, "text", {
            set: function (text) {
                var innerHTML = text || '';
                innerHTML = strings_1.escape(innerHTML);
                innerHTML = expand(innerHTML);
                this._container.innerHTML = innerHTML;
            },
            enumerable: true,
            configurable: true
        });
        return MockOcticonLabel;
    }());
    var mock = {
        expand: expand,
        OcticonLabel: MockOcticonLabel
    };
    return mock;
});

define(__m[504/*vs/base/common/comparers*/], __M([1/*require*/,0/*exports*/,429/*vs/base/common/scorer*/,9/*vs/base/common/strings*/]), function (require, exports, scorer, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FileNameComparer = new Intl.Collator(undefined, { numeric: true, sensitivity: 'base' });
    function compareFileNames(one, other) {
        return FileNameComparer.compare(one || '', other || '');
    }
    exports.compareFileNames = compareFileNames;
    function compareAnything(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var prefixCompare = compareByPrefix(one, other, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Sort suffix matches over non suffix matches
        var elementASuffixMatch = strings.endsWith(elementAName, lookFor);
        var elementBSuffixMatch = strings.endsWith(elementBName, lookFor);
        if (elementASuffixMatch !== elementBSuffixMatch) {
            return elementASuffixMatch ? -1 : 1;
        }
        // Understand file names
        var r = compareFileNames(elementAName, elementBName);
        if (r !== 0) {
            return r;
        }
        // Compare by name
        return elementAName.localeCompare(elementBName);
    }
    exports.compareAnything = compareAnything;
    function compareByPrefix(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var elementAPrefixMatch = strings.startsWith(elementAName, lookFor);
        var elementBPrefixMatch = strings.startsWith(elementBName, lookFor);
        if (elementAPrefixMatch !== elementBPrefixMatch) {
            return elementAPrefixMatch ? -1 : 1;
        }
        else if (elementAPrefixMatch && elementBPrefixMatch) {
            if (elementAName.length < elementBName.length) {
                return -1;
            }
            if (elementAName.length > elementBName.length) {
                return 1;
            }
        }
        return 0;
    }
    exports.compareByPrefix = compareByPrefix;
    function compareByScore(elementA, elementB, accessor, lookFor, lookForNormalizedLower, scorerCache) {
        var labelA = accessor.getLabel(elementA);
        var labelB = accessor.getLabel(elementB);
        // treat prefix matches highest in any case
        var prefixCompare = compareByPrefix(labelA, labelB, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Give higher importance to label score
        var labelAScore = scorer.score(labelA, lookFor, scorerCache);
        var labelBScore = scorer.score(labelB, lookFor, scorerCache);
        // Useful for understanding the scoring
        // elementA.setPrefix(labelAScore + ' ');
        // elementB.setPrefix(labelBScore + ' ');
        if (labelAScore !== labelBScore) {
            return labelAScore > labelBScore ? -1 : 1;
        }
        // Score on full resource path comes next (if available)
        var resourcePathA = accessor.getResourcePath(elementA);
        var resourcePathB = accessor.getResourcePath(elementB);
        if (resourcePathA && resourcePathB) {
            var resourceAScore = scorer.score(resourcePathA, lookFor, scorerCache);
            var resourceBScore = scorer.score(resourcePathB, lookFor, scorerCache);
            // Useful for understanding the scoring
            // elementA.setPrefix(elementA.getPrefix() + ' ' + resourceAScore + ': ');
            // elementB.setPrefix(elementB.getPrefix() + ' ' + resourceBScore + ': ');
            if (resourceAScore !== resourceBScore) {
                return resourceAScore > resourceBScore ? -1 : 1;
            }
        }
        // At this place, the scores are identical so we check for string lengths and favor shorter ones
        if (labelA.length !== labelB.length) {
            return labelA.length < labelB.length ? -1 : 1;
        }
        if (resourcePathA && resourcePathB && resourcePathA.length !== resourcePathB.length) {
            return resourcePathA.length < resourcePathB.length ? -1 : 1;
        }
        // Finally compare by label or resource path
        if (labelA === labelB && resourcePathA && resourcePathB) {
            return compareAnything(resourcePathA, resourcePathB, lookForNormalizedLower);
        }
        return compareAnything(labelA, labelB, lookForNormalizedLower);
    }
    exports.compareByScore = compareByScore;
});

define(__m[86/*vs/base/common/filters*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,108/*vs/base/common/map*/]), function (require, exports, strings, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    exports.or = or;
    /**
     * @returns A filter which combines the provided set
     * of filters with an and. The combines matches are
     * returned if *all* filters match.
     */
    function and() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            var result = [];
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (!match) {
                    return null;
                }
                result = result.concat(match);
            }
            return result;
        };
    }
    exports.and = and;
    // Prefix
    exports.matchesStrictPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(false, word, wordToMatchAgainst); };
    exports.matchesPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(true, word, wordToMatchAgainst); };
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {
            return null;
        }
        if (ignoreCase) {
            word = word.toLowerCase();
            wordToMatchAgainst = wordToMatchAgainst.toLowerCase();
        }
        for (var i = 0; i < word.length; i++) {
            if (word[i] !== wordToMatchAgainst[i]) {
                return null;
            }
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function matchesContiguousSubString(word, wordToMatchAgainst) {
        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    exports.matchesContiguousSubString = matchesContiguousSubString;
    // Substring
    function matchesSubString(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    exports.matchesSubString = matchesSubString;
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                var result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return 97 /* a */ <= code && code <= 122 /* z */;
    }
    function isUpper(code) {
        return 65 /* A */ <= code && code <= 90 /* Z */;
    }
    function isNumber(code) {
        return 48 /* Digit0 */ <= code && code <= 57 /* Digit9 */;
    }
    function isWhitespace(code) {
        return (code === 32 /* Space */
            || code === 9 /* Tab */
            || code === 10 /* LineFeed */
            || code === 13 /* CarriageReturn */);
    }
    function isAlphanumeric(code) {
        return isLower(code) || isUpper(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (var i = start; i < camelCaseWord.length; i++) {
            var c = camelCaseWord.charCodeAt(i);
            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function analyzeCamelCaseWord(word) {
        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        var upperPercent = upper / word.length;
        var lowerPercent = lower / word.length;
        var alphaPercent = alpha / word.length;
        var numericPercent = numeric / word.length;
        return { upperPercent: upperPercent, lowerPercent: lowerPercent, alphaPercent: alphaPercent, numericPercent: numericPercent };
    }
    function isUpperCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent;
        return lowerPercent === 0 && upperPercent > 0.6;
    }
    function isCamelCaseWord(analysis) {
        var upperPercent = analysis.upperPercent, lowerPercent = analysis.lowerPercent, alphaPercent = analysis.alphaPercent, numericPercent = analysis.numericPercent;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        var upper = 0, lower = 0, code = 0, whitespace = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function matchesCamelCase(word, camelCaseWord) {
        if (!camelCaseWord || camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        if (camelCaseWord.length > 60) {
            return null;
        }
        var analysis = analyzeCamelCaseWord(camelCaseWord);
        if (!isCamelCaseWord(analysis)) {
            if (!isUpperCaseWord(analysis)) {
                return null;
            }
            camelCaseWord = camelCaseWord.toLowerCase();
        }
        var result = null;
        var i = 0;
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    exports.matchesCamelCase = matchesCamelCase;
    // Matches beginning of words supporting non-ASCII languages
    // If `contiguous` is true then matches word with beginnings of the words in the target. E.g. "pul" will match "Git: Pull"
    // Otherwise also matches sub string of the word with beginnings of the words in the target. E.g. "gp" or "g p" will match "Git: Pull"
    // Useful in cases where the target is words (e.g. command labels)
    function matchesWords(word, target, contiguous) {
        if (contiguous === void 0) { contiguous = false; }
        if (!target || target.length === 0) {
            return null;
        }
        var result = null;
        var i = 0;
        while (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i, contiguous)) === null) {
            i = nextWord(target, i + 1);
        }
        return result;
    }
    exports.matchesWords = matchesWords;
    function _matchesWords(word, target, i, j, contiguous) {
        if (i === word.length) {
            return [];
        }
        else if (j === target.length) {
            return null;
        }
        else if (word[i] !== target[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextWordIndex = j + 1;
            result = _matchesWords(word, target, i + 1, j + 1, contiguous);
            if (!contiguous) {
                while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
                    result = _matchesWords(word, target, i + 1, nextWordIndex, contiguous);
                    nextWordIndex++;
                }
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    function nextWord(word, start) {
        for (var i = start; i < word.length; i++) {
            var c = word.charCodeAt(i);
            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return word.length;
    }
    // Fuzzy
    var SubstringMatching;
    (function (SubstringMatching) {
        SubstringMatching[SubstringMatching["Contiguous"] = 0] = "Contiguous";
        SubstringMatching[SubstringMatching["Separate"] = 1] = "Separate";
    })(SubstringMatching = exports.SubstringMatching || (exports.SubstringMatching = {}));
    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);
    var fuzzyRegExpCache = new map_1.BoundedLinkedMap(10000); // bounded to 10000 elements
    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
            return null; // return early for invalid input
        }
        // Form RegExp for wildcard matches
        var regexp = fuzzyRegExpCache.get(word);
        if (!regexp) {
            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');
            fuzzyRegExpCache.set(word, regexp);
        }
        // RegExp Filter
        var match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    exports.matchesFuzzy = matchesFuzzy;
});

define(__m[39/*vs/base/common/paths*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,28/*vs/base/common/arrays*/,9/*vs/base/common/strings*/]), function (require, exports, platform_1, arrays_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    function relative(from, to) {
        // ignore trailing slashes
        var originalNormalizedFrom = strings_1.rtrim(normalize(from), exports.sep);
        var originalNormalizedTo = strings_1.rtrim(normalize(to), exports.sep);
        // we're assuming here that any non=linux OS is case insensitive
        // so we must compare each part in its lowercase form
        var normalizedFrom = platform_1.isLinux ? originalNormalizedFrom : originalNormalizedFrom.toLowerCase();
        var normalizedTo = platform_1.isLinux ? originalNormalizedTo : originalNormalizedTo.toLowerCase();
        var fromParts = normalizedFrom.split(exports.sep);
        var toParts = normalizedTo.split(exports.sep);
        var i = 0, max = Math.min(fromParts.length, toParts.length);
        for (; i < max; i++) {
            if (fromParts[i] !== toParts[i]) {
                break;
            }
        }
        var result = arrays_1.fill(fromParts.length - i, function () { return '..'; }).concat(originalNormalizedTo.split(exports.sep).slice(i));
        return result.join(exports.sep);
    }
    exports.relative = relative;
    /**
     * @returns the directory name of a path.
     */
    function dirname(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else {
            return path.substring(0, ~idx);
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns {{.far}} from boo.far or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = platform_1.isWindows && toOSPath;
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === 47 /* Slash */ || path.charCodeAt(end) === 92 /* Backslash */) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
            code = path.charCodeAt(1);
            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== 47 /* Slash */ && code !== 92 /* Backslash */) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= 65 /* A */ && code <= 90 /* Z */) || (code >= 97 /* a */ && code <= 122 /* z */)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === 58 /* Colon */) {
                code = path.charCodeAt(2);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === 47 /* Slash */ || code === 92 /* Backslash */) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        // Not using a function with var-args because of how TS compiles
        // them to JS - it would result in 2*n runtime cost instead
        // of 1*n, where n is parts.length.
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== 47 /* Slash */ && last !== 92 /* Backslash */) {
                    var next = part.charCodeAt(0);
                    if (next !== 47 /* Slash */ && next !== 92 /* Backslash */) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== 92 /* Backslash */) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === 92 /* Backslash */) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === 92 /* Backslash */) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    function isPosixAbsolute(path) {
        return path && path[0] === '/';
    }
    function makePosixAbsolute(path) {
        return isPosixAbsolute(normalize(path)) ? path : exports.sep + path;
    }
    exports.makePosixAbsolute = makePosixAbsolute;
    function isEqualOrParent(path, candidate) {
        if (path === candidate) {
            return true;
        }
        path = normalize(path);
        candidate = normalize(candidate);
        var candidateLen = candidate.length;
        var lastCandidateChar = candidate.charCodeAt(candidateLen - 1);
        if (lastCandidateChar === 47 /* Slash */) {
            candidate = candidate.substring(0, candidateLen - 1);
            candidateLen -= 1;
        }
        if (path === candidate) {
            return true;
        }
        if (!platform_1.isLinux) {
            // case insensitive
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        if (path === candidate) {
            return true;
        }
        if (path.indexOf(candidate) !== 0) {
            return false;
        }
        var char = path.charCodeAt(candidateLen);
        return char === 47 /* Slash */;
    }
    exports.isEqualOrParent = isEqualOrParent;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    exports.isAbsoluteRegex = /^((\/|[a-zA-Z]:\\)[^\(\)<>\\'\"\[\]]+)/;
    /**
     * If you have access to node, it is recommended to use node's path.isAbsolute().
     * This is a simple regex based approach.
     */
    function isAbsolute(path) {
        return exports.isAbsoluteRegex.test(path);
    }
    exports.isAbsolute = isAbsolute;
});

define(__m[164/*vs/base/common/glob*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,9/*vs/base/common/strings*/,39/*vs/base/common/paths*/,108/*vs/base/common/map*/]), function (require, exports, arrays, strings, paths, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    var ALL_FORWARD_SLASHES = /\//g;
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, '/');
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === '**'; })) {
            regEx = '.*';
        }
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === '**') {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (char !== ']' && inBrackets) {
                        var res = void 0;
                        switch (char) {
                            case '-':
                                res = char;
                                break;
                            case '^':
                                res = char;
                                break;
                            default:
                                res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the next one is not a globstar
                if (index < segments.length - 1 && segments[index + 1] !== '**') {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/([\w\.-]+)\/?$/; // **/something
    var T3 = /^{\*\*\/[\*\.]?[\w\.-]+\/?(,\*\*\/[\*\.]?[\w\.-]+\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}
    var T3_2 = /^{\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?(,\*\*\/[\*\.]?[\w\.-]+(\/(\*\*)?)?)*}$/; // Like T3, with optional trailing /**
    var T4 = /^\*\*((\/[\w\.-]+)+)\/?$/; // **/something/else
    var T5 = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/; // something/else
    var CACHE = new map_1.BoundedLinkedMap(10000); // bounded to 10000 elements
    var FALSE = function () {
        return false;
    };
    var NULL = function () {
        return null;
    };
    function parsePattern(pattern, options) {
        if (!pattern) {
            return NULL;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var patternKey = pattern + "_" + !!options.trimForExclusions;
        var parsedPattern = CACHE.get(patternKey);
        if (parsedPattern) {
            return parsedPattern;
        }
        // Check for Trivias
        var match;
        if (T1.test(pattern)) {
            var base_1 = pattern.substr(4); // '**/*'.length === 4
            parsedPattern = function (path, basename) {
                return path && strings.endsWith(path, base_1) ? pattern : null;
            };
        }
        else if (match = T2.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia2(match[1], pattern);
        }
        else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {
            parsedPattern = trivia3(pattern, options);
        }
        else if (match = T4.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia4and5(match[1].substr(1), pattern, true);
        }
        else if (match = T5.exec(trimForExclusions(pattern, options))) {
            parsedPattern = trivia4and5(match[1], pattern, false);
        }
        else {
            parsedPattern = toRegExp(pattern);
        }
        // Cache
        CACHE.set(patternKey, parsedPattern);
        return parsedPattern;
    }
    function trimForExclusions(pattern, options) {
        return options.trimForExclusions && strings.endsWith(pattern, '/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later
    }
    // common pattern: **/some.txt just need basename check
    function trivia2(base, originalPattern) {
        var slashBase = "/" + base;
        var backslashBase = "\\" + base;
        var parsedPattern = function (path, basename) {
            if (!path) {
                return null;
            }
            if (basename) {
                return basename === base ? originalPattern : null;
            }
            return path === base || strings.endsWith(path, slashBase) || strings.endsWith(path, backslashBase) ? originalPattern : null;
        };
        var basenames = [base];
        parsedPattern.basenames = basenames;
        parsedPattern.patterns = [originalPattern];
        parsedPattern.allBasenames = basenames;
        return parsedPattern;
    }
    // repetition of common patterns (see above) {**/*.txt,**/*.png}
    function trivia3(pattern, options) {
        var parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',')
            .map(function (pattern) { return parsePattern(pattern, options); })
            .filter(function (pattern) { return pattern !== NULL; }), pattern);
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (n === 1) {
            return parsedPatterns[0];
        }
        var parsedPattern = function (path, basename) {
            for (var i = 0, n_1 = parsedPatterns.length; i < n_1; i++) {
                if (parsedPatterns[i](path, basename)) {
                    return pattern;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            parsedPattern.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            parsedPattern.allPaths = allPaths;
        }
        return parsedPattern;
    }
    // common patterns: **/something/else just need endsWith check, something/else just needs and equals check
    function trivia4and5(path, pattern, matchPathEnds) {
        var nativePath = paths.nativeSep !== paths.sep ? path.replace(ALL_FORWARD_SLASHES, paths.nativeSep) : path;
        var nativePathEnd = paths.nativeSep + nativePath;
        var parsedPattern = matchPathEnds ? function (path, basename) {
            return path && (path === nativePath || strings.endsWith(path, nativePathEnd)) ? pattern : null;
        } : function (path, basename) {
            return path && path === nativePath ? pattern : null;
        };
        parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + path];
        return parsedPattern;
    }
    function toRegExp(pattern) {
        try {
            var regExp_1 = new RegExp("^" + parseRegExp(pattern) + "$");
            return function (path, basename) {
                regExp_1.lastIndex = 0; // reset RegExp to its initial state to reuse it!
                return path && regExp_1.test(path) ? pattern : null;
            };
        }
        catch (error) {
            return NULL;
        }
    }
    function match(arg1, path, siblingsFn) {
        if (!arg1 || !path) {
            return false;
        }
        return parse(arg1)(path, undefined, siblingsFn);
    }
    exports.match = match;
    function parse(arg1, options) {
        if (options === void 0) { options = {}; }
        if (!arg1) {
            return FALSE;
        }
        // Glob with String
        if (typeof arg1 === 'string') {
            var parsedPattern_1 = parsePattern(arg1, options);
            if (parsedPattern_1 === NULL) {
                return FALSE;
            }
            var resultPattern = function (path, basename) {
                return !!parsedPattern_1(path, basename);
            };
            if (parsedPattern_1.allBasenames) {
                resultPattern.allBasenames = parsedPattern_1.allBasenames;
            }
            if (parsedPattern_1.allPaths) {
                resultPattern.allPaths = parsedPattern_1.allPaths;
            }
            return resultPattern;
        }
        // Glob with Expression
        return parsedExpression(arg1, options);
    }
    exports.parse = parse;
    function getBasenameTerms(patternOrExpression) {
        return patternOrExpression.allBasenames || [];
    }
    exports.getBasenameTerms = getBasenameTerms;
    function getPathTerms(patternOrExpression) {
        return patternOrExpression.allPaths || [];
    }
    exports.getPathTerms = getPathTerms;
    function parsedExpression(expression, options) {
        var parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)
            .map(function (pattern) { return parseExpressionPattern(pattern, expression[pattern], options); })
            .filter(function (pattern) { return pattern !== NULL; }));
        var n = parsedPatterns.length;
        if (!n) {
            return NULL;
        }
        if (!parsedPatterns.some(function (parsedPattern) { return parsedPattern.requiresSiblings; })) {
            if (n === 1) {
                return parsedPatterns[0];
            }
            var resultExpression_1 = function (path, basename, siblingsFn) {
                for (var i = 0, n_2 = parsedPatterns.length; i < n_2; i++) {
                    // Pattern matches path
                    var result = parsedPatterns[i](path, basename);
                    if (result) {
                        return result;
                    }
                }
                return null;
            };
            var withBasenames_1 = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
            if (withBasenames_1) {
                resultExpression_1.allBasenames = withBasenames_1.allBasenames;
            }
            var allPaths_1 = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
            if (allPaths_1.length) {
                resultExpression_1.allPaths = allPaths_1;
            }
            return resultExpression_1;
        }
        var resultExpression = function (path, basename, siblingsFn) {
            var siblingsPattern;
            var siblingsResolved = !siblingsFn;
            function siblingsPatternFn() {
                // Resolve siblings only once
                if (!siblingsResolved) {
                    siblingsResolved = true;
                    var siblings = siblingsFn();
                    if (siblings && siblings.length) {
                        if (!basename) {
                            basename = paths.basename(path);
                        }
                        var name_1 = basename.substr(0, basename.length - paths.extname(path).length);
                        siblingsPattern = { siblings: siblings, name: name_1 };
                    }
                }
                return siblingsPattern;
            }
            for (var i = 0, n_3 = parsedPatterns.length; i < n_3; i++) {
                // Pattern matches path
                var result = parsedPatterns[i](path, basename, siblingsPatternFn);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        var withBasenames = arrays.first(parsedPatterns, function (pattern) { return !!pattern.allBasenames; });
        if (withBasenames) {
            resultExpression.allBasenames = withBasenames.allBasenames;
        }
        var allPaths = parsedPatterns.reduce(function (all, current) { return current.allPaths ? all.concat(current.allPaths) : all; }, []);
        if (allPaths.length) {
            resultExpression.allPaths = allPaths;
        }
        return resultExpression;
    }
    function parseExpressionPattern(pattern, value, options) {
        if (value === false) {
            return NULL; // pattern is disabled
        }
        var parsedPattern = parsePattern(pattern, options);
        if (parsedPattern === NULL) {
            return NULL;
        }
        // Expression Pattern is <boolean>
        if (typeof value === 'boolean') {
            return parsedPattern;
        }
        // Expression Pattern is <SiblingClause>
        if (value) {
            var when_1 = value.when;
            if (typeof when_1 === 'string') {
                var result = function (path, basename, siblingsPatternFn) {
                    if (!parsedPattern(path, basename)) {
                        return null;
                    }
                    var siblingsPattern = siblingsPatternFn();
                    if (!siblingsPattern) {
                        return null; // pattern is malformed or we don't have siblings
                    }
                    var clausePattern = when_1.replace('$(basename)', siblingsPattern.name);
                    if (siblingsPattern.siblings.indexOf(clausePattern) !== -1) {
                        return pattern;
                    }
                    else {
                        return null; // pattern does not match in the end because the when clause is not satisfied
                    }
                };
                result.requiresSiblings = true;
                return result;
            }
        }
        // Expression is Anything
        return parsedPattern;
    }
    function aggregateBasenameMatches(parsedPatterns, result) {
        var basenamePatterns = parsedPatterns.filter(function (parsedPattern) { return !!parsedPattern.basenames; });
        if (basenamePatterns.length < 2) {
            return parsedPatterns;
        }
        var basenames = basenamePatterns.reduce(function (all, current) { return all.concat(current.basenames); }, []);
        var patterns;
        if (result) {
            patterns = [];
            for (var i = 0, n = basenames.length; i < n; i++) {
                patterns.push(result);
            }
        }
        else {
            patterns = basenamePatterns.reduce(function (all, current) { return all.concat(current.patterns); }, []);
        }
        var aggregate = function (path, basename) {
            if (!path) {
                return null;
            }
            if (!basename) {
                var i = void 0;
                for (i = path.length; i > 0; i--) {
                    var ch = path.charCodeAt(i - 1);
                    if (ch === 47 /* Slash */ || ch === 92 /* Backslash */) {
                        break;
                    }
                }
                basename = path.substr(i);
            }
            var index = basenames.indexOf(basename);
            return index !== -1 ? patterns[index] : null;
        };
        aggregate.basenames = basenames;
        aggregate.patterns = patterns;
        aggregate.allBasenames = basenames;
        var aggregatedPatterns = parsedPatterns.filter(function (parsedPattern) { return !parsedPattern.basenames; });
        aggregatedPatterns.push(aggregate);
        return aggregatedPatterns;
    }
});

define(__m[24/*vs/base/common/types*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        // The method can't do a type cast since there are type (like strings) which
        // are subclasses of any put not positvely matched by the function. Hence type
        // narrowing results in wrong results.
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (arg && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

define(__m[10/*vs/base/common/errors*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,24/*vs/base/common/types*/]), function (require, exports, platform, types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                platform.setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        // For external errors, we don't want the listeners to be called
        ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
            this.unexpectedErrorHandler(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedExternalError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedExternalError(e);
        }
    }
    exports.onUnexpectedExternalError = onUnexpectedExternalError;
    function onUnexpectedPromiseError(promise) {
        return promise.then(null, onUnexpectedError);
    }
    exports.onUnexpectedPromiseError = onUnexpectedPromiseError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    /**
     * Returns an error that signals something is not implemented.
     */
    function notImplemented() {
        return new Error('Not Implemented');
    }
    exports.notImplemented = notImplemented;
    function illegalArgument(name) {
        if (name) {
            return new Error("Illegal argument: " + name);
        }
        else {
            return new Error('Illegal argument');
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error("Illegal state: " + name);
        }
        else {
            return new Error('Illegal state');
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function create(message, options) {
        if (options === void 0) { options = {}; }
        var result = new Error(message);
        if (types.isNumber(options.severity)) {
            result.severity = options.severity;
        }
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
    function getErrorMessage(err) {
        if (!err) {
            return 'Error';
        }
        if (err.message) {
            return err.message;
        }
        if (err.stack) {
            return err.stack.split('\n')[0];
        }
        return String(err);
    }
    exports.getErrorMessage = getErrorMessage;
});

define(__m[254/*vs/base/common/callbackList*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CallbackList = (function () {
        function CallbackList() {
        }
        CallbackList.prototype.add = function (callback, context, bucket) {
            var _this = this;
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                this._callbacks = [];
                this._contexts = [];
            }
            this._callbacks.push(callback);
            this._contexts.push(context);
            if (Array.isArray(bucket)) {
                bucket.push({ dispose: function () { return _this.remove(callback, context); } });
            }
        };
        CallbackList.prototype.remove = function (callback, context) {
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                return;
            }
            var foundCallbackWithDifferentContext = false;
            for (var i = 0, len = this._callbacks.length; i < len; i++) {
                if (this._callbacks[i] === callback) {
                    if (this._contexts[i] === context) {
                        // callback & context match => remove it
                        this._callbacks.splice(i, 1);
                        this._contexts.splice(i, 1);
                        return;
                    }
                    else {
                        foundCallbackWithDifferentContext = true;
                    }
                }
            }
            if (foundCallbackWithDifferentContext) {
                throw new Error('When adding a listener with a context, you should remove it with the same context');
            }
        };
        CallbackList.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this._callbacks) {
                return;
            }
            var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
            for (var i = 0, len = callbacks.length; i < len; i++) {
                try {
                    ret.push(callbacks[i].apply(contexts[i], args));
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            return ret;
        };
        CallbackList.prototype.isEmpty = function () {
            return !this._callbacks || this._callbacks.length === 0;
        };
        CallbackList.prototype.entries = function () {
            var _this = this;
            if (!this._callbacks) {
                return [];
            }
            return this._callbacks.map(function (fn, index) { return [fn, _this._contexts[index]]; });
        };
        CallbackList.prototype.dispose = function () {
            this._callbacks = undefined;
            this._contexts = undefined;
        };
        return CallbackList;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = CallbackList;
});

define(__m[12/*vs/base/common/event*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,254/*vs/base/common/callbackList*/,195/*vs/base/common/functional*/]), function (require, exports, lifecycle_1, callbackList_1, functional_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event || (Event = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Event;
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._callbacks) {
                            _this._callbacks = new callbackList_1.default();
                        }
                        var firstListener = _this._callbacks.isEmpty();
                        if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        _this._callbacks.add(listener, thisArgs);
                        if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                            _this._options.onFirstListenerDidAdd(_this);
                        }
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    _this._callbacks.remove(listener, thisArgs);
                                    if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._callbacks) {
                this._callbacks.invoke.call(this._callbacks, event);
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._callbacks) {
                this._callbacks.dispose();
                this._callbacks = undefined;
                this._disposed = true;
            }
        };
        return Emitter;
    }());
    Emitter._noop = function () { };
    exports.Emitter = Emitter;
    var EventMultiplexer = (function () {
        function EventMultiplexer() {
            var _this = this;
            this.hasListeners = false;
            this.events = [];
            this.emitter = new Emitter({
                onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
                onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
            });
        }
        Object.defineProperty(EventMultiplexer.prototype, "event", {
            get: function () {
                return this.emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        EventMultiplexer.prototype.add = function (event) {
            var _this = this;
            var e = { event: event, listener: null };
            this.events.push(e);
            if (this.hasListeners) {
                this.hook(e);
            }
            var dispose = function () {
                if (_this.hasListeners) {
                    _this.unhook(e);
                }
                var idx = _this.events.indexOf(e);
                _this.events.splice(idx, 1);
            };
            return lifecycle_1.toDisposable(functional_1.once(dispose));
        };
        EventMultiplexer.prototype.onFirstListenerAdd = function () {
            var _this = this;
            this.hasListeners = true;
            this.events.forEach(function (e) { return _this.hook(e); });
        };
        EventMultiplexer.prototype.onLastListenerRemove = function () {
            var _this = this;
            this.hasListeners = false;
            this.events.forEach(function (e) { return _this.unhook(e); });
        };
        EventMultiplexer.prototype.hook = function (e) {
            var _this = this;
            e.listener = e.event(function (r) { return _this.emitter.fire(r); });
        };
        EventMultiplexer.prototype.unhook = function (e) {
            e.listener.dispose();
            e.listener = null;
        };
        EventMultiplexer.prototype.dispose = function () {
            this.emitter.dispose();
        };
        return EventMultiplexer;
    }());
    exports.EventMultiplexer = EventMultiplexer;
    /**
     * Creates an Event which is backed-up by the event emitter. This allows
     * to use the existing eventing pattern and is likely using less memory.
     * Sample:
     *
     * 	class Document {
     *
     *		private _eventbus = new EventEmitter();
     *
     *		public onDidChange = fromEventEmitter(this._eventbus, 'changed');
     *
     *		// getter-style
     *		// get onDidChange(): Event<(value:string)=>any> {
     *		// 	cache fromEventEmitter result and return
     *		// }
     *
     *		private _doIt() {
     *			// ...
     *			this._eventbus.emit('changed', value)
     *		}
     *	}
     */
    function fromEventEmitter(emitter, eventType) {
        return function (listener, thisArgs, disposables) {
            var result = emitter.addListener2(eventType, function () {
                listener.apply(thisArgs, arguments);
            });
            if (Array.isArray(disposables)) {
                disposables.push(result);
            }
            return result;
        };
    }
    exports.fromEventEmitter = fromEventEmitter;
    function fromCallback(fn) {
        var listener;
        var emitter = new Emitter({
            onFirstListenerAdd: function () { return listener = fn(function (e) { return emitter.fire(e); }); },
            onLastListenerRemove: function () { return listener.dispose(); }
        });
        return emitter.event;
    }
    exports.fromCallback = fromCallback;
    function fromPromise(promise) {
        var emitter = new Emitter();
        var shouldEmit = false;
        promise
            .then(null, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(); }, 0);
            }
            else {
                emitter.fire();
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    exports.fromPromise = fromPromise;
    function delayed(promise) {
        var toCancel = null;
        var listener = null;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                toCancel = promise.then(function (event) { return listener = event(function (e) { return emitter.fire(e); }); }, function () { return null; });
            },
            onLastListenerRemove: function () {
                if (toCancel) {
                    toCancel.cancel();
                    toCancel = null;
                }
                if (listener) {
                    listener.dispose();
                    listener = null;
                }
            }
        });
        return emitter.event;
    }
    exports.delayed = delayed;
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            var result = event(function (e) {
                result.dispose();
                return listener.call(thisArgs, e);
            }, null, disposables);
            return result;
        };
    }
    exports.once = once;
    function any() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        var listeners = [];
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                listeners = events.map(function (e) { return e(function (r) { return emitter.fire(r); }); });
            },
            onLastListenerRemove: function () {
                listeners = lifecycle_1.dispose(listeners);
            }
        });
        return emitter.event;
    }
    exports.any = any;
    function debounceEvent(event, merger, delay) {
        if (delay === void 0) { delay = 100; }
        var subscription;
        var output;
        var handle;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    output = merger(output, cur);
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        emitter.fire(_output);
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.wrapEvent(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.bufferEvents(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    var ChainableEvent = (function () {
        function ChainableEvent(_event) {
            this._event = _event;
        }
        Object.defineProperty(ChainableEvent.prototype, "event", {
            get: function () { return this._event; },
            enumerable: true,
            configurable: true
        });
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(mapEvent(this._event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filterEvent(this._event, fn));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this._event(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    exports.chain = chain;
    function stopwatch(event) {
        var start = new Date().getTime();
        return mapEvent(once(event), function (_) { return new Date().getTime() - start; });
    }
    exports.stopwatch = stopwatch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (buffer === void 0) { buffer = []; }
        buffer = buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            buffer.forEach(function (e) { return emitter.fire(e); });
            buffer = null;
        };
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                listener.dispose();
                listener = null;
            }
        });
        return emitter.event;
    }
    exports.buffer = buffer;
});

define(__m[23/*vs/base/browser/browser*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,12/*vs/base/common/event*/]), function (require, exports, Platform, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var WindowManager = (function () {
        function WindowManager() {
            this._zoomLevel = 0;
            this._zoomFactor = 0;
            this._pixelRatioCache = 0;
            this._pixelRatioComputed = false;
            this._onDidChangeZoomLevel = new event_1.Emitter();
            this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
            this._onDidChangeFullscreen = new event_1.Emitter();
            this.onDidChangeFullscreen = this._onDidChangeFullscreen.event;
        }
        WindowManager.prototype.getZoomLevel = function () {
            return this._zoomLevel;
        };
        WindowManager.prototype.setZoomLevel = function (zoomLevel) {
            if (this._zoomLevel === zoomLevel) {
                return;
            }
            this._zoomLevel = zoomLevel;
            this._pixelRatioComputed = false;
            this._onDidChangeZoomLevel.fire(this._zoomLevel);
        };
        WindowManager.prototype.getZoomFactor = function () {
            return this._zoomFactor;
        };
        WindowManager.prototype.setZoomFactor = function (zoomFactor) {
            this._zoomFactor = zoomFactor;
        };
        WindowManager.prototype.getPixelRatio = function () {
            if (!this._pixelRatioComputed) {
                this._pixelRatioCache = this._computePixelRatio();
                this._pixelRatioComputed = true;
            }
            return this._pixelRatioCache;
        };
        WindowManager.prototype._computePixelRatio = function () {
            var ctx = document.createElement('canvas').getContext('2d');
            var dpr = window.devicePixelRatio || 1;
            var bsr = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;
            return dpr / bsr;
        };
        WindowManager.prototype.setFullscreen = function (fullscreen) {
            if (this._fullscreen === fullscreen) {
                return;
            }
            this._fullscreen = fullscreen;
            this._onDidChangeFullscreen.fire();
        };
        WindowManager.prototype.isFullscreen = function () {
            return this._fullscreen;
        };
        return WindowManager;
    }());
    WindowManager.INSTANCE = new WindowManager();
    /** A zoom index, e.g. 1, 2, 3 */
    function getZoomLevel() {
        return WindowManager.INSTANCE.getZoomLevel();
    }
    exports.getZoomLevel = getZoomLevel;
    /** The zoom scale for an index, e.g. 1, 1.2, 1.4 */
    function getZoomFactor() {
        return WindowManager.INSTANCE.getZoomFactor();
    }
    exports.getZoomFactor = getZoomFactor;
    function getPixelRatio() {
        return WindowManager.INSTANCE.getPixelRatio();
    }
    exports.getPixelRatio = getPixelRatio;
    function setZoomLevel(zoomLevel) {
        WindowManager.INSTANCE.setZoomLevel(zoomLevel);
    }
    exports.setZoomLevel = setZoomLevel;
    function setZoomFactor(zoomFactor) {
        WindowManager.INSTANCE.setZoomFactor(zoomFactor);
    }
    exports.setZoomFactor = setZoomFactor;
    function onDidChangeZoomLevel(callback) {
        return WindowManager.INSTANCE.onDidChangeZoomLevel(callback);
    }
    exports.onDidChangeZoomLevel = onDidChangeZoomLevel;
    function setFullscreen(fullscreen) {
        WindowManager.INSTANCE.setFullscreen(fullscreen);
    }
    exports.setFullscreen = setFullscreen;
    function isFullscreen() {
        return WindowManager.INSTANCE.isFullscreen();
    }
    exports.isFullscreen = isFullscreen;
    function onDidChangeFullscreen(callback) {
        return WindowManager.INSTANCE.onDidChangeFullscreen(callback);
    }
    exports.onDidChangeFullscreen = onDidChangeFullscreen;
    var userAgent = navigator.userAgent;
    exports.isIE = (userAgent.indexOf('Trident') >= 0);
    exports.isEdge = (userAgent.indexOf('Edge/') >= 0);
    exports.isEdgeOrIE = exports.isIE || exports.isEdge;
    exports.isOpera = (userAgent.indexOf('Opera') >= 0);
    exports.isFirefox = (userAgent.indexOf('Firefox') >= 0);
    exports.isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);
    exports.isChrome = (userAgent.indexOf('Chrome') >= 0);
    exports.isSafari = (userAgent.indexOf('Chrome') === -1) && (userAgent.indexOf('Safari') >= 0);
    exports.isIPad = (userAgent.indexOf('iPad') >= 0);
    exports.canUseTranslate3d = !exports.isFirefox;
    exports.enableEmptySelectionClipboard = exports.isWebKit;
    function supportsExecCommand(command) {
        return ((exports.isIE || Platform.isNative)
            && document.queryCommandSupported(command));
    }
    exports.supportsExecCommand = supportsExecCommand;
});

define(__m[121/*vs/base/browser/event*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/]), function (require, exports, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.domEvent = function (element, type, useCapture) {
        var fn = function (e) { return emitter.fire(e); };
        var emitter = new event_1.Emitter({
            onFirstListenerAdd: function () {
                element.addEventListener(type, fn, useCapture);
            },
            onLastListenerRemove: function () {
                element.removeEventListener(type, fn, useCapture);
            }
        });
        return emitter.event;
    };
    function stop(event) {
        return event_1.mapEvent(event, function (e) {
            e.preventDefault();
            e.stopPropagation();
            return e;
        });
    }
    exports.stop = stop;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[51/*vs/base/browser/keyboardEvent*/], __M([1/*require*/,0/*exports*/,32/*vs/base/common/keyCodes*/,19/*vs/base/common/platform*/,23/*vs/base/browser/browser*/]), function (require, exports, keyCodes_1, platform, browser) {
    'use strict';
    var KEY_CODE_MAP = {};
    (function () {
        KEY_CODE_MAP[3] = 7 /* PauseBreak */; // VK_CANCEL 0x03 Control-break processing
        KEY_CODE_MAP[8] = 1 /* Backspace */;
        KEY_CODE_MAP[9] = 2 /* Tab */;
        KEY_CODE_MAP[13] = 3 /* Enter */;
        KEY_CODE_MAP[16] = 4 /* Shift */;
        KEY_CODE_MAP[17] = 5 /* Ctrl */;
        KEY_CODE_MAP[18] = 6 /* Alt */;
        KEY_CODE_MAP[19] = 7 /* PauseBreak */;
        KEY_CODE_MAP[20] = 8 /* CapsLock */;
        KEY_CODE_MAP[27] = 9 /* Escape */;
        KEY_CODE_MAP[32] = 10 /* Space */;
        KEY_CODE_MAP[33] = 11 /* PageUp */;
        KEY_CODE_MAP[34] = 12 /* PageDown */;
        KEY_CODE_MAP[35] = 13 /* End */;
        KEY_CODE_MAP[36] = 14 /* Home */;
        KEY_CODE_MAP[37] = 15 /* LeftArrow */;
        KEY_CODE_MAP[38] = 16 /* UpArrow */;
        KEY_CODE_MAP[39] = 17 /* RightArrow */;
        KEY_CODE_MAP[40] = 18 /* DownArrow */;
        KEY_CODE_MAP[45] = 19 /* Insert */;
        KEY_CODE_MAP[46] = 20 /* Delete */;
        KEY_CODE_MAP[48] = 21 /* KEY_0 */;
        KEY_CODE_MAP[49] = 22 /* KEY_1 */;
        KEY_CODE_MAP[50] = 23 /* KEY_2 */;
        KEY_CODE_MAP[51] = 24 /* KEY_3 */;
        KEY_CODE_MAP[52] = 25 /* KEY_4 */;
        KEY_CODE_MAP[53] = 26 /* KEY_5 */;
        KEY_CODE_MAP[54] = 27 /* KEY_6 */;
        KEY_CODE_MAP[55] = 28 /* KEY_7 */;
        KEY_CODE_MAP[56] = 29 /* KEY_8 */;
        KEY_CODE_MAP[57] = 30 /* KEY_9 */;
        KEY_CODE_MAP[65] = 31 /* KEY_A */;
        KEY_CODE_MAP[66] = 32 /* KEY_B */;
        KEY_CODE_MAP[67] = 33 /* KEY_C */;
        KEY_CODE_MAP[68] = 34 /* KEY_D */;
        KEY_CODE_MAP[69] = 35 /* KEY_E */;
        KEY_CODE_MAP[70] = 36 /* KEY_F */;
        KEY_CODE_MAP[71] = 37 /* KEY_G */;
        KEY_CODE_MAP[72] = 38 /* KEY_H */;
        KEY_CODE_MAP[73] = 39 /* KEY_I */;
        KEY_CODE_MAP[74] = 40 /* KEY_J */;
        KEY_CODE_MAP[75] = 41 /* KEY_K */;
        KEY_CODE_MAP[76] = 42 /* KEY_L */;
        KEY_CODE_MAP[77] = 43 /* KEY_M */;
        KEY_CODE_MAP[78] = 44 /* KEY_N */;
        KEY_CODE_MAP[79] = 45 /* KEY_O */;
        KEY_CODE_MAP[80] = 46 /* KEY_P */;
        KEY_CODE_MAP[81] = 47 /* KEY_Q */;
        KEY_CODE_MAP[82] = 48 /* KEY_R */;
        KEY_CODE_MAP[83] = 49 /* KEY_S */;
        KEY_CODE_MAP[84] = 50 /* KEY_T */;
        KEY_CODE_MAP[85] = 51 /* KEY_U */;
        KEY_CODE_MAP[86] = 52 /* KEY_V */;
        KEY_CODE_MAP[87] = 53 /* KEY_W */;
        KEY_CODE_MAP[88] = 54 /* KEY_X */;
        KEY_CODE_MAP[89] = 55 /* KEY_Y */;
        KEY_CODE_MAP[90] = 56 /* KEY_Z */;
        KEY_CODE_MAP[93] = 58 /* ContextMenu */;
        KEY_CODE_MAP[96] = 93 /* NUMPAD_0 */;
        KEY_CODE_MAP[97] = 94 /* NUMPAD_1 */;
        KEY_CODE_MAP[98] = 95 /* NUMPAD_2 */;
        KEY_CODE_MAP[99] = 96 /* NUMPAD_3 */;
        KEY_CODE_MAP[100] = 97 /* NUMPAD_4 */;
        KEY_CODE_MAP[101] = 98 /* NUMPAD_5 */;
        KEY_CODE_MAP[102] = 99 /* NUMPAD_6 */;
        KEY_CODE_MAP[103] = 100 /* NUMPAD_7 */;
        KEY_CODE_MAP[104] = 101 /* NUMPAD_8 */;
        KEY_CODE_MAP[105] = 102 /* NUMPAD_9 */;
        KEY_CODE_MAP[106] = 103 /* NUMPAD_MULTIPLY */;
        KEY_CODE_MAP[107] = 104 /* NUMPAD_ADD */;
        KEY_CODE_MAP[108] = 105 /* NUMPAD_SEPARATOR */;
        KEY_CODE_MAP[109] = 106 /* NUMPAD_SUBTRACT */;
        KEY_CODE_MAP[110] = 107 /* NUMPAD_DECIMAL */;
        KEY_CODE_MAP[111] = 108 /* NUMPAD_DIVIDE */;
        KEY_CODE_MAP[112] = 59 /* F1 */;
        KEY_CODE_MAP[113] = 60 /* F2 */;
        KEY_CODE_MAP[114] = 61 /* F3 */;
        KEY_CODE_MAP[115] = 62 /* F4 */;
        KEY_CODE_MAP[116] = 63 /* F5 */;
        KEY_CODE_MAP[117] = 64 /* F6 */;
        KEY_CODE_MAP[118] = 65 /* F7 */;
        KEY_CODE_MAP[119] = 66 /* F8 */;
        KEY_CODE_MAP[120] = 67 /* F9 */;
        KEY_CODE_MAP[121] = 68 /* F10 */;
        KEY_CODE_MAP[122] = 69 /* F11 */;
        KEY_CODE_MAP[123] = 70 /* F12 */;
        KEY_CODE_MAP[124] = 71 /* F13 */;
        KEY_CODE_MAP[125] = 72 /* F14 */;
        KEY_CODE_MAP[126] = 73 /* F15 */;
        KEY_CODE_MAP[127] = 74 /* F16 */;
        KEY_CODE_MAP[128] = 75 /* F17 */;
        KEY_CODE_MAP[129] = 76 /* F18 */;
        KEY_CODE_MAP[130] = 77 /* F19 */;
        KEY_CODE_MAP[144] = 78 /* NumLock */;
        KEY_CODE_MAP[145] = 79 /* ScrollLock */;
        KEY_CODE_MAP[186] = 80 /* US_SEMICOLON */;
        KEY_CODE_MAP[187] = 81 /* US_EQUAL */;
        KEY_CODE_MAP[188] = 82 /* US_COMMA */;
        KEY_CODE_MAP[189] = 83 /* US_MINUS */;
        KEY_CODE_MAP[190] = 84 /* US_DOT */;
        KEY_CODE_MAP[191] = 85 /* US_SLASH */;
        KEY_CODE_MAP[192] = 86 /* US_BACKTICK */;
        KEY_CODE_MAP[219] = 87 /* US_OPEN_SQUARE_BRACKET */;
        KEY_CODE_MAP[220] = 88 /* US_BACKSLASH */;
        KEY_CODE_MAP[221] = 89 /* US_CLOSE_SQUARE_BRACKET */;
        KEY_CODE_MAP[222] = 90 /* US_QUOTE */;
        KEY_CODE_MAP[223] = 91 /* OEM_8 */;
        KEY_CODE_MAP[226] = 92 /* OEM_102 */;
        if (browser.isIE) {
            KEY_CODE_MAP[91] = 57 /* Meta */;
        }
        else if (browser.isFirefox) {
            KEY_CODE_MAP[59] = 80 /* US_SEMICOLON */;
            KEY_CODE_MAP[107] = 81 /* US_EQUAL */;
            KEY_CODE_MAP[109] = 83 /* US_MINUS */;
            if (platform.isMacintosh) {
                KEY_CODE_MAP[224] = 57 /* Meta */;
            }
        }
        else if (browser.isWebKit) {
            KEY_CODE_MAP[91] = 57 /* Meta */;
            if (platform.isMacintosh) {
                // the two meta keys in the Mac have different key codes (91 and 93)
                KEY_CODE_MAP[93] = 57 /* Meta */;
            }
            else {
                KEY_CODE_MAP[92] = 57 /* Meta */;
            }
        }
    })();
    function lookupKeyCode(e) {
        return KEY_CODE_MAP[e.keyCode] || 0 /* Unknown */;
    }
    exports.lookupKeyCode = lookupKeyCode;
    var extractKeyCode = function extractKeyCode(e) {
        if (e.charCode) {
            // "keypress" events mostly
            var char = String.fromCharCode(e.charCode).toUpperCase();
            return keyCodes_1.KeyCodeUtils.fromString(char);
        }
        return lookupKeyCode(e);
    };
    function setExtractKeyCode(newExtractKeyCode) {
        extractKeyCode = newExtractKeyCode;
    }
    exports.setExtractKeyCode = setExtractKeyCode;
    var ctrlKeyMod = (platform.isMacintosh ? 256 /* WinCtrl */ : 2048 /* CtrlCmd */);
    var altKeyMod = 512 /* Alt */;
    var shiftKeyMod = 1024 /* Shift */;
    var metaKeyMod = (platform.isMacintosh ? 2048 /* CtrlCmd */ : 256 /* WinCtrl */);
    var StandardKeyboardEvent = (function () {
        function StandardKeyboardEvent(source) {
            var e = source;
            this.browserEvent = e;
            this.target = e.target;
            this.ctrlKey = e.ctrlKey;
            this.shiftKey = e.shiftKey;
            this.altKey = e.altKey;
            this.metaKey = e.metaKey;
            this.keyCode = extractKeyCode(e);
            // console.info(e.type + ": keyCode: " + e.keyCode + ", which: " + e.which + ", charCode: " + e.charCode + ", detail: " + e.detail + " ====> " + this.keyCode + ' -- ' + KeyCode[this.keyCode]);
            this.ctrlKey = this.ctrlKey || this.keyCode === 5 /* Ctrl */;
            this.altKey = this.altKey || this.keyCode === 6 /* Alt */;
            this.shiftKey = this.shiftKey || this.keyCode === 4 /* Shift */;
            this.metaKey = this.metaKey || this.keyCode === 57 /* Meta */;
            this._asKeybinding = this._computeKeybinding();
        }
        StandardKeyboardEvent.prototype.preventDefault = function () {
            if (this.browserEvent && this.browserEvent.preventDefault) {
                this.browserEvent.preventDefault();
            }
        };
        StandardKeyboardEvent.prototype.stopPropagation = function () {
            if (this.browserEvent && this.browserEvent.stopPropagation) {
                this.browserEvent.stopPropagation();
            }
        };
        StandardKeyboardEvent.prototype.toKeybinding = function () {
            return this._asKeybinding;
        };
        StandardKeyboardEvent.prototype.equals = function (other) {
            return this._asKeybinding.value === other;
        };
        StandardKeyboardEvent.prototype._computeKeybinding = function () {
            var key = 0 /* Unknown */;
            if (this.keyCode !== 5 /* Ctrl */ && this.keyCode !== 4 /* Shift */ && this.keyCode !== 6 /* Alt */ && this.keyCode !== 57 /* Meta */) {
                key = this.keyCode;
            }
            var result = 0;
            if (this.ctrlKey) {
                result |= ctrlKeyMod;
            }
            if (this.altKey) {
                result |= altKeyMod;
            }
            if (this.shiftKey) {
                result |= shiftKeyMod;
            }
            if (this.metaKey) {
                result |= metaKeyMod;
            }
            result |= key;
            return new keyCodes_1.Keybinding(result);
        };
        return StandardKeyboardEvent;
    }());
    exports.StandardKeyboardEvent = StandardKeyboardEvent;
});






define(__m[34/*vs/base/browser/mouseEvent*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,23/*vs/base/browser/browser*/,155/*vs/base/browser/iframe*/]), function (require, exports, platform, browser, iframe_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var StandardMouseEvent = (function () {
        function StandardMouseEvent(e) {
            this.timestamp = Date.now();
            this.browserEvent = e;
            this.leftButton = e.button === 0;
            this.middleButton = e.button === 1;
            this.rightButton = e.button === 2;
            this.target = e.target;
            this.detail = e.detail || 1;
            if (e.type === 'dblclick') {
                this.detail = 2;
            }
            this.ctrlKey = e.ctrlKey;
            this.shiftKey = e.shiftKey;
            this.altKey = e.altKey;
            this.metaKey = e.metaKey;
            if (typeof e.pageX === 'number') {
                this.posx = e.pageX;
                this.posy = e.pageY;
            }
            else {
                // Probably hit by MSGestureEvent
                this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }
            // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.
            var iframeOffsets = iframe_1.IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
            this.posx -= iframeOffsets.left;
            this.posy -= iframeOffsets.top;
        }
        StandardMouseEvent.prototype.preventDefault = function () {
            if (this.browserEvent.preventDefault) {
                this.browserEvent.preventDefault();
            }
        };
        StandardMouseEvent.prototype.stopPropagation = function () {
            if (this.browserEvent.stopPropagation) {
                this.browserEvent.stopPropagation();
            }
        };
        return StandardMouseEvent;
    }());
    exports.StandardMouseEvent = StandardMouseEvent;
    var DragMouseEvent = (function (_super) {
        __extends(DragMouseEvent, _super);
        function DragMouseEvent(e) {
            var _this = _super.call(this, e) || this;
            _this.dataTransfer = e.dataTransfer;
            return _this;
        }
        return DragMouseEvent;
    }(StandardMouseEvent));
    exports.DragMouseEvent = DragMouseEvent;
    var DropMouseEvent = (function (_super) {
        __extends(DropMouseEvent, _super);
        function DropMouseEvent(e) {
            return _super.call(this, e) || this;
        }
        return DropMouseEvent;
    }(DragMouseEvent));
    exports.DropMouseEvent = DropMouseEvent;
    var StandardMouseWheelEvent = (function () {
        function StandardMouseWheelEvent(e, deltaX, deltaY) {
            if (deltaX === void 0) { deltaX = 0; }
            if (deltaY === void 0) { deltaY = 0; }
            this.browserEvent = e || null;
            this.target = e ? (e.target || e.targetNode || e.srcElement) : null;
            this.deltaY = deltaY;
            this.deltaX = deltaX;
            if (e) {
                var e1 = e;
                var e2 = e;
                // vertical delta scroll
                if (typeof e1.wheelDeltaY !== 'undefined') {
                    this.deltaY = e1.wheelDeltaY / 120;
                }
                else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {
                    this.deltaY = -e2.detail / 3;
                }
                // horizontal delta scroll
                if (typeof e1.wheelDeltaX !== 'undefined') {
                    if (browser.isSafari && platform.isWindows) {
                        this.deltaX = -(e1.wheelDeltaX / 120);
                    }
                    else {
                        this.deltaX = e1.wheelDeltaX / 120;
                    }
                }
                else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {
                    this.deltaX = -e.detail / 3;
                }
                // Assume a vertical scroll if nothing else worked
                if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
                    this.deltaY = e.wheelDelta / 120;
                }
            }
        }
        StandardMouseWheelEvent.prototype.preventDefault = function () {
            if (this.browserEvent) {
                if (this.browserEvent.preventDefault) {
                    this.browserEvent.preventDefault();
                }
            }
        };
        StandardMouseWheelEvent.prototype.stopPropagation = function () {
            if (this.browserEvent) {
                if (this.browserEvent.stopPropagation) {
                    this.browserEvent.stopPropagation();
                }
            }
        };
        return StandardMouseWheelEvent;
    }());
    exports.StandardMouseWheelEvent = StandardMouseWheelEvent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[138/*vs/base/common/cancellation*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/]), function (require, exports, event_1) {
    'use strict';
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.default.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: shortcutEvent
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var MutableToken = (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this._emitter = undefined;
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return MutableToken;
    }());
    var CancellationTokenSource = (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else {
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            this.cancel();
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});






define(__m[25/*vs/base/common/eventEmitter*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/]), function (require, exports, Errors) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EmitterEvent = (function () {
        function EmitterEvent(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            this._type = eventType;
            this._data = data;
        }
        EmitterEvent.prototype.getType = function () {
            return this._type;
        };
        EmitterEvent.prototype.getData = function () {
            return this._data;
        };
        return EmitterEvent;
    }());
    exports.EmitterEvent = EmitterEvent;
    var EventEmitter = (function () {
        function EventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            if (allowedEventTypes) {
                this._allowedEventTypes = {};
                for (var i = 0; i < allowedEventTypes.length; i++) {
                    this._allowedEventTypes[allowedEventTypes[i]] = true;
                }
            }
            else {
                this._allowedEventTypes = null;
            }
        }
        EventEmitter.prototype.dispose = function () {
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            this._allowedEventTypes = null;
        };
        EventEmitter.prototype.addListener = function (eventType, listener) {
            if (eventType === '*') {
                throw new Error('Use addBulkListener(listener) to register your listener!');
            }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('This object will never emit this event type!');
            }
            if (this._listeners.hasOwnProperty(eventType)) {
                this._listeners[eventType].push(listener);
            }
            else {
                this._listeners[eventType] = [listener];
            }
            var bound = this;
            return {
                dispose: function () {
                    if (!bound) {
                        // Already called
                        return;
                    }
                    bound._removeListener(eventType, listener);
                    // Prevent leakers from holding on to the event emitter
                    bound = null;
                    listener = null;
                }
            };
        };
        EventEmitter.prototype.addListener2 = function (eventType, listener) {
            return this.addListener(eventType, listener);
        };
        EventEmitter.prototype.addOneTimeDisposableListener = function (eventType, listener) {
            var disposable = this.addListener(eventType, function (value) {
                disposable.dispose();
                listener(value);
            });
            return disposable;
        };
        EventEmitter.prototype.addBulkListener = function (listener) {
            var _this = this;
            this._bulkListeners.push(listener);
            return {
                dispose: function () {
                    _this._removeBulkListener(listener);
                }
            };
        };
        EventEmitter.prototype.addBulkListener2 = function (listener) {
            return this.addBulkListener(listener);
        };
        EventEmitter.prototype.addEmitter = function (eventEmitter) {
            var _this = this;
            return eventEmitter.addBulkListener2(function (events) {
                var newEvents = events;
                if (_this._deferredCnt === 0) {
                    _this._emitEvents(newEvents);
                }
                else {
                    // Collect for later
                    _this._collectedEvents.push.apply(_this._collectedEvents, newEvents);
                }
            });
        };
        EventEmitter.prototype.addEmitter2 = function (eventEmitter) {
            return this.addEmitter(eventEmitter);
        };
        EventEmitter.prototype._removeListener = function (eventType, listener) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        };
        EventEmitter.prototype._removeBulkListener = function (listener) {
            for (var i = 0, len = this._bulkListeners.length; i < len; i++) {
                if (this._bulkListeners[i] === listener) {
                    this._bulkListeners.splice(i, 1);
                    break;
                }
            }
        };
        EventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType].slice(0);
                for (var i = 0, len = listeners.length; i < len; i++) {
                    safeInvoke1Arg(listeners[i], data);
                }
            }
        };
        EventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners.slice(0);
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                safeInvoke1Arg(bulkListeners[i], events);
            }
        };
        EventEmitter.prototype._emitEvents = function (events) {
            if (this._bulkListeners.length > 0) {
                this._emitToBulkListeners(events);
            }
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._emitToSpecificTypeListeners(e.getType(), e.getData());
            }
        };
        EventEmitter.prototype.emit = function (eventType, data) {
            if (data === void 0) { data = {}; }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('Cannot emit this event type because it wasn\'t white-listed!');
            }
            // Early return if no listeners would get this
            if (!this._listeners.hasOwnProperty(eventType) && this._bulkListeners.length === 0) {
                return;
            }
            var emitterEvent = new EmitterEvent(eventType, data);
            if (this._deferredCnt === 0) {
                this._emitEvents([emitterEvent]);
            }
            else {
                // Collect for later
                this._collectedEvents.push(emitterEvent);
            }
        };
        EventEmitter.prototype._beginDeferredEmit = function () {
            this._deferredCnt = this._deferredCnt + 1;
        };
        EventEmitter.prototype._endDeferredEmit = function () {
            this._deferredCnt = this._deferredCnt - 1;
            if (this._deferredCnt === 0) {
                this._emitCollected();
            }
        };
        EventEmitter.prototype.deferredEmit = function (callback) {
            this._beginDeferredEmit();
            var result = safeInvokeNoArg(callback);
            this._endDeferredEmit();
            return result;
        };
        EventEmitter.prototype._emitCollected = function () {
            // Flush collected events
            var events = this._collectedEvents;
            this._collectedEvents = [];
            if (events.length > 0) {
                this._emitEvents(events);
            }
        };
        return EventEmitter;
    }());
    exports.EventEmitter = EventEmitter;
    var EmitQueueElement = (function () {
        function EmitQueueElement(target, arg) {
            this.target = target;
            this.arg = arg;
        }
        return EmitQueueElement;
    }());
    /**
     * Same as EventEmitter, but guarantees events are delivered in order to each listener
     */
    var OrderGuaranteeEventEmitter = (function (_super) {
        __extends(OrderGuaranteeEventEmitter, _super);
        function OrderGuaranteeEventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            var _this = _super.call(this, allowedEventTypes) || this;
            _this._emitQueue = [];
            return _this;
        }
        OrderGuaranteeEventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    this._emitQueue.push(new EmitQueueElement(listeners[i], data));
                }
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners;
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                this._emitQueue.push(new EmitQueueElement(bulkListeners[i], events));
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitEvents = function (events) {
            _super.prototype._emitEvents.call(this, events);
            while (this._emitQueue.length > 0) {
                var queueElement = this._emitQueue.shift();
                safeInvoke1Arg(queueElement.target, queueElement.arg);
            }
        };
        return OrderGuaranteeEventEmitter;
    }(EventEmitter));
    exports.OrderGuaranteeEventEmitter = OrderGuaranteeEventEmitter;
    function safeInvokeNoArg(func) {
        try {
            return func();
        }
        catch (e) {
            Errors.onUnexpectedError(e);
        }
    }
    function safeInvoke1Arg(func, arg1) {
        try {
            return func(arg1);
        }
        catch (e) {
            Errors.onUnexpectedError(e);
        }
    }
});

define(__m[472/*vs/base/common/graph*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/types*/,91/*vs/base/common/collections*/]), function (require, exports, types_1, collections_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function newNode(data) {
        return {
            data: data,
            incoming: Object.create(null),
            outgoing: Object.create(null)
        };
    }
    var Graph = (function () {
        function Graph(_hashFn) {
            this._hashFn = _hashFn;
            this._nodes = Object.create(null);
            // empty
        }
        Graph.prototype.roots = function () {
            var ret = [];
            collections_1.forEach(this._nodes, function (entry) {
                if (types_1.isEmptyObject(entry.value.outgoing)) {
                    ret.push(entry.value);
                }
            });
            return ret;
        };
        Graph.prototype.traverse = function (start, inwards, callback) {
            var startNode = this.lookup(start);
            if (!startNode) {
                return;
            }
            this._traverse(startNode, inwards, Object.create(null), callback);
        };
        Graph.prototype._traverse = function (node, inwards, seen, callback) {
            var _this = this;
            var key = this._hashFn(node.data);
            if (seen[key]) {
                return;
            }
            seen[key] = true;
            callback(node.data);
            var nodes = inwards ? node.outgoing : node.incoming;
            collections_1.forEach(nodes, function (entry) { return _this._traverse(entry.value, inwards, seen, callback); });
        };
        Graph.prototype.insertEdge = function (from, to) {
            var fromNode = this.lookupOrInsertNode(from), toNode = this.lookupOrInsertNode(to);
            fromNode.outgoing[this._hashFn(to)] = toNode;
            toNode.incoming[this._hashFn(from)] = fromNode;
        };
        Graph.prototype.removeNode = function (data) {
            var key = this._hashFn(data);
            delete this._nodes[key];
            collections_1.forEach(this._nodes, function (entry) {
                delete entry.value.outgoing[key];
                delete entry.value.incoming[key];
            });
        };
        Graph.prototype.lookupOrInsertNode = function (data) {
            var key = this._hashFn(data);
            var node = this._nodes[key];
            if (!node) {
                node = newNode(data);
                this._nodes[key] = node;
            }
            return node;
        };
        Graph.prototype.lookup = function (data) {
            return this._nodes[this._hashFn(data)];
        };
        Object.defineProperty(Graph.prototype, "length", {
            get: function () {
                return Object.keys(this._nodes).length;
            },
            enumerable: true,
            configurable: true
        });
        Graph.prototype.toString = function () {
            var data = [];
            collections_1.forEach(this._nodes, function (entry) {
                data.push(entry.key + ", (incoming)[" + Object.keys(entry.value.incoming).join(', ') + "], (outgoing)[" + Object.keys(entry.value.outgoing).join(',') + "]");
            });
            return data.join('\n');
        };
        return Graph;
    }());
    exports.Graph = Graph;
});

define(__m[156/*vs/base/common/labels*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,24/*vs/base/common/types*/,39/*vs/base/common/paths*/,9/*vs/base/common/strings*/]), function (require, exports, platform, types, paths_1, strings_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PathLabelProvider = (function () {
        function PathLabelProvider(arg1) {
            this.root = arg1 && getPath(arg1);
        }
        PathLabelProvider.prototype.getLabel = function (arg1) {
            return getPathLabel(getPath(arg1), this.root);
        };
        return PathLabelProvider;
    }());
    exports.PathLabelProvider = PathLabelProvider;
    function getPathLabel(resource, basePathProvider) {
        var absolutePath = getPath(resource);
        if (!absolutePath) {
            return null;
        }
        var basepath = basePathProvider && getPath(basePathProvider);
        if (basepath && paths_1.isEqualOrParent(absolutePath, basepath)) {
            if (basepath === absolutePath) {
                return ''; // no label if pathes are identical
            }
            return paths_1.normalize(strings_1.ltrim(absolutePath.substr(basepath.length), paths_1.nativeSep), true);
        }
        if (platform.isWindows && absolutePath && absolutePath[1] === ':') {
            return paths_1.normalize(absolutePath.charAt(0).toUpperCase() + absolutePath.slice(1), true); // convert c:\something => C:\something
        }
        return paths_1.normalize(absolutePath, true);
    }
    exports.getPathLabel = getPathLabel;
    function getPath(arg1) {
        if (!arg1) {
            return null;
        }
        if (typeof arg1 === 'string') {
            return arg1;
        }
        if (types.isFunction(arg1.getWorkspace)) {
            var ws = arg1.getWorkspace();
            return ws ? ws.resource.fsPath : void 0;
        }
        return arg1.fsPath;
    }
    /**
     * Shortens the paths but keeps them easy to distinguish.
     * Replaces not important parts with ellipsis.
     * Every shorten path matches only one original path and vice versa.
     */
    function shorten(paths) {
        var ellipsis = '\u2026';
        var shortenedPaths = new Array(paths.length);
        // for every path
        var match = false;
        for (var pathIndex = 0; pathIndex < paths.length; pathIndex++) {
            var path = paths[pathIndex];
            match = true;
            // pick the first shortest subpath found
            if (typeof path === 'string') {
                var segments = path.split(paths_1.nativeSep);
                for (var subpathLength = 1; match && subpathLength <= segments.length; subpathLength++) {
                    for (var start = segments.length - subpathLength; match && start >= 0; start--) {
                        match = false;
                        var subpath = segments.slice(start, start + subpathLength).join(paths_1.nativeSep);
                        // that is unique to any other path
                        for (var otherPathIndex = 0; !match && otherPathIndex < paths.length; otherPathIndex++) {
                            // suffix subpath treated specially as we consider no match 'x' and 'x/...'
                            if (otherPathIndex !== pathIndex && paths[otherPathIndex].indexOf(subpath) > -1) {
                                var isSubpathEnding = (start + subpathLength === segments.length);
                                var isOtherPathEnding = strings_1.endsWith(paths[otherPathIndex], subpath);
                                match = !isSubpathEnding || isOtherPathEnding;
                            }
                        }
                        // found unique subpath
                        if (!match) {
                            var result = subpath;
                            if (start + subpathLength < segments.length) {
                                result = result + paths_1.nativeSep + ellipsis;
                            }
                            if (start > 0) {
                                result = ellipsis + paths_1.nativeSep + result;
                            }
                            shortenedPaths[pathIndex] = result;
                        }
                    }
                }
            }
            if (match) {
                shortenedPaths[pathIndex] = path; // use full path if no unique subpaths found
            }
        }
        return shortenedPaths;
    }
    exports.shorten = shorten;
});

define(__m[500/*vs/base/common/mime*/], __M([1/*require*/,0/*exports*/,39/*vs/base/common/paths*/,24/*vs/base/common/types*/,9/*vs/base/common/strings*/,164/*vs/base/common/glob*/]), function (require, exports, paths, types, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    var nonUserRegisteredAssociations = [];
    var userRegisteredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association) {
        // Register
        var associationItem = toTextMimeAssociationItem(association);
        registeredAssociations.push(associationItem);
        if (!associationItem.userConfigured) {
            nonUserRegisteredAssociations.push(associationItem);
        }
        else {
            userRegisteredAssociations.push(associationItem);
        }
        // Check for conflicts unless this is a user configured association
        if (!associationItem.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === associationItem.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (associationItem.extension && a.extension === associationItem.extension) {
                    console.warn("Overwriting extension <<" + associationItem.extension + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filename && a.filename === associationItem.filename) {
                    console.warn("Overwriting filename <<" + associationItem.filename + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {
                    console.warn("Overwriting filepattern <<" + associationItem.filepattern + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
                if (associationItem.firstline && a.firstline === associationItem.firstline) {
                    console.warn("Overwriting firstline <<" + associationItem.firstline + ">> to now point to mime <<" + associationItem.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    function toTextMimeAssociationItem(association) {
        return {
            id: association.id,
            mime: association.mime,
            filename: association.filename,
            extension: association.extension,
            filepattern: association.filepattern,
            firstline: association.firstline,
            userConfigured: association.userConfigured,
            filenameLowercase: association.filename ? association.filename.toLowerCase() : void 0,
            extensionLowercase: association.extension ? association.extension.toLowerCase() : void 0,
            filepatternLowercase: association.filepattern ? association.filepattern.toLowerCase() : void 0,
            filepatternOnPath: association.filepattern ? association.filepattern.indexOf(paths.sep) >= 0 : false
        };
    }
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
            nonUserRegisteredAssociations = [];
            userRegisteredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
            userRegisteredAssociations = [];
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        var filename = paths.basename(path);
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, filename, userRegisteredAssociations);
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, filename, nonUserRegisteredAssociations);
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, filename, associations) {
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        for (var i = 0; i < associations.length; i++) {
            var association = associations[i];
            // First exact name match
            if (filename === association.filenameLowercase) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                    var target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator
                    if (glob_1.match(association.filepatternLowercase, target)) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                    if (strings.endsWith(filename, association.extensionLowercase)) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                // Make sure the entire line matches, not just a subpart.
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0 && matches[0].length === firstLine.length) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isBinaryMime(mimes) {
        if (!mimes) {
            return false;
        }
        var mimeVals;
        if (types.isArray(mimes)) {
            mimeVals = mimes;
        }
        else {
            mimeVals = mimes.split(',').map(function (mime) { return mime.trim(); });
        }
        return mimeVals.indexOf(exports.MIME_BINARY) >= 0;
    }
    exports.isBinaryMime = isBinaryMime;
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    function suggestFilename(langId, prefix) {
        for (var i = 0; i < registeredAssociations.length; i++) {
            var association = registeredAssociations[i];
            if (association.userConfigured) {
                continue; // only support registered ones
            }
            if (association.id === langId && association.extension) {
                return prefix + association.extension;
            }
        }
        return prefix; // without any known extension, just return the prefix
    }
    exports.suggestFilename = suggestFilename;
});

define(__m[36/*vs/base/common/objects*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/types*/]), function (require, exports, Types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function clone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            // See https://github.com/Microsoft/TypeScript/issues/10990
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = clone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.clone = clone;
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (Types.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (Types.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (Types.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    // DON'T USE THESE FUNCTION UNLESS YOU KNOW HOW CHROME
    // WORKS... WE HAVE SEEN VERY WEIRD BEHAVIOUR WITH CHROME >= 37
    ///**
    // * Recursively call Object.freeze on object and any properties that are objects.
    // */
    //export function deepFreeze(obj:any):void {
    //	Object.freeze(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isFrozen(obj[key])) {
    //			return;
    //		}
    //
    //		deepFreeze(obj[key]);
    //	});
    //	if(!Object.isFrozen(obj)) {
    //		console.log('too warm');
    //	}
    //}
    //
    //export function deepSeal(obj:any):void {
    //	Object.seal(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isSealed(obj[key])) {
    //			return;
    //		}
    //
    //		deepSeal(obj[key]);
    //	});
    //	if(!Object.isSealed(obj)) {
    //		console.log('NOT sealed');
    //	}
    //}
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!Types.isObject(destination)) {
            return source;
        }
        if (Types.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (Types.isObject(destination[key]) && Types.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function toObject(arr, keyMap, valueMap) {
        if (valueMap === void 0) { valueMap = function (x) { return x; }; }
        return arr.reduce(function (o, d) {
            return assign(o, (_a = {}, _a[keyMap(d)] = valueMap(d), _a));
            var _a;
        }, Object.create(null));
    }
    exports.toObject = toObject;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i, key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function ensureProperty(obj, property, defaultValue) {
        if (typeof obj[property] === 'undefined') {
            obj[property] = defaultValue;
        }
    }
    exports.ensureProperty = ensureProperty;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Started from TypeScript's __extends function to make a type a subclass of a specific class.
     * Modified to work with properties already defined on the derivedClass, since we can't get TS
     * to call this method before the constructor definition.
     */
    function derive(baseClass, derivedClass) {
        for (var prop in baseClass) {
            if (baseClass.hasOwnProperty(prop)) {
                derivedClass[prop] = baseClass[prop];
            }
        }
        derivedClass = derivedClass || function () { };
        var basePrototype = baseClass.prototype;
        var derivedPrototype = derivedClass.prototype;
        derivedClass.prototype = Object.create(basePrototype);
        for (var prop in derivedPrototype) {
            if (derivedPrototype.hasOwnProperty(prop)) {
                // handle getters and setters properly
                Object.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));
            }
        }
        // Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.
        Object.defineProperty(derivedClass.prototype, 'constructor', { value: derivedClass, writable: true, configurable: true, enumerable: true });
    }
    exports.derive = derive;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (Types.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
});






define(__m[38/*vs/base/common/scrollable*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,12/*vs/base/common/event*/]), function (require, exports, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ScrollbarVisibility;
    (function (ScrollbarVisibility) {
        ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
        ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
    })(ScrollbarVisibility = exports.ScrollbarVisibility || (exports.ScrollbarVisibility = {}));
    var Scrollable = (function (_super) {
        __extends(Scrollable, _super);
        function Scrollable() {
            var _this = _super.call(this) || this;
            _this._onScroll = _this._register(new event_1.Emitter());
            _this.onScroll = _this._onScroll.event;
            _this._width = 0;
            _this._scrollWidth = 0;
            _this._scrollLeft = 0;
            _this._height = 0;
            _this._scrollHeight = 0;
            _this._scrollTop = 0;
            return _this;
        }
        Scrollable.prototype.getWidth = function () {
            return this._width;
        };
        Scrollable.prototype.getScrollWidth = function () {
            return this._scrollWidth;
        };
        Scrollable.prototype.getScrollLeft = function () {
            return this._scrollLeft;
        };
        Scrollable.prototype.getHeight = function () {
            return this._height;
        };
        Scrollable.prototype.getScrollHeight = function () {
            return this._scrollHeight;
        };
        Scrollable.prototype.getScrollTop = function () {
            return this._scrollTop;
        };
        Scrollable.prototype.updateState = function (newState) {
            var width = (typeof newState.width !== 'undefined' ? newState.width | 0 : this._width);
            var scrollWidth = (typeof newState.scrollWidth !== 'undefined' ? newState.scrollWidth | 0 : this._scrollWidth);
            var scrollLeft = (typeof newState.scrollLeft !== 'undefined' ? newState.scrollLeft | 0 : this._scrollLeft);
            var height = (typeof newState.height !== 'undefined' ? newState.height | 0 : this._height);
            var scrollHeight = (typeof newState.scrollHeight !== 'undefined' ? newState.scrollHeight | 0 : this._scrollHeight);
            var scrollTop = (typeof newState.scrollTop !== 'undefined' ? newState.scrollTop | 0 : this._scrollTop);
            if (width < 0) {
                width = 0;
            }
            if (scrollLeft + width > scrollWidth) {
                scrollLeft = scrollWidth - width;
            }
            if (scrollLeft < 0) {
                scrollLeft = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (scrollTop + height > scrollHeight) {
                scrollTop = scrollHeight - height;
            }
            if (scrollTop < 0) {
                scrollTop = 0;
            }
            var widthChanged = (this._width !== width);
            var scrollWidthChanged = (this._scrollWidth !== scrollWidth);
            var scrollLeftChanged = (this._scrollLeft !== scrollLeft);
            var heightChanged = (this._height !== height);
            var scrollHeightChanged = (this._scrollHeight !== scrollHeight);
            var scrollTopChanged = (this._scrollTop !== scrollTop);
            if (!widthChanged && !scrollWidthChanged && !scrollLeftChanged && !heightChanged && !scrollHeightChanged && !scrollTopChanged) {
                return;
            }
            this._width = width;
            this._scrollWidth = scrollWidth;
            this._scrollLeft = scrollLeft;
            this._height = height;
            this._scrollHeight = scrollHeight;
            this._scrollTop = scrollTop;
            this._onScroll.fire({
                width: this._width,
                scrollWidth: this._scrollWidth,
                scrollLeft: this._scrollLeft,
                height: this._height,
                scrollHeight: this._scrollHeight,
                scrollTop: this._scrollTop,
                widthChanged: widthChanged,
                scrollWidthChanged: scrollWidthChanged,
                scrollLeftChanged: scrollLeftChanged,
                heightChanged: heightChanged,
                scrollHeightChanged: scrollHeightChanged,
                scrollTopChanged: scrollTopChanged,
            });
        };
        return Scrollable;
    }(lifecycle_1.Disposable));
    exports.Scrollable = Scrollable;
});

define(__m[27/*vs/base/common/uri*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/]), function (require, exports, platform) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function _encode(ch) {
        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    }
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
    function encodeURIComponent2(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);
    }
    function encodeNoop(str) {
        return str;
    }
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component paths
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     *
     *
     */
    var URI = (function () {
        function URI() {
            this._scheme = URI._empty;
            this._authority = URI._empty;
            this._path = URI._empty;
            this._query = URI._empty;
            this._fragment = URI._empty;
            this._formatted = null;
            this._fsPath = null;
        }
        URI.isUri = function (thing) {
            if (thing instanceof URI) {
                return true;
            }
            if (!thing) {
                return false;
            }
            return typeof thing.authority === 'string'
                && typeof thing.fragment === 'string'
                && typeof thing.path === 'string'
                && typeof thing.query === 'string'
                && typeof thing.scheme === 'string';
        };
        Object.defineProperty(URI.prototype, "scheme", {
            /**
             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part before the first colon.
             */
            get: function () {
                return this._scheme;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "authority", {
            /**
             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part between the first double slashes and the next slash.
             */
            get: function () {
                return this._authority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "path", {
            /**
             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "query", {
            /**
             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._query;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fragment", {
            /**
             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._fragment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths and normalize windows drive letters to lower-case. Also
             * uses the platform specific path separator. Will *not* validate the path for
             * invalid characters and semantics. Will *not* look at the scheme of this URI.
             */
            get: function () {
                if (!this._fsPath) {
                    var value;
                    if (this._authority && this._path && this.scheme === 'file') {
                        // unc path: file://shares/c$/far/boo
                        value = "//" + this._authority + this._path;
                    }
                    else if (URI._driveLetterPath.test(this._path)) {
                        // windows drive letter: file:///c:/far/boo
                        value = this._path[1].toLowerCase() + this._path.substr(2);
                    }
                    else {
                        // other path
                        value = this._path;
                    }
                    if (platform.isWindows) {
                        value = value.replace(/\//g, '\\');
                    }
                    this._fsPath = value;
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
            if (scheme === void 0) {
                scheme = this.scheme;
            }
            else if (scheme === null) {
                scheme = '';
            }
            if (authority === void 0) {
                authority = this.authority;
            }
            else if (authority === null) {
                authority = '';
            }
            if (path === void 0) {
                path = this.path;
            }
            else if (path === null) {
                path = '';
            }
            if (query === void 0) {
                query = this.query;
            }
            else if (query === null) {
                query = '';
            }
            if (fragment === void 0) {
                fragment = this.fragment;
            }
            else if (fragment === null) {
                fragment = '';
            }
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            var ret = new URI();
            ret._scheme = scheme;
            ret._authority = authority;
            ret._path = path;
            ret._query = query;
            ret._fragment = fragment;
            URI._validate(ret);
            return ret;
        };
        // ---- parse & validate ------------------------
        URI.parse = function (value) {
            var ret = new URI();
            var data = URI._parseComponents(value);
            ret._scheme = data.scheme;
            ret._authority = decodeURIComponent(data.authority);
            ret._path = decodeURIComponent(data.path);
            ret._query = decodeURIComponent(data.query);
            ret._fragment = decodeURIComponent(data.fragment);
            URI._validate(ret);
            return ret;
        };
        URI.file = function (path) {
            var ret = new URI();
            ret._scheme = 'file';
            // normalize to fwd-slashes
            path = path.replace(/\\/g, URI._slash);
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === URI._slash && path[0] === path[1]) {
                var idx = path.indexOf(URI._slash, 2);
                if (idx === -1) {
                    ret._authority = path.substring(2);
                }
                else {
                    ret._authority = path.substring(2, idx);
                    ret._path = path.substring(idx);
                }
            }
            else {
                ret._path = path;
            }
            // Ensure that path starts with a slash
            // or that it is at least a slash
            if (ret._path[0] !== URI._slash) {
                ret._path = URI._slash + ret._path;
            }
            URI._validate(ret);
            return ret;
        };
        URI._parseComponents = function (value) {
            var ret = {
                scheme: URI._empty,
                authority: URI._empty,
                path: URI._empty,
                query: URI._empty,
                fragment: URI._empty,
            };
            var match = URI._regexp.exec(value);
            if (match) {
                ret.scheme = match[2] || ret.scheme;
                ret.authority = match[4] || ret.authority;
                ret.path = match[5] || ret.path;
                ret.query = match[7] || ret.query;
                ret.fragment = match[9] || ret.fragment;
            }
            return ret;
        };
        URI.from = function (components) {
            return new URI().with(components);
        };
        URI._validate = function (ret) {
            // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
            // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
            if (ret.scheme && !URI._schemePattern.test(ret.scheme)) {
                throw new Error('[UriError]: Scheme contains illegal characters.');
            }
            // path, http://tools.ietf.org/html/rfc3986#section-3.3
            // If a URI contains an authority component, then the path component
            // must either be empty or begin with a slash ("/") character.  If a URI
            // does not contain an authority component, then the path cannot begin
            // with two slash characters ("//").
            if (ret.path) {
                if (ret.authority) {
                    if (!URI._singleSlashStart.test(ret.path)) {
                        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                    }
                }
                else {
                    if (URI._doubleSlashStart.test(ret.path)) {
                        throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
                    }
                }
            }
        };
        // ---- printing/externalize ---------------------------
        /**
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = URI._asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return URI._asFormatted(this, true);
            }
        };
        URI._asFormatted = function (uri, skipEncoding) {
            var encoder = !skipEncoding
                ? encodeURIComponent2
                : encodeNoop;
            var parts = [];
            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
            if (scheme) {
                parts.push(scheme, ':');
            }
            if (authority || scheme === 'file') {
                parts.push('//');
            }
            if (authority) {
                authority = authority.toLowerCase();
                var idx = authority.indexOf(':');
                if (idx === -1) {
                    parts.push(encoder(authority));
                }
                else {
                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));
                }
            }
            if (path) {
                // lower-case windows drive letters in /C:/fff or C:/fff
                var m = URI._upperCaseDrive.exec(path);
                if (m) {
                    if (m[1]) {
                        path = '/' + m[2].toLowerCase() + path.substr(3); // "/c:".length === 3
                    }
                    else {
                        path = m[2].toLowerCase() + path.substr(2); // // "c:".length === 2
                    }
                }
                // encode every segement but not slashes
                // make sure that # and ? are always encoded
                // when occurring in paths - otherwise the result
                // cannot be parsed back again
                var lastIdx = 0;
                while (true) {
                    var idx = path.indexOf(URI._slash, lastIdx);
                    if (idx === -1) {
                        parts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));
                        break;
                    }
                    parts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);
                    lastIdx = idx + 1;
                }
                ;
            }
            if (query) {
                parts.push('?', encoder(query));
            }
            if (fragment) {
                parts.push('#', encoder(fragment));
            }
            return parts.join(URI._empty);
        };
        URI.prototype.toJSON = function () {
            var res = {
                fsPath: this.fsPath,
                external: this.toString(),
                $mid: 1
            };
            if (this.path) {
                res.path = this.path;
            }
            if (this.scheme) {
                res.scheme = this.scheme;
            }
            if (this.authority) {
                res.authority = this.authority;
            }
            if (this.query) {
                res.query = this.query;
            }
            if (this.fragment) {
                res.fragment = this.fragment;
            }
            return res;
        };
        URI.revive = function (data) {
            var result = new URI();
            result._scheme = data.scheme || URI._empty;
            result._authority = data.authority || URI._empty;
            result._path = data.path || URI._empty;
            result._query = data.query || URI._empty;
            result._fragment = data.fragment || URI._empty;
            result._fsPath = data.fsPath;
            result._formatted = data.external;
            URI._validate(result);
            return result;
        };
        return URI;
    }());
    URI._empty = '';
    URI._slash = '/';
    URI._regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    URI._driveLetterPath = /^\/[a-zA-z]:/;
    URI._upperCaseDrive = /^(\/)?([A-Z]:)/;
    URI._schemePattern = /^\w[\w\d+.-]*$/;
    URI._singleSlashStart = /^\//;
    URI._doubleSlashStart = /^\/\//;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = URI;
});

define(__m[145/*vs/base/common/marshalling*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/uri*/]), function (require, exports, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        return JSON.parse(text, reviver);
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function reviver(key, value) {
        var marshallingConst;
        if (value !== void 0 && value !== null) {
            marshallingConst = value.$mid;
        }
        if (marshallingConst === 1) {
            return uri_1.default.revive(value);
        }
        else if (marshallingConst === 2) {
            return new RegExp(value.source, value.flags);
        }
        else {
            return value;
        }
    }
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the MIT License.
 */
(function() {

var _modules = {};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

var exported = _modules["WinJS/Core/_WinJS"];

if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base.raw", exported);
} else {
    module.exports = exported;
}

if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
    _modules["WinJS/Core/_BaseCoreUtils"]._setImmediate = function(handler) {
        return process.nextTick(handler);
    };
}

})();
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define(__m[6/*vs/base/common/winjs.base*/], __M([506/*vs/base/common/winjs.base.raw*/,10/*vs/base/common/errors*/]), function (winjs, __Errors__) {
	'use strict';

	var outstandingPromiseErrors = {};
	function promiseErrorHandler(e) {

		//
		// e.detail looks like: { exception, error, promise, handler, id, parent }
		//
		var details = e.detail;
		var id = details.id;

		// If the error has a parent promise then this is not the origination of the
		//  error so we check if it has a handler, and if so we mark that the error
		//  was handled by removing it from outstandingPromiseErrors
		//
		if (details.parent) {
			if (details.handler && outstandingPromiseErrors) {
				delete outstandingPromiseErrors[id];
			}
			return;
		}

		// Indicate that this error was originated and needs to be handled
		outstandingPromiseErrors[id] = details;

		// The first time the queue fills up this iteration, schedule a timeout to
		// check if any errors are still unhandled.
		if (Object.keys(outstandingPromiseErrors).length === 1) {
			setTimeout(function () {
				var errors = outstandingPromiseErrors;
				outstandingPromiseErrors = {};
				Object.keys(errors).forEach(function (errorId) {
					var error = errors[errorId];
					if(error.exception) {
						__Errors__.onUnexpectedError(error.exception);
					} else if(error.error) {
						__Errors__.onUnexpectedError(error.error);
					}
					console.log("WARNING: Promise with no error callback:" + error.id);
					console.log(error);
					if(error.exception) {
						console.log(error.exception.stack);
					}
				});
			}, 0);
		}
	}

	winjs.Promise.addEventListener("error", promiseErrorHandler);

	return {
		Promise: winjs.Promise,
		TPromise: winjs.Promise,
		PPromise: winjs.Promise
	};
});





define(__m[50/*vs/base/common/actions*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,25/*vs/base/common/eventEmitter*/,67/*vs/base/common/events*/,12/*vs/base/common/event*/]), function (require, exports, winjs_base_1, eventEmitter_1, Events, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Checks if the provided object is compatible
     * with the IAction interface.
     * @param thing an object
     */
    function isAction(thing) {
        if (!thing) {
            return false;
        }
        else if (thing instanceof Action) {
            return true;
        }
        else if (typeof thing.id !== 'string') {
            return false;
        }
        else if (typeof thing.label !== 'string') {
            return false;
        }
        else if (typeof thing.class !== 'string') {
            return false;
        }
        else if (typeof thing.enabled !== 'boolean') {
            return false;
        }
        else if (typeof thing.checked !== 'boolean') {
            return false;
        }
        else if (typeof thing.run !== 'function') {
            return false;
        }
        else {
            return true;
        }
    }
    exports.isAction = isAction;
    var Action = (function () {
        function Action(id, label, cssClass, enabled, actionCallback) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            this._onDidChange = new event_1.Emitter();
            this._id = id;
            this._label = label;
            this._cssClass = cssClass;
            this._enabled = enabled;
            this._actionCallback = actionCallback;
        }
        Action.prototype.dispose = function () {
            this._onDidChange.dispose();
        };
        Object.defineProperty(Action.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (value) {
                this._setLabel(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setLabel = function (value) {
            if (this._label !== value) {
                this._label = value;
                this._onDidChange.fire({ label: value });
            }
        };
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._setTooltip(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setTooltip = function (value) {
            if (this._tooltip !== value) {
                this._tooltip = value;
                this._onDidChange.fire({ tooltip: value });
            }
        };
        Object.defineProperty(Action.prototype, "class", {
            get: function () {
                return this._cssClass;
            },
            set: function (value) {
                this._setClass(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setClass = function (value) {
            if (this._cssClass !== value) {
                this._cssClass = value;
                this._onDidChange.fire({ class: value });
            }
        };
        Object.defineProperty(Action.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setEnabled = function (value) {
            if (this._enabled !== value) {
                this._enabled = value;
                this._onDidChange.fire({ enabled: value });
            }
        };
        Object.defineProperty(Action.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (value) {
                this._setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "radio", {
            get: function () {
                return this._radio;
            },
            set: function (value) {
                this._setRadio(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setChecked = function (value) {
            if (this._checked !== value) {
                this._checked = value;
                this._onDidChange.fire({ checked: value });
            }
        };
        Action.prototype._setRadio = function (value) {
            if (this._radio !== value) {
                this._radio = value;
                this._onDidChange.fire({ radio: value });
            }
        };
        Object.defineProperty(Action.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.run = function (event) {
            if (this._actionCallback !== void 0) {
                return this._actionCallback(event);
            }
            return winjs_base_1.TPromise.as(true);
        };
        return Action;
    }());
    exports.Action = Action;
    var ActionRunner = (function (_super) {
        __extends(ActionRunner, _super);
        function ActionRunner() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ActionRunner.prototype.run = function (action, context) {
            var _this = this;
            if (!action.enabled) {
                return winjs_base_1.TPromise.as(null);
            }
            this.emit(Events.EventType.BEFORE_RUN, { action: action });
            return winjs_base_1.TPromise.as(action.run(context)).then(function (result) {
                _this.emit(Events.EventType.RUN, { action: action, result: result });
            }, function (error) {
                _this.emit(Events.EventType.RUN, { action: action, error: error });
            });
        };
        return ActionRunner;
    }(eventEmitter_1.EventEmitter));
    exports.ActionRunner = ActionRunner;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[17/*vs/base/common/async*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,19/*vs/base/common/platform*/,6/*vs/base/common/winjs.base*/,138/*vs/base/common/cancellation*/,3/*vs/base/common/lifecycle*/,12/*vs/base/common/event*/]), function (require, exports, errors, platform, winjs_base_1, cancellation_1, lifecycle_1, event_1) {
    'use strict';
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    function toThenable(arg) {
        if (isThenable(arg)) {
            return arg;
        }
        else {
            return winjs_base_1.TPromise.as(arg);
        }
    }
    exports.toThenable = toThenable;
    function asWinJsPromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        return new winjs_base_1.TPromise(function (resolve, reject, progress) {
            var item = callback(source.token);
            if (item instanceof winjs_base_1.TPromise) {
                item.then(resolve, reject, progress);
            }
            else if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        }, function () {
            source.cancel();
        });
    }
    exports.asWinJsPromise = asWinJsPromise;
    /**
     * Hook a cancellation token to a WinJS Promise
     */
    function wireCancellationToken(token, promise, resolveAsUndefinedWhenCancelled) {
        var subscription = token.onCancellationRequested(function () { return promise.cancel(); });
        if (resolveAsUndefinedWhenCancelled) {
            promise = promise.then(undefined, function (err) {
                if (!errors.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
        }
        return always(promise, function () { return subscription.dispose(); });
    }
    exports.wireCancellationToken = wireCancellationToken;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		const throttler = new Throttler();
     * 		const letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.Promise(function (c, e, p) {
                        _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                    }, function () {
                        _this.activePromise.cancel();
                    });
                }
                return new winjs_base_1.Promise(function (c, e, p) {
                    _this.queuedPromise.then(c, e, p);
                }, function () {
                    // no-op
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.activePromise.done(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                }, p);
            }, function () {
                _this.activePromise.cancel();
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.as(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so the he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		const delayer = new Delayer(WAITING_PERIOD);
     * 		const letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.onSuccess = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.Promise(function (c) {
                    _this.onSuccess = c;
                }, function () {
                    // no-op
                }).then(function () {
                    _this.completionPromise = null;
                    _this.onSuccess = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.onSuccess(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.completionPromise.cancel();
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail man strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            var _this = _super.call(this, defaultDelay) || this;
            _this.throttler = new Throttler();
            return _this;
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * Similar to the ThrottledDelayer, except it also guarantees that the promise
     * factory doesn't get called more often than every `minimumPeriod` milliseconds.
     */
    var PeriodThrottledDelayer = (function (_super) {
        __extends(PeriodThrottledDelayer, _super);
        function PeriodThrottledDelayer(defaultDelay, minimumPeriod) {
            if (minimumPeriod === void 0) { minimumPeriod = 0; }
            var _this = _super.call(this, defaultDelay) || this;
            _this.minimumPeriod = minimumPeriod;
            _this.periodThrottler = new Throttler();
            return _this;
        }
        PeriodThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () {
                return _this.periodThrottler.queue(function () {
                    return winjs_base_1.Promise.join([
                        winjs_base_1.TPromise.timeout(_this.minimumPeriod),
                        promiseFactory()
                    ]).then(function (r) { return r[1]; });
                });
            }, delay);
        };
        return PeriodThrottledDelayer;
    }(ThrottledDelayer));
    exports.PeriodThrottledDelayer = PeriodThrottledDelayer;
    var PromiseSource = (function () {
        function PromiseSource() {
            var _this = this;
            this._value = new winjs_base_1.TPromise(function (c, e) {
                _this._completeCallback = c;
                _this._errorCallback = e;
            });
        }
        Object.defineProperty(PromiseSource.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        PromiseSource.prototype.complete = function (value) {
            this._completeCallback(value);
        };
        PromiseSource.prototype.error = function (err) {
            this._errorCallback(err);
        };
        return PromiseSource;
    }());
    exports.PromiseSource = PromiseSource;
    var ShallowCancelThenPromise = (function (_super) {
        __extends(ShallowCancelThenPromise, _super);
        function ShallowCancelThenPromise(outer) {
            var _this = this;
            var completeCallback, errorCallback, progressCallback;
            _this = _super.call(this, function (c, e, p) {
                completeCallback = c;
                errorCallback = e;
                progressCallback = p;
            }, function () {
                // cancel this promise but not the
                // outer promise
                errorCallback(errors.canceled());
            }) || this;
            outer.then(completeCallback, errorCallback, progressCallback);
            return _this;
        }
        return ShallowCancelThenPromise;
    }(winjs_base_1.TPromise));
    exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
    /**
     * Returns a new promise that joins the provided promise. Upon completion of
     * the provided promise the provided function will always be called. This
     * method is comparable to a try-finally code block.
     * @param promise a promise
     * @param f a function that will be call in the success and error case.
     */
    function always(promise, f) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            promise.done(function (result) {
                try {
                    f(result);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                c(result);
            }, function (err) {
                try {
                    f(err);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                e(err);
            }, function (progress) {
                p(progress);
            });
        }, function () {
            promise.cancel();
        });
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactories) {
        var results = [];
        // reverse since we start with last element using pop()
        promiseFactories = promiseFactories.reverse();
        function next() {
            if (promiseFactories.length) {
                return promiseFactories.pop()();
            }
            return null;
        }
        function thenHandler(result) {
            if (result !== undefined && result !== null) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function first(promiseFactories, shouldStop) {
        if (shouldStop === void 0) { shouldStop = function (t) { return !!t; }; }
        promiseFactories = promiseFactories.reverse().slice();
        var loop = function () {
            if (promiseFactories.length === 0) {
                return winjs_base_1.TPromise.as(null);
            }
            var factory = promiseFactories.pop();
            var promise = factory();
            return promise.then(function (result) {
                if (shouldStop(result)) {
                    return winjs_base_1.TPromise.as(result);
                }
                return loop();
            });
        };
        return loop();
    }
    exports.first = first;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
            this._onFinished = new event_1.Emitter();
        }
        Object.defineProperty(Limiter.prototype, "onFinished", {
            get: function () {
                return this._onFinished.event;
            },
            enumerable: true,
            configurable: true
        });
        Limiter.prototype.queue = function (promiseFactory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.outstandingPromises.push({
                    factory: promiseFactory,
                    c: c,
                    e: e,
                    p: p
                });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
                promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            if (this.outstandingPromises.length > 0) {
                this.consume();
            }
            else {
                this._onFinished.fire();
            }
        };
        Limiter.prototype.dispose = function () {
            this._onFinished.dispose();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    /**
     * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.
     */
    var Queue = (function (_super) {
        __extends(Queue, _super);
        function Queue() {
            return _super.call(this, 1) || this;
        }
        return Queue;
    }(Limiter));
    exports.Queue = Queue;
    var TimeoutTimer = (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            var _this = _super.call(this) || this;
            _this._token = -1;
            return _this;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = platform.setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                platform.clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Replace runner. If there is a runner already scheduled, the new runner will be called.
         */
        RunOnceScheduler.prototype.setRunner = function (runner) {
            this.runner = runner;
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = platform.setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.runner();
            }
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.ninvoke = ninvoke;
});






define(__m[11/*vs/base/browser/dom*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,24/*vs/base/common/types*/,23/*vs/base/browser/browser*/,51/*vs/base/browser/keyboardEvent*/,34/*vs/base/browser/mouseEvent*/]), function (require, exports, winjs_base_1, async_1, errors_1, eventEmitter_1, lifecycle_1, types_1, browser_1, keyboardEvent_1, mouseEvent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function clearNode(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }
    exports.clearNode = clearNode;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringifyDOMAware(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            // HTML elements are never going to serialize nicely
            if (value instanceof Element) {
                return '[Element]';
            }
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringifyDOMAware = safeStringifyDOMAware;
    function isInDOM(node) {
        while (node) {
            if (node === document.body) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    exports.isInDOM = isInDOM;
    var lastStart, lastEnd;
    function _findClassName(node, className) {
        var classes = node.className;
        if (!classes) {
            lastStart = -1;
            return;
        }
        className = className.trim();
        var classesLen = classes.length, classLen = className.length;
        if (classLen === 0) {
            lastStart = -1;
            return;
        }
        if (classesLen < classLen) {
            lastStart = -1;
            return;
        }
        if (classes === className) {
            lastStart = 0;
            lastEnd = classesLen;
            return;
        }
        var idx = -1, idxEnd;
        while ((idx = classes.indexOf(className, idx + 1)) >= 0) {
            idxEnd = idx + classLen;
            // a class that is followed by another class
            if ((idx === 0 || classes.charCodeAt(idx - 1) === 32 /* Space */) && classes.charCodeAt(idxEnd) === 32 /* Space */) {
                lastStart = idx;
                lastEnd = idxEnd + 1;
                return;
            }
            // last class
            if (idx > 0 && classes.charCodeAt(idx - 1) === 32 /* Space */ && idxEnd === classesLen) {
                lastStart = idx - 1;
                lastEnd = idxEnd;
                return;
            }
            // equal - duplicate of cmp above
            if (idx === 0 && idxEnd === classesLen) {
                lastStart = 0;
                lastEnd = idxEnd;
                return;
            }
        }
        lastStart = -1;
    }
    /**
     * @param node a dom node
     * @param className a class name
     * @return true if the className attribute of the provided node contains the provided className
     */
    function hasClass(node, className) {
        _findClassName(node, className);
        return lastStart !== -1;
    }
    exports.hasClass = hasClass;
    /**
     * Adds the provided className to the provided node. This is a no-op
     * if the class is already set.
     * @param node a dom node
     * @param className a class name
     */
    function addClass(node, className) {
        if (!node.className) {
            node.className = className;
        }
        else {
            _findClassName(node, className); // see if it's already there
            if (lastStart === -1) {
                node.className = node.className + ' ' + className;
            }
        }
    }
    exports.addClass = addClass;
    /**
     * Removes the className for the provided node. This is a no-op
     * if the class isn't present.
     * @param node a dom node
     * @param className a class name
     */
    function removeClass(node, className) {
        _findClassName(node, className);
        if (lastStart === -1) {
            return; // Prevent styles invalidation if not necessary
        }
        else {
            node.className = node.className.substring(0, lastStart) + node.className.substring(lastEnd);
        }
    }
    exports.removeClass = removeClass;
    /**
     * @param node a dom node
     * @param className a class name
     * @param shouldHaveIt
     */
    function toggleClass(node, className, shouldHaveIt) {
        _findClassName(node, className);
        if (lastStart !== -1 && (shouldHaveIt === void 0 || !shouldHaveIt)) {
            removeClass(node, className);
        }
        if (lastStart === -1 && (shouldHaveIt === void 0 || shouldHaveIt)) {
            addClass(node, className);
        }
    }
    exports.toggleClass = toggleClass;
    var DomListener = (function () {
        function DomListener(node, type, handler, useCapture) {
            this._node = node;
            this._type = type;
            this._handler = handler;
            this._useCapture = (useCapture || false);
            this._node.addEventListener(this._type, this._handler, this._useCapture);
        }
        DomListener.prototype.dispose = function () {
            if (!this._handler) {
                // Already disposed
                return;
            }
            this._node.removeEventListener(this._type, this._handler, this._useCapture);
            // Prevent leakers from holding on to the dom or handler func
            this._node = null;
            this._handler = null;
        };
        return DomListener;
    }());
    function addDisposableListener(node, type, handler, useCapture) {
        return new DomListener(node, type, handler, useCapture);
    }
    exports.addDisposableListener = addDisposableListener;
    function _wrapAsStandardMouseEvent(handler) {
        return function (e) {
            return handler(new mouseEvent_1.StandardMouseEvent(e));
        };
    }
    function _wrapAsStandardKeyboardEvent(handler) {
        return function (e) {
            return handler(new keyboardEvent_1.StandardKeyboardEvent(e));
        };
    }
    exports.addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {
        var wrapHandler = handler;
        if (type === 'click') {
            wrapHandler = _wrapAsStandardMouseEvent(handler);
        }
        else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {
            wrapHandler = _wrapAsStandardKeyboardEvent(handler);
        }
        return addDisposableListener(node, type, wrapHandler, useCapture);
    };
    function addDisposableNonBubblingMouseOutListener(node, handler) {
        return addDisposableListener(node, 'mouseout', function (e) {
            // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements
            var toElement = (e.relatedTarget || e.toElement);
            while (toElement && toElement !== node) {
                toElement = toElement.parentNode;
            }
            if (toElement === node) {
                return;
            }
            handler(e);
        });
    }
    exports.addDisposableNonBubblingMouseOutListener = addDisposableNonBubblingMouseOutListener;
    var _animationFrame = (function () {
        var emulatedRequestAnimationFrame = function (callback) {
            return setTimeout(function () { return callback(new Date().getTime()); }, 0);
        };
        var nativeRequestAnimationFrame = self.requestAnimationFrame
            || self.msRequestAnimationFrame
            || self.webkitRequestAnimationFrame
            || self.mozRequestAnimationFrame
            || self.oRequestAnimationFrame;
        var emulatedCancelAnimationFrame = function (id) { };
        var nativeCancelAnimationFrame = self.cancelAnimationFrame || self.cancelRequestAnimationFrame
            || self.msCancelAnimationFrame || self.msCancelRequestAnimationFrame
            || self.webkitCancelAnimationFrame || self.webkitCancelRequestAnimationFrame
            || self.mozCancelAnimationFrame || self.mozCancelRequestAnimationFrame
            || self.oCancelAnimationFrame || self.oCancelRequestAnimationFrame;
        var isNative = !!nativeRequestAnimationFrame;
        var request = nativeRequestAnimationFrame || emulatedRequestAnimationFrame;
        var cancel = nativeCancelAnimationFrame || emulatedCancelAnimationFrame;
        return {
            isNative: isNative,
            request: function (callback) {
                return request(callback);
            },
            cancel: function (id) {
                return cancel(id);
            }
        };
    })();
    var AnimationFrameQueueItem = (function () {
        function AnimationFrameQueueItem(runner, priority) {
            this._runner = runner;
            this.priority = priority;
            this._canceled = false;
        }
        AnimationFrameQueueItem.prototype.dispose = function () {
            this._canceled = true;
        };
        AnimationFrameQueueItem.prototype.execute = function () {
            if (this._canceled) {
                return;
            }
            try {
                this._runner();
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
        };
        // Sort by priority (largest to lowest)
        AnimationFrameQueueItem.sort = function (a, b) {
            return b.priority - a.priority;
        };
        return AnimationFrameQueueItem;
    }());
    (function () {
        /**
         * The runners scheduled at the next animation frame
         */
        var NEXT_QUEUE = [];
        /**
         * The runners scheduled at the current animation frame
         */
        var CURRENT_QUEUE = null;
        /**
         * A flag to keep track if the native requestAnimationFrame was already called
         */
        var animFrameRequested = false;
        /**
         * A flag to indicate if currently handling a native requestAnimationFrame callback
         */
        var inAnimationFrameRunner = false;
        var animationFrameRunner = function () {
            animFrameRequested = false;
            CURRENT_QUEUE = NEXT_QUEUE;
            NEXT_QUEUE = [];
            inAnimationFrameRunner = true;
            while (CURRENT_QUEUE.length > 0) {
                CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
                var top_1 = CURRENT_QUEUE.shift();
                top_1.execute();
            }
            inAnimationFrameRunner = false;
        };
        exports.scheduleAtNextAnimationFrame = function (runner, priority) {
            if (priority === void 0) { priority = 0; }
            var item = new AnimationFrameQueueItem(runner, priority);
            NEXT_QUEUE.push(item);
            if (!animFrameRequested) {
                animFrameRequested = true;
                // TODO@Alex: also check if it is electron
                if (browser_1.isChrome) {
                    var handle_1;
                    _animationFrame.request(function () {
                        clearTimeout(handle_1);
                        animationFrameRunner();
                    });
                    // This is a fallback in-case chrome dropped
                    // the request for an animation frame. This
                    // is sick but was spotted in the wild
                    handle_1 = setTimeout(animationFrameRunner, 1000);
                }
                else {
                    _animationFrame.request(animationFrameRunner);
                }
            }
            return item;
        };
        exports.runAtThisOrScheduleAtNextAnimationFrame = function (runner, priority) {
            if (inAnimationFrameRunner) {
                var item = new AnimationFrameQueueItem(runner, priority);
                CURRENT_QUEUE.push(item);
                return item;
            }
            else {
                return exports.scheduleAtNextAnimationFrame(runner, priority);
            }
        };
    })();
    var MINIMUM_TIME_MS = 16;
    var DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
        return currentEvent;
    };
    var TimeoutThrottledDomListener = (function (_super) {
        __extends(TimeoutThrottledDomListener, _super);
        function TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs) {
            if (eventMerger === void 0) { eventMerger = DEFAULT_EVENT_MERGER; }
            if (minimumTimeMs === void 0) { minimumTimeMs = MINIMUM_TIME_MS; }
            var _this = _super.call(this) || this;
            var lastEvent = null;
            var lastHandlerTime = 0;
            var timeout = _this._register(new async_1.TimeoutTimer());
            var invokeHandler = function () {
                lastHandlerTime = (new Date()).getTime();
                handler(lastEvent);
                lastEvent = null;
            };
            _this._register(addDisposableListener(node, type, function (e) {
                lastEvent = eventMerger(lastEvent, e);
                var elapsedTime = (new Date()).getTime() - lastHandlerTime;
                if (elapsedTime >= minimumTimeMs) {
                    timeout.cancel();
                    invokeHandler();
                }
                else {
                    timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
                }
            }));
            return _this;
        }
        return TimeoutThrottledDomListener;
    }(lifecycle_1.Disposable));
    function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
        return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
    }
    exports.addDisposableThrottledListener = addDisposableThrottledListener;
    function getComputedStyle(el) {
        return document.defaultView.getComputedStyle(el, null);
    }
    exports.getComputedStyle = getComputedStyle;
    // Adapted from WinJS
    // Converts a CSS positioning string for the specified element to pixels.
    var convertToPixels = (function () {
        return function (element, value) {
            return parseFloat(value) || 0;
        };
    })();
    function getDimension(element, cssPropertyName, jsPropertyName) {
        var computedStyle = getComputedStyle(element);
        var value = '0';
        if (computedStyle) {
            if (computedStyle.getPropertyValue) {
                value = computedStyle.getPropertyValue(cssPropertyName);
            }
            else {
                // IE8
                value = computedStyle.getAttribute(jsPropertyName);
            }
        }
        return convertToPixels(element, value);
    }
    var sizeUtils = {
        getBorderLeftWidth: function (element) {
            return getDimension(element, 'border-left-width', 'borderLeftWidth');
        },
        getBorderTopWidth: function (element) {
            return getDimension(element, 'border-top-width', 'borderTopWidth');
        },
        getBorderRightWidth: function (element) {
            return getDimension(element, 'border-right-width', 'borderRightWidth');
        },
        getBorderBottomWidth: function (element) {
            return getDimension(element, 'border-bottom-width', 'borderBottomWidth');
        },
        getPaddingLeft: function (element) {
            return getDimension(element, 'padding-left', 'paddingLeft');
        },
        getPaddingTop: function (element) {
            return getDimension(element, 'padding-top', 'paddingTop');
        },
        getPaddingRight: function (element) {
            return getDimension(element, 'padding-right', 'paddingRight');
        },
        getPaddingBottom: function (element) {
            return getDimension(element, 'padding-bottom', 'paddingBottom');
        },
        getMarginLeft: function (element) {
            return getDimension(element, 'margin-left', 'marginLeft');
        },
        getMarginTop: function (element) {
            return getDimension(element, 'margin-top', 'marginTop');
        },
        getMarginRight: function (element) {
            return getDimension(element, 'margin-right', 'marginRight');
        },
        getMarginBottom: function (element) {
            return getDimension(element, 'margin-bottom', 'marginBottom');
        },
        __commaSentinel: false
    };
    // ----------------------------------------------------------------------------------------
    // Position & Dimension
    function getTopLeftOffset(element) {
        // Adapted from WinJS.Utilities.getPosition
        // and added borders to the mix
        var offsetParent = element.offsetParent, top = element.offsetTop, left = element.offsetLeft;
        while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
            top -= element.scrollTop;
            var c = getComputedStyle(element);
            if (c) {
                left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;
            }
            if (element === offsetParent) {
                left += sizeUtils.getBorderLeftWidth(element);
                top += sizeUtils.getBorderTopWidth(element);
                top += element.offsetTop;
                left += element.offsetLeft;
                offsetParent = element.offsetParent;
            }
        }
        return {
            left: left,
            top: top
        };
    }
    exports.getTopLeftOffset = getTopLeftOffset;
    /**
     * Returns the position of a dom node relative to the entire page.
     */
    function getDomNodePagePosition(domNode) {
        var bb = domNode.getBoundingClientRect();
        return {
            left: bb.left + exports.StandardWindow.scrollX,
            top: bb.top + exports.StandardWindow.scrollY,
            width: bb.width,
            height: bb.height
        };
    }
    exports.getDomNodePagePosition = getDomNodePagePosition;
    exports.StandardWindow = new (function () {
        function class_1() {
        }
        Object.defineProperty(class_1.prototype, "scrollX", {
            get: function () {
                if (typeof window.scrollX === 'number') {
                    // modern browsers
                    return window.scrollX;
                }
                else {
                    return document.body.scrollLeft + document.documentElement.scrollLeft;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "scrollY", {
            get: function () {
                if (typeof window.scrollY === 'number') {
                    // modern browsers
                    return window.scrollY;
                }
                else {
                    return document.body.scrollTop + document.documentElement.scrollTop;
                }
            },
            enumerable: true,
            configurable: true
        });
        return class_1;
    }());
    // Adapted from WinJS
    // Gets the width of the content of the specified element. The content width does not include borders or padding.
    function getContentWidth(element) {
        var border = sizeUtils.getBorderLeftWidth(element) + sizeUtils.getBorderRightWidth(element);
        var padding = sizeUtils.getPaddingLeft(element) + sizeUtils.getPaddingRight(element);
        return element.offsetWidth - border - padding;
    }
    exports.getContentWidth = getContentWidth;
    // Adapted from WinJS
    // Gets the width of the element, including margins.
    function getTotalWidth(element) {
        var margin = sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);
        return element.offsetWidth + margin;
    }
    exports.getTotalWidth = getTotalWidth;
    function getTotalScrollWidth(element) {
        var margin = sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);
        return element.scrollWidth + margin;
    }
    exports.getTotalScrollWidth = getTotalScrollWidth;
    // Adapted from WinJS
    // Gets the height of the content of the specified element. The content height does not include borders or padding.
    function getContentHeight(element) {
        var border = sizeUtils.getBorderTopWidth(element) + sizeUtils.getBorderBottomWidth(element);
        var padding = sizeUtils.getPaddingTop(element) + sizeUtils.getPaddingBottom(element);
        return element.offsetHeight - border - padding;
    }
    exports.getContentHeight = getContentHeight;
    // Adapted from WinJS
    // Gets the height of the element, including its margins.
    function getTotalHeight(element) {
        var margin = sizeUtils.getMarginTop(element) + sizeUtils.getMarginBottom(element);
        return element.offsetHeight + margin;
    }
    exports.getTotalHeight = getTotalHeight;
    // Gets the left coordinate of the specified element relative to the specified parent.
    function getRelativeLeft(element, parent) {
        if (element === null) {
            return 0;
        }
        var elementPosition = getTopLeftOffset(element);
        var parentPosition = getTopLeftOffset(parent);
        return elementPosition.left - parentPosition.left;
    }
    function getLargestChildWidth(parent, children) {
        var childWidths = children.map(function (child) {
            return Math.max(getTotalScrollWidth(child), getTotalWidth(child)) + getRelativeLeft(child, parent) || 0;
        });
        var maxWidth = Math.max.apply(Math, childWidths);
        return maxWidth;
    }
    exports.getLargestChildWidth = getLargestChildWidth;
    // ----------------------------------------------------------------------------------------
    function isAncestor(testChild, testAncestor) {
        while (testChild) {
            if (testChild === testAncestor) {
                return true;
            }
            testChild = testChild.parentNode;
        }
        return false;
    }
    exports.isAncestor = isAncestor;
    function findParentWithClass(node, clazz, stopAtClazz) {
        while (node) {
            if (hasClass(node, clazz)) {
                return node;
            }
            if (stopAtClazz && hasClass(node, stopAtClazz)) {
                return null;
            }
            node = node.parentNode;
        }
        return null;
    }
    exports.findParentWithClass = findParentWithClass;
    function createStyleSheet() {
        var style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        document.getElementsByTagName('head')[0].appendChild(style);
        return style;
    }
    exports.createStyleSheet = createStyleSheet;
    var sharedStyle = createStyleSheet();
    function getDynamicStyleSheetRules(style) {
        if (style && style.sheet && style.sheet.rules) {
            // Chrome, IE
            return style.sheet.rules;
        }
        if (style && style.sheet && style.sheet.cssRules) {
            // FF
            return style.sheet.cssRules;
        }
        return [];
    }
    function createCSSRule(selector, cssText, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style || !cssText) {
            return;
        }
        style.sheet.insertRule(selector + '{' + cssText + '}', 0);
    }
    exports.createCSSRule = createCSSRule;
    function getCSSRule(selector, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style) {
            return null;
        }
        var rules = getDynamicStyleSheetRules(style);
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var normalizedSelectorText = rule.selectorText.replace(/::/gi, ':');
            if (normalizedSelectorText === selector) {
                return rule;
            }
        }
        return null;
    }
    exports.getCSSRule = getCSSRule;
    function removeCSSRulesContainingSelector(ruleName, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style) {
            return;
        }
        var rules = getDynamicStyleSheetRules(style);
        var toDelete = [];
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var normalizedSelectorText = rule.selectorText.replace(/::/gi, ':');
            if (normalizedSelectorText.indexOf(ruleName) !== -1) {
                toDelete.push(i);
            }
        }
        for (var i = toDelete.length - 1; i >= 0; i--) {
            style.sheet.deleteRule(toDelete[i]);
        }
    }
    exports.removeCSSRulesContainingSelector = removeCSSRulesContainingSelector;
    function isHTMLElement(o) {
        if (typeof HTMLElement === 'object') {
            return o instanceof HTMLElement;
        }
        return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
    }
    exports.isHTMLElement = isHTMLElement;
    exports.EventType = {
        // Mouse
        CLICK: 'click',
        DBLCLICK: 'dblclick',
        MOUSE_UP: 'mouseup',
        MOUSE_DOWN: 'mousedown',
        MOUSE_OVER: 'mouseover',
        MOUSE_MOVE: 'mousemove',
        MOUSE_OUT: 'mouseout',
        CONTEXT_MENU: 'contextmenu',
        WHEEL: 'wheel',
        // Keyboard
        KEY_DOWN: 'keydown',
        KEY_PRESS: 'keypress',
        KEY_UP: 'keyup',
        // HTML Document
        LOAD: 'load',
        UNLOAD: 'unload',
        ABORT: 'abort',
        ERROR: 'error',
        RESIZE: 'resize',
        SCROLL: 'scroll',
        // Form
        SELECT: 'select',
        CHANGE: 'change',
        SUBMIT: 'submit',
        RESET: 'reset',
        FOCUS: 'focus',
        BLUR: 'blur',
        INPUT: 'input',
        // Local Storage
        STORAGE: 'storage',
        // Drag
        DRAG_START: 'dragstart',
        DRAG: 'drag',
        DRAG_ENTER: 'dragenter',
        DRAG_LEAVE: 'dragleave',
        DRAG_OVER: 'dragover',
        DROP: 'drop',
        DRAG_END: 'dragend',
        // Animation
        ANIMATION_START: browser_1.isWebKit ? 'webkitAnimationStart' : 'animationstart',
        ANIMATION_END: browser_1.isWebKit ? 'webkitAnimationEnd' : 'animationend',
        ANIMATION_ITERATION: browser_1.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
    };
    exports.EventHelper = {
        stop: function (e, cancelBubble) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                // IE8
                e.returnValue = false;
            }
            if (cancelBubble) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                else {
                    // IE8
                    e.cancelBubble = true;
                }
            }
        }
    };
    function saveParentsScrollTop(node) {
        var r = [];
        for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
            r[i] = node.scrollTop;
            node = node.parentNode;
        }
        return r;
    }
    exports.saveParentsScrollTop = saveParentsScrollTop;
    function restoreParentsScrollTop(node, state) {
        for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
            if (node.scrollTop !== state[i]) {
                node.scrollTop = state[i];
            }
            node = node.parentNode;
        }
    }
    exports.restoreParentsScrollTop = restoreParentsScrollTop;
    var FocusTracker = (function (_super) {
        __extends(FocusTracker, _super);
        function FocusTracker(element) {
            var _this = _super.call(this) || this;
            var hasFocus = false;
            var loosingFocus = false;
            _this._eventEmitter = _this._register(new eventEmitter_1.EventEmitter());
            var onFocus = function (event) {
                loosingFocus = false;
                if (!hasFocus) {
                    hasFocus = true;
                    _this._eventEmitter.emit('focus', {});
                }
            };
            var onBlur = function (event) {
                if (hasFocus) {
                    loosingFocus = true;
                    window.setTimeout(function () {
                        if (loosingFocus) {
                            loosingFocus = false;
                            hasFocus = false;
                            _this._eventEmitter.emit('blur', {});
                        }
                    }, 0);
                }
            };
            _this._register(addDisposableListener(element, exports.EventType.FOCUS, onFocus, true));
            _this._register(addDisposableListener(element, exports.EventType.BLUR, onBlur, true));
            return _this;
        }
        FocusTracker.prototype.addFocusListener = function (fn) {
            return this._eventEmitter.addListener2('focus', fn);
        };
        FocusTracker.prototype.addBlurListener = function (fn) {
            return this._eventEmitter.addListener2('blur', fn);
        };
        return FocusTracker;
    }(lifecycle_1.Disposable));
    function trackFocus(element) {
        return new FocusTracker(element);
    }
    exports.trackFocus = trackFocus;
    function append(parent) {
        var children = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            children[_i - 1] = arguments[_i];
        }
        children.forEach(function (child) { return parent.appendChild(child); });
        return children[children.length - 1];
    }
    exports.append = append;
    function prepend(parent, child) {
        parent.insertBefore(child, parent.firstChild);
        return child;
    }
    exports.prepend = prepend;
    var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
    // Similar to builder, but much more lightweight
    function $(description, attrs) {
        var children = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            children[_i - 2] = arguments[_i];
        }
        var match = SELECTOR_REGEX.exec(description);
        if (!match) {
            throw new Error('Bad use of emmet');
        }
        var result = document.createElement(match[1] || 'div');
        if (match[3]) {
            result.id = match[3];
        }
        if (match[4]) {
            result.className = match[4].replace(/\./g, ' ').trim();
        }
        Object.keys(attrs || {}).forEach(function (name) {
            if (/^on\w+$/.test(name)) {
                result[name] = attrs[name];
            }
            else if (name === 'selected') {
                var value = attrs[name];
                if (value) {
                    result.setAttribute(name, 'true');
                }
            }
            else {
                result.setAttribute(name, attrs[name]);
            }
        });
        children
            .filter(function (child) { return !!child; })
            .forEach(function (child) {
            if (child instanceof Node) {
                result.appendChild(child);
            }
            else {
                result.appendChild(document.createTextNode(child));
            }
        });
        return result;
    }
    exports.$ = $;
    function join(nodes, separator) {
        var result = [];
        nodes.forEach(function (node, index) {
            if (index > 0) {
                if (separator instanceof Node) {
                    result.push(separator.cloneNode());
                }
                else {
                    result.push(document.createTextNode(separator));
                }
            }
            result.push(node);
        });
        return result;
    }
    exports.join = join;
    function show() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {
            var element = elements_1[_a];
            element.style.display = '';
        }
    }
    exports.show = show;
    function hide() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i] = arguments[_i];
        }
        for (var _a = 0, elements_2 = elements; _a < elements_2.length; _a++) {
            var element = elements_2[_a];
            element.style.display = 'none';
        }
    }
    exports.hide = hide;
    function findParentWithAttribute(node, attribute) {
        while (node) {
            if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    }
    function removeTabIndexAndUpdateFocus(node) {
        if (!node || !node.hasAttribute('tabIndex')) {
            return;
        }
        // If we are the currently focused element and tabIndex is removed,
        // standard DOM behavior is to move focus to the <body> element. We
        // typically never want that, rather put focus to the closest element
        // in the hierarchy of the parent DOM nodes.
        if (document.activeElement === node) {
            var parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
            if (parentFocusable) {
                parentFocusable.focus();
            }
        }
        node.removeAttribute('tabindex');
    }
    exports.removeTabIndexAndUpdateFocus = removeTabIndexAndUpdateFocus;
    function getElementsByTagName(tag) {
        return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function finalHandler(fn) {
        return function (e) {
            e.preventDefault();
            e.stopPropagation();
            fn(e);
        };
    }
    exports.finalHandler = finalHandler;
    function domContentLoaded() {
        return new winjs_base_1.TPromise(function (c, e) {
            var readyState = document.readyState;
            if (readyState === 'complete' || (document && document.body !== null)) {
                window.setImmediate(c);
            }
            else {
                window.addEventListener('DOMContentLoaded', c, false);
            }
        });
    }
    exports.domContentLoaded = domContentLoaded;
});






define(__m[102/*vs/base/browser/globalMouseMoveMonitor*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/,155/*vs/base/browser/iframe*/,34/*vs/base/browser/mouseEvent*/]), function (require, exports, lifecycle_1, dom, iframe_1, mouseEvent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function standardMouseMoveMerger(lastEvent, currentEvent) {
        var ev = new mouseEvent_1.StandardMouseEvent(currentEvent);
        ev.preventDefault();
        return {
            leftButton: ev.leftButton,
            posx: ev.posx,
            posy: ev.posy
        };
    }
    exports.standardMouseMoveMerger = standardMouseMoveMerger;
    var GlobalMouseMoveMonitor = (function (_super) {
        __extends(GlobalMouseMoveMonitor, _super);
        function GlobalMouseMoveMonitor() {
            var _this = _super.call(this) || this;
            _this.hooks = [];
            _this.mouseMoveEventMerger = null;
            _this.mouseMoveCallback = null;
            _this.onStopCallback = null;
            return _this;
        }
        GlobalMouseMoveMonitor.prototype.dispose = function () {
            this.stopMonitoring(false);
            _super.prototype.dispose.call(this);
        };
        GlobalMouseMoveMonitor.prototype.stopMonitoring = function (invokeStopCallback) {
            if (!this.isMonitoring()) {
                // Not monitoring
                return;
            }
            // Unhook
            this.hooks = lifecycle_1.dispose(this.hooks);
            this.mouseMoveEventMerger = null;
            this.mouseMoveCallback = null;
            var onStopCallback = this.onStopCallback;
            this.onStopCallback = null;
            if (invokeStopCallback) {
                onStopCallback();
            }
        };
        GlobalMouseMoveMonitor.prototype.isMonitoring = function () {
            return this.hooks.length > 0;
        };
        GlobalMouseMoveMonitor.prototype.startMonitoring = function (mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {
            var _this = this;
            if (this.isMonitoring()) {
                // I am already hooked
                return;
            }
            this.mouseMoveEventMerger = mouseMoveEventMerger;
            this.mouseMoveCallback = mouseMoveCallback;
            this.onStopCallback = onStopCallback;
            var windowChain = iframe_1.IframeUtils.getSameOriginWindowChain();
            for (var i = 0; i < windowChain.length; i++) {
                this.hooks.push(dom.addDisposableThrottledListener(windowChain[i].window.document, 'mousemove', function (data) { return _this.mouseMoveCallback(data); }, function (lastEvent, currentEvent) { return _this.mouseMoveEventMerger(lastEvent, currentEvent); }));
                this.hooks.push(dom.addDisposableListener(windowChain[i].window.document, 'mouseup', function (e) { return _this.stopMonitoring(true); }));
            }
            if (iframe_1.IframeUtils.hasDifferentOriginAncestor()) {
                var lastSameOriginAncestor = windowChain[windowChain.length - 1];
                // We might miss a mouse up if it happens outside the iframe
                // This one is for Chrome
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseout', function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
                    if (e.target.tagName.toLowerCase() === 'html') {
                        _this.stopMonitoring(true);
                    }
                }));
                // This one is for FF
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseover', function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
                    if (e.target.tagName.toLowerCase() === 'html') {
                        _this.stopMonitoring(true);
                    }
                }));
                // This one is for IE
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document.body, 'mouseleave', function (browserEvent) {
                    _this.stopMonitoring(true);
                }));
            }
        };
        return GlobalMouseMoveMonitor;
    }(lifecycle_1.Disposable));
    exports.GlobalMouseMoveMonitor = GlobalMouseMoveMonitor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[103/*vs/base/browser/htmlContentRenderer*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,113/*vs/base/common/idGenerator*/,9/*vs/base/common/strings*/,6/*vs/base/common/winjs.base*/,109/*vs/base/common/htmlContent*/,244/*vs/base/common/marked/marked*/]), function (require, exports, DOM, idGenerator_1, strings_1, winjs_base_1, htmlContent_1, marked_1) {
    'use strict';
    function renderMarkedString(markedString, options) {
        if (options === void 0) { options = {}; }
        var htmlContentElement = typeof markedString === 'string' ? { markdown: markedString } : { code: markedString };
        return renderHtml(htmlContentElement, options);
    }
    exports.renderMarkedString = renderMarkedString;
    /**
     * Create html nodes for the given content element.
     *
     * @param content a html element description
     * @param actionCallback a callback function for any action links in the string. Argument is the zero-based index of the clicked action.
     */
    function renderHtml(content, options) {
        if (options === void 0) { options = {}; }
        if (typeof content === 'string') {
            return _renderHtml({ isText: true, text: content }, options);
        }
        else if (Array.isArray(content)) {
            return _renderHtml({ children: content }, options);
        }
        else if (content) {
            return _renderHtml(content, options);
        }
    }
    exports.renderHtml = renderHtml;
    function _renderHtml(content, options) {
        if (options === void 0) { options = {}; }
        var codeBlockRenderer = options.codeBlockRenderer, actionCallback = options.actionCallback;
        if (content.isText) {
            return document.createTextNode(content.text);
        }
        var tagName = getSafeTagName(content.tagName) || 'div';
        var element = document.createElement(tagName);
        if (content.className) {
            element.className = content.className;
        }
        if (content.text) {
            element.textContent = content.text;
        }
        if (content.style) {
            element.setAttribute('style', content.style);
        }
        if (content.customStyle) {
            Object.keys(content.customStyle).forEach(function (key) {
                element.style[key] = content.customStyle[key];
            });
        }
        if (content.children) {
            content.children.forEach(function (child) {
                element.appendChild(renderHtml(child, options));
            });
        }
        if (content.formattedText) {
            renderFormattedText(element, parseFormattedText(content.formattedText), actionCallback);
        }
        if (content.code && codeBlockRenderer) {
            // this is sort of legacy given that we have full
            // support for markdown. Turn this into markdown
            // and continue
            var _a = content.code, language = _a.language, value = _a.value;
            content.markdown = '```' + language + '\n' + value + '\n```';
        }
        if (content.markdown) {
            // signal to code-block render that the
            // element has been created
            var signalInnerHTML_1;
            var withInnerHTML_1 = new winjs_base_1.TPromise(function (c) { return signalInnerHTML_1 = c; });
            var renderer = new marked_1.marked.Renderer();
            renderer.image = function (href, title, text) {
                var dimensions = [];
                if (href) {
                    var splitted = href.split('|').map(function (s) { return s.trim(); });
                    href = splitted[0];
                    var parameters = splitted[1];
                    if (parameters) {
                        var heightFromParams = /height=(\d+)/.exec(parameters);
                        var widthFromParams = /width=(\d+)/.exec(parameters);
                        var height = (heightFromParams && heightFromParams[1]);
                        var width = (widthFromParams && widthFromParams[1]);
                        var widthIsFinite = isFinite(parseInt(width));
                        var heightIsFinite = isFinite(parseInt(height));
                        if (widthIsFinite) {
                            dimensions.push("width=\"" + width + "\"");
                        }
                        if (heightIsFinite) {
                            dimensions.push("height=\"" + height + "\"");
                        }
                    }
                }
                var attributes = [];
                if (href) {
                    attributes.push("src=\"" + href + "\"");
                }
                if (text) {
                    attributes.push("alt=\"" + text + "\"");
                }
                if (title) {
                    attributes.push("title=\"" + title + "\"");
                }
                if (dimensions.length) {
                    attributes = attributes.concat(dimensions);
                }
                return '<img ' + attributes.join(' ') + '>';
            };
            renderer.link = function (href, title, text) {
                // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829
                if (href === text) {
                    text = htmlContent_1.removeMarkdownEscapes(text);
                }
                title = htmlContent_1.removeMarkdownEscapes(title);
                href = htmlContent_1.removeMarkdownEscapes(href);
                return "<a href=\"#\" data-href=\"" + href + "\" title=\"" + (title || text) + "\">" + text + "</a>";
            };
            renderer.paragraph = function (text) {
                return "<p>" + text + "</p>";
            };
            if (options.codeBlockRenderer) {
                renderer.code = function (code, lang) {
                    var value = options.codeBlockRenderer(lang, code);
                    if (typeof value === 'string') {
                        return value;
                    }
                    if (winjs_base_1.TPromise.is(value)) {
                        // when code-block rendering is async we return sync
                        // but update the node with the real result later.
                        var id_1 = idGenerator_1.defaultGenerator.nextId();
                        winjs_base_1.TPromise.join([value, withInnerHTML_1]).done(function (values) {
                            var strValue = values[0];
                            var span = element.querySelector("span[data-code=\"" + id_1 + "\"]");
                            if (span) {
                                span.innerHTML = strValue;
                            }
                        }, function (err) {
                            // ignore
                        });
                        return "<span data-code=\"" + id_1 + "\">" + strings_1.escape(code) + "</span>";
                    }
                    return code;
                };
            }
            if (options.actionCallback) {
                DOM.addStandardDisposableListener(element, 'click', function (event) {
                    if (event.target.tagName === 'A') {
                        var href = event.target.dataset['href'];
                        if (href) {
                            options.actionCallback(href, event);
                        }
                    }
                });
            }
            element.innerHTML = marked_1.marked(content.markdown, {
                sanitize: true,
                renderer: renderer
            });
            signalInnerHTML_1();
        }
        return element;
    }
    var SAFE_TAG_NAMES = {
        a: true,
        b: true,
        blockquote: true,
        code: true,
        del: true,
        dd: true,
        div: true,
        dl: true,
        dt: true,
        em: true,
        h1h2h3i: true,
        img: true,
        kbd: true,
        li: true,
        ol: true,
        p: true,
        pre: true,
        s: true,
        span: true,
        sup: true,
        sub: true,
        strong: true,
        strike: true,
        ul: true,
        br: true,
        hr: true,
    };
    function getSafeTagName(tagName) {
        if (!tagName) {
            return null;
        }
        if (SAFE_TAG_NAMES.hasOwnProperty(tagName)) {
            return tagName;
        }
        return null;
    }
    // --- formatted string parsing
    var StringStream = (function () {
        function StringStream(source) {
            this.source = source;
            this.index = 0;
        }
        StringStream.prototype.eos = function () {
            return this.index >= this.source.length;
        };
        StringStream.prototype.next = function () {
            var next = this.peek();
            this.advance();
            return next;
        };
        StringStream.prototype.peek = function () {
            return this.source[this.index];
        };
        StringStream.prototype.advance = function () {
            this.index++;
        };
        return StringStream;
    }());
    var FormatType;
    (function (FormatType) {
        FormatType[FormatType["Invalid"] = 0] = "Invalid";
        FormatType[FormatType["Root"] = 1] = "Root";
        FormatType[FormatType["Text"] = 2] = "Text";
        FormatType[FormatType["Bold"] = 3] = "Bold";
        FormatType[FormatType["Italics"] = 4] = "Italics";
        FormatType[FormatType["Action"] = 5] = "Action";
        FormatType[FormatType["ActionClose"] = 6] = "ActionClose";
        FormatType[FormatType["NewLine"] = 7] = "NewLine";
    })(FormatType || (FormatType = {}));
    function renderFormattedText(element, treeNode, actionCallback) {
        var child;
        if (treeNode.type === 2 /* Text */) {
            child = document.createTextNode(treeNode.content);
        }
        else if (treeNode.type === 3 /* Bold */) {
            child = document.createElement('b');
        }
        else if (treeNode.type === 4 /* Italics */) {
            child = document.createElement('i');
        }
        else if (treeNode.type === 5 /* Action */) {
            var a = document.createElement('a');
            a.href = '#';
            DOM.addStandardDisposableListener(a, 'click', function (event) {
                actionCallback(String(treeNode.index), event);
            });
            child = a;
        }
        else if (treeNode.type === 7 /* NewLine */) {
            child = document.createElement('br');
        }
        else if (treeNode.type === 1 /* Root */) {
            child = element;
        }
        if (element !== child) {
            element.appendChild(child);
        }
        if (Array.isArray(treeNode.children)) {
            treeNode.children.forEach(function (nodeChild) {
                renderFormattedText(child, nodeChild, actionCallback);
            });
        }
    }
    function parseFormattedText(content) {
        var root = {
            type: 1 /* Root */,
            children: []
        };
        var actionItemIndex = 0;
        var current = root;
        var stack = [];
        var stream = new StringStream(content);
        while (!stream.eos()) {
            var next = stream.next();
            var isEscapedFormatType = (next === '\\' && formatTagType(stream.peek()) !== 0 /* Invalid */);
            if (isEscapedFormatType) {
                next = stream.next(); // unread the backslash if it escapes a format tag type
            }
            if (!isEscapedFormatType && isFormatTag(next) && next === stream.peek()) {
                stream.advance();
                if (current.type === 2 /* Text */) {
                    current = stack.pop();
                }
                var type = formatTagType(next);
                if (current.type === type || (current.type === 5 /* Action */ && type === 6 /* ActionClose */)) {
                    current = stack.pop();
                }
                else {
                    var newCurrent = {
                        type: type,
                        children: []
                    };
                    if (type === 5 /* Action */) {
                        newCurrent.index = actionItemIndex;
                        actionItemIndex++;
                    }
                    current.children.push(newCurrent);
                    stack.push(current);
                    current = newCurrent;
                }
            }
            else if (next === '\n') {
                if (current.type === 2 /* Text */) {
                    current = stack.pop();
                }
                current.children.push({
                    type: 7 /* NewLine */
                });
            }
            else {
                if (current.type !== 2 /* Text */) {
                    var textCurrent = {
                        type: 2 /* Text */,
                        content: next
                    };
                    current.children.push(textCurrent);
                    stack.push(current);
                    current = textCurrent;
                }
                else {
                    current.content += next;
                }
            }
        }
        if (current.type === 2 /* Text */) {
            current = stack.pop();
        }
        if (stack.length) {
        }
        return root;
    }
    function isFormatTag(char) {
        return formatTagType(char) !== 0 /* Invalid */;
    }
    function formatTagType(char) {
        switch (char) {
            case '*':
                return 3 /* Bold */;
            case '_':
                return 4 /* Italics */;
            case '[':
                return 5 /* Action */;
            case ']':
                return 6 /* ActionClose */;
            default:
                return 0 /* Invalid */;
        }
    }
});






define(__m[29/*vs/base/browser/styleMutator*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/]), function (require, exports, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FastDomNode = (function () {
        function FastDomNode(domNode) {
            this._domNode = domNode;
            this._maxWidth = -1;
            this._width = -1;
            this._height = -1;
            this._top = -1;
            this._left = -1;
            this._bottom = -1;
            this._right = -1;
            this._fontFamily = '';
            this._fontWeight = '';
            this._fontSize = -1;
            this._lineHeight = -1;
            this._className = '';
            this._display = '';
            this._position = '';
            this._visibility = '';
            this._transform = '';
            this._lineNumber = '';
        }
        Object.defineProperty(FastDomNode.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        FastDomNode.prototype.setMaxWidth = function (maxWidth) {
            if (this._maxWidth === maxWidth) {
                return;
            }
            this._maxWidth = maxWidth;
            this._domNode.style.maxWidth = this._maxWidth + 'px';
        };
        FastDomNode.prototype.setWidth = function (width) {
            if (this._width === width) {
                return;
            }
            this._width = width;
            this._domNode.style.width = this._width + 'px';
        };
        FastDomNode.prototype.setHeight = function (height) {
            if (this._height === height) {
                return;
            }
            this._height = height;
            this._domNode.style.height = this._height + 'px';
        };
        FastDomNode.prototype.setTop = function (top) {
            if (this._top === top) {
                return;
            }
            this._top = top;
            this._domNode.style.top = this._top + 'px';
        };
        FastDomNode.prototype.setLeft = function (left) {
            if (this._left === left) {
                return;
            }
            this._left = left;
            this._domNode.style.left = this._left + 'px';
        };
        FastDomNode.prototype.setBottom = function (bottom) {
            if (this._bottom === bottom) {
                return;
            }
            this._bottom = bottom;
            this._domNode.style.bottom = this._bottom + 'px';
        };
        FastDomNode.prototype.setRight = function (right) {
            if (this._right === right) {
                return;
            }
            this._right = right;
            this._domNode.style.right = this._right + 'px';
        };
        FastDomNode.prototype.setFontFamily = function (fontFamily) {
            if (this._fontFamily === fontFamily) {
                return;
            }
            this._fontFamily = fontFamily;
            this._domNode.style.fontFamily = this._fontFamily;
        };
        FastDomNode.prototype.setFontWeight = function (fontWeight) {
            if (this._fontWeight === fontWeight) {
                return;
            }
            this._fontWeight = fontWeight;
            this._domNode.style.fontWeight = this._fontWeight;
        };
        FastDomNode.prototype.setFontSize = function (fontSize) {
            if (this._fontSize === fontSize) {
                return;
            }
            this._fontSize = fontSize;
            this._domNode.style.fontSize = this._fontSize + 'px';
        };
        FastDomNode.prototype.setLineHeight = function (lineHeight) {
            if (this._lineHeight === lineHeight) {
                return;
            }
            this._lineHeight = lineHeight;
            this._domNode.style.lineHeight = this._lineHeight + 'px';
        };
        FastDomNode.prototype.setClassName = function (className) {
            if (this._className === className) {
                return;
            }
            this._className = className;
            this._domNode.className = this._className;
        };
        FastDomNode.prototype.toggleClassName = function (className, shouldHaveIt) {
            dom.toggleClass(this._domNode, className, shouldHaveIt);
            this._className = this._domNode.className;
        };
        FastDomNode.prototype.setDisplay = function (display) {
            if (this._display === display) {
                return;
            }
            this._display = display;
            this._domNode.style.display = this._display;
        };
        FastDomNode.prototype.setPosition = function (position) {
            if (this._position === position) {
                return;
            }
            this._position = position;
            this._domNode.style.position = this._position;
        };
        FastDomNode.prototype.setVisibility = function (visibility) {
            if (this._visibility === visibility) {
                return;
            }
            this._visibility = visibility;
            this._domNode.style.visibility = this._visibility;
        };
        FastDomNode.prototype.setTransform = function (transform) {
            if (this._transform === transform) {
                return;
            }
            this._transform = transform;
            this._setTransform(this._domNode, this._transform);
        };
        FastDomNode.prototype.setLineNumber = function (lineNumber) {
            if (this._lineNumber === lineNumber) {
                return;
            }
            this._lineNumber = lineNumber;
            this._domNode.setAttribute('lineNumber', this._lineNumber);
        };
        FastDomNode.prototype.setAttribute = function (name, value) {
            this._domNode.setAttribute(name, value);
        };
        return FastDomNode;
    }());
    exports.FastDomNode = FastDomNode;
    var WebKitFastDomNode = (function (_super) {
        __extends(WebKitFastDomNode, _super);
        function WebKitFastDomNode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WebKitFastDomNode.prototype._setTransform = function (domNode, transform) {
            domNode.style.webkitTransform = transform;
        };
        return WebKitFastDomNode;
    }(FastDomNode));
    var StandardFastDomNode = (function (_super) {
        __extends(StandardFastDomNode, _super);
        function StandardFastDomNode() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        StandardFastDomNode.prototype._setTransform = function (domNode, transform) {
            domNode.style.transform = transform;
        };
        return StandardFastDomNode;
    }(FastDomNode));
    var useWebKitFastDomNode = false;
    (function () {
        var testDomNode = document.createElement('div');
        if (typeof testDomNode.style.webkitTransform !== 'undefined') {
            useWebKitFastDomNode = true;
        }
    })();
    function createFastDomNode(domNode) {
        if (useWebKitFastDomNode) {
            return new WebKitFastDomNode(domNode);
        }
        else {
            return new StandardFastDomNode(domNode);
        }
    }
    exports.createFastDomNode = createFastDomNode;
    exports.StyleMutator = {
        setMaxWidth: function (domNode, maxWidth) {
            var desiredValue = maxWidth + 'px';
            if (domNode.style.maxWidth !== desiredValue) {
                domNode.style.maxWidth = desiredValue;
            }
        },
        setWidth: function (domNode, width) {
            var desiredValue = width + 'px';
            if (domNode.style.width !== desiredValue) {
                domNode.style.width = desiredValue;
            }
        },
        setHeight: function (domNode, height) {
            var desiredValue = height + 'px';
            if (domNode.style.height !== desiredValue) {
                domNode.style.height = desiredValue;
            }
        },
        setTop: function (domNode, top) {
            var desiredValue = top + 'px';
            if (domNode.style.top !== desiredValue) {
                domNode.style.top = desiredValue;
                return true;
            }
            return false;
        },
        setLeft: function (domNode, left) {
            var desiredValue = left + 'px';
            if (domNode.style.left !== desiredValue) {
                domNode.style.left = desiredValue;
                return true;
            }
            return false;
        },
        setBottom: function (domNode, bottom) {
            var desiredValue = bottom + 'px';
            if (domNode.style.bottom !== desiredValue) {
                domNode.style.bottom = desiredValue;
            }
        },
        setRight: function (domNode, right) {
            var desiredValue = right + 'px';
            if (domNode.style.right !== desiredValue) {
                domNode.style.right = desiredValue;
            }
        },
        setFontSize: function (domNode, fontSize) {
            var desiredValue = fontSize + 'px';
            if (domNode.style.fontSize !== desiredValue) {
                domNode.style.fontSize = desiredValue;
            }
        },
        setLineHeight: function (domNode, lineHeight) {
            var desiredValue = lineHeight + 'px';
            if (domNode.style.lineHeight !== desiredValue) {
                domNode.style.lineHeight = desiredValue;
            }
        },
        setTransform: null,
        setDisplay: function (domNode, desiredValue) {
            if (domNode.style.display !== desiredValue) {
                domNode.style.display = desiredValue;
            }
        },
        setVisibility: function (domNode, desiredValue) {
            if (domNode.style.visibility !== desiredValue) {
                domNode.style.visibility = desiredValue;
            }
        },
    };
    // Define setTransform
    function setWebkitTransform(domNode, desiredValue) {
        if (domNode.getAttribute('data-transform') !== desiredValue) {
            domNode.setAttribute('data-transform', desiredValue);
            domNode.style.webkitTransform = desiredValue;
            return true;
        }
        return false;
    }
    function setTransform(domNode, desiredValue) {
        if (domNode.getAttribute('data-transform') !== desiredValue) {
            domNode.setAttribute('data-transform', desiredValue);
            domNode.style.transform = desiredValue;
            return true;
        }
        return false;
    }
    (function () {
        var testDomNode = document.createElement('div');
        if (typeof testDomNode.style.webkitTransform !== 'undefined') {
            exports.StyleMutator.setTransform = setWebkitTransform;
        }
        else {
            exports.StyleMutator.setTransform = setTransform;
        }
    })();
});

define(__m[61/*vs/base/browser/touch*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/]), function (require, exports, arrays, lifecycle_1, DomUtils) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EventType;
    (function (EventType) {
        EventType.Tap = '-monaco-gesturetap';
        EventType.Change = '-monaco-gesturechange';
        EventType.Start = '-monaco-gesturestart';
        EventType.End = '-monaco-gesturesend';
        EventType.Contextmenu = '-monaco-gesturecontextmenu';
    })(EventType = exports.EventType || (exports.EventType = {}));
    var Gesture = (function () {
        function Gesture(target) {
            this.callOnTarget = [];
            this.activeTouches = {};
            this.target = target;
            this.handle = null;
        }
        Gesture.prototype.dispose = function () {
            this.target = null;
            if (this.handle) {
                this.handle.dispose();
                this.handle = null;
            }
        };
        Object.defineProperty(Gesture.prototype, "target", {
            set: function (element) {
                var _this = this;
                this.callOnTarget = lifecycle_1.dispose(this.callOnTarget);
                this.activeTouches = {};
                this.targetElement = element;
                if (!this.targetElement) {
                    return;
                }
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchstart', function (e) { return _this.onTouchStart(e); }));
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchend', function (e) { return _this.onTouchEnd(e); }));
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchmove', function (e) { return _this.onTouchMove(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Gesture.newGestureEvent = function (type) {
            var event = document.createEvent('CustomEvent');
            event.initEvent(type, false, true);
            return event;
        };
        Gesture.prototype.onTouchStart = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            if (this.handle) {
                this.handle.dispose();
                this.handle = null;
            }
            for (var i = 0, len = e.targetTouches.length; i < len; i++) {
                var touch = e.targetTouches.item(i);
                this.activeTouches[touch.identifier] = {
                    id: touch.identifier,
                    initialTarget: touch.target,
                    initialTimeStamp: timestamp,
                    initialPageX: touch.pageX,
                    initialPageY: touch.pageY,
                    rollingTimestamps: [timestamp],
                    rollingPageX: [touch.pageX],
                    rollingPageY: [touch.pageY]
                };
                var evt = Gesture.newGestureEvent(EventType.Start);
                evt.pageX = touch.pageX;
                evt.pageY = touch.pageY;
                this.targetElement.dispatchEvent(evt);
            }
        };
        Gesture.prototype.onTouchEnd = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            var activeTouchCount = Object.keys(this.activeTouches).length;
            for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                var touch = e.changedTouches.item(i);
                if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
                    console.warn('move of an UNKNOWN touch', touch);
                    continue;
                }
                var data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
                if (holdTime < Gesture.HOLD_DELAY
                    && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30
                    && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
                    var evt = Gesture.newGestureEvent(EventType.Tap);
                    evt.initialTarget = data.initialTarget;
                    evt.pageX = arrays.tail(data.rollingPageX);
                    evt.pageY = arrays.tail(data.rollingPageY);
                    this.targetElement.dispatchEvent(evt);
                }
                else if (holdTime >= Gesture.HOLD_DELAY
                    && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30
                    && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
                    var evt = Gesture.newGestureEvent(EventType.Contextmenu);
                    evt.initialTarget = data.initialTarget;
                    evt.pageX = arrays.tail(data.rollingPageX);
                    evt.pageY = arrays.tail(data.rollingPageY);
                    this.targetElement.dispatchEvent(evt);
                }
                else if (activeTouchCount === 1) {
                    var finalX = arrays.tail(data.rollingPageX);
                    var finalY = arrays.tail(data.rollingPageY);
                    var deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];
                    var deltaX = finalX - data.rollingPageX[0];
                    var deltaY = finalY - data.rollingPageY[0];
                    this.inertia(timestamp, // time now
                    Math.abs(deltaX) / deltaT, // speed
                    deltaX > 0 ? 1 : -1, // x direction
                    finalX, // x now
                    Math.abs(deltaY) / deltaT, // y speed
                    deltaY > 0 ? 1 : -1, // y direction
                    finalY // y now
                    );
                }
                // forget about this touch
                delete this.activeTouches[touch.identifier];
            }
        };
        Gesture.prototype.inertia = function (t1, vX, dirX, x, vY, dirY, y) {
            var _this = this;
            this.handle = DomUtils.scheduleAtNextAnimationFrame(function () {
                var now = Date.now();
                // velocity: old speed + accel_over_time
                var deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;
                vX += Gesture.SCROLL_FRICTION * deltaT;
                vY += Gesture.SCROLL_FRICTION * deltaT;
                if (vX > 0) {
                    stopped = false;
                    delta_pos_x = dirX * vX * deltaT;
                }
                if (vY > 0) {
                    stopped = false;
                    delta_pos_y = dirY * vY * deltaT;
                }
                // dispatch translation event
                var evt = Gesture.newGestureEvent(EventType.Change);
                evt.translationX = delta_pos_x;
                evt.translationY = delta_pos_y;
                _this.targetElement.dispatchEvent(evt);
                if (!stopped) {
                    _this.inertia(now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
                }
            });
        };
        Gesture.prototype.onTouchMove = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                var touch = e.changedTouches.item(i);
                if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
                    console.warn('end of an UNKNOWN touch', touch);
                    continue;
                }
                var data = this.activeTouches[touch.identifier];
                var evt = Gesture.newGestureEvent(EventType.Change);
                evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);
                evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);
                evt.pageX = touch.pageX;
                evt.pageY = touch.pageY;
                this.targetElement.dispatchEvent(evt);
                // only keep a few data points, to average the final speed
                if (data.rollingPageX.length > 3) {
                    data.rollingPageX.shift();
                    data.rollingPageY.shift();
                    data.rollingTimestamps.shift();
                }
                data.rollingPageX.push(touch.pageX);
                data.rollingPageY.push(touch.pageY);
                data.rollingTimestamps.push(timestamp);
            }
        };
        return Gesture;
    }());
    Gesture.HOLD_DELAY = 700;
    Gesture.SCROLL_FRICTION = -0.005;
    exports.Gesture = Gesture;
});

define(__m[110/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,11/*vs/base/browser/dom*/,36/*vs/base/common/objects*/,481/*vs/base/browser/ui/octiconLabel/octiconLabel*/]), function (require, exports, strings_1, dom, objects, octiconLabel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HighlightedLabel = (function () {
        function HighlightedLabel(container) {
            this.domNode = document.createElement('span');
            this.domNode.className = 'monaco-highlighted-label';
            this.didEverRender = false;
            container.appendChild(this.domNode);
        }
        Object.defineProperty(HighlightedLabel.prototype, "element", {
            get: function () {
                return this.domNode;
            },
            enumerable: true,
            configurable: true
        });
        HighlightedLabel.prototype.set = function (text, highlights) {
            if (highlights === void 0) { highlights = []; }
            if (!text) {
                text = '';
            }
            if (this.didEverRender && this.text === text && objects.equals(this.highlights, highlights)) {
                return;
            }
            if (!Array.isArray(highlights)) {
                highlights = [];
            }
            this.text = text;
            this.highlights = highlights;
            this.render();
        };
        HighlightedLabel.prototype.render = function () {
            dom.clearNode(this.domNode);
            var htmlContent = [], highlight, pos = 0;
            for (var i = 0; i < this.highlights.length; i++) {
                highlight = this.highlights[i];
                if (highlight.end === highlight.start) {
                    continue;
                }
                if (pos < highlight.start) {
                    htmlContent.push('<span>');
                    htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(pos, highlight.start))));
                    htmlContent.push('</span>');
                    pos = highlight.end;
                }
                htmlContent.push('<span class="highlight">');
                htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(highlight.start, highlight.end))));
                htmlContent.push('</span>');
                pos = highlight.end;
            }
            if (pos < this.text.length) {
                htmlContent.push('<span>');
                htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(pos))));
                htmlContent.push('</span>');
            }
            this.domNode.innerHTML = htmlContent.join('');
            this.didEverRender = true;
        };
        HighlightedLabel.prototype.dispose = function () {
            this.text = null;
            this.highlights = null;
        };
        return HighlightedLabel;
    }());
    exports.HighlightedLabel = HighlightedLabel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[440/*vs/base/browser/ui/list/rowCache*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/]), function (require, exports, dom_1) {
    "use strict";
    function getLastScrollTime(element) {
        var value = element.getAttribute('last-scroll-time');
        return value ? parseInt(value, 10) : 0;
    }
    function removeFromParent(element) {
        try {
            element.parentElement.removeChild(element);
        }
        catch (e) {
        }
    }
    var RowCache = (function () {
        function RowCache(renderers) {
            this.renderers = renderers;
            this.cache = Object.create(null);
            this.scrollingRow = null;
        }
        /**
         * Returns a row either by creating a new one or reusing
         * a previously released row which shares the same templateId.
         */
        RowCache.prototype.alloc = function (templateId) {
            var result = this.getTemplateCache(templateId).pop();
            if (!result) {
                var domNode = dom_1.$('.monaco-list-row');
                var renderer = this.renderers[templateId];
                var templateData = renderer.renderTemplate(domNode);
                result = { domNode: domNode, templateId: templateId, templateData: templateData };
            }
            return result;
        };
        /**
         * Releases the row for eventual reuse. The row's domNode
         * will eventually be removed from its parent, given that
         * it is not the currently scrolling row (for OS X ballistic
         * scrolling).
         */
        RowCache.prototype.release = function (row) {
            if (!row) {
                return;
            }
            var lastScrollTime = getLastScrollTime(row.domNode);
            if (!lastScrollTime) {
                this.releaseRow(row);
                return;
            }
            if (this.scrollingRow) {
                var lastKnownScrollTime = getLastScrollTime(this.scrollingRow.domNode);
                if (lastKnownScrollTime > lastScrollTime) {
                    this.releaseRow(row);
                    return;
                }
                if (this.scrollingRow.domNode.parentElement) {
                    this.releaseRow(this.scrollingRow);
                }
            }
            this.scrollingRow = row;
            dom_1.addClass(this.scrollingRow.domNode, 'scrolling');
        };
        RowCache.prototype.releaseRow = function (row) {
            var domNode = row.domNode, templateId = row.templateId;
            dom_1.removeClass(domNode, 'scrolling');
            removeFromParent(domNode);
            var cache = this.getTemplateCache(templateId);
            cache.push(row);
        };
        RowCache.prototype.getTemplateCache = function (templateId) {
            return this.cache[templateId] || (this.cache[templateId] = []);
        };
        RowCache.prototype.garbageCollect = function () {
            var _this = this;
            if (this.cache) {
                Object.keys(this.cache).forEach(function (templateId) {
                    _this.cache[templateId].forEach(function (cachedRow) {
                        var renderer = _this.renderers[templateId];
                        renderer.disposeTemplate(cachedRow.templateData);
                        cachedRow.domNode = null;
                        cachedRow.templateData = null;
                    });
                    delete _this.cache[templateId];
                });
            }
            if (this.scrollingRow) {
                var renderer = this.renderers[this.scrollingRow.templateId];
                renderer.disposeTemplate(this.scrollingRow.templateData);
                this.scrollingRow = null;
            }
        };
        RowCache.prototype.dispose = function () {
            this.garbageCollect();
            this.cache = null;
            this.renderers = null;
        };
        return RowCache;
    }());
    exports.RowCache = RowCache;
});






define(__m[442/*vs/base/browser/ui/scrollbar/scrollbarVisibilityController*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,17/*vs/base/common/async*/,38/*vs/base/common/scrollable*/]), function (require, exports, lifecycle_1, async_1, scrollable_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ScrollbarVisibilityController = (function (_super) {
        __extends(ScrollbarVisibilityController, _super);
        function ScrollbarVisibilityController(visibility, visibleClassName, invisibleClassName) {
            var _this = _super.call(this) || this;
            _this._visibility = visibility;
            _this._visibleClassName = visibleClassName;
            _this._invisibleClassName = invisibleClassName;
            _this._domNode = null;
            _this._isVisible = false;
            _this._isNeeded = false;
            _this._shouldBeVisible = false;
            _this._revealTimer = _this._register(new async_1.TimeoutTimer());
            return _this;
        }
        // ----------------- Hide / Reveal
        ScrollbarVisibilityController.prototype.applyVisibilitySetting = function (shouldBeVisible) {
            if (this._visibility === scrollable_1.ScrollbarVisibility.Hidden) {
                return false;
            }
            if (this._visibility === scrollable_1.ScrollbarVisibility.Visible) {
                return true;
            }
            return shouldBeVisible;
        };
        ScrollbarVisibilityController.prototype.setShouldBeVisible = function (rawShouldBeVisible) {
            var shouldBeVisible = this.applyVisibilitySetting(rawShouldBeVisible);
            if (this._shouldBeVisible !== shouldBeVisible) {
                this._shouldBeVisible = shouldBeVisible;
                this.ensureVisibility();
            }
        };
        ScrollbarVisibilityController.prototype.setIsNeeded = function (isNeeded) {
            if (this._isNeeded !== isNeeded) {
                this._isNeeded = isNeeded;
                this.ensureVisibility();
            }
        };
        ScrollbarVisibilityController.prototype.setDomNode = function (domNode) {
            this._domNode = domNode;
            this._domNode.setClassName(this._invisibleClassName);
            // Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration
            this.setShouldBeVisible(false);
        };
        ScrollbarVisibilityController.prototype.ensureVisibility = function () {
            if (!this._isNeeded) {
                // Nothing to be rendered
                this._hide(false);
                return;
            }
            if (this._shouldBeVisible) {
                this._reveal();
            }
            else {
                this._hide(true);
            }
        };
        ScrollbarVisibilityController.prototype._reveal = function () {
            var _this = this;
            if (this._isVisible) {
                return;
            }
            this._isVisible = true;
            // The CSS animation doesn't play otherwise
            this._revealTimer.setIfNotSet(function () {
                _this._domNode.setClassName(_this._visibleClassName);
            }, 0);
        };
        ScrollbarVisibilityController.prototype._hide = function (withFadeAway) {
            this._revealTimer.cancel();
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
        };
        return ScrollbarVisibilityController;
    }(lifecycle_1.Disposable));
    exports.ScrollbarVisibilityController = ScrollbarVisibilityController;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[40/*vs/base/browser/ui/widget*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,34/*vs/base/browser/mouseEvent*/,51/*vs/base/browser/keyboardEvent*/,11/*vs/base/browser/dom*/]), function (require, exports, lifecycle_1, mouseEvent_1, keyboardEvent_1, DomUtils) {
    'use strict';
    var Widget = (function (_super) {
        __extends(Widget, _super);
        function Widget() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Widget.prototype.onclick = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.CLICK, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onmousedown = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.MOUSE_DOWN, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onmouseover = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.MOUSE_OVER, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onnonbubblingmouseout = function (domNode, listener) {
            this._register(DomUtils.addDisposableNonBubblingMouseOutListener(domNode, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onkeydown = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.KEY_DOWN, function (e) { return listener(new keyboardEvent_1.StandardKeyboardEvent(e)); }));
        };
        Widget.prototype.onkeyup = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.KEY_UP, function (e) { return listener(new keyboardEvent_1.StandardKeyboardEvent(e)); }));
        };
        Widget.prototype.oninput = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.INPUT, listener));
        };
        Widget.prototype.onblur = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.BLUR, listener));
        };
        Widget.prototype.onfocus = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.FOCUS, listener));
        };
        Widget.prototype.onchange = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.CHANGE, listener));
        };
        return Widget;
    }(lifecycle_1.Disposable));
    exports.Widget = Widget;
});






define(__m[114/*vs/base/browser/ui/scrollbar/scrollbarArrow*/], __M([1/*require*/,0/*exports*/,102/*vs/base/browser/globalMouseMoveMonitor*/,40/*vs/base/browser/ui/widget*/,17/*vs/base/common/async*/]), function (require, exports, globalMouseMoveMonitor_1, widget_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The arrow image size.
     */
    exports.ARROW_IMG_SIZE = 11;
    var ScrollbarArrow = (function (_super) {
        __extends(ScrollbarArrow, _super);
        function ScrollbarArrow(opts) {
            var _this = _super.call(this) || this;
            _this._onActivate = opts.onActivate;
            _this.bgDomNode = document.createElement('div');
            _this.bgDomNode.className = 'arrow-background';
            _this.bgDomNode.style.position = 'absolute';
            _this.bgDomNode.style.width = opts.bgWidth + 'px';
            _this.bgDomNode.style.height = opts.bgHeight + 'px';
            if (typeof opts.top !== 'undefined') {
                _this.bgDomNode.style.top = '0px';
            }
            if (typeof opts.left !== 'undefined') {
                _this.bgDomNode.style.left = '0px';
            }
            if (typeof opts.bottom !== 'undefined') {
                _this.bgDomNode.style.bottom = '0px';
            }
            if (typeof opts.right !== 'undefined') {
                _this.bgDomNode.style.right = '0px';
            }
            _this.domNode = document.createElement('div');
            _this.domNode.className = opts.className;
            _this.domNode.style.position = 'absolute';
            _this.domNode.style.width = exports.ARROW_IMG_SIZE + 'px';
            _this.domNode.style.height = exports.ARROW_IMG_SIZE + 'px';
            if (typeof opts.top !== 'undefined') {
                _this.domNode.style.top = opts.top + 'px';
            }
            if (typeof opts.left !== 'undefined') {
                _this.domNode.style.left = opts.left + 'px';
            }
            if (typeof opts.bottom !== 'undefined') {
                _this.domNode.style.bottom = opts.bottom + 'px';
            }
            if (typeof opts.right !== 'undefined') {
                _this.domNode.style.right = opts.right + 'px';
            }
            _this._mouseMoveMonitor = _this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
            _this.onmousedown(_this.bgDomNode, function (e) { return _this._arrowMouseDown(e); });
            _this.onmousedown(_this.domNode, function (e) { return _this._arrowMouseDown(e); });
            _this._mousedownRepeatTimer = _this._register(new async_1.IntervalTimer());
            _this._mousedownScheduleRepeatTimer = _this._register(new async_1.TimeoutTimer());
            return _this;
        }
        ScrollbarArrow.prototype._arrowMouseDown = function (e) {
            var _this = this;
            var scheduleRepeater = function () {
                _this._mousedownRepeatTimer.cancelAndSet(function () { return _this._onActivate(); }, 1000 / 24);
            };
            this._onActivate();
            this._mousedownRepeatTimer.cancel();
            this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
            this._mouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                /* Intentional empty */
            }, function () {
                _this._mousedownRepeatTimer.cancel();
                _this._mousedownScheduleRepeatTimer.cancel();
            });
            e.preventDefault();
        };
        return ScrollbarArrow;
    }(widget_1.Widget));
    exports.ScrollbarArrow = ScrollbarArrow;
});






define(__m[140/*vs/base/browser/ui/scrollbar/abstractScrollbar*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,11/*vs/base/browser/dom*/,34/*vs/base/browser/mouseEvent*/,102/*vs/base/browser/globalMouseMoveMonitor*/,40/*vs/base/browser/ui/widget*/,29/*vs/base/browser/styleMutator*/,114/*vs/base/browser/ui/scrollbar/scrollbarArrow*/,442/*vs/base/browser/ui/scrollbar/scrollbarVisibilityController*/]), function (require, exports, Platform, DomUtils, mouseEvent_1, globalMouseMoveMonitor_1, widget_1, styleMutator_1, scrollbarArrow_1, scrollbarVisibilityController_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
     */
    var MOUSE_DRAG_RESET_DISTANCE = 140;
    var AbstractScrollbar = (function (_super) {
        __extends(AbstractScrollbar, _super);
        function AbstractScrollbar(opts) {
            var _this = _super.call(this) || this;
            _this._canUseTranslate3d = opts.canUseTranslate3d;
            _this._lazyRender = opts.lazyRender;
            _this._host = opts.host;
            _this._scrollable = opts.scrollable;
            _this._scrollbarState = opts.scrollbarState;
            _this._visibilityController = _this._register(new scrollbarVisibilityController_1.ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));
            _this._mouseMoveMonitor = _this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
            _this._shouldRender = true;
            _this.domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            _this._visibilityController.setDomNode(_this.domNode);
            _this.domNode.setPosition('absolute');
            _this.onmousedown(_this.domNode.domNode, function (e) { return _this._domNodeMouseDown(e); });
            return _this;
        }
        // ----------------- creation
        /**
         * Creates the dom node for an arrow & adds it to the container
         */
        AbstractScrollbar.prototype._createArrow = function (opts) {
            var arrow = this._register(new scrollbarArrow_1.ScrollbarArrow(opts));
            this.domNode.domNode.appendChild(arrow.bgDomNode);
            this.domNode.domNode.appendChild(arrow.domNode);
        };
        /**
         * Creates the slider dom node, adds it to the container & hooks up the events
         */
        AbstractScrollbar.prototype._createSlider = function (top, left, width, height) {
            var _this = this;
            this.slider = styleMutator_1.createFastDomNode(document.createElement('div'));
            this.slider.setClassName('slider');
            this.slider.setPosition('absolute');
            this.slider.setTop(top);
            this.slider.setLeft(left);
            this.slider.setWidth(width);
            this.slider.setHeight(height);
            this.domNode.domNode.appendChild(this.slider.domNode);
            this.onmousedown(this.slider.domNode, function (e) { return _this._sliderMouseDown(e); });
        };
        // ----------------- Update state
        AbstractScrollbar.prototype.setCanUseTranslate3d = function (canUseTranslate3d) {
            this._canUseTranslate3d = canUseTranslate3d;
            return true;
        };
        AbstractScrollbar.prototype._onElementSize = function (visibleSize) {
            if (this._scrollbarState.setVisibleSize(visibleSize)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        AbstractScrollbar.prototype._onElementScrollSize = function (elementScrollSize) {
            if (this._scrollbarState.setScrollSize(elementScrollSize)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        AbstractScrollbar.prototype._onElementScrollPosition = function (elementScrollPosition) {
            if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        // ----------------- rendering
        AbstractScrollbar.prototype.beginReveal = function () {
            this._visibilityController.setShouldBeVisible(true);
        };
        AbstractScrollbar.prototype.beginHide = function () {
            this._visibilityController.setShouldBeVisible(false);
        };
        AbstractScrollbar.prototype.render = function () {
            if (!this._shouldRender) {
                return;
            }
            this._shouldRender = false;
            if (this._canUseTranslate3d) {
                // Put the scrollbar in its own layer
                this.domNode.setTransform('translate3d(0px, 0px, 0px)');
            }
            else {
                this.domNode.setTransform('');
            }
            this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
            this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
        };
        // ----------------- DOM events
        AbstractScrollbar.prototype._domNodeMouseDown = function (e) {
            if (e.target !== this.domNode.domNode) {
                return;
            }
            this._onMouseDown(e);
        };
        AbstractScrollbar.prototype.delegateMouseDown = function (browserEvent) {
            var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
            var domTop = this.domNode.domNode.getClientRects()[0].top;
            var sliderStart = domTop + this._scrollbarState.getSliderPosition();
            var sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
            var mousePos = this._sliderMousePosition(e);
            if (sliderStart <= mousePos && mousePos <= sliderStop) {
                // Act as if it was a mouse down on the slider
                this._sliderMouseDown(e);
            }
            else {
                // Act as if it was a mouse down on the scrollbar
                this._onMouseDown(e);
            }
        };
        AbstractScrollbar.prototype._onMouseDown = function (e) {
            var domNodePosition = DomUtils.getDomNodePagePosition(this.domNode.domNode);
            var desiredSliderPosition = this._mouseDownRelativePosition(e, domNodePosition) - this._scrollbarState.getArrowSize() - this._scrollbarState.getSliderSize() / 2;
            this.setDesiredScrollPosition(this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
            this._sliderMouseDown(e);
        };
        AbstractScrollbar.prototype._sliderMouseDown = function (e) {
            var _this = this;
            if (e.leftButton) {
                var initialMouseOrthogonalPosition_1 = this._sliderOrthogonalMousePosition(e);
                var initialScrollPosition_1 = this._getScrollPosition();
                var draggingDelta_1 = this._sliderMousePosition(e) - this._scrollbarState.getSliderPosition();
                this.slider.toggleClassName('active', true);
                this._mouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                    var mouseOrthogonalPosition = _this._sliderOrthogonalMousePosition(mouseMoveData);
                    var mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition_1);
                    // console.log(initialMouseOrthogonalPosition + ' -> ' + mouseOrthogonalPosition + ': ' + mouseOrthogonalDelta);
                    if (Platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
                        // The mouse has wondered away from the scrollbar => reset dragging
                        _this.setDesiredScrollPosition(initialScrollPosition_1);
                    }
                    else {
                        var desiredSliderPosition = _this._sliderMousePosition(mouseMoveData) - draggingDelta_1;
                        _this.setDesiredScrollPosition(_this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
                    }
                }, function () {
                    _this.slider.toggleClassName('active', false);
                    _this._host.onDragEnd();
                });
                e.preventDefault();
                this._host.onDragStart();
            }
        };
        AbstractScrollbar.prototype.validateScrollPosition = function (desiredScrollPosition) {
            return this._scrollbarState.validateScrollPosition(desiredScrollPosition);
        };
        AbstractScrollbar.prototype.setDesiredScrollPosition = function (desiredScrollPosition) {
            desiredScrollPosition = this.validateScrollPosition(desiredScrollPosition);
            var oldScrollPosition = this._getScrollPosition();
            this._setScrollPosition(desiredScrollPosition);
            var newScrollPosition = this._getScrollPosition();
            if (oldScrollPosition !== newScrollPosition) {
                this._onElementScrollPosition(this._getScrollPosition());
                return true;
            }
            return false;
        };
        return AbstractScrollbar;
    }(widget_1.Widget));
    exports.AbstractScrollbar = AbstractScrollbar;
});






define(__m[483/*vs/base/browser/ui/scrollbar/horizontalScrollbar*/], __M([1/*require*/,0/*exports*/,140/*vs/base/browser/ui/scrollbar/abstractScrollbar*/,34/*vs/base/browser/mouseEvent*/,38/*vs/base/common/scrollable*/,131/*vs/base/browser/ui/scrollbar/scrollbarState*/,114/*vs/base/browser/ui/scrollbar/scrollbarArrow*/]), function (require, exports, abstractScrollbar_1, mouseEvent_1, scrollable_1, scrollbarState_1, scrollbarArrow_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HorizontalScrollbar = (function (_super) {
        __extends(HorizontalScrollbar, _super);
        function HorizontalScrollbar(scrollable, options, host) {
            var _this = _super.call(this, {
                canUseTranslate3d: options.canUseTranslate3d,
                lazyRender: options.lazyRender,
                host: host,
                scrollbarState: new scrollbarState_1.ScrollbarState((options.horizontalHasArrows ? options.arrowSize : 0), (options.horizontal === scrollable_1.ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize), (options.vertical === scrollable_1.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize)),
                visibility: options.horizontal,
                extraScrollbarClassName: 'horizontal',
                scrollable: scrollable
            }) || this;
            if (options.horizontalHasArrows) {
                var arrowDelta = (options.arrowSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                var scrollbarDelta = (options.horizontalScrollbarSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                _this._createArrow({
                    className: 'left-arrow',
                    top: scrollbarDelta,
                    left: arrowDelta,
                    bottom: void 0,
                    right: void 0,
                    bgWidth: options.arrowSize,
                    bgHeight: options.horizontalScrollbarSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 1, 0)); },
                });
                _this._createArrow({
                    className: 'right-arrow',
                    top: scrollbarDelta,
                    left: void 0,
                    bottom: void 0,
                    right: arrowDelta,
                    bgWidth: options.arrowSize,
                    bgHeight: options.horizontalScrollbarSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, -1, 0)); },
                });
            }
            _this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, null, options.horizontalSliderSize);
            return _this;
        }
        HorizontalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
            this.slider.setWidth(sliderSize);
            if (this._canUseTranslate3d) {
                this.slider.setTransform('translate3d(' + sliderPosition + 'px, 0px, 0px)');
                this.slider.setLeft(0);
            }
            else {
                this.slider.setTransform('');
                this.slider.setLeft(sliderPosition);
            }
        };
        HorizontalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
            this.domNode.setWidth(largeSize);
            this.domNode.setHeight(smallSize);
            this.domNode.setLeft(0);
            this.domNode.setBottom(0);
        };
        HorizontalScrollbar.prototype.onDidScroll = function (e) {
            this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
            this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
            this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
            return this._shouldRender;
        };
        HorizontalScrollbar.prototype._mouseDownRelativePosition = function (e, domNodePosition) {
            return e.posx - domNodePosition.left;
        };
        HorizontalScrollbar.prototype._sliderMousePosition = function (e) {
            return e.posx;
        };
        HorizontalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
            return e.posy;
        };
        HorizontalScrollbar.prototype._getScrollPosition = function () {
            return this._scrollable.getScrollLeft();
        };
        HorizontalScrollbar.prototype._setScrollPosition = function (scrollPosition) {
            this._scrollable.updateState({
                scrollLeft: scrollPosition
            });
        };
        return HorizontalScrollbar;
    }(abstractScrollbar_1.AbstractScrollbar));
    exports.HorizontalScrollbar = HorizontalScrollbar;
});






define(__m[493/*vs/base/browser/ui/scrollbar/verticalScrollbar*/], __M([1/*require*/,0/*exports*/,140/*vs/base/browser/ui/scrollbar/abstractScrollbar*/,34/*vs/base/browser/mouseEvent*/,38/*vs/base/common/scrollable*/,131/*vs/base/browser/ui/scrollbar/scrollbarState*/,114/*vs/base/browser/ui/scrollbar/scrollbarArrow*/]), function (require, exports, abstractScrollbar_1, mouseEvent_1, scrollable_1, scrollbarState_1, scrollbarArrow_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var VerticalScrollbar = (function (_super) {
        __extends(VerticalScrollbar, _super);
        function VerticalScrollbar(scrollable, options, host) {
            var _this = _super.call(this, {
                canUseTranslate3d: options.canUseTranslate3d,
                lazyRender: options.lazyRender,
                host: host,
                scrollbarState: new scrollbarState_1.ScrollbarState((options.verticalHasArrows ? options.arrowSize : 0), (options.vertical === scrollable_1.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize), 
                // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
                0),
                visibility: options.vertical,
                extraScrollbarClassName: 'vertical',
                scrollable: scrollable
            }) || this;
            if (options.verticalHasArrows) {
                var arrowDelta = (options.arrowSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                var scrollbarDelta = (options.verticalScrollbarSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                _this._createArrow({
                    className: 'up-arrow',
                    top: arrowDelta,
                    left: scrollbarDelta,
                    bottom: void 0,
                    right: void 0,
                    bgWidth: options.verticalScrollbarSize,
                    bgHeight: options.arrowSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 0, 1)); },
                });
                _this._createArrow({
                    className: 'down-arrow',
                    top: void 0,
                    left: scrollbarDelta,
                    bottom: arrowDelta,
                    right: void 0,
                    bgWidth: options.verticalScrollbarSize,
                    bgHeight: options.arrowSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 0, -1)); },
                });
            }
            _this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, null);
            return _this;
        }
        VerticalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
            this.slider.setHeight(sliderSize);
            if (this._canUseTranslate3d) {
                this.slider.setTransform('translate3d(0px, ' + sliderPosition + 'px, 0px)');
                this.slider.setTop(0);
            }
            else {
                this.slider.setTransform('');
                this.slider.setTop(sliderPosition);
            }
        };
        VerticalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
            this.domNode.setWidth(smallSize);
            this.domNode.setHeight(largeSize);
            this.domNode.setRight(0);
            this.domNode.setTop(0);
        };
        VerticalScrollbar.prototype.onDidScroll = function (e) {
            this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
            this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
            this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
            return this._shouldRender;
        };
        VerticalScrollbar.prototype._mouseDownRelativePosition = function (e, domNodePosition) {
            return e.posy - domNodePosition.top;
        };
        VerticalScrollbar.prototype._sliderMousePosition = function (e) {
            return e.posy;
        };
        VerticalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
            return e.posx;
        };
        VerticalScrollbar.prototype._getScrollPosition = function () {
            return this._scrollable.getScrollTop();
        };
        VerticalScrollbar.prototype._setScrollPosition = function (scrollPosition) {
            this._scrollable.updateState({
                scrollTop: scrollPosition
            });
        };
        return VerticalScrollbar;
    }(abstractScrollbar_1.AbstractScrollbar));
    exports.VerticalScrollbar = VerticalScrollbar;
});

define(__m[70/*vs/base/common/network*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
    function xhr(options) {
        var req = null;
        var canceled = false;
        return new winjs_base_1.TPromise(function (c, e, p) {
            req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (canceled) {
                    return;
                }
                if (req.readyState === 4) {
                    // Handle 1223: http://bugs.jquery.com/ticket/1450
                    if ((req.status >= 200 && req.status < 300) || req.status === 1223) {
                        c(req);
                    }
                    else {
                        e(req);
                    }
                    req.onreadystatechange = function () { };
                }
                else {
                    p(req);
                }
            };
            req.open(options.type || 'GET', options.url, 
            // Promise based XHR does not support sync.
            //
            true, options.user, options.password);
            req.responseType = options.responseType || '';
            Object.keys(options.headers || {}).forEach(function (k) {
                req.setRequestHeader(k, options.headers[k]);
            });
            if (options.customRequestInitializer) {
                options.customRequestInitializer(req);
            }
            req.send(options.data);
        }, function () {
            canceled = true;
            req.abort();
        });
    }
    exports.xhr = xhr;
});






define(__m[148/*vs/base/common/worker/simpleWorker*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,17/*vs/base/common/async*/,19/*vs/base/common/platform*/]), function (require, exports, errors_1, lifecycle_1, winjs_base_1, async_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var INITIALIZE = '$initialize';
    var webWorkerWarningLogged = false;
    function logOnceWebWorkerWarning(err) {
        if (!platform_1.isWeb) {
            // running tests
            return;
        }
        if (!webWorkerWarningLogged) {
            webWorkerWarningLogged = true;
            console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');
        }
        console.warn(err.message);
    }
    exports.logOnceWebWorkerWarning = logOnceWebWorkerWarning;
    var SimpleWorkerProtocol = (function () {
        function SimpleWorkerProtocol(handler) {
            this._workerId = -1;
            this._handler = handler;
            this._lastSentReq = 0;
            this._pendingReplies = Object.create(null);
        }
        SimpleWorkerProtocol.prototype.setWorkerId = function (workerId) {
            this._workerId = workerId;
        };
        SimpleWorkerProtocol.prototype.sendMessage = function (method, args) {
            var req = String(++this._lastSentReq);
            var reply = {
                c: null,
                e: null
            };
            var result = new winjs_base_1.TPromise(function (c, e, p) {
                reply.c = c;
                reply.e = e;
            }, function () {
                // Cancel not supported
            });
            this._pendingReplies[req] = reply;
            this._send({
                vsWorker: this._workerId,
                req: req,
                method: method,
                args: args
            });
            return result;
        };
        SimpleWorkerProtocol.prototype.handleMessage = function (serializedMessage) {
            var message;
            try {
                message = JSON.parse(serializedMessage);
            }
            catch (e) {
            }
            if (!message.vsWorker) {
                return;
            }
            if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
                return;
            }
            this._handleMessage(message);
        };
        SimpleWorkerProtocol.prototype._handleMessage = function (msg) {
            var _this = this;
            if (msg.seq) {
                var replyMessage = msg;
                if (!this._pendingReplies[replyMessage.seq]) {
                    console.warn('Got reply to unknown seq');
                    return;
                }
                var reply = this._pendingReplies[replyMessage.seq];
                delete this._pendingReplies[replyMessage.seq];
                if (replyMessage.err) {
                    var err = replyMessage.err;
                    if (replyMessage.err.$isError) {
                        err = new Error();
                        err.name = replyMessage.err.name;
                        err.message = replyMessage.err.message;
                        err.stack = replyMessage.err.stack;
                    }
                    reply.e(err);
                    return;
                }
                reply.c(replyMessage.res);
                return;
            }
            var requestMessage = msg;
            var req = requestMessage.req;
            var result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
            result.then(function (r) {
                _this._send({
                    vsWorker: _this._workerId,
                    seq: req,
                    res: r,
                    err: undefined
                });
            }, function (e) {
                _this._send({
                    vsWorker: _this._workerId,
                    seq: req,
                    res: undefined,
                    err: errors_1.transformErrorForSerialization(e)
                });
            });
        };
        SimpleWorkerProtocol.prototype._send = function (msg) {
            var strMsg = JSON.stringify(msg);
            // console.log('SENDING: ' + strMsg);
            this._handler.sendMessage(strMsg);
        };
        return SimpleWorkerProtocol;
    }());
    /**
     * Main thread side
     */
    var SimpleWorkerClient = (function (_super) {
        __extends(SimpleWorkerClient, _super);
        function SimpleWorkerClient(workerFactory, moduleId) {
            var _this = _super.call(this) || this;
            _this._lastRequestTimestamp = -1;
            var lazyProxyFulfill = null;
            var lazyProxyReject = null;
            _this._worker = _this._register(workerFactory.create('vs/base/common/worker/simpleWorker', function (msg) {
                _this._protocol.handleMessage(msg);
            }, function (err) {
                // in Firefox, web workers fail lazily :(
                // we will reject the proxy
                lazyProxyReject(err);
            }));
            _this._protocol = new SimpleWorkerProtocol({
                sendMessage: function (msg) {
                    _this._worker.postMessage(msg);
                },
                handleMessage: function (method, args) {
                    // Intentionally not supporting worker -> main requests
                    return winjs_base_1.TPromise.as(null);
                }
            });
            _this._protocol.setWorkerId(_this._worker.getId());
            // Gather loader configuration
            var loaderConfiguration = null;
            var globalRequire = self.require;
            if (typeof globalRequire.getConfig === 'function') {
                // Get the configuration from the Monaco AMD Loader
                loaderConfiguration = globalRequire.getConfig();
            }
            else if (typeof self.requirejs !== 'undefined') {
                // Get the configuration from requirejs
                loaderConfiguration = self.requirejs.s.contexts._.config;
            }
            _this._lazyProxy = new winjs_base_1.TPromise(function (c, e, p) {
                lazyProxyFulfill = c;
                lazyProxyReject = e;
            }, function () { });
            // Send initialize message
            _this._onModuleLoaded = _this._protocol.sendMessage(INITIALIZE, [
                _this._worker.getId(),
                moduleId,
                loaderConfiguration
            ]);
            _this._onModuleLoaded.then(function (availableMethods) {
                var proxy = {};
                for (var i = 0; i < availableMethods.length; i++) {
                    proxy[availableMethods[i]] = createProxyMethod(availableMethods[i], proxyMethodRequest);
                }
                lazyProxyFulfill(proxy);
            }, function (e) {
                lazyProxyReject(e);
                _this._onError('Worker failed to load ' + moduleId, e);
            });
            // Create proxy to loaded code
            var proxyMethodRequest = function (method, args) {
                return _this._request(method, args);
            };
            var createProxyMethod = function (method, proxyMethodRequest) {
                return function () {
                    var args = Array.prototype.slice.call(arguments, 0);
                    return proxyMethodRequest(method, args);
                };
            };
            return _this;
        }
        SimpleWorkerClient.prototype.getProxyObject = function () {
            // Do not allow chaining promises to cancel the proxy creation
            return new async_1.ShallowCancelThenPromise(this._lazyProxy);
        };
        SimpleWorkerClient.prototype.getLastRequestTimestamp = function () {
            return this._lastRequestTimestamp;
        };
        SimpleWorkerClient.prototype._request = function (method, args) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this._onModuleLoaded.then(function () {
                    _this._lastRequestTimestamp = Date.now();
                    _this._protocol.sendMessage(method, args).then(c, e);
                }, e);
            }, function () {
                // Cancel intentionally not supported
            });
        };
        SimpleWorkerClient.prototype._onError = function (message, error) {
            console.error(message);
            console.info(error);
        };
        return SimpleWorkerClient;
    }(lifecycle_1.Disposable));
    exports.SimpleWorkerClient = SimpleWorkerClient;
    /**
     * Worker side
     */
    var SimpleWorkerServer = (function () {
        function SimpleWorkerServer(postSerializedMessage) {
            var _this = this;
            this._protocol = new SimpleWorkerProtocol({
                sendMessage: function (msg) {
                    postSerializedMessage(msg);
                },
                handleMessage: function (method, args) { return _this._handleMessage(method, args); }
            });
        }
        SimpleWorkerServer.prototype.onmessage = function (msg) {
            this._protocol.handleMessage(msg);
        };
        SimpleWorkerServer.prototype._handleMessage = function (method, args) {
            if (method === INITIALIZE) {
                return this.initialize(args[0], args[1], args[2]);
            }
            if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));
            }
            try {
                return winjs_base_1.TPromise.as(this._requestHandler[method].apply(this._requestHandler, args));
            }
            catch (e) {
                return winjs_base_1.TPromise.wrapError(e);
            }
        };
        SimpleWorkerServer.prototype.initialize = function (workerId, moduleId, loaderConfig) {
            var _this = this;
            this._protocol.setWorkerId(workerId);
            if (loaderConfig) {
                // Remove 'baseUrl', handling it is beyond scope for now
                if (typeof loaderConfig.baseUrl !== 'undefined') {
                    delete loaderConfig['baseUrl'];
                }
                if (typeof loaderConfig.paths !== 'undefined') {
                    if (typeof loaderConfig.paths.vs !== 'undefined') {
                        delete loaderConfig.paths['vs'];
                    }
                }
                var nlsConfig_1 = loaderConfig['vs/nls'];
                // We need to have pseudo translation
                if (nlsConfig_1 && nlsConfig_1.pseudo) {
                    require(['vs/nls'], function (nlsPlugin) {
                        nlsPlugin.setPseudoTranslation(nlsConfig_1.pseudo);
                    });
                }
                // Since this is in a web worker, enable catching errors
                loaderConfig.catchError = true;
                self.require.config(loaderConfig);
            }
            var cc;
            var ee;
            var r = new winjs_base_1.TPromise(function (c, e, p) {
                cc = c;
                ee = e;
            });
            // Use the global require to be sure to get the global config
            self.require([moduleId], function () {
                var result = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    result[_i] = arguments[_i];
                }
                var handlerModule = result[0];
                _this._requestHandler = handlerModule.create();
                var methods = [];
                for (var prop in _this._requestHandler) {
                    if (typeof _this._requestHandler[prop] === 'function') {
                        methods.push(prop);
                    }
                }
                cc(methods);
            }, ee);
            return r;
        };
        return SimpleWorkerServer;
    }());
    exports.SimpleWorkerServer = SimpleWorkerServer;
    /**
     * Called on the worker side
     */
    function create(postMessage) {
        return new SimpleWorkerServer(postMessage);
    }
    exports.create = create;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[175/*vs/base/parts/quickopen/browser/quickOpenViewer*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,24/*vs/base/common/types*/]), function (require, exports, winjs_base_1, types_1) {
    "use strict";
    var DataSource = (function () {
        function DataSource(arg) {
            this.modelProvider = types_1.isFunction(arg.getModel) ? arg : { getModel: function () { return arg; } };
        }
        DataSource.prototype.getId = function (tree, element) {
            if (!element) {
                return null;
            }
            var model = this.modelProvider.getModel();
            return model === element ? '__root__' : model.dataSource.getId(element);
        };
        DataSource.prototype.hasChildren = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model && model === element && model.entries.length > 0;
        };
        DataSource.prototype.getChildren = function (tree, element) {
            var model = this.modelProvider.getModel();
            return winjs_base_1.TPromise.as(model === element ? model.entries : []);
        };
        DataSource.prototype.getParent = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        return DataSource;
    }());
    exports.DataSource = DataSource;
    var AccessibilityProvider = (function () {
        function AccessibilityProvider(modelProvider) {
            this.modelProvider = modelProvider;
        }
        AccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.accessibilityProvider && model.accessibilityProvider.getAriaLabel(element);
        };
        return AccessibilityProvider;
    }());
    exports.AccessibilityProvider = AccessibilityProvider;
    var Filter = (function () {
        function Filter(modelProvider) {
            this.modelProvider = modelProvider;
        }
        Filter.prototype.isVisible = function (tree, element) {
            var model = this.modelProvider.getModel();
            if (!model.filter) {
                return true;
            }
            return model.filter.isVisible(element);
        };
        return Filter;
    }());
    exports.Filter = Filter;
    var Renderer = (function () {
        function Renderer(modelProvider) {
            this.modelProvider = modelProvider;
        }
        Renderer.prototype.getHeight = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.renderer.getHeight(element);
        };
        Renderer.prototype.getTemplateId = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.renderer.getTemplateId(element);
        };
        Renderer.prototype.renderTemplate = function (tree, templateId, container) {
            var model = this.modelProvider.getModel();
            return model.renderer.renderTemplate(templateId, container);
        };
        Renderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            var model = this.modelProvider.getModel();
            model.renderer.renderElement(element, templateId, templateData);
        };
        Renderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            var model = this.modelProvider.getModel();
            model.renderer.disposeTemplate(templateId, templateData);
        };
        return Renderer;
    }());
    exports.Renderer = Renderer;
});

define(__m[84/*vs/base/parts/quickopen/common/quickOpen*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Mode;
    (function (Mode) {
        Mode[Mode["PREVIEW"] = 0] = "PREVIEW";
        Mode[Mode["OPEN"] = 1] = "OPEN";
        Mode[Mode["OPEN_IN_BACKGROUND"] = 2] = "OPEN_IN_BACKGROUND";
    })(Mode = exports.Mode || (exports.Mode = {}));
});






define(__m[178/*vs/base/parts/tree/browser/tree*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuEvent = (function () {
        function ContextMenuEvent(posx, posy, target) {
            this._posx = posx;
            this._posy = posy;
            this._target = target;
        }
        ContextMenuEvent.prototype.preventDefault = function () {
            // no-op
        };
        ContextMenuEvent.prototype.stopPropagation = function () {
            // no-op
        };
        Object.defineProperty(ContextMenuEvent.prototype, "posx", {
            get: function () {
                return this._posx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContextMenuEvent.prototype, "posy", {
            get: function () {
                return this._posy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContextMenuEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        return ContextMenuEvent;
    }());
    exports.ContextMenuEvent = ContextMenuEvent;
    var MouseContextMenuEvent = (function (_super) {
        __extends(MouseContextMenuEvent, _super);
        function MouseContextMenuEvent(originalEvent) {
            var _this = _super.call(this, originalEvent.posx, originalEvent.posy, originalEvent.target) || this;
            _this.originalEvent = originalEvent;
            return _this;
        }
        MouseContextMenuEvent.prototype.preventDefault = function () {
            this.originalEvent.preventDefault();
        };
        MouseContextMenuEvent.prototype.stopPropagation = function () {
            this.originalEvent.stopPropagation();
        };
        return MouseContextMenuEvent;
    }(ContextMenuEvent));
    exports.MouseContextMenuEvent = MouseContextMenuEvent;
    var KeyboardContextMenuEvent = (function (_super) {
        __extends(KeyboardContextMenuEvent, _super);
        function KeyboardContextMenuEvent(posx, posy, originalEvent) {
            var _this = _super.call(this, posx, posy, originalEvent.target) || this;
            _this.originalEvent = originalEvent;
            return _this;
        }
        KeyboardContextMenuEvent.prototype.preventDefault = function () {
            this.originalEvent.preventDefault();
        };
        KeyboardContextMenuEvent.prototype.stopPropagation = function () {
            this.originalEvent.stopPropagation();
        };
        return KeyboardContextMenuEvent;
    }(ContextMenuEvent));
    exports.KeyboardContextMenuEvent = KeyboardContextMenuEvent;
    var DragOverEffect;
    (function (DragOverEffect) {
        DragOverEffect[DragOverEffect["COPY"] = 0] = "COPY";
        DragOverEffect[DragOverEffect["MOVE"] = 1] = "MOVE";
    })(DragOverEffect = exports.DragOverEffect || (exports.DragOverEffect = {}));
    var DragOverBubble;
    (function (DragOverBubble) {
        DragOverBubble[DragOverBubble["BUBBLE_DOWN"] = 0] = "BUBBLE_DOWN";
        DragOverBubble[DragOverBubble["BUBBLE_UP"] = 1] = "BUBBLE_UP";
    })(DragOverBubble = exports.DragOverBubble || (exports.DragOverBubble = {}));
    exports.DRAG_OVER_REJECT = { accept: false };
    exports.DRAG_OVER_ACCEPT = { accept: true };
    exports.DRAG_OVER_ACCEPT_BUBBLE_UP = { accept: true, bubble: DragOverBubble.BUBBLE_UP };
    exports.DRAG_OVER_ACCEPT_BUBBLE_DOWN = function (autoExpand) {
        if (autoExpand === void 0) { autoExpand = false; }
        return ({ accept: true, bubble: DragOverBubble.BUBBLE_DOWN, autoExpand: autoExpand });
    };
    exports.DRAG_OVER_ACCEPT_BUBBLE_UP_COPY = { accept: true, bubble: DragOverBubble.BUBBLE_UP, effect: DragOverEffect.COPY };
    exports.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY = function (autoExpand) {
        if (autoExpand === void 0) { autoExpand = false; }
        return ({ accept: true, bubble: DragOverBubble.BUBBLE_DOWN, effect: DragOverEffect.COPY });
    };
});

define(__m[181/*vs/base/parts/tree/browser/treeDnd*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ElementsDragAndDropData = (function () {
        function ElementsDragAndDropData(elements) {
            this.elements = elements;
        }
        ElementsDragAndDropData.prototype.update = function (event) {
            // no-op
        };
        ElementsDragAndDropData.prototype.getData = function () {
            return this.elements;
        };
        return ElementsDragAndDropData;
    }());
    exports.ElementsDragAndDropData = ElementsDragAndDropData;
    var ExternalElementsDragAndDropData = (function () {
        function ExternalElementsDragAndDropData(elements) {
            this.elements = elements;
        }
        ExternalElementsDragAndDropData.prototype.update = function (event) {
            // no-op
        };
        ExternalElementsDragAndDropData.prototype.getData = function () {
            return this.elements;
        };
        return ExternalElementsDragAndDropData;
    }());
    exports.ExternalElementsDragAndDropData = ExternalElementsDragAndDropData;
    var DesktopDragAndDropData = (function () {
        function DesktopDragAndDropData() {
            this.types = [];
            this.files = [];
        }
        DesktopDragAndDropData.prototype.update = function (event) {
            if (event.dataTransfer.types) {
                this.types = [];
                Array.prototype.push.apply(this.types, event.dataTransfer.types);
            }
            if (event.dataTransfer.files) {
                this.files = [];
                Array.prototype.push.apply(this.files, event.dataTransfer.files);
                this.files = this.files.filter(function (f) { return f.size || f.type; });
            }
        };
        DesktopDragAndDropData.prototype.getData = function () {
            return {
                types: this.types,
                files: this.files
            };
        };
        return DesktopDragAndDropData;
    }());
    exports.DesktopDragAndDropData = DesktopDragAndDropData;
});






define(__m[183/*vs/base/parts/tree/browser/treeModel*/], __M([1/*require*/,0/*exports*/,63/*vs/base/common/assert*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,28/*vs/base/common/arrays*/,25/*vs/base/common/eventEmitter*/,6/*vs/base/common/winjs.base*/]), function (require, exports, Assert, errors_1, lifecycle_1, arrays, Events, WinJS) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LockData = (function (_super) {
        __extends(LockData, _super);
        function LockData(item) {
            var _this = _super.call(this) || this;
            _this._item = item;
            return _this;
        }
        Object.defineProperty(LockData.prototype, "item", {
            get: function () {
                return this._item;
            },
            enumerable: true,
            configurable: true
        });
        LockData.prototype.dispose = function () {
            this.emit('unlock');
            _super.prototype.dispose.call(this);
        };
        return LockData;
    }(Events.EventEmitter));
    exports.LockData = LockData;
    var Lock = (function () {
        function Lock() {
            this.locks = Object.create({});
        }
        Lock.prototype.isLocked = function (item) {
            return !!this.locks[item.id];
        };
        Lock.prototype.run = function (item, fn) {
            var _this = this;
            var lock = this.getLock(item);
            if (lock) {
                var unbindListener;
                return new WinJS.Promise(function (c, e) {
                    unbindListener = lock.addOneTimeDisposableListener('unlock', function () {
                        return _this.run(item, fn).then(c, e);
                    });
                }, function () { unbindListener.dispose(); });
            }
            var result;
            return new WinJS.Promise(function (c, e) {
                if (item.isDisposed()) {
                    return e(new Error('Item is disposed.'));
                }
                var lock = _this.locks[item.id] = new LockData(item);
                result = fn().then(function (r) {
                    delete _this.locks[item.id];
                    lock.dispose();
                    return r;
                }).then(c, e);
                return result;
            }, function () { return result.cancel(); });
        };
        Lock.prototype.getLock = function (item) {
            var key;
            for (key in this.locks) {
                var lock = this.locks[key];
                if (item.intersects(lock.item)) {
                    return lock;
                }
            }
            return null;
        };
        return Lock;
    }());
    exports.Lock = Lock;
    var ItemRegistry = (function (_super) {
        __extends(ItemRegistry, _super);
        function ItemRegistry() {
            var _this = _super.call(this) || this;
            _this._isDisposed = false;
            _this.items = {};
            return _this;
        }
        ItemRegistry.prototype.register = function (item) {
            Assert.ok(!this.isRegistered(item.id), 'item already registered: ' + item.id);
            this.items[item.id] = { item: item, disposable: this.addEmitter2(item) };
        };
        ItemRegistry.prototype.deregister = function (item) {
            Assert.ok(this.isRegistered(item.id), 'item not registered: ' + item.id);
            this.items[item.id].disposable.dispose();
            delete this.items[item.id];
        };
        ItemRegistry.prototype.isRegistered = function (id) {
            return this.items.hasOwnProperty(id);
        };
        ItemRegistry.prototype.getItem = function (id) {
            var result = this.items[id];
            return result ? result.item : null;
        };
        ItemRegistry.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.items = null;
            this._isDisposed = true;
        };
        ItemRegistry.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        return ItemRegistry;
    }(Events.EventEmitter));
    exports.ItemRegistry = ItemRegistry;
    var Item = (function (_super) {
        __extends(Item, _super);
        function Item(id, registry, context, lock, element) {
            var _this = _super.call(this) || this;
            _this.registry = registry;
            _this.context = context;
            _this.lock = lock;
            _this.element = element;
            _this.id = id;
            _this.registry.register(_this);
            _this.doesHaveChildren = _this.context.dataSource.hasChildren(_this.context.tree, _this.element);
            _this.needsChildrenRefresh = true;
            _this.parent = null;
            _this.previous = null;
            _this.next = null;
            _this.firstChild = null;
            _this.lastChild = null;
            _this.userContent = null;
            _this.traits = {};
            _this.depth = 0;
            _this.expanded = false;
            _this.emit('item:create', { item: _this });
            _this.visible = _this._isVisible();
            _this.height = _this._getHeight();
            _this._isDisposed = false;
            return _this;
        }
        Item.prototype.getElement = function () {
            return this.element;
        };
        Item.prototype.hasChildren = function () {
            return this.doesHaveChildren;
        };
        Item.prototype.getDepth = function () {
            return this.depth;
        };
        Item.prototype.isVisible = function () {
            return this.visible;
        };
        Item.prototype.setVisible = function (value) {
            this.visible = value;
        };
        Item.prototype.isExpanded = function () {
            return this.expanded;
        };
        /* protected */ Item.prototype._setExpanded = function (value) {
            this.expanded = value;
        };
        Item.prototype.reveal = function (relativeTop) {
            if (relativeTop === void 0) { relativeTop = null; }
            var eventData = { item: this, relativeTop: relativeTop };
            this.emit('item:reveal', eventData);
        };
        Item.prototype.expand = function () {
            var _this = this;
            if (this.isExpanded() || !this.doesHaveChildren || this.lock.isLocked(this)) {
                return WinJS.TPromise.as(false);
            }
            var result = this.lock.run(this, function () {
                var eventData = { item: _this };
                var result;
                _this.emit('item:expanding', eventData);
                if (_this.needsChildrenRefresh) {
                    result = _this.refreshChildren(false, true, true);
                }
                else {
                    result = WinJS.TPromise.as(null);
                }
                return result.then(function () {
                    _this._setExpanded(true);
                    _this.emit('item:expanded', eventData);
                    return true;
                });
            });
            return result.then(function (r) {
                if (_this.isDisposed()) {
                    return false;
                }
                // Auto expand single child folders
                if (_this.context.options.autoExpandSingleChildren && r && _this.firstChild !== null && _this.firstChild === _this.lastChild && _this.firstChild.isVisible()) {
                    return _this.firstChild.expand().then(function () { return true; });
                }
                return r;
            });
        };
        Item.prototype.collapse = function (recursive) {
            var _this = this;
            if (recursive === void 0) { recursive = false; }
            if (recursive) {
                var collapseChildrenPromise = WinJS.TPromise.as(null);
                this.forEachChild(function (child) {
                    collapseChildrenPromise = collapseChildrenPromise.then(function () { return child.collapse(true); });
                });
                return collapseChildrenPromise.then(function () {
                    return _this.collapse(false);
                });
            }
            else {
                if (!this.isExpanded() || this.lock.isLocked(this)) {
                    return WinJS.TPromise.as(false);
                }
                return this.lock.run(this, function () {
                    var eventData = { item: _this };
                    _this.emit('item:collapsing', eventData);
                    _this._setExpanded(false);
                    _this.emit('item:collapsed', eventData);
                    return WinJS.TPromise.as(true);
                });
            }
        };
        Item.prototype.addTrait = function (trait) {
            var eventData = { item: this, trait: trait };
            this.traits[trait] = true;
            this.emit('item:addTrait', eventData);
        };
        Item.prototype.removeTrait = function (trait) {
            var eventData = { item: this, trait: trait };
            delete this.traits[trait];
            this.emit('item:removeTrait', eventData);
        };
        Item.prototype.hasTrait = function (trait) {
            return this.traits[trait] || false;
        };
        Item.prototype.getAllTraits = function () {
            var result = [];
            var trait;
            for (trait in this.traits) {
                if (this.traits.hasOwnProperty(trait) && this.traits[trait]) {
                    result.push(trait);
                }
            }
            return result;
        };
        Item.prototype.getHeight = function () {
            return this.height;
        };
        Item.prototype.refreshChildren = function (recursive, safe, force) {
            var _this = this;
            if (safe === void 0) { safe = false; }
            if (force === void 0) { force = false; }
            if (!force && !this.isExpanded()) {
                this.needsChildrenRefresh = true;
                return WinJS.TPromise.as(this);
            }
            this.needsChildrenRefresh = false;
            var doRefresh = function () {
                var eventData = { item: _this, isNested: safe };
                _this.emit('item:childrenRefreshing', eventData);
                var childrenPromise;
                if (_this.doesHaveChildren) {
                    childrenPromise = _this.context.dataSource.getChildren(_this.context.tree, _this.element);
                }
                else {
                    childrenPromise = WinJS.TPromise.as([]);
                }
                var result = childrenPromise.then(function (elements) {
                    if (_this.isDisposed() || _this.registry.isDisposed()) {
                        return WinJS.TPromise.as(null);
                    }
                    elements = !elements ? [] : elements.slice(0);
                    elements = _this.sort(elements);
                    var staleItems = {};
                    while (_this.firstChild !== null) {
                        staleItems[_this.firstChild.id] = _this.firstChild;
                        _this.removeChild(_this.firstChild);
                    }
                    for (var i = 0, len = elements.length; i < len; i++) {
                        var element = elements[i];
                        var id = _this.context.dataSource.getId(_this.context.tree, element);
                        var item = staleItems[id] || new Item(id, _this.registry, _this.context, _this.lock, element);
                        item.element = element;
                        if (recursive) {
                            item.needsChildrenRefresh = recursive;
                        }
                        delete staleItems[id];
                        _this.addChild(item);
                    }
                    for (var staleItemId in staleItems) {
                        if (staleItems.hasOwnProperty(staleItemId)) {
                            staleItems[staleItemId].dispose();
                        }
                    }
                    if (recursive) {
                        return WinJS.Promise.join(_this.mapEachChild(function (child) {
                            return child.doRefresh(recursive, true);
                        }));
                    }
                    else {
                        return WinJS.TPromise.as(null);
                    }
                });
                return result
                    .then(null, errors_1.onUnexpectedError)
                    .then(function () { return _this.emit('item:childrenRefreshed', eventData); });
            };
            return safe ? doRefresh() : this.lock.run(this, doRefresh);
        };
        Item.prototype.doRefresh = function (recursive, safe) {
            if (safe === void 0) { safe = false; }
            var eventData = { item: this };
            this.doesHaveChildren = this.context.dataSource.hasChildren(this.context.tree, this.element);
            this.height = this._getHeight();
            this.setVisible(this._isVisible());
            this.emit('item:refresh', eventData);
            return this.refreshChildren(recursive, safe);
        };
        Item.prototype.refresh = function (recursive) {
            return this.doRefresh(recursive);
        };
        Item.prototype.getNavigator = function () {
            return new TreeNavigator(this);
        };
        Item.prototype.intersects = function (other) {
            return this.isAncestorOf(other) || other.isAncestorOf(this);
        };
        Item.prototype.getHierarchy = function () {
            var result = [];
            var node = this;
            do {
                result.push(node);
                node = node.parent;
            } while (node);
            result.reverse();
            return result;
        };
        Item.prototype.isAncestorOf = function (item) {
            while (item) {
                if (item.id === this.id) {
                    return true;
                }
                item = item.parent;
            }
            return false;
        };
        Item.prototype.addChild = function (item, afterItem) {
            if (afterItem === void 0) { afterItem = this.lastChild; }
            var isEmpty = this.firstChild === null;
            var atHead = afterItem === null;
            var atTail = afterItem === this.lastChild;
            if (isEmpty) {
                this.firstChild = this.lastChild = item;
                item.next = item.previous = null;
            }
            else if (atHead) {
                this.firstChild.previous = item;
                item.next = this.firstChild;
                item.previous = null;
                this.firstChild = item;
            }
            else if (atTail) {
                this.lastChild.next = item;
                item.next = null;
                item.previous = this.lastChild;
                this.lastChild = item;
            }
            else {
                item.previous = afterItem;
                item.next = afterItem.next;
                afterItem.next.previous = item;
                afterItem.next = item;
            }
            item.parent = this;
            item.depth = this.depth + 1;
        };
        Item.prototype.removeChild = function (item) {
            var isFirstChild = this.firstChild === item;
            var isLastChild = this.lastChild === item;
            if (isFirstChild && isLastChild) {
                this.firstChild = this.lastChild = null;
            }
            else if (isFirstChild) {
                item.next.previous = null;
                this.firstChild = item.next;
            }
            else if (isLastChild) {
                item.previous.next = null;
                this.lastChild = item.previous;
            }
            else {
                item.next.previous = item.previous;
                item.previous.next = item.next;
            }
            item.parent = null;
            item.depth = null;
        };
        Item.prototype.forEachChild = function (fn) {
            var child = this.firstChild, next;
            while (child) {
                next = child.next;
                fn(child);
                child = next;
            }
        };
        Item.prototype.mapEachChild = function (fn) {
            var result = [];
            this.forEachChild(function (child) {
                result.push(fn(child));
            });
            return result;
        };
        Item.prototype.sort = function (elements) {
            var _this = this;
            if (this.context.sorter) {
                return elements.sort(function (element, otherElement) {
                    return _this.context.sorter.compare(_this.context.tree, element, otherElement);
                });
            }
            return elements;
        };
        /* protected */ Item.prototype._getHeight = function () {
            return this.context.renderer.getHeight(this.context.tree, this.element);
        };
        /* protected */ Item.prototype._isVisible = function () {
            return this.context.filter.isVisible(this.context.tree, this.element);
        };
        Item.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        Item.prototype.dispose = function () {
            this.forEachChild(function (child) { return child.dispose(); });
            this.parent = null;
            this.previous = null;
            this.next = null;
            this.firstChild = null;
            this.lastChild = null;
            var eventData = { item: this };
            this.emit('item:dispose', eventData);
            this.registry.deregister(this);
            _super.prototype.dispose.call(this);
            this._isDisposed = true;
        };
        return Item;
    }(Events.EventEmitter));
    exports.Item = Item;
    var RootItem = (function (_super) {
        __extends(RootItem, _super);
        function RootItem(id, registry, context, lock, element) {
            return _super.call(this, id, registry, context, lock, element) || this;
        }
        RootItem.prototype.isVisible = function () {
            return false;
        };
        RootItem.prototype.setVisible = function (value) {
            // no-op
        };
        RootItem.prototype.isExpanded = function () {
            return true;
        };
        /* protected */ RootItem.prototype._setExpanded = function (value) {
            // no-op
        };
        RootItem.prototype.render = function () {
            // no-op
        };
        /* protected */ RootItem.prototype._getHeight = function () {
            return 0;
        };
        /* protected */ RootItem.prototype._isVisible = function () {
            return false;
        };
        return RootItem;
    }(Item));
    var TreeNavigator = (function () {
        function TreeNavigator(item, subTreeOnly) {
            if (subTreeOnly === void 0) { subTreeOnly = true; }
            this.item = item;
            this.start = subTreeOnly ? item : null;
        }
        TreeNavigator.lastDescendantOf = function (item) {
            if (!item) {
                return null;
            }
            else {
                if (!item.isVisible() || !item.isExpanded() || item.lastChild === null) {
                    return item;
                }
                else {
                    return TreeNavigator.lastDescendantOf(item.lastChild);
                }
            }
        };
        TreeNavigator.prototype.current = function () {
            return this.item || null;
        };
        TreeNavigator.prototype.next = function () {
            if (this.item) {
                do {
                    if ((this.item instanceof RootItem || (this.item.isVisible() && this.item.isExpanded())) && this.item.firstChild) {
                        this.item = this.item.firstChild;
                    }
                    else if (this.item === this.start) {
                        this.item = null;
                    }
                    else {
                        // select next brother, next uncle, next great-uncle, etc...
                        while (this.item && this.item !== this.start && !this.item.next) {
                            this.item = this.item.parent;
                        }
                        if (this.item === this.start) {
                            this.item = null;
                        }
                        this.item = !this.item ? null : this.item.next;
                    }
                } while (this.item && !this.item.isVisible());
            }
            return this.item || null;
        };
        TreeNavigator.prototype.previous = function () {
            if (this.item) {
                do {
                    var previous = TreeNavigator.lastDescendantOf(this.item.previous);
                    if (previous) {
                        this.item = previous;
                    }
                    else if (this.item.parent && this.item.parent !== this.start && this.item.parent.isVisible()) {
                        this.item = this.item.parent;
                    }
                    else {
                        this.item = null;
                    }
                } while (this.item && !this.item.isVisible());
            }
            return this.item || null;
        };
        TreeNavigator.prototype.parent = function () {
            if (this.item) {
                var parent = this.item.parent;
                if (parent && parent !== this.start && parent.isVisible()) {
                    this.item = parent;
                }
                else {
                    this.item = null;
                }
            }
            return this.item || null;
        };
        TreeNavigator.prototype.first = function () {
            this.item = this.start;
            this.next();
            return this.item || null;
        };
        TreeNavigator.prototype.last = function () {
            if (this.start && this.start.isExpanded()) {
                this.item = this.start.lastChild;
                if (this.item && !this.item.isVisible()) {
                    this.previous();
                }
            }
            return this.item || null;
        };
        return TreeNavigator;
    }());
    exports.TreeNavigator = TreeNavigator;
    function getRange(one, other) {
        var oneHierarchy = one.getHierarchy();
        var otherHierarchy = other.getHierarchy();
        var length = arrays.commonPrefixLength(oneHierarchy, otherHierarchy);
        var item = oneHierarchy[length - 1];
        var nav = item.getNavigator();
        var oneIndex = null;
        var otherIndex = null;
        var index = 0;
        var result = [];
        while (item && (oneIndex === null || otherIndex === null)) {
            result.push(item);
            if (item === one) {
                oneIndex = index;
            }
            if (item === other) {
                otherIndex = index;
            }
            index++;
            item = nav.next();
        }
        if (oneIndex === null || otherIndex === null) {
            return [];
        }
        var min = Math.min(oneIndex, otherIndex);
        var max = Math.max(oneIndex, otherIndex);
        return result.slice(min, max + 1);
    }
    var TreeModel = (function (_super) {
        __extends(TreeModel, _super);
        function TreeModel(context) {
            var _this = _super.call(this) || this;
            _this.context = context;
            _this.input = null;
            _this.traitsToItems = {};
            return _this;
        }
        TreeModel.prototype.setInput = function (element) {
            var _this = this;
            var eventData = { item: this.input };
            this.emit('clearingInput', eventData);
            this.setSelection([]);
            this.setFocus();
            this.setHighlight();
            this.lock = new Lock();
            if (this.input) {
                this.input.dispose();
            }
            if (this.registry) {
                this.registry.dispose();
                this.registryDisposable.dispose();
            }
            this.registry = new ItemRegistry();
            this.registryDisposable = lifecycle_1.combinedDisposable([
                this.addEmitter2(this.registry),
                this.registry.addListener2('item:dispose', function (event) {
                    event.item.getAllTraits()
                        .forEach(function (trait) { return delete _this.traitsToItems[trait][event.item.id]; });
                })
            ]);
            var id = this.context.dataSource.getId(this.context.tree, element);
            this.input = new RootItem(id, this.registry, this.context, this.lock, element);
            eventData = { item: this.input };
            this.emit('setInput', eventData);
            return this.refresh(this.input);
        };
        TreeModel.prototype.getInput = function () {
            return this.input ? this.input.getElement() : null;
        };
        TreeModel.prototype.refresh = function (element, recursive) {
            var _this = this;
            if (element === void 0) { element = null; }
            if (recursive === void 0) { recursive = true; }
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(null);
            }
            var eventData = { item: item, recursive: recursive };
            this.emit('refreshing', eventData);
            return item.refresh(recursive).then(function () {
                _this.emit('refreshed', eventData);
            });
        };
        TreeModel.prototype.refreshAll = function (elements, recursive) {
            if (recursive === void 0) { recursive = true; }
            try {
                this._beginDeferredEmit();
                return this._refreshAll(elements, recursive);
            }
            finally {
                this._endDeferredEmit();
            }
        };
        TreeModel.prototype._refreshAll = function (elements, recursive) {
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.refresh(elements[i], recursive));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.expand = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(false);
            }
            return item.expand();
        };
        TreeModel.prototype.expandAll = function (elements) {
            if (!elements) {
                elements = [];
                var item;
                var nav = this.getNavigator();
                while (item = nav.next()) {
                    elements.push(item);
                }
            }
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.expand(elements[i]));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.collapse = function (element, recursive) {
            if (recursive === void 0) { recursive = false; }
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(false);
            }
            return item.collapse(recursive);
        };
        TreeModel.prototype.collapseAll = function (elements, recursive) {
            if (elements === void 0) { elements = null; }
            if (recursive === void 0) { recursive = false; }
            if (!elements) {
                elements = [this.input];
                recursive = true;
            }
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.collapse(elements[i], recursive));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.toggleExpansion = function (element) {
            return this.isExpanded(element) ? this.collapse(element) : this.expand(element);
        };
        TreeModel.prototype.toggleExpansionAll = function (elements) {
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.toggleExpansion(elements[i]));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.isExpanded = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.isExpanded();
        };
        TreeModel.prototype.getExpandedElements = function () {
            var result = [];
            var item;
            var nav = this.getNavigator();
            while (item = nav.next()) {
                if (item.isExpanded()) {
                    result.push(item.getElement());
                }
            }
            return result;
        };
        TreeModel.prototype.reveal = function (element, relativeTop) {
            var _this = this;
            if (relativeTop === void 0) { relativeTop = null; }
            return this.resolveUnknownParentChain(element).then(function (chain) {
                var result = WinJS.TPromise.as(null);
                chain.forEach(function (e) {
                    result = result.then(function () { return _this.expand(e); });
                });
                return result;
            }).then(function () {
                var item = _this.getItem(element);
                if (item) {
                    return item.reveal(relativeTop);
                }
            });
        };
        TreeModel.prototype.resolveUnknownParentChain = function (element) {
            var _this = this;
            return this.context.dataSource.getParent(this.context.tree, element).then(function (parent) {
                if (!parent) {
                    return WinJS.TPromise.as([]);
                }
                return _this.resolveUnknownParentChain(parent).then(function (result) {
                    result.push(parent);
                    return result;
                });
            });
        };
        TreeModel.prototype.setHighlight = function (element, eventPayload) {
            this.setTraits('highlighted', element ? [element] : []);
            var eventData = { highlight: this.getHighlight(), payload: eventPayload };
            this.emit('highlight', eventData);
        };
        TreeModel.prototype.getHighlight = function (includeHidden) {
            var result = this.getElementsWithTrait('highlighted', includeHidden);
            return result.length === 0 ? null : result[0];
        };
        TreeModel.prototype.isHighlighted = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('highlighted');
        };
        TreeModel.prototype.select = function (element, eventPayload) {
            this.selectAll([element], eventPayload);
        };
        TreeModel.prototype.selectRange = function (fromElement, toElement, eventPayload) {
            var fromItem = this.getItem(fromElement);
            var toItem = this.getItem(toElement);
            if (!fromItem || !toItem) {
                return;
            }
            this.selectAll(getRange(fromItem, toItem), eventPayload);
        };
        TreeModel.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
            var fromItem = this.getItem(fromElement);
            var toItem = this.getItem(toElement);
            if (!fromItem || !toItem) {
                return;
            }
            this.deselectAll(getRange(fromItem, toItem), eventPayload);
        };
        TreeModel.prototype.selectAll = function (elements, eventPayload) {
            this.addTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.deselect = function (element, eventPayload) {
            this.deselectAll([element], eventPayload);
        };
        TreeModel.prototype.deselectAll = function (elements, eventPayload) {
            this.removeTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.setSelection = function (elements, eventPayload) {
            this.setTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.toggleSelection = function (element, eventPayload) {
            this.toggleTrait('selected', element);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.isSelected = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('selected');
        };
        TreeModel.prototype.getSelection = function (includeHidden) {
            return this.getElementsWithTrait('selected', includeHidden);
        };
        TreeModel.prototype.selectNext = function (count, clearSelection, eventPayload) {
            if (count === void 0) { count = 1; }
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection();
            var item = selection.length > 0 ? selection[0] : this.input;
            var nextItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                nextItem = nav.next();
                if (!nextItem) {
                    break;
                }
                item = nextItem;
            }
            if (clearSelection) {
                this.setSelection([item], eventPayload);
            }
            else {
                this.select(item, eventPayload);
            }
        };
        TreeModel.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
            if (count === void 0) { count = 1; }
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection(), item = null, previousItem = null;
            if (selection.length === 0) {
                var nav = this.getNavigator(this.input);
                while (item = nav.next()) {
                    previousItem = item;
                }
                item = previousItem;
            }
            else {
                item = selection[0];
                var nav = this.getNavigator(item, false);
                for (var i = 0; i < count; i++) {
                    previousItem = nav.previous();
                    if (!previousItem) {
                        break;
                    }
                    item = previousItem;
                }
            }
            if (clearSelection) {
                this.setSelection([item], eventPayload);
            }
            else {
                this.select(item, eventPayload);
            }
        };
        TreeModel.prototype.selectParent = function (eventPayload, clearSelection) {
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection();
            var item = selection.length > 0 ? selection[0] : this.input;
            var nav = this.getNavigator(item, false);
            var parent = nav.parent();
            if (parent) {
                if (clearSelection) {
                    this.setSelection([parent], eventPayload);
                }
                else {
                    this.select(parent, eventPayload);
                }
            }
        };
        TreeModel.prototype.setFocus = function (element, eventPayload) {
            this.setTraits('focused', element ? [element] : []);
            var eventData = { focus: this.getFocus(), payload: eventPayload };
            this.emit('focus', eventData);
        };
        TreeModel.prototype.isFocused = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('focused');
        };
        TreeModel.prototype.getFocus = function (includeHidden) {
            var result = this.getElementsWithTrait('focused', includeHidden);
            return result.length === 0 ? null : result[0];
        };
        TreeModel.prototype.focusNext = function (count, eventPayload) {
            if (count === void 0) { count = 1; }
            var item = this.getFocus() || this.input;
            var nextItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                nextItem = nav.next();
                if (!nextItem) {
                    break;
                }
                item = nextItem;
            }
            this.setFocus(item, eventPayload);
        };
        TreeModel.prototype.focusPrevious = function (count, eventPayload) {
            if (count === void 0) { count = 1; }
            var item = this.getFocus() || this.input;
            var previousItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                previousItem = nav.previous();
                if (!previousItem) {
                    break;
                }
                item = previousItem;
            }
            this.setFocus(item, eventPayload);
        };
        TreeModel.prototype.focusParent = function (eventPayload) {
            var item = this.getFocus() || this.input;
            var nav = this.getNavigator(item, false);
            var parent = nav.parent();
            if (parent) {
                this.setFocus(parent, eventPayload);
            }
        };
        TreeModel.prototype.focusFirstChild = function (eventPayload) {
            var item = this.getItem(this.getFocus() || this.input);
            var nav = this.getNavigator(item, false);
            var next = nav.next();
            var parent = nav.parent();
            if (parent === item) {
                this.setFocus(next, eventPayload);
            }
        };
        TreeModel.prototype.focusFirst = function (eventPayload) {
            this.focusNth(0, eventPayload);
        };
        TreeModel.prototype.focusNth = function (index, eventPayload) {
            var nav = this.getNavigator(this.input);
            var item = nav.first();
            for (var i = 0; i < index; i++) {
                item = nav.next();
            }
            if (item) {
                this.setFocus(item, eventPayload);
            }
        };
        TreeModel.prototype.focusLast = function (eventPayload) {
            var nav = this.getNavigator(this.input);
            var item = nav.last();
            if (item) {
                this.setFocus(item, eventPayload);
            }
        };
        TreeModel.prototype.getNavigator = function (element, subTreeOnly) {
            if (element === void 0) { element = null; }
            if (subTreeOnly === void 0) { subTreeOnly = true; }
            return new TreeNavigator(this.getItem(element), subTreeOnly);
        };
        TreeModel.prototype.getItem = function (element) {
            if (element === void 0) { element = null; }
            if (element === null) {
                return this.input;
            }
            else if (element instanceof Item) {
                return element;
            }
            else if (typeof element === 'string') {
                return this.registry.getItem(element);
            }
            else {
                return this.registry.getItem(this.context.dataSource.getId(this.context.tree, element));
            }
        };
        TreeModel.prototype.addTraits = function (trait, elements) {
            var items = this.traitsToItems[trait] || {};
            var item;
            for (var i = 0, len = elements.length; i < len; i++) {
                item = this.getItem(elements[i]);
                if (item) {
                    item.addTrait(trait);
                    items[item.id] = item;
                }
            }
            this.traitsToItems[trait] = items;
        };
        TreeModel.prototype.removeTraits = function (trait, elements) {
            var items = this.traitsToItems[trait] || {};
            var item;
            var id;
            if (elements.length === 0) {
                for (id in items) {
                    if (items.hasOwnProperty(id)) {
                        item = items[id];
                        item.removeTrait(trait);
                    }
                }
                delete this.traitsToItems[trait];
            }
            else {
                for (var i = 0, len = elements.length; i < len; i++) {
                    item = this.getItem(elements[i]);
                    if (item) {
                        item.removeTrait(trait);
                        delete items[item.id];
                    }
                }
            }
        };
        TreeModel.prototype.hasTrait = function (trait, element) {
            var item = this.getItem(element);
            return item && item.hasTrait(trait);
        };
        TreeModel.prototype.toggleTrait = function (trait, element) {
            var item = this.getItem(element);
            if (!item) {
                return;
            }
            if (item.hasTrait(trait)) {
                this.removeTraits(trait, [element]);
            }
            else {
                this.addTraits(trait, [element]);
            }
        };
        TreeModel.prototype.setTraits = function (trait, elements) {
            if (elements.length === 0) {
                this.removeTraits(trait, elements);
            }
            else {
                var items = {};
                var item;
                for (var i = 0, len = elements.length; i < len; i++) {
                    item = this.getItem(elements[i]);
                    if (item) {
                        items[item.id] = item;
                    }
                }
                var traitItems = this.traitsToItems[trait] || {};
                var itemsToRemoveTrait = [];
                var id;
                for (id in traitItems) {
                    if (traitItems.hasOwnProperty(id)) {
                        if (items.hasOwnProperty(id)) {
                            delete items[id];
                        }
                        else {
                            itemsToRemoveTrait.push(traitItems[id]);
                        }
                    }
                }
                for (var i = 0, len = itemsToRemoveTrait.length; i < len; i++) {
                    item = itemsToRemoveTrait[i];
                    item.removeTrait(trait);
                    delete traitItems[item.id];
                }
                for (id in items) {
                    if (items.hasOwnProperty(id)) {
                        item = items[id];
                        item.addTrait(trait);
                        traitItems[id] = item;
                    }
                }
                this.traitsToItems[trait] = traitItems;
            }
        };
        TreeModel.prototype.getElementsWithTrait = function (trait, includeHidden) {
            var elements = [];
            var items = this.traitsToItems[trait] || {};
            var id;
            for (id in items) {
                if (items.hasOwnProperty(id) && (items[id].isVisible() || includeHidden)) {
                    elements.push(items[id].getElement());
                }
            }
            return elements;
        };
        TreeModel.prototype.dispose = function () {
            if (this.registry) {
                this.registry.dispose();
                this.registry = null;
            }
            _super.prototype.dispose.call(this);
        };
        return TreeModel;
    }(Events.EventEmitter));
    exports.TreeModel = TreeModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[185/*vs/base/parts/tree/browser/treeViewModel*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,88/*vs/base/common/iterator*/]), function (require, exports, eventEmitter_1, iterator_1) {
    "use strict";
    var HeightMap = (function (_super) {
        __extends(HeightMap, _super);
        function HeightMap() {
            var _this = _super.call(this) || this;
            _this.heightMap = [];
            _this.indexes = {};
            return _this;
        }
        HeightMap.prototype.getTotalHeight = function () {
            var last = this.heightMap[this.heightMap.length - 1];
            return !last ? 0 : last.top + last.height;
        };
        HeightMap.prototype.onInsertItems = function (iterator, afterItemId) {
            if (afterItemId === void 0) { afterItemId = null; }
            var item;
            var viewItem;
            var i, j;
            var totalSize;
            var sizeDiff = 0;
            if (afterItemId === null) {
                i = 0;
                totalSize = 0;
            }
            else {
                i = this.indexes[afterItemId] + 1;
                viewItem = this.heightMap[i - 1];
                if (!viewItem) {
                    console.error('view item doesnt exist');
                    return;
                }
                totalSize = viewItem.top + viewItem.height;
            }
            var boundSplice = this.heightMap.splice.bind(this.heightMap, i, 0);
            var itemsToInsert = [];
            while (item = iterator.next()) {
                viewItem = this.createViewItem(item);
                viewItem.top = totalSize + sizeDiff;
                this.emit('viewItem:create', { item: viewItem.model });
                this.indexes[item.id] = i++;
                itemsToInsert.push(viewItem);
                sizeDiff += viewItem.height;
            }
            boundSplice.apply(this.heightMap, itemsToInsert);
            for (j = i; j < this.heightMap.length; j++) {
                viewItem = this.heightMap[j];
                viewItem.top += sizeDiff;
                this.indexes[viewItem.model.id] = j;
            }
            for (j = itemsToInsert.length - 1; j >= 0; j--) {
                this.onInsertItem(itemsToInsert[j]);
            }
            for (j = this.heightMap.length - 1; j >= i; j--) {
                this.onRefreshItem(this.heightMap[j]);
            }
            return sizeDiff;
        };
        HeightMap.prototype.onInsertItem = function (item) {
            // noop
        };
        // Contiguous items
        HeightMap.prototype.onRemoveItems = function (iterator) {
            var itemId;
            var viewItem;
            var startIndex = null;
            var i;
            var sizeDiff = 0;
            while (itemId = iterator.next()) {
                i = this.indexes[itemId];
                viewItem = this.heightMap[i];
                if (!viewItem) {
                    console.error('view item doesnt exist');
                    return;
                }
                sizeDiff -= viewItem.height;
                delete this.indexes[itemId];
                this.onRemoveItem(viewItem);
                if (startIndex === null) {
                    startIndex = i;
                }
            }
            if (sizeDiff === 0) {
                return;
            }
            this.heightMap.splice(startIndex, i - startIndex + 1);
            for (i = startIndex; i < this.heightMap.length; i++) {
                viewItem = this.heightMap[i];
                viewItem.top += sizeDiff;
                this.indexes[viewItem.model.id] = i;
                this.onRefreshItem(viewItem);
            }
        };
        HeightMap.prototype.onRemoveItem = function (item) {
            // noop
        };
        HeightMap.prototype.onRefreshItemSet = function (items) {
            var _this = this;
            var sortedItems = items.sort(function (a, b) { return _this.indexes[a.id] - _this.indexes[b.id]; });
            this.onRefreshItems(new iterator_1.ArrayIterator(sortedItems));
        };
        // Ordered, but not necessarily contiguous items
        HeightMap.prototype.onRefreshItems = function (iterator) {
            var item;
            var viewItem;
            var newHeight;
            var i, j = null;
            var cummDiff = 0;
            while (item = iterator.next()) {
                i = this.indexes[item.id];
                for (; cummDiff !== 0 && j !== null && j < i; j++) {
                    viewItem = this.heightMap[j];
                    viewItem.top += cummDiff;
                    this.onRefreshItem(viewItem);
                }
                viewItem = this.heightMap[i];
                newHeight = item.getHeight();
                viewItem.top += cummDiff;
                cummDiff += newHeight - viewItem.height;
                viewItem.height = newHeight;
                this.onRefreshItem(viewItem, true);
                j = i + 1;
            }
            if (cummDiff !== 0 && j !== null) {
                for (; j < this.heightMap.length; j++) {
                    viewItem = this.heightMap[j];
                    viewItem.top += cummDiff;
                    this.onRefreshItem(viewItem);
                }
            }
        };
        HeightMap.prototype.onRefreshItem = function (item, needsRender) {
            if (needsRender === void 0) { needsRender = false; }
            // noop
        };
        HeightMap.prototype.itemsCount = function () {
            return this.heightMap.length;
        };
        HeightMap.prototype.itemAt = function (position) {
            return this.heightMap[this.indexAt(position)].model.id;
        };
        HeightMap.prototype.withItemsInRange = function (start, end, fn) {
            start = this.indexAt(start);
            end = this.indexAt(end);
            for (var i = start; i <= end; i++) {
                fn(this.heightMap[i].model.id);
            }
        };
        HeightMap.prototype.indexAt = function (position) {
            var left = 0;
            var right = this.heightMap.length;
            var center;
            var item;
            // Binary search
            while (left < right) {
                center = Math.floor((left + right) / 2);
                item = this.heightMap[center];
                if (position < item.top) {
                    right = center;
                }
                else if (position >= item.top + item.height) {
                    if (left === center) {
                        break;
                    }
                    left = center;
                }
                else {
                    return center;
                }
            }
            return this.heightMap.length;
        };
        HeightMap.prototype.indexAfter = function (position) {
            return Math.min(this.indexAt(position) + 1, this.heightMap.length);
        };
        HeightMap.prototype.itemAtIndex = function (index) {
            return this.heightMap[index];
        };
        HeightMap.prototype.itemAfter = function (item) {
            return this.heightMap[this.indexes[item.model.id] + 1] || null;
        };
        HeightMap.prototype.createViewItem = function (item) {
            throw new Error('not implemented');
        };
        HeightMap.prototype.dispose = function () {
            this.heightMap = null;
            this.indexes = null;
        };
        return HeightMap;
    }(eventEmitter_1.EventEmitter));
    exports.HeightMap = HeightMap;
});

define(__m[187/*vs/base/worker/defaultWorkerFactory*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,148/*vs/base/common/worker/simpleWorker*/]), function (require, exports, platform_1, simpleWorker_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Option for hosts to overwrite the worker script url (used in the standalone editor)
    var getCrossOriginWorkerScriptUrl = environment('getWorkerUrl', null);
    function environment(name, fallback) {
        if (fallback === void 0) { fallback = false; }
        if (platform_1.globals.MonacoEnvironment && platform_1.globals.MonacoEnvironment.hasOwnProperty(name)) {
            return platform_1.globals.MonacoEnvironment[name];
        }
        return fallback;
    }
    function defaultGetWorkerUrl(workerId, label) {
        return require.toUrl('./' + workerId) + '#' + label;
    }
    var getWorkerUrl = getCrossOriginWorkerScriptUrl || defaultGetWorkerUrl;
    /**
     * A worker that uses HTML5 web workers so that is has
     * its own global scope and its own thread.
     */
    var WebWorker = (function () {
        function WebWorker(moduleId, id, label, onMessageCallback, onErrorCallback) {
            this.id = id;
            this.worker = new Worker(getWorkerUrl('workerMain.js', label));
            this.postMessage(moduleId);
            this.worker.onmessage = function (ev) {
                onMessageCallback(ev.data);
            };
            if (typeof this.worker.addEventListener === 'function') {
                this.worker.addEventListener('error', onErrorCallback);
            }
        }
        WebWorker.prototype.getId = function () {
            return this.id;
        };
        WebWorker.prototype.postMessage = function (msg) {
            if (this.worker) {
                this.worker.postMessage(msg);
            }
        };
        WebWorker.prototype.dispose = function () {
            this.worker.terminate();
            this.worker = null;
        };
        return WebWorker;
    }());
    var DefaultWorkerFactory = (function () {
        function DefaultWorkerFactory(label) {
            this._label = label;
            this._webWorkerFailedBeforeError = false;
        }
        DefaultWorkerFactory.prototype.create = function (moduleId, onMessageCallback, onErrorCallback) {
            var _this = this;
            var workerId = (++DefaultWorkerFactory.LAST_WORKER_ID);
            if (this._webWorkerFailedBeforeError) {
                throw this._webWorkerFailedBeforeError;
            }
            return new WebWorker(moduleId, workerId, this._label || 'anonymous' + workerId, onMessageCallback, function (err) {
                simpleWorker_1.logOnceWebWorkerWarning(err);
                _this._webWorkerFailedBeforeError = err;
                onErrorCallback(err);
            });
        };
        return DefaultWorkerFactory;
    }());
    DefaultWorkerFactory.LAST_WORKER_ID = 0;
    exports.DefaultWorkerFactory = DefaultWorkerFactory;
});

define(__m[191/*vs/css!vs/base/browser/builder*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});





define(__m[33/*vs/base/browser/builder*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,24/*vs/base/common/types*/,3/*vs/base/common/lifecycle*/,9/*vs/base/common/strings*/,63/*vs/base/common/assert*/,11/*vs/base/browser/dom*/,191/*vs/css!vs/base/browser/builder*/]), function (require, exports, winjs_base_1, types, lifecycle_1, strings, assert, DOM) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Create a new builder from the element that is uniquely identified by the given identifier. If the
     *  second parameter "offdom" is set to true, the created elements will only be added to the provided
     *  element when the build() method is called.
     */
    function withElementById(id, offdom) {
        assert.ok(types.isString(id), 'Expected String as parameter');
        var element = document.getElementById(id);
        if (element) {
            return new Builder(element, offdom);
        }
        return null;
    }
    exports.withElementById = withElementById;
    exports.Build = {
        withElementById: withElementById
    };
    // --- Implementation starts here
    var MS_DATA_KEY = '_msDataKey';
    var DATA_BINDING_ID = '__$binding';
    var LISTENER_BINDING_ID = '__$listeners';
    var VISIBILITY_BINDING_ID = '__$visibility';
    var Position = (function () {
        function Position(x, y) {
            this.x = x;
            this.y = y;
        }
        return Position;
    }());
    exports.Position = Position;
    var Box = (function () {
        function Box(top, right, bottom, left) {
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.left = left;
        }
        return Box;
    }());
    exports.Box = Box;
    var Dimension = (function () {
        function Dimension(width, height) {
            this.width = width;
            this.height = height;
        }
        Dimension.prototype.substract = function (box) {
            return new Dimension(this.width - box.left - box.right, this.height - box.top - box.bottom);
        };
        return Dimension;
    }());
    exports.Dimension = Dimension;
    function data(element) {
        if (!element[MS_DATA_KEY]) {
            element[MS_DATA_KEY] = {};
        }
        return element[MS_DATA_KEY];
    }
    function hasData(element) {
        return !!element[MS_DATA_KEY];
    }
    /**
     *  Wraps around the provided element to manipulate it and add more child elements.
     */
    var Builder = (function () {
        function Builder(element, offdom) {
            this.offdom = offdom;
            this.container = element;
            this.currentElement = element;
            this.createdElements = [];
            this.toUnbind = {};
            this.captureToUnbind = {};
        }
        /**
         *  Returns a new builder that lets the current HTML Element of this builder be the container
         *  for future additions on the builder.
         */
        Builder.prototype.asContainer = function () {
            return withBuilder(this, this.offdom);
        };
        /**
         *  Clones the builder providing the same properties as this one.
         */
        Builder.prototype.clone = function () {
            var builder = new Builder(this.container, this.offdom);
            builder.currentElement = this.currentElement;
            builder.createdElements = this.createdElements;
            builder.captureToUnbind = this.captureToUnbind;
            builder.toUnbind = this.toUnbind;
            return builder;
        };
        Builder.prototype.and = function (obj) {
            // Convert HTMLElement to Builder as necessary
            if (!(obj instanceof Builder) && !(obj instanceof MultiBuilder)) {
                obj = new Builder(obj, this.offdom);
            }
            // Wrap Builders into MultiBuilder
            var builders = [this];
            if (obj instanceof MultiBuilder) {
                for (var i = 0; i < obj.length; i++) {
                    builders.push(obj.item(i));
                }
            }
            else {
                builders.push(obj);
            }
            return new MultiBuilder(builders);
        };
        Builder.prototype.build = function (container, index) {
            assert.ok(this.offdom, 'This builder was not created off-dom, so build() can not be called.');
            // Use builders own container if present
            if (!container) {
                container = this.container;
            }
            else if (container instanceof Builder) {
                container = container.getHTMLElement();
            }
            assert.ok(container, 'Builder can only be build() with a container provided.');
            assert.ok(DOM.isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
            var htmlContainer = container;
            // Append
            var i, len;
            var childNodes = htmlContainer.childNodes;
            if (types.isNumber(index) && index < childNodes.length) {
                for (i = 0, len = this.createdElements.length; i < len; i++) {
                    htmlContainer.insertBefore(this.createdElements[i], childNodes[index++]);
                }
            }
            else {
                for (i = 0, len = this.createdElements.length; i < len; i++) {
                    htmlContainer.appendChild(this.createdElements[i]);
                }
            }
            return this;
        };
        Builder.prototype.appendTo = function (container, index) {
            // Use builders own container if present
            if (!container) {
                container = this.container;
            }
            else if (container instanceof Builder) {
                container = container.getHTMLElement();
            }
            assert.ok(container, 'Builder can only be build() with a container provided.');
            assert.ok(DOM.isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
            var htmlContainer = container;
            // Remove node from parent, if needed
            if (this.currentElement.parentNode) {
                this.currentElement.parentNode.removeChild(this.currentElement);
            }
            var childNodes = htmlContainer.childNodes;
            if (types.isNumber(index) && index < childNodes.length) {
                htmlContainer.insertBefore(this.currentElement, childNodes[index]);
            }
            else {
                htmlContainer.appendChild(this.currentElement);
            }
            return this;
        };
        Builder.prototype.append = function (child, index) {
            assert.ok(child, 'Need a child to append');
            if (DOM.isHTMLElement(child)) {
                child = withElement(child);
            }
            assert.ok(child instanceof Builder || child instanceof MultiBuilder, 'Need a child to append');
            child.appendTo(this, index);
            return this;
        };
        /**
         *  Removes the current element of this builder from its parent node.
         */
        Builder.prototype.offDOM = function () {
            if (this.currentElement.parentNode) {
                this.currentElement.parentNode.removeChild(this.currentElement);
            }
            return this;
        };
        /**
         *  Returns the HTML Element the builder is currently active on.
         */
        Builder.prototype.getHTMLElement = function () {
            return this.currentElement;
        };
        /**
         *  Returns the HTML Element the builder is building in.
         */
        Builder.prototype.getContainer = function () {
            return this.container;
        };
        // HTML Elements
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.div = function (attributes, fn) {
            return this.doElement('div', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.p = function (attributes, fn) {
            return this.doElement('p', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.ul = function (attributes, fn) {
            return this.doElement('ul', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.ol = function (attributes, fn) {
            return this.doElement('ol', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.li = function (attributes, fn) {
            return this.doElement('li', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.span = function (attributes, fn) {
            return this.doElement('span', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.img = function (attributes, fn) {
            return this.doElement('img', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.a = function (attributes, fn) {
            return this.doElement('a', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.header = function (attributes, fn) {
            return this.doElement('header', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.section = function (attributes, fn) {
            return this.doElement('section', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.footer = function (attributes, fn) {
            return this.doElement('footer', attributes, fn);
        };
        /**
         *  Creates a new element of given tag name as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.element = function (name, attributes, fn) {
            return this.doElement(name, attributes, fn);
        };
        Builder.prototype.doElement = function (name, attributesOrFn, fn) {
            // Create Element
            var element = document.createElement(name);
            this.currentElement = element;
            // Off-DOM: Remember in array of created elements
            if (this.offdom) {
                this.createdElements.push(element);
            }
            // Object (apply properties as attributes to HTML element)
            if (types.isObject(attributesOrFn)) {
                this.attr(attributesOrFn);
            }
            // Support second argument being function
            if (types.isFunction(attributesOrFn)) {
                fn = attributesOrFn;
            }
            // Apply Functions (Elements created in Functions will be added as child to current element)
            if (types.isFunction(fn)) {
                var builder = new Builder(element);
                fn.call(builder, builder); // Set both 'this' and the first parameter to the new builder
            }
            // Add to parent
            if (!this.offdom) {
                this.container.appendChild(element);
            }
            return this;
        };
        /**
         *  Calls focus() on the current HTML element;
         */
        Builder.prototype.domFocus = function () {
            this.currentElement.focus();
            return this;
        };
        /**
         *  Returns true if the current element of this builder is the active element.
         */
        Builder.prototype.hasFocus = function () {
            var activeElement = document.activeElement;
            return (activeElement === this.currentElement);
        };
        /**
         *  Calls select() on the current HTML element;
         */
        Builder.prototype.domSelect = function (range) {
            if (range === void 0) { range = null; }
            var input = this.currentElement;
            input.select();
            if (range) {
                input.setSelectionRange(range.start, range.end);
            }
            return this;
        };
        /**
         *  Calls blur() on the current HTML element;
         */
        Builder.prototype.domBlur = function () {
            this.currentElement.blur();
            return this;
        };
        /**
         *  Calls click() on the current HTML element;
         */
        Builder.prototype.domClick = function () {
            this.currentElement.click();
            return this;
        };
        Builder.prototype.on = function (arg1, fn, listenerToUnbindContainer, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.on(type, fn, listenerToUnbindContainer, useCapture);
                });
            }
            else {
                var type = arg1;
                // Add Listener
                var unbind_1 = DOM.addDisposableListener(this.currentElement, type, function (e) {
                    fn(e, _this, unbind_1); // Pass in Builder as Second Argument
                }, useCapture || false);
                // Remember for off() use
                if (useCapture) {
                    if (!this.captureToUnbind[type]) {
                        this.captureToUnbind[type] = [];
                    }
                    this.captureToUnbind[type].push(unbind_1);
                }
                else {
                    if (!this.toUnbind[type]) {
                        this.toUnbind[type] = [];
                    }
                    this.toUnbind[type].push(unbind_1);
                }
                // Bind to Element
                var listenerBinding = this.getProperty(LISTENER_BINDING_ID, []);
                listenerBinding.push(unbind_1);
                this.setProperty(LISTENER_BINDING_ID, listenerBinding);
                // Add to Array if passed in
                if (listenerToUnbindContainer && types.isArray(listenerToUnbindContainer)) {
                    listenerToUnbindContainer.push(unbind_1);
                }
            }
            return this;
        };
        Builder.prototype.off = function (arg1, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.off(type);
                });
            }
            else {
                var type = arg1;
                if (useCapture) {
                    if (this.captureToUnbind[type]) {
                        this.captureToUnbind[type] = lifecycle_1.dispose(this.captureToUnbind[type]);
                    }
                }
                else {
                    if (this.toUnbind[type]) {
                        this.toUnbind[type] = lifecycle_1.dispose(this.toUnbind[type]);
                    }
                }
            }
            return this;
        };
        Builder.prototype.once = function (arg1, fn, listenerToUnbindContainer, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.once(type, fn);
                });
            }
            else {
                var type = arg1;
                // Add Listener
                var unbind_2 = DOM.addDisposableListener(this.currentElement, type, function (e) {
                    fn(e, _this, unbind_2); // Pass in Builder as Second Argument
                    unbind_2.dispose();
                }, useCapture || false);
                // Add to Array if passed in
                if (listenerToUnbindContainer && types.isArray(listenerToUnbindContainer)) {
                    listenerToUnbindContainer.push(unbind_2);
                }
            }
            return this;
        };
        Builder.prototype.preventDefault = function (arg1, cancelBubble, listenerToUnbindContainer, useCapture) {
            var fn = function (e) {
                e.preventDefault();
                if (cancelBubble) {
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                    else {
                        e.cancelBubble = true;
                    }
                }
            };
            return this.on(arg1, fn, listenerToUnbindContainer, useCapture);
        };
        Builder.prototype.attr = function (firstP, secondP) {
            // Apply Object Literal to Attributes of Element
            if (types.isObject(firstP)) {
                for (var prop in firstP) {
                    if (firstP.hasOwnProperty(prop)) {
                        var value = firstP[prop];
                        this.doSetAttr(prop, value);
                    }
                }
                return this;
            }
            // Get Attribute Value
            if (types.isString(firstP) && !types.isString(secondP)) {
                return this.currentElement.getAttribute(firstP);
            }
            // Set Attribute Value
            if (types.isString(firstP)) {
                if (!types.isString(secondP)) {
                    secondP = String(secondP);
                }
                this.doSetAttr(firstP, secondP);
            }
            return this;
        };
        Builder.prototype.doSetAttr = function (prop, value) {
            if (prop === 'class') {
                prop = 'addClass'; // Workaround for the issue that a function name can not be 'class' in ES
            }
            if (this[prop]) {
                if (types.isArray(value)) {
                    this[prop].apply(this, value);
                }
                else {
                    this[prop].call(this, value);
                }
            }
            else {
                this.currentElement.setAttribute(prop, value);
            }
        };
        /**
         * Removes an attribute by the given name.
         */
        Builder.prototype.removeAttribute = function (prop) {
            this.currentElement.removeAttribute(prop);
        };
        /**
         *  Sets the id attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.id = function (id) {
            this.currentElement.setAttribute('id', id);
            return this;
        };
        /**
         *  Sets the src attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.src = function (src) {
            this.currentElement.setAttribute('src', src);
            return this;
        };
        /**
         *  Sets the href attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.href = function (href) {
            this.currentElement.setAttribute('href', href);
            return this;
        };
        /**
         *  Sets the title attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.title = function (title) {
            this.currentElement.setAttribute('title', title);
            return this;
        };
        /**
         *  Sets the name attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.name = function (name) {
            this.currentElement.setAttribute('name', name);
            return this;
        };
        /**
         *  Sets the type attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.type = function (type) {
            this.currentElement.setAttribute('type', type);
            return this;
        };
        /**
         *  Sets the value attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.value = function (value) {
            this.currentElement.setAttribute('value', value);
            return this;
        };
        /**
         *  Sets the alt attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.alt = function (alt) {
            this.currentElement.setAttribute('alt', alt);
            return this;
        };
        /**
         *  Sets the name draggable to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.draggable = function (isDraggable) {
            this.currentElement.setAttribute('draggable', isDraggable ? 'true' : 'false');
            return this;
        };
        /**
         *  Sets the tabindex attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.tabindex = function (index) {
            this.currentElement.setAttribute('tabindex', index.toString());
            return this;
        };
        Builder.prototype.style = function (firstP, secondP) {
            // Apply Object Literal to Styles of Element
            if (types.isObject(firstP)) {
                for (var prop in firstP) {
                    if (firstP.hasOwnProperty(prop)) {
                        var value = firstP[prop];
                        this.doSetStyle(prop, value);
                    }
                }
            }
            else if (types.isString(firstP) && !types.isString(secondP)) {
                return this.currentElement.style[this.cssKeyToJavaScriptProperty(firstP)];
            }
            else if (types.isString(firstP) && types.isString(secondP)) {
                this.doSetStyle(firstP, secondP);
            }
            return this;
        };
        Builder.prototype.doSetStyle = function (key, value) {
            if (key.indexOf('-') >= 0) {
                var segments = key.split('-');
                key = segments[0];
                for (var i = 1; i < segments.length; i++) {
                    var segment = segments[i];
                    key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
                }
            }
            this.currentElement.style[this.cssKeyToJavaScriptProperty(key)] = value;
        };
        Builder.prototype.cssKeyToJavaScriptProperty = function (key) {
            // Automagically convert dashes as they are not allowed when programmatically
            // setting a CSS style property
            if (key.indexOf('-') >= 0) {
                var segments = key.split('-');
                key = segments[0];
                for (var i = 1; i < segments.length; i++) {
                    var segment = segments[i];
                    key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
                }
            }
            else if (key === 'float') {
                key = 'cssFloat';
            }
            return key;
        };
        /**
         *  Returns the computed CSS style for the current HTML element of the builder.
         */
        Builder.prototype.getComputedStyle = function () {
            return DOM.getComputedStyle(this.currentElement);
        };
        /**
         *  Adds the variable list of arguments as class names to the current HTML element of the builder.
         */
        Builder.prototype.addClass = function () {
            var _this = this;
            var classes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                classes[_i] = arguments[_i];
            }
            classes.forEach(function (nameValue) {
                var names = nameValue.split(' ');
                names.forEach(function (name) {
                    DOM.addClass(_this.currentElement, name);
                });
            });
            return this;
        };
        /**
         *  Sets the class name of the current HTML element of the builder to the provided className.
         *  If shouldAddClass is provided - for true class is added, for false class is removed.
         */
        Builder.prototype.setClass = function (className, shouldAddClass) {
            if (shouldAddClass === void 0) { shouldAddClass = null; }
            if (shouldAddClass === null) {
                this.currentElement.className = className;
            }
            else if (shouldAddClass) {
                this.addClass(className);
            }
            else {
                this.removeClass(className);
            }
            return this;
        };
        /**
         *  Returns whether the current HTML element of the builder has the provided class assigned.
         */
        Builder.prototype.hasClass = function (className) {
            return DOM.hasClass(this.currentElement, className);
        };
        /**
         *  Removes the variable list of arguments as class names from the current HTML element of the builder.
         */
        Builder.prototype.removeClass = function () {
            var _this = this;
            var classes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                classes[_i] = arguments[_i];
            }
            classes.forEach(function (nameValue) {
                var names = nameValue.split(' ');
                names.forEach(function (name) {
                    DOM.removeClass(_this.currentElement, name);
                });
            });
            return this;
        };
        /**
         *  Sets the first class to the current HTML element of the builder if the second class is currently set
         *  and vice versa otherwise.
         */
        Builder.prototype.swapClass = function (classA, classB) {
            if (this.hasClass(classA)) {
                this.removeClass(classA);
                this.addClass(classB);
            }
            else {
                this.removeClass(classB);
                this.addClass(classA);
            }
            return this;
        };
        /**
         *  Adds or removes the provided className for the current HTML element of the builder.
         */
        Builder.prototype.toggleClass = function (className) {
            if (this.hasClass(className)) {
                this.removeClass(className);
            }
            else {
                this.addClass(className);
            }
            return this;
        };
        /**
         *  Sets the CSS property color.
         */
        Builder.prototype.color = function (color) {
            this.currentElement.style.color = color;
            return this;
        };
        /**
         *  Sets the CSS property background.
         */
        Builder.prototype.background = function (color) {
            this.currentElement.style.backgroundColor = color;
            return this;
        };
        Builder.prototype.padding = function (top, right, bottom, left) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.padding.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.paddingTop = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.paddingRight = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.paddingBottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.paddingLeft = this.toPixel(left);
            }
            return this;
        };
        Builder.prototype.margin = function (top, right, bottom, left) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.margin.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.marginTop = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.marginRight = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.marginBottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.marginLeft = this.toPixel(left);
            }
            return this;
        };
        Builder.prototype.position = function (top, right, bottom, left, position) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.position.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.top = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.right = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.bottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.left = this.toPixel(left);
            }
            if (!position) {
                position = 'absolute';
            }
            this.currentElement.style.position = position;
            return this;
        };
        Builder.prototype.size = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.size.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.width = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.height = this.toPixel(height);
            }
            return this;
        };
        Builder.prototype.minSize = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.minSize.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.minWidth = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.minHeight = this.toPixel(height);
            }
            return this;
        };
        Builder.prototype.maxSize = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.maxSize.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.maxWidth = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.maxHeight = this.toPixel(height);
            }
            return this;
        };
        /**
         *  Sets the CSS property float.
         */
        Builder.prototype.float = function (float) {
            this.currentElement.style.cssFloat = float;
            return this;
        };
        /**
         *  Sets the CSS property clear.
         */
        Builder.prototype.clear = function (clear) {
            this.currentElement.style.clear = clear;
            return this;
        };
        /**
         *  Sets the CSS property for fonts back to default.
         */
        Builder.prototype.normal = function () {
            this.currentElement.style.fontStyle = 'normal';
            this.currentElement.style.fontWeight = 'normal';
            this.currentElement.style.textDecoration = 'none';
            return this;
        };
        /**
         *  Sets the CSS property font-style to italic.
         */
        Builder.prototype.italic = function () {
            this.currentElement.style.fontStyle = 'italic';
            return this;
        };
        /**
         *  Sets the CSS property font-weight to bold.
         */
        Builder.prototype.bold = function () {
            this.currentElement.style.fontWeight = 'bold';
            return this;
        };
        /**
         *  Sets the CSS property text-decoration to underline.
         */
        Builder.prototype.underline = function () {
            this.currentElement.style.textDecoration = 'underline';
            return this;
        };
        /**
         *  Sets the CSS property overflow.
         */
        Builder.prototype.overflow = function (overflow) {
            this.currentElement.style.overflow = overflow;
            return this;
        };
        /**
         *  Sets the CSS property display.
         */
        Builder.prototype.display = function (display) {
            this.currentElement.style.display = display;
            return this;
        };
        Builder.prototype.disable = function () {
            this.currentElement.setAttribute('disabled', 'disabled');
            return this;
        };
        Builder.prototype.enable = function () {
            this.currentElement.removeAttribute('disabled');
            return this;
        };
        /**
         *  Shows the current element of the builder.
         */
        Builder.prototype.show = function () {
            if (this.hasClass('builder-hidden')) {
                this.removeClass('builder-hidden');
            }
            this.attr('aria-hidden', 'false');
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            return this;
        };
        /**
         *  Shows the current builder element after the provided delay. If the builder
         *  was set to hidden using the hide() method before this method executed, the
         *  function will return without showing the current element. This is useful to
         *  only show the element when a specific delay is reached (e.g. for a long running
         *  operation.
         */
        Builder.prototype.showDelayed = function (delay) {
            var _this = this;
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            var promise = winjs_base_1.TPromise.timeout(delay);
            this.setProperty(VISIBILITY_BINDING_ID, promise);
            promise.done(function () {
                _this.removeProperty(VISIBILITY_BINDING_ID);
                _this.show();
            });
            return this;
        };
        /**
         *  Hides the current element of the builder.
         */
        Builder.prototype.hide = function () {
            if (!this.hasClass('builder-hidden')) {
                this.addClass('builder-hidden');
            }
            this.attr('aria-hidden', 'true');
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            return this;
        };
        /**
         *  Returns true if the current element of the builder is hidden.
         */
        Builder.prototype.isHidden = function () {
            return this.hasClass('builder-hidden') || this.currentElement.style.display === 'none';
        };
        /**
         *  Toggles visibility of the current element of the builder.
         */
        Builder.prototype.toggleVisibility = function () {
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            this.swapClass('builder-visible', 'builder-hidden');
            if (this.isHidden()) {
                this.attr('aria-hidden', 'true');
            }
            else {
                this.attr('aria-hidden', 'false');
            }
            return this;
        };
        Builder.prototype.cancelVisibilityPromise = function () {
            var promise = this.getProperty(VISIBILITY_BINDING_ID);
            if (promise) {
                promise.cancel();
                this.removeProperty(VISIBILITY_BINDING_ID);
            }
        };
        Builder.prototype.border = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.border.apply(this, width.split(' '));
            }
            this.currentElement.style.borderWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderColor = color;
            }
            if (style) {
                this.currentElement.style.borderStyle = style;
            }
            return this;
        };
        Builder.prototype.borderTop = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderTop.apply(this, width.split(' '));
            }
            this.currentElement.style.borderTopWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderTopColor = color;
            }
            if (style) {
                this.currentElement.style.borderTopStyle = style;
            }
            return this;
        };
        Builder.prototype.borderBottom = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderBottom.apply(this, width.split(' '));
            }
            this.currentElement.style.borderBottomWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderBottomColor = color;
            }
            if (style) {
                this.currentElement.style.borderBottomStyle = style;
            }
            return this;
        };
        Builder.prototype.borderLeft = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderLeft.apply(this, width.split(' '));
            }
            this.currentElement.style.borderLeftWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderLeftColor = color;
            }
            if (style) {
                this.currentElement.style.borderLeftStyle = style;
            }
            return this;
        };
        Builder.prototype.borderRight = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderRight.apply(this, width.split(' '));
            }
            this.currentElement.style.borderRightWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderRightColor = color;
            }
            if (style) {
                this.currentElement.style.borderRightStyle = style;
            }
            return this;
        };
        /**
         *  Sets the CSS property text-align.
         */
        Builder.prototype.textAlign = function (textAlign) {
            this.currentElement.style.textAlign = textAlign;
            return this;
        };
        /**
         *  Sets the CSS property vertical-align.
         */
        Builder.prototype.verticalAlign = function (valign) {
            this.currentElement.style.verticalAlign = valign;
            return this;
        };
        Builder.prototype.toPixel = function (obj) {
            if (obj.toString().indexOf('px') === -1) {
                return obj.toString() + 'px';
            }
            return obj;
        };
        /**
         *  Sets the innerHTML attribute.
         */
        Builder.prototype.innerHtml = function (html, append) {
            if (append) {
                this.currentElement.innerHTML += html;
            }
            else {
                this.currentElement.innerHTML = html;
            }
            return this;
        };
        /**
         *  Sets the textContent property of the element.
         *  All HTML special characters will be escaped.
         */
        Builder.prototype.text = function (text, append) {
            if (append) {
                // children is child Elements versus childNodes includes textNodes
                if (this.currentElement.children.length === 0) {
                    this.currentElement.textContent += text;
                }
                else {
                    // if there are elements inside this node, append the string as a new text node
                    // to avoid wiping out the innerHTML and replacing it with only text content
                    this.currentElement.appendChild(document.createTextNode(text));
                }
            }
            else {
                this.currentElement.textContent = text;
            }
            return this;
        };
        /**
         *  Sets the innerHTML attribute in escaped form.
         */
        Builder.prototype.safeInnerHtml = function (html, append) {
            return this.innerHtml(strings.escape(html), append);
        };
        /**
         *  Adds the provided object as property to the current element. Call getBinding()
         *  to retrieve it again.
         */
        Builder.prototype.bind = function (object) {
            bindElement(this.currentElement, object);
            return this;
        };
        /**
         *  Removes the binding of the current element.
         */
        Builder.prototype.unbind = function () {
            unbindElement(this.currentElement);
            return this;
        };
        /**
         *  Returns the object that was passed into the bind() call.
         */
        Builder.prototype.getBinding = function () {
            return getBindingFromElement(this.currentElement);
        };
        /**
         *  Allows to store arbritary data into the current element.
         */
        Builder.prototype.setProperty = function (key, value) {
            setPropertyOnElement(this.currentElement, key, value);
            return this;
        };
        /**
         *  Allows to get arbritary data from the current element.
         */
        Builder.prototype.getProperty = function (key, fallback) {
            return getPropertyFromElement(this.currentElement, key, fallback);
        };
        /**
         *  Removes a property from the current element that is stored under the given key.
         */
        Builder.prototype.removeProperty = function (key) {
            if (hasData(this.currentElement)) {
                delete data(this.currentElement)[key];
            }
            return this;
        };
        /**
         *  Returns a new builder with the parent element of the current element of the builder.
         */
        Builder.prototype.parent = function (offdom) {
            assert.ok(!this.offdom, 'Builder was created with offdom = true and thus has no parent set');
            return withElement(this.currentElement.parentNode, offdom);
        };
        /**
         *  Returns a new builder with all child elements of the current element of the builder.
         */
        Builder.prototype.children = function (offdom) {
            var children = this.currentElement.children;
            var builders = [];
            for (var i = 0; i < children.length; i++) {
                builders.push(withElement(children.item(i), offdom));
            }
            return new MultiBuilder(builders);
        };
        /**
         * Returns a new builder with the child at the given index.
         */
        Builder.prototype.child = function (index) {
            if (index === void 0) { index = 0; }
            var children = this.currentElement.children;
            return withElement(children.item(index));
        };
        /**
         *  Removes the current HTMLElement from the given builder from this builder if this builders
         *  current HTMLElement is the direct parent.
         */
        Builder.prototype.removeChild = function (builder) {
            if (this.currentElement === builder.parent().getHTMLElement()) {
                this.currentElement.removeChild(builder.getHTMLElement());
            }
            return this;
        };
        /**
         *  Returns a new builder with all elements matching the provided selector scoped to the
         *  current element of the builder. Use Build.withElementsBySelector() to run the selector
         *  over the entire DOM.
         *  The returned builder is an instance of array that can have 0 elements if the selector does not match any
         *  elements.
         */
        Builder.prototype.select = function (selector, offdom) {
            assert.ok(types.isString(selector), 'Expected String as parameter');
            var elements = this.currentElement.querySelectorAll(selector);
            var builders = [];
            for (var i = 0; i < elements.length; i++) {
                builders.push(withElement(elements.item(i), offdom));
            }
            return new MultiBuilder(builders);
        };
        /**
         *  Returns true if the current element of the builder matches the given selector and false otherwise.
         */
        Builder.prototype.matches = function (selector) {
            var element = this.currentElement;
            var matches = element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
            return matches && matches.call(element, selector);
        };
        /**
         *  Returns true if the current element of the builder has no children.
         */
        Builder.prototype.isEmpty = function () {
            return !this.currentElement.childNodes || this.currentElement.childNodes.length === 0;
        };
        /**
         * Recurse through all descendant nodes and remove their data binding.
         */
        Builder.prototype.unbindDescendants = function (current) {
            if (current && current.children) {
                for (var i = 0, length_1 = current.children.length; i < length_1; i++) {
                    var element = current.children.item(i);
                    // Unbind
                    if (hasData(element)) {
                        // Listeners
                        var listeners = data(element)[LISTENER_BINDING_ID];
                        if (types.isArray(listeners)) {
                            while (listeners.length) {
                                listeners.pop().dispose();
                            }
                        }
                        // Delete Data Slot
                        delete element[MS_DATA_KEY];
                    }
                    // Recurse
                    this.unbindDescendants(element);
                }
            }
        };
        /**
         *  Removes all HTML elements from the current element of the builder. Will also clean up any
         *  event listners registered and also clear any data binding and properties stored
         *  to any child element.
         */
        Builder.prototype.empty = function () {
            this.unbindDescendants(this.currentElement);
            this.clearChildren();
            if (this.offdom) {
                this.createdElements = [];
            }
            return this;
        };
        /**
         *  Removes all HTML elements from the current element of the builder.
         */
        Builder.prototype.clearChildren = function () {
            // Remove Elements
            if (this.currentElement) {
                DOM.clearNode(this.currentElement);
            }
            return this;
        };
        /**
         *  Removes the current HTML element and all its children from its parent and unbinds
         *  all listeners and properties set to the data slots.
         */
        Builder.prototype.destroy = function () {
            if (this.currentElement) {
                // Remove from parent
                if (this.currentElement.parentNode) {
                    this.currentElement.parentNode.removeChild(this.currentElement);
                }
                // Empty to clear listeners and bindings from children
                this.empty();
                // Unbind
                if (hasData(this.currentElement)) {
                    // Listeners
                    var listeners = data(this.currentElement)[LISTENER_BINDING_ID];
                    if (types.isArray(listeners)) {
                        while (listeners.length) {
                            listeners.pop().dispose();
                        }
                    }
                    // Delete Data Slot
                    delete this.currentElement[MS_DATA_KEY];
                }
            }
            var type;
            for (type in this.toUnbind) {
                if (this.toUnbind.hasOwnProperty(type) && types.isArray(this.toUnbind[type])) {
                    this.toUnbind[type] = lifecycle_1.dispose(this.toUnbind[type]);
                }
            }
            for (type in this.captureToUnbind) {
                if (this.captureToUnbind.hasOwnProperty(type) && types.isArray(this.captureToUnbind[type])) {
                    this.captureToUnbind[type] = lifecycle_1.dispose(this.captureToUnbind[type]);
                }
            }
            // Nullify fields
            this.currentElement = null;
            this.container = null;
            this.offdom = null;
            this.createdElements = null;
            this.captureToUnbind = null;
            this.toUnbind = null;
        };
        /**
         *  Removes the current HTML element and all its children from its parent and unbinds
         *  all listeners and properties set to the data slots.
         */
        Builder.prototype.dispose = function () {
            this.destroy();
        };
        /**
         *  Gets the size (in pixels) of an element, including the margin.
         */
        Builder.prototype.getTotalSize = function () {
            var totalWidth = DOM.getTotalWidth(this.currentElement);
            var totalHeight = DOM.getTotalHeight(this.currentElement);
            return new Dimension(totalWidth, totalHeight);
        };
        /**
         *  Gets the size (in pixels) of the inside of the element, excluding the border and padding.
         */
        Builder.prototype.getContentSize = function () {
            var contentWidth = DOM.getContentWidth(this.currentElement);
            var contentHeight = DOM.getContentHeight(this.currentElement);
            return new Dimension(contentWidth, contentHeight);
        };
        /**
         *  Another variant of getting the inner dimensions of an element.
         */
        Builder.prototype.getClientArea = function () {
            // 0.) Try with DOM clientWidth / clientHeight
            if (this.currentElement !== document.body) {
                return new Dimension(this.currentElement.clientWidth, this.currentElement.clientHeight);
            }
            // 1.) Try innerWidth / innerHeight
            if (window.innerWidth && window.innerHeight) {
                return new Dimension(window.innerWidth, window.innerHeight);
            }
            // 2.) Try with document.body.clientWidth / document.body.clientHeigh
            if (document.body && document.body.clientWidth && document.body.clientWidth) {
                return new Dimension(document.body.clientWidth, document.body.clientHeight);
            }
            // 3.) Try with document.documentElement.clientWidth / document.documentElement.clientHeight
            if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
                return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
            }
            throw new Error('Unable to figure out browser width and height');
        };
        return Builder;
    }());
    exports.Builder = Builder;
    /**
     *  The multi builder provides the same methods as the builder, but allows to call
     *  them on an array of builders.
     */
    var MultiBuilder = (function (_super) {
        __extends(MultiBuilder, _super);
        function MultiBuilder(builders) {
            var _this = this;
            assert.ok(types.isArray(builders) || builders instanceof MultiBuilder, 'Expected Array or MultiBuilder as parameter');
            _this = _super.call(this) || this;
            _this.length = 0;
            _this.builders = [];
            // Add Builders to Array
            if (types.isArray(builders)) {
                for (var i = 0; i < builders.length; i++) {
                    if (builders[i] instanceof HTMLElement) {
                        _this.push(withElement(builders[i]));
                    }
                    else {
                        _this.push(builders[i]);
                    }
                }
            }
            else {
                for (var i = 0; i < builders.length; i++) {
                    _this.push(builders.item(i));
                }
            }
            // Mixin Builder functions to operate on all builders
            var $outer = _this;
            var propertyFn = function (prop) {
                $outer[prop] = function () {
                    var args = Array.prototype.slice.call(arguments);
                    var returnValues;
                    var mergeBuilders = false;
                    for (var i = 0; i < $outer.length; i++) {
                        var res = $outer.item(i)[prop].apply($outer.item(i), args);
                        // Merge MultiBuilders into one
                        if (res instanceof MultiBuilder) {
                            if (!returnValues) {
                                returnValues = [];
                            }
                            mergeBuilders = true;
                            for (var j = 0; j < res.length; j++) {
                                returnValues.push(res.item(j));
                            }
                        }
                        else if (!types.isUndefined(res) && !(res instanceof Builder)) {
                            if (!returnValues) {
                                returnValues = [];
                            }
                            returnValues.push(res);
                        }
                    }
                    if (returnValues && mergeBuilders) {
                        return new MultiBuilder(returnValues);
                    }
                    return returnValues || $outer;
                };
            };
            for (var prop in Builder.prototype) {
                if (prop !== 'clone' && prop !== 'and') {
                    if (Builder.prototype.hasOwnProperty(prop) && types.isFunction(Builder.prototype[prop])) {
                        propertyFn(prop);
                    }
                }
            }
            return _this;
        }
        MultiBuilder.prototype.item = function (i) {
            return this.builders[i];
        };
        MultiBuilder.prototype.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            for (var i = 0; i < items.length; i++) {
                this.builders.push(items[i]);
            }
            this.length = this.builders.length;
        };
        MultiBuilder.prototype.pop = function () {
            var element = this.builders.pop();
            this.length = this.builders.length;
            return element;
        };
        MultiBuilder.prototype.concat = function (items) {
            var elements = this.builders.concat(items);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.shift = function () {
            var element = this.builders.shift();
            this.length = this.builders.length;
            return element;
        };
        MultiBuilder.prototype.unshift = function (item) {
            var res = this.builders.unshift(item);
            this.length = this.builders.length;
            return res;
        };
        MultiBuilder.prototype.slice = function (start, end) {
            var elements = this.builders.slice(start, end);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.splice = function (start, deleteCount) {
            var elements = this.builders.splice(start, deleteCount);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.clone = function () {
            return new MultiBuilder(this);
        };
        MultiBuilder.prototype.and = function (obj) {
            // Convert HTMLElement to Builder as necessary
            if (!(obj instanceof Builder) && !(obj instanceof MultiBuilder)) {
                obj = new Builder(obj);
            }
            var builders = [];
            if (obj instanceof MultiBuilder) {
                for (var i = 0; i < obj.length; i++) {
                    builders.push(obj.item(i));
                }
            }
            else {
                builders.push(obj);
            }
            this.push.apply(this, builders);
            return this;
        };
        return MultiBuilder;
    }(Builder));
    exports.MultiBuilder = MultiBuilder;
    function withBuilder(builder, offdom) {
        if (builder instanceof MultiBuilder) {
            return new MultiBuilder(builder);
        }
        return new Builder(builder.getHTMLElement(), offdom);
    }
    function withElement(element, offdom) {
        return new Builder(element, offdom);
    }
    function offDOM() {
        return new Builder(null, true);
    }
    // Binding functions
    /**
     *  Allows to store arbritary data into element.
     */
    function setPropertyOnElement(element, key, value) {
        data(element)[key] = value;
    }
    exports.setPropertyOnElement = setPropertyOnElement;
    /**
     *  Allows to get arbritary data from element.
     */
    function getPropertyFromElement(element, key, fallback) {
        if (hasData(element)) {
            var value = data(element)[key];
            if (!types.isUndefined(value)) {
                return value;
            }
        }
        return fallback;
    }
    exports.getPropertyFromElement = getPropertyFromElement;
    /**
     *  Removes a property from an element.
     */
    function removePropertyFromElement(element, key) {
        if (hasData(element)) {
            delete data(element)[key];
        }
    }
    exports.removePropertyFromElement = removePropertyFromElement;
    /**
     *  Adds the provided object as property to the given element. Call getBinding()
     *  to retrieve it again.
     */
    function bindElement(element, object) {
        setPropertyOnElement(element, DATA_BINDING_ID, object);
    }
    exports.bindElement = bindElement;
    /**
     *  Removes the binding of the given element.
     */
    function unbindElement(element) {
        removePropertyFromElement(element, DATA_BINDING_ID);
    }
    exports.unbindElement = unbindElement;
    /**
     *  Returns the object that was passed into the bind() call for the element.
     */
    function getBindingFromElement(element) {
        return getPropertyFromElement(element, DATA_BINDING_ID);
    }
    exports.getBindingFromElement = getBindingFromElement;
    exports.Binding = {
        setPropertyOnElement: setPropertyOnElement,
        getPropertyFromElement: getPropertyFromElement,
        removePropertyFromElement: removePropertyFromElement,
        bindElement: bindElement,
        unbindElement: unbindElement,
        getBindingFromElement: getBindingFromElement
    };
    var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
    exports.$ = function (arg) {
        // Off-DOM use
        if (types.isUndefined(arg)) {
            return offDOM();
        }
        // Falsified values cause error otherwise
        if (!arg) {
            throw new Error('Bad use of $');
        }
        // Wrap the given element
        if (DOM.isHTMLElement(arg) || arg === window) {
            return withElement(arg);
        }
        // Wrap the given builders
        if (types.isArray(arg)) {
            return new MultiBuilder(arg);
        }
        // Wrap the given builder
        if (arg instanceof Builder) {
            return withBuilder(arg);
        }
        if (types.isString(arg)) {
            // Use the argument as HTML code
            if (arg[0] === '<') {
                var element = void 0;
                var container = document.createElement('div');
                container.innerHTML = strings.format.apply(strings, arguments);
                if (container.children.length === 0) {
                    throw new Error('Bad use of $');
                }
                if (container.children.length === 1) {
                    element = container.firstChild;
                    container.removeChild(element);
                    return withElement(element);
                }
                var builders = [];
                while (container.firstChild) {
                    element = container.firstChild;
                    container.removeChild(element);
                    builders.push(withElement(element));
                }
                return new MultiBuilder(builders);
            }
            else if (arguments.length === 1) {
                var match = SELECTOR_REGEX.exec(arg);
                if (!match) {
                    throw new Error('Bad use of $');
                }
                var tag = match[1] || 'div';
                var id = match[3] || undefined;
                var classes = (match[4] || '').replace(/\./g, ' ');
                var props = {};
                if (id) {
                    props['id'] = id;
                }
                if (classes) {
                    props['class'] = classes;
                }
                return offDOM().element(tag, props);
            }
            else {
                var result = offDOM();
                result.element.apply(result, arguments);
                return result;
            }
        }
        else {
            throw new Error('Bad use of $');
        }
    };
    exports.$.Box = Box;
    exports.$.Dimension = Dimension;
    exports.$.Position = Position;
    exports.$.Builder = Builder;
    exports.$.MultiBuilder = MultiBuilder;
    exports.$.Build = exports.Build;
    exports.$.Binding = exports.Binding;
});

define(__m[197/*vs/css!vs/base/browser/ui/actionbar/actionbar*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[200/*vs/css!vs/base/browser/ui/aria/aria*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[203/*vs/css!vs/base/browser/ui/checkbox/checkbox*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[204/*vs/base/browser/ui/checkbox/checkbox*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,40/*vs/base/browser/ui/widget*/,203/*vs/css!vs/base/browser/ui/checkbox/checkbox*/]), function (require, exports, DOM, widget_1) {
    'use strict';
    var Checkbox = (function (_super) {
        __extends(Checkbox, _super);
        function Checkbox(opts) {
            var _this = _super.call(this) || this;
            _this._opts = opts;
            _this._checked = _this._opts.isChecked;
            _this.domNode = document.createElement('div');
            _this.domNode.title = _this._opts.title;
            _this.domNode.className = _this._className();
            _this.domNode.tabIndex = 0;
            _this.domNode.setAttribute('role', 'checkbox');
            _this.domNode.setAttribute('aria-checked', String(_this._checked));
            _this.domNode.setAttribute('aria-label', _this._opts.title);
            _this.onclick(_this.domNode, function (ev) {
                _this.checked = !_this._checked;
                _this._opts.onChange(false);
                ev.preventDefault();
            });
            _this.onkeydown(_this.domNode, function (keyboardEvent) {
                if (keyboardEvent.keyCode === 10 /* Space */ || keyboardEvent.keyCode === 3 /* Enter */) {
                    _this.checked = !_this._checked;
                    _this._opts.onChange(true);
                    keyboardEvent.preventDefault();
                    return;
                }
                if (_this._opts.onKeyDown) {
                    _this._opts.onKeyDown(keyboardEvent);
                }
            });
            return _this;
        }
        Checkbox.prototype.focus = function () {
            this.domNode.focus();
        };
        Object.defineProperty(Checkbox.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (newIsChecked) {
                this._checked = newIsChecked;
                this.domNode.setAttribute('aria-checked', String(this._checked));
                this.domNode.className = this._className();
            },
            enumerable: true,
            configurable: true
        });
        Checkbox.prototype._className = function () {
            return 'custom-checkbox ' + this._opts.actionClassName + ' ' + (this._checked ? 'checked' : 'unchecked');
        };
        Checkbox.prototype.width = function () {
            return 2 /*marginleft*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;
        };
        Checkbox.prototype.enable = function () {
            this.domNode.tabIndex = 0;
            this.domNode.setAttribute('aria-disabled', String(false));
        };
        Checkbox.prototype.disable = function () {
            DOM.removeTabIndexAndUpdateFocus(this.domNode);
            this.domNode.setAttribute('aria-disabled', String(true));
        };
        return Checkbox;
    }(widget_1.Widget));
    exports.Checkbox = Checkbox;
});

define(__m[205/*vs/css!vs/base/browser/ui/contextview/contextview*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[171/*vs/base/browser/ui/contextview/contextview*/], __M([1/*require*/,0/*exports*/,33/*vs/base/browser/builder*/,11/*vs/base/browser/dom*/,3/*vs/base/common/lifecycle*/,25/*vs/base/common/eventEmitter*/,205/*vs/css!vs/base/browser/ui/contextview/contextview*/]), function (require, exports, builder_1, DOM, lifecycle_1, eventEmitter_1) {
    'use strict';
    var AnchorAlignment;
    (function (AnchorAlignment) {
        AnchorAlignment[AnchorAlignment["LEFT"] = 0] = "LEFT";
        AnchorAlignment[AnchorAlignment["RIGHT"] = 1] = "RIGHT";
    })(AnchorAlignment = exports.AnchorAlignment || (exports.AnchorAlignment = {}));
    var AnchorPosition;
    (function (AnchorPosition) {
        AnchorPosition[AnchorPosition["BELOW"] = 0] = "BELOW";
        AnchorPosition[AnchorPosition["ABOVE"] = 1] = "ABOVE";
    })(AnchorPosition = exports.AnchorPosition || (exports.AnchorPosition = {}));
    function layout(view, around, viewport, anchorPosition, anchorAlignment) {
        var chooseBiased = function (a, aIsGood, b, bIsGood) {
            if (aIsGood) {
                return a;
            }
            if (bIsGood) {
                return b;
            }
            return a;
        };
        var chooseOne = function (a, aIsGood, b, bIsGood, aIsPreferred) {
            if (aIsPreferred) {
                return chooseBiased(a, aIsGood, b, bIsGood);
            }
            else {
                return chooseBiased(b, bIsGood, a, aIsGood);
            }
        };
        var top = (function () {
            // Compute both options (putting the segment above and below)
            var posAbove = around.top - view.height;
            var posBelow = around.top + around.height;
            // Check for both options if they are good
            var aboveIsGood = (posAbove >= viewport.top && posAbove + view.height <= viewport.top + viewport.height);
            var belowIsGood = (posBelow >= viewport.top && posBelow + view.height <= viewport.top + viewport.height);
            return chooseOne(posAbove, aboveIsGood, posBelow, belowIsGood, anchorPosition === AnchorPosition.ABOVE);
        })();
        var left = (function () {
            // Compute both options (aligning left and right)
            var posLeft = around.left;
            var posRight = around.left + around.width - view.width;
            // Check for both options if they are good
            var leftIsGood = (posLeft >= viewport.left && posLeft + view.width <= viewport.left + viewport.width);
            var rightIsGood = (posRight >= viewport.left && posRight + view.width <= viewport.left + viewport.width);
            return chooseOne(posLeft, leftIsGood, posRight, rightIsGood, anchorAlignment === AnchorAlignment.LEFT);
        })();
        return { top: top, left: left };
    }
    var ContextView = (function (_super) {
        __extends(ContextView, _super);
        function ContextView(container) {
            var _this = _super.call(this) || this;
            _this.$view = builder_1.$('.context-view').hide();
            _this.setContainer(container);
            _this.toDispose = [{
                    dispose: function () {
                        _this.setContainer(null);
                    }
                }];
            _this.toDisposeOnClean = null;
            return _this;
        }
        ContextView.prototype.setContainer = function (container) {
            var _this = this;
            if (this.$container) {
                this.$container.off(ContextView.BUBBLE_UP_EVENTS);
                this.$container.off(ContextView.BUBBLE_DOWN_EVENTS, true);
                this.$container = null;
            }
            if (container) {
                this.$container = builder_1.$(container);
                this.$view.appendTo(this.$container);
                this.$container.on(ContextView.BUBBLE_UP_EVENTS, function (e) {
                    _this.onDOMEvent(e, document.activeElement, false);
                });
                this.$container.on(ContextView.BUBBLE_DOWN_EVENTS, function (e) {
                    _this.onDOMEvent(e, document.activeElement, true);
                }, null, true);
            }
        };
        ContextView.prototype.show = function (delegate) {
            if (this.isVisible()) {
                this.hide();
            }
            // Show static box
            this.$view.setClass('context-view').empty().style({ top: '0px', left: '0px' }).show();
            // Render content
            this.toDisposeOnClean = delegate.render(this.$view.getHTMLElement());
            // Set active delegate
            this.delegate = delegate;
            // Layout
            this.doLayout();
        };
        ContextView.prototype.layout = function () {
            if (!this.isVisible()) {
                return;
            }
            if (this.delegate.canRelayout === false) {
                this.hide();
                return;
            }
            if (this.delegate.layout) {
                this.delegate.layout();
            }
            this.doLayout();
        };
        ContextView.prototype.doLayout = function () {
            // Get anchor
            var anchor = this.delegate.getAnchor();
            // Compute around
            var around;
            // Get the element's position and size (to anchor the view)
            if (DOM.isHTMLElement(anchor)) {
                var elementPosition = DOM.getDomNodePagePosition(anchor);
                around = {
                    top: elementPosition.top,
                    left: elementPosition.left,
                    width: elementPosition.width,
                    height: elementPosition.height
                };
            }
            else {
                var realAnchor = anchor;
                around = {
                    top: realAnchor.y,
                    left: realAnchor.x,
                    width: realAnchor.width || 0,
                    height: realAnchor.height || 0
                };
            }
            var viewport = {
                top: DOM.StandardWindow.scrollY,
                left: DOM.StandardWindow.scrollX,
                height: window.innerHeight,
                width: window.innerWidth
            };
            // Get the view's size
            var viewSize = this.$view.getTotalSize();
            var view = { width: viewSize.width, height: viewSize.height };
            var anchorPosition = this.delegate.anchorPosition || AnchorPosition.BELOW;
            var anchorAlignment = this.delegate.anchorAlignment || AnchorAlignment.LEFT;
            var result = layout(view, around, viewport, anchorPosition, anchorAlignment);
            var containerPosition = DOM.getDomNodePagePosition(this.$container.getHTMLElement());
            result.top -= containerPosition.top;
            result.left -= containerPosition.left;
            this.$view.removeClass('top', 'bottom', 'left', 'right');
            this.$view.addClass(anchorPosition === AnchorPosition.BELOW ? 'bottom' : 'top');
            this.$view.addClass(anchorAlignment === AnchorAlignment.LEFT ? 'left' : 'right');
            this.$view.style({ top: result.top + 'px', left: result.left + 'px', width: 'initial' });
        };
        ContextView.prototype.hide = function (data) {
            if (this.delegate && this.delegate.onHide) {
                this.delegate.onHide(data);
            }
            this.delegate = null;
            if (this.toDisposeOnClean) {
                this.toDisposeOnClean.dispose();
                this.toDisposeOnClean = null;
            }
            this.$view.hide();
        };
        ContextView.prototype.isVisible = function () {
            return !!this.delegate;
        };
        ContextView.prototype.onDOMEvent = function (e, element, onCapture) {
            if (this.delegate) {
                if (this.delegate.onDOMEvent) {
                    this.delegate.onDOMEvent(e, document.activeElement);
                }
                else if (onCapture && !DOM.isAncestor(e.target, this.$container.getHTMLElement())) {
                    this.hide();
                }
            }
        };
        ContextView.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.hide();
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        return ContextView;
    }(eventEmitter_1.EventEmitter));
    ContextView.BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur'];
    ContextView.BUBBLE_DOWN_EVENTS = ['click'];
    exports.ContextView = ContextView;
});

define(__m[214/*vs/css!vs/base/browser/ui/countBadge/countBadge*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[216/*vs/base/browser/ui/countBadge/countBadge*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,9/*vs/base/common/strings*/,214/*vs/css!vs/base/browser/ui/countBadge/countBadge*/]), function (require, exports, dom_1, strings_1) {
    'use strict';
    var CountBadge = (function () {
        function CountBadge(container, count, titleFormat) {
            this.element = dom_1.append(container, dom_1.$('.monaco-count-badge'));
            this.titleFormat = titleFormat || '';
            this.setCount(count || 0);
        }
        CountBadge.prototype.setCount = function (count) {
            this.count = count;
            this.render();
        };
        CountBadge.prototype.setTitleFormat = function (titleFormat) {
            this.titleFormat = titleFormat;
            this.render();
        };
        CountBadge.prototype.render = function () {
            this.element.textContent = '' + this.count;
            this.element.title = strings_1.format(this.titleFormat, this.count);
        };
        return CountBadge;
    }());
    exports.CountBadge = CountBadge;
});

define(__m[218/*vs/css!vs/base/browser/ui/findinput/findInput*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[225/*vs/css!vs/base/browser/ui/iconLabel/iconlabel*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[172/*vs/base/browser/ui/iconLabel/iconLabel*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,110/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,39/*vs/base/common/paths*/,24/*vs/base/common/types*/,156/*vs/base/common/labels*/,225/*vs/css!vs/base/browser/ui/iconLabel/iconlabel*/]), function (require, exports, dom, highlightedLabel_1, paths, types, labels_1) {
    'use strict';
    var IconLabel = (function () {
        function IconLabel(container, options) {
            this.domNode = dom.append(container, dom.$('.monaco-icon-label'));
            if (options && options.supportHighlights) {
                this.labelNode = new highlightedLabel_1.HighlightedLabel(dom.append(this.domNode, dom.$('a.label-name')));
            }
            else {
                this.labelNode = dom.append(this.domNode, dom.$('a.label-name'));
            }
            this.descriptionNode = dom.append(this.domNode, dom.$('span.label-description'));
        }
        Object.defineProperty(IconLabel.prototype, "element", {
            get: function () {
                return this.domNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconLabel.prototype, "labelElement", {
            get: function () {
                var labelNode = this.labelNode;
                if (labelNode instanceof highlightedLabel_1.HighlightedLabel) {
                    return labelNode.element;
                }
                else {
                    return labelNode;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IconLabel.prototype, "descriptionElement", {
            get: function () {
                return this.descriptionNode;
            },
            enumerable: true,
            configurable: true
        });
        IconLabel.prototype.setValue = function (label, description, options) {
            var labelNode = this.labelNode;
            if (labelNode instanceof highlightedLabel_1.HighlightedLabel) {
                labelNode.set(label || '', options ? options.matches : void 0);
            }
            else {
                labelNode.textContent = label || '';
            }
            this.descriptionNode.textContent = description || '';
            if (!description) {
                dom.addClass(this.descriptionNode, 'empty');
            }
            else {
                dom.removeClass(this.descriptionNode, 'empty');
            }
            this.domNode.title = options && options.title ? options.title : '';
            var classes = ['monaco-icon-label'];
            if (options) {
                if (options.extraClasses) {
                    classes.push.apply(classes, options.extraClasses);
                }
                if (options.italic) {
                    classes.push('italic');
                }
            }
            this.domNode.className = classes.join(' ');
        };
        IconLabel.prototype.dispose = function () {
            var labelNode = this.labelNode;
            if (labelNode instanceof highlightedLabel_1.HighlightedLabel) {
                labelNode.dispose();
            }
        };
        return IconLabel;
    }());
    exports.IconLabel = IconLabel;
    var FileLabel = (function (_super) {
        __extends(FileLabel, _super);
        function FileLabel(container, file, provider) {
            var _this = _super.call(this, container) || this;
            _this.setFile(file, provider);
            return _this;
        }
        FileLabel.prototype.setFile = function (file, provider) {
            var path = getPath(file);
            var parent = paths.dirname(path);
            this.setValue(paths.basename(path), parent && parent !== '.' ? labels_1.getPathLabel(parent, provider) : '', { title: path });
        };
        return FileLabel;
    }(IconLabel));
    exports.FileLabel = FileLabel;
    function getPath(arg1) {
        if (!arg1) {
            return null;
        }
        if (types.isFunction(arg1.getWorkspace)) {
            var ws = arg1.getWorkspace();
            return ws ? ws.resource.fsPath : void 0;
        }
        return arg1.fsPath;
    }
});

define(__m[233/*vs/css!vs/base/browser/ui/inputbox/inputBox*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[237/*vs/css!vs/base/browser/ui/leftRightWidget/leftRightWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[240/*vs/base/browser/ui/leftRightWidget/leftRightWidget*/], __M([1/*require*/,0/*exports*/,33/*vs/base/browser/builder*/,237/*vs/css!vs/base/browser/ui/leftRightWidget/leftRightWidget*/]), function (require, exports, builder_1) {
    'use strict';
    var LeftRightWidget = (function () {
        function LeftRightWidget(container, renderLeftFn, renderRightFn) {
            this.$el = builder_1.$('.monaco-left-right-widget').appendTo(container);
            this.toDispose = [
                renderRightFn(builder_1.$('.right').appendTo(this.$el).getHTMLElement()),
                renderLeftFn(builder_1.$('span.left').appendTo(this.$el).getHTMLElement())
            ].filter(function (x) { return !!x; });
        }
        LeftRightWidget.prototype.dispose = function () {
            if (this.$el) {
                this.$el.destroy();
                this.$el = null;
            }
        };
        return LeftRightWidget;
    }());
    exports.LeftRightWidget = LeftRightWidget;
});

define(__m[242/*vs/css!vs/base/browser/ui/list/list*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[243/*vs/css!vs/base/browser/ui/menu/menu*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[127/*vs/css!vs/base/browser/ui/progressbar/progressbar*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[247/*vs/base/browser/ui/progressbar/progressbar*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,63/*vs/base/common/assert*/,33/*vs/base/browser/builder*/,11/*vs/base/browser/dom*/,3/*vs/base/common/lifecycle*/,127/*vs/css!vs/base/browser/ui/progressbar/progressbar*/]), function (require, exports, winjs_base_1, assert, builder_1, DOM, lifecycle_1) {
    'use strict';
    var css_done = 'done';
    var css_active = 'active';
    var css_infinite = 'infinite';
    var css_discrete = 'discrete';
    var css_progress_container = 'progress-container';
    var css_progress_bit = 'progress-bit';
    /**
     * A progress bar with support for infinite or discrete progress.
     */
    var ProgressBar = (function () {
        function ProgressBar(builder) {
            this.toUnbind = [];
            this.workedVal = 0;
            this.create(builder);
        }
        ProgressBar.prototype.create = function (parent) {
            var _this = this;
            parent.div({ 'class': css_progress_container }, function (builder) {
                _this.element = builder.clone();
                builder.div({ 'class': css_progress_bit }).on([DOM.EventType.ANIMATION_START, DOM.EventType.ANIMATION_END, DOM.EventType.ANIMATION_ITERATION], function (e) {
                    switch (e.type) {
                        case DOM.EventType.ANIMATION_START:
                        case DOM.EventType.ANIMATION_END:
                            _this.animationRunning = e.type === DOM.EventType.ANIMATION_START;
                            break;
                        case DOM.EventType.ANIMATION_ITERATION:
                            if (_this.animationStopToken) {
                                _this.animationStopToken(null);
                            }
                            break;
                    }
                }, _this.toUnbind);
                _this.bit = builder.getHTMLElement();
            });
        };
        ProgressBar.prototype.off = function () {
            this.bit.style.width = 'inherit';
            this.bit.style.opacity = '1';
            this.element.removeClass(css_active);
            this.element.removeClass(css_infinite);
            this.element.removeClass(css_discrete);
            this.workedVal = 0;
            this.totalWork = undefined;
        };
        /**
         * Indicates to the progress bar that all work is done.
         */
        ProgressBar.prototype.done = function () {
            return this.doDone(true);
        };
        /**
         * Stops the progressbar from showing any progress instantly without fading out.
         */
        ProgressBar.prototype.stop = function () {
            return this.doDone(false);
        };
        ProgressBar.prototype.doDone = function (delayed) {
            var _this = this;
            this.element.addClass(css_done);
            // let it grow to 100% width and hide afterwards
            if (!this.element.hasClass(css_infinite)) {
                this.bit.style.width = 'inherit';
                if (delayed) {
                    winjs_base_1.TPromise.timeout(200).then(function () { return _this.off(); });
                }
                else {
                    this.off();
                }
            }
            else {
                this.bit.style.opacity = '0';
                if (delayed) {
                    winjs_base_1.TPromise.timeout(200).then(function () { return _this.off(); });
                }
                else {
                    this.off();
                }
            }
            return this;
        };
        /**
         * Use this mode to indicate progress that has no total number of work units.
         */
        ProgressBar.prototype.infinite = function () {
            this.bit.style.width = '2%';
            this.bit.style.opacity = '1';
            this.element.removeClass(css_discrete);
            this.element.removeClass(css_done);
            this.element.addClass(css_active);
            this.element.addClass(css_infinite);
            return this;
        };
        /**
         * Tells the progress bar the total number of work. Use in combination with workedVal() to let
         * the progress bar show the actual progress based on the work that is done.
         */
        ProgressBar.prototype.total = function (value) {
            this.workedVal = 0;
            this.totalWork = value;
            return this;
        };
        /**
         * Finds out if this progress bar is configured with total work
         */
        ProgressBar.prototype.hasTotal = function () {
            return !isNaN(this.totalWork);
        };
        /**
         * Tells the progress bar that an amount of work has been completed.
         */
        ProgressBar.prototype.worked = function (value) {
            assert.ok(!isNaN(this.totalWork), 'Total work not set');
            value = Number(value);
            assert.ok(!isNaN(value), 'Value is not a number');
            value = Math.max(1, value);
            this.workedVal += value;
            this.workedVal = Math.min(this.totalWork, this.workedVal);
            if (this.element.hasClass(css_infinite)) {
                this.element.removeClass(css_infinite);
            }
            if (this.element.hasClass(css_done)) {
                this.element.removeClass(css_done);
            }
            if (!this.element.hasClass(css_active)) {
                this.element.addClass(css_active);
            }
            if (!this.element.hasClass(css_discrete)) {
                this.element.addClass(css_discrete);
            }
            this.bit.style.width = 100 * (this.workedVal / this.totalWork) + '%';
            return this;
        };
        /**
         * Returns the builder this progress bar is building in.
         */
        ProgressBar.prototype.getContainer = function () {
            return builder_1.$(this.element);
        };
        ProgressBar.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
        };
        return ProgressBar;
    }());
    exports.ProgressBar = ProgressBar;
});

define(__m[250/*vs/css!vs/base/browser/ui/sash/sash*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[98/*vs/base/browser/ui/sash/sash*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,33/*vs/base/browser/builder*/,23/*vs/base/browser/browser*/,19/*vs/base/common/platform*/,24/*vs/base/common/types*/,11/*vs/base/browser/dom*/,61/*vs/base/browser/touch*/,25/*vs/base/common/eventEmitter*/,34/*vs/base/browser/mouseEvent*/,12/*vs/base/common/event*/,250/*vs/css!vs/base/browser/ui/sash/sash*/]), function (require, exports, lifecycle_1, builder_1, browser_1, platform_1, types, DOM, touch_1, eventEmitter_1, mouseEvent_1, event_1) {
    'use strict';
    var Orientation;
    (function (Orientation) {
        Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
        Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
    })(Orientation = exports.Orientation || (exports.Orientation = {}));
    var Sash = (function (_super) {
        __extends(Sash, _super);
        function Sash(container, layoutProvider, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.$e = builder_1.$('.monaco-sash').appendTo(container);
            if (platform_1.isMacintosh) {
                _this.$e.addClass('mac');
            }
            _this.gesture = new touch_1.Gesture(_this.$e.getHTMLElement());
            _this.$e.on(DOM.EventType.MOUSE_DOWN, function (e) { _this.onMouseDown(e); });
            _this.$e.on(DOM.EventType.DBLCLICK, function (e) { _this.emit('reset', e); });
            _this.$e.on(touch_1.EventType.Start, function (e) { _this.onTouchStart(e); });
            _this.size = options.baseSize || 5;
            if (browser_1.isIPad) {
                _this.size *= 4; // see also http://ux.stackexchange.com/questions/39023/what-is-the-optimum-button-size-of-touch-screen-applications
                _this.$e.addClass('touch');
            }
            _this.setOrientation(options.orientation || Orientation.VERTICAL);
            _this.isDisabled = false;
            _this.hidden = false;
            _this.layoutProvider = layoutProvider;
            return _this;
        }
        Sash.prototype.getHTMLElement = function () {
            return this.$e.getHTMLElement();
        };
        Sash.prototype.setOrientation = function (orientation) {
            this.orientation = orientation;
            this.$e.removeClass('horizontal', 'vertical');
            this.$e.addClass(this.getOrientation());
            if (this.orientation === Orientation.HORIZONTAL) {
                this.$e.size(null, this.size);
            }
            else {
                this.$e.size(this.size);
            }
            if (this.layoutProvider) {
                this.layout();
            }
        };
        Sash.prototype.getOrientation = function () {
            return this.orientation === Orientation.HORIZONTAL ? 'horizontal' : 'vertical';
        };
        Sash.prototype.onMouseDown = function (e) {
            var _this = this;
            DOM.EventHelper.stop(e, false);
            if (this.isDisabled) {
                return;
            }
            var iframes = builder_1.$(DOM.getElementsByTagName('iframe'));
            if (iframes) {
                iframes.style('pointer-events', 'none'); // disable mouse events on iframes as long as we drag the sash
            }
            var mouseDownEvent = new mouseEvent_1.StandardMouseEvent(e);
            var startX = mouseDownEvent.posx;
            var startY = mouseDownEvent.posy;
            var startEvent = {
                startX: startX,
                currentX: startX,
                startY: startY,
                currentY: startY
            };
            this.$e.addClass('active');
            this.emit('start', startEvent);
            var $window = builder_1.$(window);
            var containerCSSClass = this.getOrientation() + "-cursor-container" + (platform_1.isMacintosh ? '-mac' : '');
            var lastCurrentX = startX;
            var lastCurrentY = startY;
            $window.on('mousemove', function (e) {
                DOM.EventHelper.stop(e, false);
                var mouseMoveEvent = new mouseEvent_1.StandardMouseEvent(e);
                var event = {
                    startX: startX,
                    currentX: mouseMoveEvent.posx,
                    startY: startY,
                    currentY: mouseMoveEvent.posy
                };
                lastCurrentX = mouseMoveEvent.posx;
                lastCurrentY = mouseMoveEvent.posy;
                _this.emit('change', event);
            }).once('mouseup', function (e) {
                DOM.EventHelper.stop(e, false);
                _this.$e.removeClass('active');
                _this.emit('end');
                $window.off('mousemove');
                document.body.classList.remove(containerCSSClass);
                var iframes = builder_1.$(DOM.getElementsByTagName('iframe'));
                if (iframes) {
                    iframes.style('pointer-events', 'auto');
                }
            });
            document.body.classList.add(containerCSSClass);
        };
        Sash.prototype.onTouchStart = function (event) {
            var _this = this;
            DOM.EventHelper.stop(event);
            var listeners = [];
            var startX = event.pageX;
            var startY = event.pageY;
            this.emit('start', {
                startX: startX,
                currentX: startX,
                startY: startY,
                currentY: startY
            });
            var lastCurrentX = startX;
            var lastCurrentY = startY;
            listeners.push(DOM.addDisposableListener(this.$e.getHTMLElement(), touch_1.EventType.Change, function (event) {
                if (types.isNumber(event.pageX) && types.isNumber(event.pageY)) {
                    _this.emit('change', {
                        startX: startX,
                        currentX: event.pageX,
                        startY: startY,
                        currentY: event.pageY
                    });
                    lastCurrentX = event.pageX;
                    lastCurrentY = event.pageY;
                }
            }));
            listeners.push(DOM.addDisposableListener(this.$e.getHTMLElement(), touch_1.EventType.End, function (event) {
                _this.emit('end');
                lifecycle_1.dispose(listeners);
            }));
        };
        Sash.prototype.layout = function () {
            var style;
            if (this.orientation === Orientation.VERTICAL) {
                var verticalProvider = this.layoutProvider;
                style = { left: verticalProvider.getVerticalSashLeft(this) - (this.size / 2) + 'px' };
                if (verticalProvider.getVerticalSashTop) {
                    style.top = verticalProvider.getVerticalSashTop(this) + 'px';
                }
                if (verticalProvider.getVerticalSashHeight) {
                    style.height = verticalProvider.getVerticalSashHeight(this) + 'px';
                }
            }
            else {
                var horizontalProvider = this.layoutProvider;
                style = { top: horizontalProvider.getHorizontalSashTop(this) - (this.size / 2) + 'px' };
                if (horizontalProvider.getHorizontalSashLeft) {
                    style.left = horizontalProvider.getHorizontalSashLeft(this) + 'px';
                }
                if (horizontalProvider.getHorizontalSashWidth) {
                    style.width = horizontalProvider.getHorizontalSashWidth(this) + 'px';
                }
            }
            this.$e.style(style);
        };
        Sash.prototype.show = function () {
            this.hidden = false;
            this.$e.show();
        };
        Sash.prototype.hide = function () {
            this.hidden = true;
            this.$e.hide();
        };
        Sash.prototype.isHidden = function () {
            return this.hidden;
        };
        Sash.prototype.enable = function () {
            this.$e.removeClass('disabled');
            this.isDisabled = false;
        };
        Sash.prototype.disable = function () {
            this.$e.addClass('disabled');
            this.isDisabled = true;
        };
        Sash.prototype.dispose = function () {
            if (this.$e) {
                this.$e.destroy();
                this.$e = null;
            }
            _super.prototype.dispose.call(this);
        };
        return Sash;
    }(eventEmitter_1.EventEmitter));
    exports.Sash = Sash;
    /**
     * A simple Vertical Sash that computes the position of the sash when it is moved between the given dimension.
     * Triggers onPositionChange event when the position is changed
     */
    var VSash = (function (_super) {
        __extends(VSash, _super);
        function VSash(container, minWidth) {
            var _this = _super.call(this) || this;
            _this.minWidth = minWidth;
            _this._onPositionChange = new event_1.Emitter();
            _this.ratio = 0.5;
            _this.sash = new Sash(container, _this);
            _this._register(_this.sash.addListener2('start', function () { return _this.onSashDragStart(); }));
            _this._register(_this.sash.addListener2('change', function (e) { return _this.onSashDrag(e); }));
            _this._register(_this.sash.addListener2('end', function () { return _this.onSashDragEnd(); }));
            _this._register(_this.sash.addListener2('reset', function () { return _this.onSashReset(); }));
            return _this;
        }
        Object.defineProperty(VSash.prototype, "onPositionChange", {
            get: function () { return this._onPositionChange.event; },
            enumerable: true,
            configurable: true
        });
        VSash.prototype.getVerticalSashTop = function () {
            return 0;
        };
        VSash.prototype.getVerticalSashLeft = function () {
            return this.position;
        };
        VSash.prototype.getVerticalSashHeight = function () {
            return this.dimension.height;
        };
        VSash.prototype.setDimenesion = function (dimension) {
            this.dimension = dimension;
            this.compute(this.ratio);
        };
        VSash.prototype.onSashDragStart = function () {
            this.startPosition = this.position;
        };
        VSash.prototype.onSashDrag = function (e) {
            this.compute((this.startPosition + (e.currentX - e.startX)) / this.dimension.width);
        };
        VSash.prototype.compute = function (ratio) {
            this.computeSashPosition(ratio);
            this.ratio = this.position / this.dimension.width;
            this._onPositionChange.fire(this.position);
        };
        VSash.prototype.onSashDragEnd = function () {
            this.sash.layout();
        };
        VSash.prototype.onSashReset = function () {
            this.ratio = 0.5;
            this._onPositionChange.fire(this.position);
            this.sash.layout();
        };
        VSash.prototype.computeSashPosition = function (sashRatio) {
            if (sashRatio === void 0) { sashRatio = this.ratio; }
            var contentWidth = this.dimension.width;
            var sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
            var midPoint = Math.floor(0.5 * contentWidth);
            if (contentWidth > this.minWidth * 2) {
                if (sashPosition < this.minWidth) {
                    sashPosition = this.minWidth;
                }
                if (sashPosition > contentWidth - this.minWidth) {
                    sashPosition = contentWidth - this.minWidth;
                }
            }
            else {
                sashPosition = midPoint;
            }
            if (this.position !== sashPosition) {
                this.position = sashPosition;
                this.sash.layout();
            }
        };
        return VSash;
    }(lifecycle_1.Disposable));
    exports.VSash = VSash;
});

define(__m[255/*vs/css!vs/base/browser/ui/scrollbar/media/scrollbars*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});





define(__m[60/*vs/base/browser/ui/scrollbar/scrollableElement*/], __M([1/*require*/,0/*exports*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,19/*vs/base/common/platform*/,34/*vs/base/browser/mouseEvent*/,483/*vs/base/browser/ui/scrollbar/horizontalScrollbar*/,493/*vs/base/browser/ui/scrollbar/verticalScrollbar*/,3/*vs/base/common/lifecycle*/,38/*vs/base/common/scrollable*/,40/*vs/base/browser/ui/widget*/,17/*vs/base/common/async*/,29/*vs/base/browser/styleMutator*/,12/*vs/base/common/event*/,255/*vs/css!vs/base/browser/ui/scrollbar/media/scrollbars*/]), function (require, exports, Browser, DomUtils, Platform, mouseEvent_1, horizontalScrollbar_1, verticalScrollbar_1, lifecycle_1, scrollable_1, widget_1, async_1, styleMutator_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HIDE_TIMEOUT = 500;
    var SCROLL_WHEEL_SENSITIVITY = 50;
    var ScrollableElement = (function (_super) {
        __extends(ScrollableElement, _super);
        function ScrollableElement(element, options) {
            var _this = _super.call(this) || this;
            _this._onScroll = _this._register(new event_1.Emitter());
            _this.onScroll = _this._onScroll.event;
            element.style.overflow = 'hidden';
            _this._options = resolveOptions(options);
            _this._scrollable = _this._register(new scrollable_1.Scrollable());
            _this._register(_this._scrollable.onScroll(function (e) {
                _this._onDidScroll(e);
                _this._onScroll.fire(e);
            }));
            // this._scrollable = this._register(new DelegateScrollable(scrollable, () => this._onScroll()));
            var scrollbarHost = {
                onMouseWheel: function (mouseWheelEvent) { return _this._onMouseWheel(mouseWheelEvent); },
                onDragStart: function () { return _this._onDragStart(); },
                onDragEnd: function () { return _this._onDragEnd(); },
            };
            _this._verticalScrollbar = _this._register(new verticalScrollbar_1.VerticalScrollbar(_this._scrollable, _this._options, scrollbarHost));
            _this._horizontalScrollbar = _this._register(new horizontalScrollbar_1.HorizontalScrollbar(_this._scrollable, _this._options, scrollbarHost));
            _this._domNode = document.createElement('div');
            _this._domNode.className = 'monaco-scrollable-element ' + _this._options.className;
            _this._domNode.setAttribute('role', 'presentation');
            _this._domNode.style.position = 'relative';
            _this._domNode.style.overflow = 'hidden';
            _this._domNode.appendChild(element);
            _this._domNode.appendChild(_this._horizontalScrollbar.domNode.domNode);
            _this._domNode.appendChild(_this._verticalScrollbar.domNode.domNode);
            if (_this._options.useShadows) {
                _this._leftShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                _this._leftShadowDomNode.setClassName('shadow');
                _this._domNode.appendChild(_this._leftShadowDomNode.domNode);
                _this._topShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                _this._topShadowDomNode.setClassName('shadow');
                _this._domNode.appendChild(_this._topShadowDomNode.domNode);
                _this._topLeftShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                _this._topLeftShadowDomNode.setClassName('shadow top-left-corner');
                _this._domNode.appendChild(_this._topLeftShadowDomNode.domNode);
            }
            _this._listenOnDomNode = _this._options.listenOnDomNode || _this._domNode;
            _this._mouseWheelToDispose = [];
            _this._setListeningToMouseWheel(_this._options.handleMouseWheel);
            _this.onmouseover(_this._listenOnDomNode, function (e) { return _this._onMouseOver(e); });
            _this.onnonbubblingmouseout(_this._listenOnDomNode, function (e) { return _this._onMouseOut(e); });
            _this._hideTimeout = _this._register(new async_1.TimeoutTimer());
            _this._isDragging = false;
            _this._mouseIsOver = false;
            _this._shouldRender = true;
            return _this;
        }
        ScrollableElement.prototype.dispose = function () {
            this._mouseWheelToDispose = lifecycle_1.dispose(this._mouseWheelToDispose);
            _super.prototype.dispose.call(this);
        };
        /**
         * Get the generated 'scrollable' dom node
         */
        ScrollableElement.prototype.getDomNode = function () {
            return this._domNode;
        };
        ScrollableElement.prototype.getOverviewRulerLayoutInfo = function () {
            return {
                parent: this._domNode,
                insertBefore: this._verticalScrollbar.domNode.domNode,
            };
        };
        /**
         * Delegate a mouse down event to the vertical scrollbar.
         * This is to help with clicking somewhere else and having the scrollbar react.
         */
        ScrollableElement.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this._verticalScrollbar.delegateMouseDown(browserEvent);
        };
        ScrollableElement.prototype.updateState = function (newState) {
            this._scrollable.updateState(newState);
        };
        ScrollableElement.prototype.getWidth = function () {
            return this._scrollable.getWidth();
        };
        ScrollableElement.prototype.getScrollWidth = function () {
            return this._scrollable.getScrollWidth();
        };
        ScrollableElement.prototype.getScrollLeft = function () {
            return this._scrollable.getScrollLeft();
        };
        ScrollableElement.prototype.getHeight = function () {
            return this._scrollable.getHeight();
        };
        ScrollableElement.prototype.getScrollHeight = function () {
            return this._scrollable.getScrollHeight();
        };
        ScrollableElement.prototype.getScrollTop = function () {
            return this._scrollable.getScrollTop();
        };
        /**
         * Update the class name of the scrollable element.
         */
        ScrollableElement.prototype.updateClassName = function (newClassName) {
            this._options.className = newClassName;
            // Defaults are different on Macs
            if (Platform.isMacintosh) {
                this._options.className += ' mac';
            }
            this._domNode.className = 'monaco-scrollable-element ' + this._options.className;
        };
        /**
         * Update configuration options for the scrollbar.
         * Really this is Editor.IEditorScrollbarOptions, but base shouldn't
         * depend on Editor.
         */
        ScrollableElement.prototype.updateOptions = function (newOptions) {
            var massagedOptions = resolveOptions(newOptions);
            this._options.handleMouseWheel = massagedOptions.handleMouseWheel;
            this._options.mouseWheelScrollSensitivity = massagedOptions.mouseWheelScrollSensitivity;
            this._setListeningToMouseWheel(this._options.handleMouseWheel);
            this._shouldRender = this._horizontalScrollbar.setCanUseTranslate3d(massagedOptions.canUseTranslate3d) || this._shouldRender;
            this._shouldRender = this._verticalScrollbar.setCanUseTranslate3d(massagedOptions.canUseTranslate3d) || this._shouldRender;
            if (!this._options.lazyRender) {
                this._render();
            }
        };
        // -------------------- mouse wheel scrolling --------------------
        ScrollableElement.prototype._setListeningToMouseWheel = function (shouldListen) {
            var _this = this;
            var isListening = (this._mouseWheelToDispose.length > 0);
            if (isListening === shouldListen) {
                // No change
                return;
            }
            // Stop listening (if necessary)
            this._mouseWheelToDispose = lifecycle_1.dispose(this._mouseWheelToDispose);
            // Start listening (if necessary)
            if (shouldListen) {
                var onMouseWheel = function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseWheelEvent(browserEvent);
                    _this._onMouseWheel(e);
                };
                this._mouseWheelToDispose.push(DomUtils.addDisposableListener(this._listenOnDomNode, 'mousewheel', onMouseWheel));
                this._mouseWheelToDispose.push(DomUtils.addDisposableListener(this._listenOnDomNode, 'DOMMouseScroll', onMouseWheel));
            }
        };
        ScrollableElement.prototype._onMouseWheel = function (e) {
            if (Platform.isMacintosh && e.browserEvent && this._options.saveLastScrollTimeOnClassName) {
                // Mark dom node with timestamp of wheel event
                var target = e.browserEvent.target;
                if (target && target.nodeType === 1) {
                    var r = DomUtils.findParentWithClass(target, this._options.saveLastScrollTimeOnClassName);
                    if (r) {
                        r.setAttribute('last-scroll-time', String(new Date().getTime()));
                    }
                }
            }
            var desiredScrollTop = -1;
            var desiredScrollLeft = -1;
            if (e.deltaY || e.deltaX) {
                var deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
                var deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
                if (this._options.flipAxes) {
                    _a = [deltaX, deltaY], deltaY = _a[0], deltaX = _a[1];
                }
                if (this._options.scrollYToX && !deltaX) {
                    deltaX = deltaY;
                    deltaY = 0;
                }
                if (Platform.isMacintosh) {
                    // Give preference to vertical scrolling
                    if (deltaY && Math.abs(deltaX) < 0.2) {
                        deltaX = 0;
                    }
                    if (Math.abs(deltaY) > Math.abs(deltaX) * 0.5) {
                        deltaX = 0;
                    }
                }
                if (deltaY) {
                    var currentScrollTop = this._scrollable.getScrollTop();
                    desiredScrollTop = this._verticalScrollbar.validateScrollPosition((desiredScrollTop !== -1 ? desiredScrollTop : currentScrollTop) - SCROLL_WHEEL_SENSITIVITY * deltaY);
                    if (desiredScrollTop === currentScrollTop) {
                        desiredScrollTop = -1;
                    }
                }
                if (deltaX) {
                    var currentScrollLeft = this._scrollable.getScrollLeft();
                    desiredScrollLeft = this._horizontalScrollbar.validateScrollPosition((desiredScrollLeft !== -1 ? desiredScrollLeft : currentScrollLeft) - SCROLL_WHEEL_SENSITIVITY * deltaX);
                    if (desiredScrollLeft === currentScrollLeft) {
                        desiredScrollLeft = -1;
                    }
                }
                if (desiredScrollTop !== -1 || desiredScrollLeft !== -1) {
                    if (desiredScrollTop !== -1) {
                        this._shouldRender = this._verticalScrollbar.setDesiredScrollPosition(desiredScrollTop) || this._shouldRender;
                        desiredScrollTop = -1;
                    }
                    if (desiredScrollLeft !== -1) {
                        this._shouldRender = this._horizontalScrollbar.setDesiredScrollPosition(desiredScrollLeft) || this._shouldRender;
                        desiredScrollLeft = -1;
                    }
                }
            }
            if (this._options.alwaysConsumeMouseWheel || this._shouldRender) {
                e.preventDefault();
                e.stopPropagation();
            }
            var _a;
        };
        ScrollableElement.prototype._onDidScroll = function (e) {
            this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
            this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
            if (this._options.useShadows) {
                this._shouldRender = true;
            }
            this._reveal();
            if (!this._options.lazyRender) {
                this._render();
            }
        };
        /**
         * Render / mutate the DOM now.
         * Should be used together with the ctor option `lazyRender`.
         */
        ScrollableElement.prototype.renderNow = function () {
            if (!this._options.lazyRender) {
                throw new Error('Please use `lazyRender` together with `renderNow`!');
            }
            this._render();
        };
        ScrollableElement.prototype._render = function () {
            if (!this._shouldRender) {
                return;
            }
            this._shouldRender = false;
            this._horizontalScrollbar.render();
            this._verticalScrollbar.render();
            if (this._options.useShadows) {
                var enableTop = this._scrollable.getScrollTop() > 0;
                var enableLeft = this._scrollable.getScrollLeft() > 0;
                this._leftShadowDomNode.setClassName('shadow' + (enableLeft ? ' left' : ''));
                this._topShadowDomNode.setClassName('shadow' + (enableTop ? ' top' : ''));
                this._topLeftShadowDomNode.setClassName('shadow top-left-corner' + (enableTop ? ' top' : '') + (enableLeft ? ' left' : ''));
            }
        };
        // -------------------- fade in / fade out --------------------
        ScrollableElement.prototype._onDragStart = function () {
            this._isDragging = true;
            this._reveal();
        };
        ScrollableElement.prototype._onDragEnd = function () {
            this._isDragging = false;
            this._hide();
        };
        ScrollableElement.prototype._onMouseOut = function (e) {
            this._mouseIsOver = false;
            this._hide();
        };
        ScrollableElement.prototype._onMouseOver = function (e) {
            this._mouseIsOver = true;
            this._reveal();
        };
        ScrollableElement.prototype._reveal = function () {
            this._verticalScrollbar.beginReveal();
            this._horizontalScrollbar.beginReveal();
            this._scheduleHide();
        };
        ScrollableElement.prototype._hide = function () {
            if (!this._mouseIsOver && !this._isDragging) {
                this._verticalScrollbar.beginHide();
                this._horizontalScrollbar.beginHide();
            }
        };
        ScrollableElement.prototype._scheduleHide = function () {
            var _this = this;
            this._hideTimeout.cancelAndSet(function () { return _this._hide(); }, HIDE_TIMEOUT);
        };
        return ScrollableElement;
    }(widget_1.Widget));
    exports.ScrollableElement = ScrollableElement;
    var DomScrollableElement = (function (_super) {
        __extends(DomScrollableElement, _super);
        function DomScrollableElement(element, options) {
            var _this = _super.call(this, element, options) || this;
            _this._element = element;
            _this.onScroll(function (e) {
                if (e.scrollTopChanged) {
                    _this._element.scrollTop = e.scrollTop;
                }
                if (e.scrollLeftChanged) {
                    _this._element.scrollLeft = e.scrollLeft;
                }
            });
            _this.scanDomNode();
            return _this;
        }
        DomScrollableElement.prototype.scanDomNode = function () {
            // widh, scrollLeft, scrollWidth, height, scrollTop, scrollHeight
            this.updateState({
                width: this._element.clientWidth,
                scrollWidth: this._element.scrollWidth,
                scrollLeft: this._element.scrollLeft,
                height: this._element.clientHeight,
                scrollHeight: this._element.scrollHeight,
                scrollTop: this._element.scrollTop,
            });
        };
        return DomScrollableElement;
    }(ScrollableElement));
    exports.DomScrollableElement = DomScrollableElement;
    function resolveOptions(opts) {
        var result = {
            canUseTranslate3d: opts.canUseTranslate3d && Browser.canUseTranslate3d,
            lazyRender: (typeof opts.lazyRender !== 'undefined' ? opts.lazyRender : false),
            className: (typeof opts.className !== 'undefined' ? opts.className : ''),
            useShadows: (typeof opts.useShadows !== 'undefined' ? opts.useShadows : true),
            handleMouseWheel: (typeof opts.handleMouseWheel !== 'undefined' ? opts.handleMouseWheel : true),
            flipAxes: (typeof opts.flipAxes !== 'undefined' ? opts.flipAxes : false),
            alwaysConsumeMouseWheel: (typeof opts.alwaysConsumeMouseWheel !== 'undefined' ? opts.alwaysConsumeMouseWheel : false),
            scrollYToX: (typeof opts.scrollYToX !== 'undefined' ? opts.scrollYToX : false),
            mouseWheelScrollSensitivity: (typeof opts.mouseWheelScrollSensitivity !== 'undefined' ? opts.mouseWheelScrollSensitivity : 1),
            arrowSize: (typeof opts.arrowSize !== 'undefined' ? opts.arrowSize : 11),
            listenOnDomNode: (typeof opts.listenOnDomNode !== 'undefined' ? opts.listenOnDomNode : null),
            horizontal: (typeof opts.horizontal !== 'undefined' ? opts.horizontal : scrollable_1.ScrollbarVisibility.Auto),
            horizontalScrollbarSize: (typeof opts.horizontalScrollbarSize !== 'undefined' ? opts.horizontalScrollbarSize : 10),
            horizontalSliderSize: (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : 0),
            horizontalHasArrows: (typeof opts.horizontalHasArrows !== 'undefined' ? opts.horizontalHasArrows : false),
            vertical: (typeof opts.vertical !== 'undefined' ? opts.vertical : scrollable_1.ScrollbarVisibility.Auto),
            verticalScrollbarSize: (typeof opts.verticalScrollbarSize !== 'undefined' ? opts.verticalScrollbarSize : 10),
            verticalHasArrows: (typeof opts.verticalHasArrows !== 'undefined' ? opts.verticalHasArrows : false),
            verticalSliderSize: (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : 0),
            saveLastScrollTimeOnClassName: (typeof opts.saveLastScrollTimeOnClassName !== 'undefined' ? opts.saveLastScrollTimeOnClassName : null)
        };
        result.horizontalSliderSize = (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : result.horizontalScrollbarSize);
        result.verticalSliderSize = (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : result.verticalScrollbarSize);
        // Defaults are different on Macs
        if (Platform.isMacintosh) {
            result.className += ' mac';
        }
        return result;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[262/*vs/base/browser/ui/list/listView*/], __M([1/*require*/,0/*exports*/,36/*vs/base/common/objects*/,3/*vs/base/common/lifecycle*/,61/*vs/base/browser/touch*/,11/*vs/base/browser/dom*/,121/*vs/base/browser/event*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,38/*vs/base/common/scrollable*/,193/*vs/base/browser/ui/list/rangeMap*/,440/*vs/base/browser/ui/list/rowCache*/]), function (require, exports, objects_1, lifecycle_1, touch_1, DOM, event_1, scrollableElement_1, scrollable_1, rangeMap_1, rowCache_1) {
    "use strict";
    var MouseEventTypes = [
        'click',
        'dblclick',
        'mouseup',
        'mousedown',
        'mouseover',
        'mousemove',
        'mouseout',
        'contextmenu'
    ];
    var DefaultOptions = {
        useShadows: true
    };
    var ListView = (function () {
        function ListView(container, delegate, renderers, options) {
            if (options === void 0) { options = DefaultOptions; }
            this.delegate = delegate;
            this.items = [];
            this.itemId = 0;
            this.rangeMap = new rangeMap_1.RangeMap();
            this.renderers = objects_1.toObject(renderers, function (r) { return r.templateId; });
            this.cache = new rowCache_1.RowCache(this.renderers);
            this.lastRenderTop = 0;
            this.lastRenderHeight = 0;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-list';
            this.rowsContainer = document.createElement('div');
            this.rowsContainer.className = 'monaco-list-rows';
            this.gesture = new touch_1.Gesture(this.rowsContainer);
            this.scrollableElement = new scrollableElement_1.ScrollableElement(this.rowsContainer, {
                canUseTranslate3d: false,
                alwaysConsumeMouseWheel: true,
                horizontal: scrollable_1.ScrollbarVisibility.Hidden,
                vertical: scrollable_1.ScrollbarVisibility.Auto,
                useShadows: objects_1.getOrDefault(options, function (o) { return o.useShadows; }, DefaultOptions.useShadows),
                saveLastScrollTimeOnClassName: 'monaco-list-row'
            });
            this._domNode.appendChild(this.scrollableElement.getDomNode());
            container.appendChild(this._domNode);
            this.disposables = [this.rangeMap, this.gesture, this.scrollableElement];
            this.scrollableElement.onScroll(this.onScroll, this, this.disposables);
            event_1.domEvent(this.rowsContainer, touch_1.EventType.Change)(this.onTouchChange, this, this.disposables);
            this.layout();
        }
        Object.defineProperty(ListView.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        ListView.prototype.splice = function (start, deleteCount, elements) {
            var _this = this;
            if (elements === void 0) { elements = []; }
            var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            rangeMap_1.each(previousRenderRange, function (i) { return _this.removeItemFromDOM(_this.items[i]); });
            var inserted = elements.map(function (element) { return ({
                id: String(_this.itemId++),
                element: element,
                size: _this.delegate.getHeight(element),
                templateId: _this.delegate.getTemplateId(element),
                row: null
            }); });
            (_a = this.rangeMap).splice.apply(_a, [start, deleteCount].concat(inserted));
            var deleted = (_b = this.items).splice.apply(_b, [start, deleteCount].concat(inserted));
            var renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            rangeMap_1.each(renderRange, function (i) { return _this.insertItemInDOM(_this.items[i], i); });
            var scrollHeight = this.getContentHeight();
            this.rowsContainer.style.height = scrollHeight + "px";
            this.scrollableElement.updateState({ scrollHeight: scrollHeight });
            return deleted.map(function (i) { return i.element; });
            var _a, _b;
        };
        Object.defineProperty(ListView.prototype, "length", {
            get: function () {
                return this.items.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListView.prototype, "renderHeight", {
            get: function () {
                return this.scrollableElement.getHeight();
            },
            enumerable: true,
            configurable: true
        });
        ListView.prototype.element = function (index) {
            return this.items[index].element;
        };
        ListView.prototype.elementHeight = function (index) {
            return this.items[index].size;
        };
        ListView.prototype.elementTop = function (index) {
            return this.rangeMap.positionAt(index);
        };
        ListView.prototype.indexAt = function (position) {
            return this.rangeMap.indexAt(position);
        };
        ListView.prototype.indexAfter = function (position) {
            return this.rangeMap.indexAfter(position);
        };
        ListView.prototype.layout = function (height) {
            this.scrollableElement.updateState({
                height: height || DOM.getContentHeight(this._domNode)
            });
        };
        // Render
        ListView.prototype.render = function (renderTop, renderHeight) {
            var _this = this;
            var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            var renderRange = this.getRenderRange(renderTop, renderHeight);
            var rangesToInsert = rangeMap_1.relativeComplement(renderRange, previousRenderRange);
            var rangesToRemove = rangeMap_1.relativeComplement(previousRenderRange, renderRange);
            rangesToInsert.forEach(function (range) { return rangeMap_1.each(range, function (i) { return _this.insertItemInDOM(_this.items[i], i); }); });
            rangesToRemove.forEach(function (range) { return rangeMap_1.each(range, function (i) { return _this.removeItemFromDOM(_this.items[i]); }); });
            var transform = "translate3d(0px, -" + renderTop + "px, 0px)";
            this.rowsContainer.style.transform = transform;
            this.rowsContainer.style.webkitTransform = transform;
            this.lastRenderTop = renderTop;
            this.lastRenderHeight = renderHeight;
        };
        // DOM operations
        ListView.prototype.insertItemInDOM = function (item, index) {
            if (!item.row) {
                item.row = this.cache.alloc(item.templateId);
            }
            if (!item.row.domNode.parentElement) {
                this.rowsContainer.appendChild(item.row.domNode);
            }
            var renderer = this.renderers[item.templateId];
            item.row.domNode.style.top = this.elementTop(index) + "px";
            item.row.domNode.style.height = item.size + "px";
            item.row.domNode.setAttribute('data-index', "" + index);
            renderer.renderElement(item.element, index, item.row.templateData);
        };
        ListView.prototype.removeItemFromDOM = function (item) {
            this.cache.release(item.row);
            item.row = null;
        };
        ListView.prototype.getContentHeight = function () {
            return this.rangeMap.size;
        };
        ListView.prototype.getScrollTop = function () {
            return this.scrollableElement.getScrollTop();
        };
        ListView.prototype.setScrollTop = function (scrollTop) {
            this.scrollableElement.updateState({ scrollTop: scrollTop });
        };
        Object.defineProperty(ListView.prototype, "scrollTop", {
            get: function () {
                return this.getScrollTop();
            },
            set: function (scrollTop) {
                this.setScrollTop(scrollTop);
            },
            enumerable: true,
            configurable: true
        });
        // Events
        ListView.prototype.addListener = function (type, handler, useCapture) {
            var _this = this;
            var userHandler = handler;
            var domNode = this.domNode;
            if (MouseEventTypes.indexOf(type) > -1) {
                handler = function (e) { return _this.fireScopedEvent(userHandler, _this.getItemIndexFromMouseEvent(e)); };
            }
            else if (type === touch_1.EventType.Tap) {
                domNode = this.rowsContainer;
                handler = function (e) { return _this.fireScopedEvent(userHandler, _this.getItemIndexFromGestureEvent(e)); };
            }
            return DOM.addDisposableListener(domNode, type, handler, useCapture);
        };
        ListView.prototype.fireScopedEvent = function (handler, index) {
            if (index < 0) {
                return;
            }
            var element = this.items[index].element;
            handler(objects_1.assign(event, { element: element, index: index }));
        };
        ListView.prototype.onScroll = function (e) {
            this.render(e.scrollTop, e.height);
        };
        ListView.prototype.onTouchChange = function (e) {
            event.preventDefault();
            event.stopPropagation();
            this.scrollTop -= e.translationY;
        };
        // Util
        ListView.prototype.getItemIndexFromMouseEvent = function (event) {
            return this.getItemIndexFromEventTarget(event.target);
        };
        ListView.prototype.getItemIndexFromGestureEvent = function (event) {
            return this.getItemIndexFromEventTarget(event.initialTarget);
        };
        ListView.prototype.getItemIndexFromEventTarget = function (target) {
            while (target instanceof HTMLElement && target !== this.rowsContainer) {
                var element = target;
                var rawIndex = element.getAttribute('data-index');
                if (rawIndex) {
                    var index = Number(rawIndex);
                    if (!isNaN(index)) {
                        return index;
                    }
                }
                target = element.parentElement;
            }
            return -1;
        };
        ListView.prototype.getRenderRange = function (renderTop, renderHeight) {
            return {
                start: this.rangeMap.indexAt(renderTop),
                end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
            };
        };
        // Dispose
        ListView.prototype.dispose = function () {
            this.items = null;
            if (this._domNode && this._domNode.parentElement) {
                this._domNode.parentNode.removeChild(this._domNode);
                this._domNode = null;
            }
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return ListView;
    }());
    exports.ListView = ListView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define(__m[263/*vs/base/browser/ui/list/listWidget*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,24/*vs/base/common/types*/,428/*vs/base/common/decorators*/,11/*vs/base/browser/dom*/,61/*vs/base/browser/touch*/,51/*vs/base/browser/keyboardEvent*/,12/*vs/base/common/event*/,121/*vs/base/browser/event*/,262/*vs/base/browser/ui/list/listView*/,242/*vs/css!vs/base/browser/ui/list/list*/]), function (require, exports, lifecycle_1, types_1, decorators_1, DOM, touch_1, keyboardEvent_1, event_1, event_2, listView_1) {
    "use strict";
    var TraitRenderer = (function () {
        function TraitRenderer(controller, renderer) {
            this.controller = controller;
            this.renderer = renderer;
        }
        Object.defineProperty(TraitRenderer.prototype, "templateId", {
            get: function () {
                return this.renderer.templateId;
            },
            enumerable: true,
            configurable: true
        });
        TraitRenderer.prototype.renderTemplate = function (container) {
            var data = this.renderer.renderTemplate(container);
            return { container: container, data: data };
        };
        TraitRenderer.prototype.renderElement = function (element, index, templateData) {
            this.controller.renderElement(element, index, templateData.container);
            this.renderer.renderElement(element, index, templateData.data);
        };
        TraitRenderer.prototype.disposeTemplate = function (templateData) {
            return this.renderer.disposeTemplate(templateData.data);
        };
        return TraitRenderer;
    }());
    var Trait = (function () {
        function Trait(_trait) {
            this._trait = _trait;
            this._onChange = new event_1.Emitter();
            this.indexes = [];
        }
        Object.defineProperty(Trait.prototype, "onChange", {
            get: function () { return this._onChange.event; },
            enumerable: true,
            configurable: true
        });
        Trait.prototype.splice = function (start, deleteCount, insertCount) {
            var diff = insertCount - deleteCount;
            var end = start + deleteCount;
            var indexes = [];
            for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
                var index = indexes_1[_i];
                if (index >= start && index < end) {
                    continue;
                }
                indexes.push(index > start ? index + diff : index);
            }
            this.indexes = indexes;
            this._onChange.fire({ indexes: indexes });
        };
        Trait.prototype.renderElement = function (element, index, container) {
            DOM.toggleClass(container, this._trait, this.contains(index));
        };
        Trait.prototype.set = function (indexes) {
            var result = this.indexes;
            this.indexes = indexes;
            this._onChange.fire({ indexes: indexes });
            return result;
        };
        Trait.prototype.get = function () {
            return this.indexes;
        };
        Trait.prototype.contains = function (index) {
            return this.indexes.some(function (i) { return i === index; });
        };
        Trait.prototype.wrapRenderer = function (renderer) {
            return new TraitRenderer(this, renderer);
        };
        Trait.prototype.dispose = function () {
            this.indexes = null;
            this._onChange = lifecycle_1.dispose(this._onChange);
        };
        return Trait;
    }());
    var FocusTrait = (function (_super) {
        __extends(FocusTrait, _super);
        function FocusTrait(getElementId) {
            var _this = _super.call(this, 'focused') || this;
            _this.getElementId = getElementId;
            return _this;
        }
        FocusTrait.prototype.renderElement = function (element, index, container) {
            _super.prototype.renderElement.call(this, element, index, container);
            container.setAttribute('role', 'treeitem');
            container.setAttribute('id', this.getElementId(index));
        };
        return FocusTrait;
    }(Trait));
    var Controller = (function () {
        function Controller(list, view) {
            var _this = this;
            this.list = list;
            this.view = view;
            this.disposables = [];
            this.disposables.push(view.addListener('mousedown', function (e) { return _this.onMouseDown(e); }));
            this.disposables.push(view.addListener('click', function (e) { return _this.onPointer(e); }));
            this.disposables.push(view.addListener(touch_1.EventType.Tap, function (e) { return _this.onPointer(e); }));
            var onKeyDown = event_1.chain(event_2.domEvent(view.domNode, 'keydown'))
                .map(function (e) { return new keyboardEvent_1.StandardKeyboardEvent(e); });
            onKeyDown.filter(function (e) { return e.keyCode === 3 /* Enter */; }).on(this.onEnter, this, this.disposables);
            onKeyDown.filter(function (e) { return e.keyCode === 16 /* UpArrow */; }).on(this.onUpArrow, this, this.disposables);
            onKeyDown.filter(function (e) { return e.keyCode === 18 /* DownArrow */; }).on(this.onDownArrow, this, this.disposables);
            onKeyDown.filter(function (e) { return e.keyCode === 11 /* PageUp */; }).on(this.onPageUpArrow, this, this.disposables);
            onKeyDown.filter(function (e) { return e.keyCode === 12 /* PageDown */; }).on(this.onPageDownArrow, this, this.disposables);
        }
        Controller.prototype.onMouseDown = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        Controller.prototype.onPointer = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.view.domNode.focus();
            this.list.setFocus([e.index]);
            this.list.setSelection([e.index]);
        };
        Controller.prototype.onEnter = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.list.setSelection(this.list.getFocus());
        };
        Controller.prototype.onUpArrow = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.list.focusPrevious();
            this.list.reveal(this.list.getFocus()[0]);
            this.view.domNode.focus();
        };
        Controller.prototype.onDownArrow = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.list.focusNext();
            this.list.reveal(this.list.getFocus()[0]);
            this.view.domNode.focus();
        };
        Controller.prototype.onPageUpArrow = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.list.focusPreviousPage();
            this.list.reveal(this.list.getFocus()[0]);
            this.view.domNode.focus();
        };
        Controller.prototype.onPageDownArrow = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.list.focusNextPage();
            this.list.reveal(this.list.getFocus()[0]);
            this.view.domNode.focus();
        };
        Controller.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return Controller;
    }());
    var DefaultOptions = {};
    var List = (function () {
        function List(container, delegate, renderers, options) {
            if (options === void 0) { options = DefaultOptions; }
            var _this = this;
            this.idPrefix = "list_id_" + ++List.InstanceCount;
            this.focus = new FocusTrait(function (i) { return _this.getElementId(i); });
            this.selection = new Trait('selected');
            this.eventBufferer = new event_1.EventBufferer();
            renderers = renderers.map(function (r) {
                r = _this.focus.wrapRenderer(r);
                r = _this.selection.wrapRenderer(r);
                return r;
            });
            this.view = new listView_1.ListView(container, delegate, renderers, options);
            this.view.domNode.setAttribute('role', 'tree');
            this.view.domNode.tabIndex = 0;
            this.controller = new Controller(this, this.view);
            this.disposables = [this.focus, this.selection, this.view, this.controller];
            this._onDOMFocus = event_2.domEvent(this.view.domNode, 'focus');
            this.onFocusChange(this._onFocusChange, this, this.disposables);
            if (options.ariaLabel) {
                this.view.domNode.setAttribute('aria-label', options.ariaLabel);
            }
        }
        Object.defineProperty(List.prototype, "onFocusChange", {
            get: function () {
                var _this = this;
                return this.eventBufferer.wrapEvent(event_1.mapEvent(this.focus.onChange, function (e) { return _this.toListEvent(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "onSelectionChange", {
            get: function () {
                var _this = this;
                return this.eventBufferer.wrapEvent(event_1.mapEvent(this.selection.onChange, function (e) { return _this.toListEvent(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "onContextMenu", {
            get: function () {
                var _this = this;
                return event_1.fromCallback(function (handler) { return _this.view.addListener('contextmenu', handler); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "onDOMFocus", {
            get: function () { return this._onDOMFocus; },
            enumerable: true,
            configurable: true
        });
        List.prototype.splice = function (start, deleteCount, elements) {
            var _this = this;
            if (elements === void 0) { elements = []; }
            this.eventBufferer.bufferEvents(function () {
                _this.focus.splice(start, deleteCount, elements.length);
                _this.selection.splice(start, deleteCount, elements.length);
                _this.view.splice(start, deleteCount, elements);
            });
        };
        Object.defineProperty(List.prototype, "length", {
            get: function () {
                return this.view.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "contentHeight", {
            get: function () {
                return this.view.getContentHeight();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "scrollTop", {
            get: function () {
                return this.view.getScrollTop();
            },
            set: function (scrollTop) {
                this.view.setScrollTop(scrollTop);
            },
            enumerable: true,
            configurable: true
        });
        List.prototype.layout = function (height) {
            this.view.layout(height);
        };
        List.prototype.setSelection = function (indexes) {
            var _this = this;
            this.eventBufferer.bufferEvents(function () {
                indexes = indexes.concat(_this.selection.set(indexes));
                indexes.forEach(function (i) { return _this.view.splice(i, 1, [_this.view.element(i)]); });
            });
        };
        List.prototype.selectNext = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var selection = this.selection.get();
            var index = selection.length > 0 ? selection[0] + n : 0;
            this.setSelection(loop ? [index % this.length] : [Math.min(index, this.length - 1)]);
        };
        List.prototype.selectPrevious = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var selection = this.selection.get();
            var index = selection.length > 0 ? selection[0] - n : 0;
            if (loop && index < 0) {
                index = this.length + (index % this.length);
            }
            this.setSelection([Math.max(index, 0)]);
        };
        List.prototype.getSelection = function () {
            return this.selection.get();
        };
        List.prototype.setFocus = function (indexes) {
            var _this = this;
            this.eventBufferer.bufferEvents(function () {
                indexes = indexes.concat(_this.focus.set(indexes));
                indexes.forEach(function (i) { return _this.view.splice(i, 1, [_this.view.element(i)]); });
            });
        };
        List.prototype.focusNext = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var focus = this.focus.get();
            var index = focus.length > 0 ? focus[0] + n : 0;
            this.setFocus(loop ? [index % this.length] : [Math.min(index, this.length - 1)]);
        };
        List.prototype.focusPrevious = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var focus = this.focus.get();
            var index = focus.length > 0 ? focus[0] - n : 0;
            if (loop && index < 0) {
                index = (this.length + (index % this.length)) % this.length;
            }
            this.setFocus([Math.max(index, 0)]);
        };
        List.prototype.focusNextPage = function () {
            var _this = this;
            var lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
            var lastPageElement = this.view.element(lastPageIndex);
            var currentlyFocusedElement = this.getFocusedElements()[0];
            if (currentlyFocusedElement !== lastPageElement) {
                this.setFocus([lastPageIndex]);
            }
            else {
                var previousScrollTop = this.view.getScrollTop();
                this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));
                if (this.view.getScrollTop() !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () { return _this.focusNextPage(); }, 0);
                }
            }
        };
        List.prototype.focusPreviousPage = function () {
            var _this = this;
            var firstPageIndex;
            var scrollTop = this.view.getScrollTop();
            if (scrollTop === 0) {
                firstPageIndex = this.view.indexAt(scrollTop);
            }
            else {
                firstPageIndex = this.view.indexAfter(scrollTop - 1);
            }
            var firstPageElement = this.view.element(firstPageIndex);
            var currentlyFocusedElement = this.getFocusedElements()[0];
            if (currentlyFocusedElement !== firstPageElement) {
                this.setFocus([firstPageIndex]);
            }
            else {
                var previousScrollTop = scrollTop;
                this.view.setScrollTop(scrollTop - this.view.renderHeight);
                if (this.view.getScrollTop() !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () { return _this.focusPreviousPage(); }, 0);
                }
            }
        };
        List.prototype.getFocus = function () {
            return this.focus.get();
        };
        List.prototype.getFocusedElements = function () {
            var _this = this;
            return this.getFocus().map(function (i) { return _this.view.element(i); });
        };
        List.prototype.reveal = function (index, relativeTop) {
            var scrollTop = this.view.getScrollTop();
            var elementTop = this.view.elementTop(index);
            var elementHeight = this.view.elementHeight(index);
            if (types_1.isNumber(relativeTop)) {
                relativeTop = relativeTop < 0 ? 0 : relativeTop;
                relativeTop = relativeTop > 1 ? 1 : relativeTop;
                // y = mx + b
                var m = elementHeight - this.view.renderHeight;
                this.view.setScrollTop(m * relativeTop + elementTop);
            }
            else {
                var viewItemBottom = elementTop + elementHeight;
                var wrapperBottom = scrollTop + this.view.renderHeight;
                if (elementTop < scrollTop) {
                    this.view.setScrollTop(elementTop);
                }
                else if (viewItemBottom >= wrapperBottom) {
                    this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
                }
            }
        };
        List.prototype.getElementId = function (index) {
            return this.idPrefix + "_" + index;
        };
        List.prototype.toListEvent = function (_a) {
            var _this = this;
            var indexes = _a.indexes;
            return { indexes: indexes, elements: indexes.map(function (i) { return _this.view.element(i); }) };
        };
        List.prototype._onFocusChange = function () {
            var focus = this.focus.get();
            if (focus.length > 0) {
                this.view.domNode.setAttribute('aria-activedescendant', this.getElementId(focus[0]));
            }
            else {
                this.view.domNode.removeAttribute('aria-activedescendant');
            }
            this.view.domNode.setAttribute('role', 'tree');
            DOM.toggleClass(this.view.domNode, 'element-focused', focus.length > 0);
        };
        List.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return List;
    }());
    List.InstanceCount = 0;
    __decorate([
        decorators_1.memoize
    ], List.prototype, "onFocusChange", null);
    __decorate([
        decorators_1.memoize
    ], List.prototype, "onSelectionChange", null);
    __decorate([
        decorators_1.memoize
    ], List.prototype, "onContextMenu", null);
    exports.List = List;
});






define(__m[264/*vs/base/parts/tree/browser/treeView*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,23/*vs/base/browser/browser*/,6/*vs/base/common/winjs.base*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/,95/*vs/base/common/diff/diff*/,61/*vs/base/browser/touch*/,9/*vs/base/common/strings*/,34/*vs/base/browser/mouseEvent*/,51/*vs/base/browser/keyboardEvent*/,181/*vs/base/parts/tree/browser/treeDnd*/,88/*vs/base/common/iterator*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,38/*vs/base/common/scrollable*/,185/*vs/base/parts/tree/browser/treeViewModel*/,178/*vs/base/parts/tree/browser/tree*/]), function (require, exports, Platform, Browser, WinJS, Lifecycle, DOM, Diff, Touch, strings, Mouse, Keyboard, dnd, iterator_1, scrollableElement_1, scrollable_1, treeViewModel_1, _) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function getLastScrollTime(element) {
        var value = element.getAttribute('last-scroll-time');
        return value ? parseInt(value, 10) : 0;
    }
    function removeFromParent(element) {
        try {
            element.parentElement.removeChild(element);
        }
        catch (e) {
        }
    }
    var RowCache = (function () {
        function RowCache(context) {
            this.context = context;
            this._cache = { '': [] };
            this.scrollingRow = null;
        }
        RowCache.prototype.alloc = function (templateId) {
            var result = this.cache(templateId).pop();
            if (!result) {
                var content = document.createElement('div');
                content.className = 'content';
                var row = document.createElement('div');
                row.appendChild(content);
                result = {
                    element: row,
                    templateId: templateId,
                    templateData: this.context.renderer.renderTemplate(this.context.tree, templateId, content)
                };
            }
            return result;
        };
        RowCache.prototype.release = function (templateId, row) {
            var lastScrollTime = getLastScrollTime(row.element);
            if (!lastScrollTime) {
                removeFromParent(row.element);
                this.cache(templateId).push(row);
                return;
            }
            if (this.scrollingRow) {
                var lastKnownScrollTime = getLastScrollTime(this.scrollingRow.element);
                if (lastKnownScrollTime > lastScrollTime) {
                    removeFromParent(row.element);
                    this.cache(templateId).push(row);
                    return;
                }
                if (this.scrollingRow.element.parentElement) {
                    removeFromParent(this.scrollingRow.element);
                    DOM.removeClass(this.scrollingRow.element, 'scrolling');
                    this.cache(this.scrollingRow.templateId).push(this.scrollingRow);
                }
            }
            this.scrollingRow = row;
            DOM.addClass(this.scrollingRow.element, 'scrolling');
        };
        RowCache.prototype.cache = function (templateId) {
            return this._cache[templateId] || (this._cache[templateId] = []);
        };
        RowCache.prototype.garbageCollect = function () {
            var _this = this;
            if (this._cache) {
                Object.keys(this._cache).forEach(function (templateId) {
                    _this._cache[templateId].forEach(function (cachedRow) {
                        _this.context.renderer.disposeTemplate(_this.context.tree, templateId, cachedRow.templateData);
                        cachedRow.element = null;
                        cachedRow.templateData = null;
                    });
                    delete _this._cache[templateId];
                });
            }
            if (this.scrollingRow) {
                this.context.renderer.disposeTemplate(this.context.tree, this.scrollingRow.templateId, this.scrollingRow.templateData);
                this.scrollingRow = null;
            }
        };
        RowCache.prototype.dispose = function () {
            this.garbageCollect();
            this._cache = null;
            this.context = null;
        };
        return RowCache;
    }());
    exports.RowCache = RowCache;
    var ViewItem = (function () {
        function ViewItem(context, model) {
            var _this = this;
            this.context = context;
            this.model = model;
            this.id = this.model.id;
            this.row = null;
            this.top = 0;
            this.height = model.getHeight();
            this._styles = {};
            model.getAllTraits().forEach(function (t) { return _this._styles[t] = true; });
            if (model.isExpanded()) {
                this.addClass('expanded');
            }
        }
        Object.defineProperty(ViewItem.prototype, "expanded", {
            set: function (value) {
                value ? this.addClass('expanded') : this.removeClass('expanded');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "loading", {
            set: function (value) {
                value ? this.addClass('loading') : this.removeClass('loading');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "draggable", {
            get: function () {
                return this._draggable;
            },
            set: function (value) {
                this._draggable = value;
                this.render(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "dropTarget", {
            set: function (value) {
                value ? this.addClass('drop-target') : this.removeClass('drop-target');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "element", {
            get: function () {
                return this.row && this.row.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "templateId", {
            get: function () {
                return this._templateId || (this._templateId = (this.context.renderer.getTemplateId && this.context.renderer.getTemplateId(this.context.tree, this.model.getElement())));
            },
            enumerable: true,
            configurable: true
        });
        ViewItem.prototype.addClass = function (name) {
            this._styles[name] = true;
            this.render(true);
        };
        ViewItem.prototype.removeClass = function (name) {
            delete this._styles[name]; // is this slow?
            this.render(true);
        };
        ViewItem.prototype.render = function (skipUserRender) {
            var _this = this;
            if (skipUserRender === void 0) { skipUserRender = false; }
            if (!this.model || !this.element) {
                return;
            }
            var classes = ['monaco-tree-row'];
            classes.push.apply(classes, Object.keys(this._styles));
            if (this.model.hasChildren()) {
                classes.push('has-children');
            }
            this.element.className = classes.join(' ');
            this.element.draggable = this.draggable;
            this.element.style.height = this.height + 'px';
            // ARIA
            this.element.setAttribute('role', 'treeitem');
            if (this.model.hasTrait('focused')) {
                var base64Id = strings.safeBtoa(this.model.id);
                var ariaLabel = this.context.accessibilityProvider.getAriaLabel(this.context.tree, this.model.getElement());
                this.element.setAttribute('aria-selected', 'true');
                this.element.setAttribute('id', base64Id);
                if (ariaLabel) {
                    this.element.setAttribute('aria-label', ariaLabel);
                }
                else {
                    this.element.setAttribute('aria-labelledby', base64Id); // force screen reader to compute label from children (helps NVDA at least)
                }
            }
            else {
                this.element.setAttribute('aria-selected', 'false');
                this.element.removeAttribute('id');
                this.element.removeAttribute('aria-label');
                this.element.removeAttribute('aria-labelledby');
            }
            if (this.model.hasChildren()) {
                this.element.setAttribute('aria-expanded', String(this.model.isExpanded()));
            }
            else {
                this.element.removeAttribute('aria-expanded');
            }
            this.element.setAttribute('aria-level', String(this.model.getDepth()));
            if (this.context.options.paddingOnRow) {
                this.element.style.paddingLeft = this.context.options.twistiePixels + ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
            }
            else {
                this.element.style.paddingLeft = ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
                this.row.element.firstElementChild.style.paddingLeft = this.context.options.twistiePixels + 'px';
            }
            var uri = this.context.dnd.getDragURI(this.context.tree, this.model.getElement());
            if (uri !== this.uri) {
                if (this.unbindDragStart) {
                    this.unbindDragStart.dispose();
                    this.unbindDragStart = null;
                }
                if (uri) {
                    this.uri = uri;
                    this.draggable = true;
                    this.unbindDragStart = DOM.addDisposableListener(this.element, 'dragstart', function (e) {
                        _this.onDragStart(e);
                    });
                }
                else {
                    this.uri = null;
                }
            }
            if (!skipUserRender) {
                this.context.renderer.renderElement(this.context.tree, this.model.getElement(), this.templateId, this.row.templateData);
            }
        };
        ViewItem.prototype.insertInDOM = function (container, afterElement) {
            if (!this.row) {
                this.row = this.context.cache.alloc(this.templateId);
                // used in reverse lookup from HTMLElement to Item
                this.element[TreeView.BINDING] = this;
            }
            if (this.element.parentElement) {
                return;
            }
            if (afterElement === null) {
                container.appendChild(this.element);
            }
            else {
                try {
                    container.insertBefore(this.element, afterElement);
                }
                catch (e) {
                    console.warn('Failed to locate previous tree element');
                    container.appendChild(this.element);
                }
            }
            this.render();
        };
        ViewItem.prototype.removeFromDOM = function () {
            if (!this.row) {
                return;
            }
            if (this.unbindDragStart) {
                this.unbindDragStart.dispose();
                this.unbindDragStart = null;
            }
            this.uri = null;
            this.element[TreeView.BINDING] = null;
            this.context.cache.release(this.templateId, this.row);
            this.row = null;
        };
        ViewItem.prototype.dispose = function () {
            this.row = null;
            this.model = null;
        };
        return ViewItem;
    }());
    exports.ViewItem = ViewItem;
    var RootViewItem = (function (_super) {
        __extends(RootViewItem, _super);
        function RootViewItem(context, model, wrapper) {
            var _this = _super.call(this, context, model) || this;
            _this.row = {
                element: wrapper,
                templateData: null,
                templateId: null
            };
            return _this;
        }
        RootViewItem.prototype.render = function () {
            if (!this.model || !this.element) {
                return;
            }
            var classes = ['monaco-tree-wrapper'];
            classes.push.apply(classes, Object.keys(this._styles));
            if (this.model.hasChildren()) {
                classes.push('has-children');
            }
            this.element.className = classes.join(' ');
        };
        RootViewItem.prototype.insertInDOM = function (container, afterElement) {
            // noop
        };
        RootViewItem.prototype.removeFromDOM = function () {
            // noop
        };
        return RootViewItem;
    }(ViewItem));
    function reactionEquals(one, other) {
        if (!one && !other) {
            return true;
        }
        else if (!one || !other) {
            return false;
        }
        else if (one.accept !== other.accept) {
            return false;
        }
        else if (one.bubble !== other.bubble) {
            return false;
        }
        else if (one.effect !== other.effect) {
            return false;
        }
        else {
            return true;
        }
    }
    var TreeView = (function (_super) {
        __extends(TreeView, _super);
        function TreeView(context, container) {
            var _this = _super.call(this) || this;
            _this.lastClickTimeStamp = 0;
            _this.isRefreshing = false;
            _this.refreshingPreviousChildrenIds = {};
            _this.context = {
                dataSource: context.dataSource,
                renderer: context.renderer,
                controller: context.controller,
                dnd: context.dnd,
                filter: context.filter,
                sorter: context.sorter,
                tree: context.tree,
                accessibilityProvider: context.accessibilityProvider,
                options: context.options,
                cache: new RowCache(context)
            };
            _this.modelListeners = [];
            _this.viewListeners = [];
            _this.dragAndDropListeners = [];
            _this.model = null;
            _this.items = {};
            _this.domNode = document.createElement('div');
            _this.domNode.className = 'monaco-tree no-focused-item';
            _this.domNode.tabIndex = 0;
            // ARIA
            _this.domNode.setAttribute('role', 'tree');
            if (_this.context.options.ariaLabel) {
                _this.domNode.setAttribute('aria-label', _this.context.options.ariaLabel);
            }
            if (_this.context.options.alwaysFocused) {
                DOM.addClass(_this.domNode, 'focused');
            }
            if (!_this.context.options.paddingOnRow) {
                DOM.addClass(_this.domNode, 'no-row-padding');
            }
            _this.wrapper = document.createElement('div');
            _this.wrapper.className = 'monaco-tree-wrapper';
            _this.scrollableElement = new scrollableElement_1.ScrollableElement(_this.wrapper, {
                canUseTranslate3d: false,
                alwaysConsumeMouseWheel: true,
                horizontal: scrollable_1.ScrollbarVisibility.Hidden,
                vertical: (typeof context.options.verticalScrollMode !== 'undefined' ? context.options.verticalScrollMode : scrollable_1.ScrollbarVisibility.Auto),
                useShadows: context.options.useShadows,
                saveLastScrollTimeOnClassName: 'monaco-tree-row'
            });
            _this.scrollableElement.onScroll(function (e) {
                _this.render(e.scrollTop, e.height);
                _this.emit('scroll', e); // TODO@Joao: is anyone interested in this event?
            });
            if (Browser.isIE) {
                _this.wrapper.style.msTouchAction = 'none';
                _this.wrapper.style.msContentZooming = 'none';
            }
            else {
                _this.wrapperGesture = new Touch.Gesture(_this.wrapper);
            }
            _this.rowsContainer = document.createElement('div');
            _this.rowsContainer.className = 'monaco-tree-rows';
            if (context.options.showTwistie) {
                _this.rowsContainer.className += ' show-twisties';
            }
            var focusTracker = DOM.trackFocus(_this.domNode);
            focusTracker.addFocusListener(function () { return _this.onFocus(); });
            focusTracker.addBlurListener(function () { return _this.onBlur(); });
            _this.viewListeners.push(focusTracker);
            _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'keydown', function (e) { return _this.onKeyDown(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'keyup', function (e) { return _this.onKeyUp(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'mousedown', function (e) { return _this.onMouseDown(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'mouseup', function (e) { return _this.onMouseUp(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'click', function (e) { return _this.onClick(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.domNode, 'contextmenu', function (e) { return _this.onContextMenu(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, Touch.EventType.Tap, function (e) { return _this.onTap(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, Touch.EventType.Change, function (e) { return _this.onTouchChange(e); }));
            if (Browser.isIE) {
                _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'MSPointerDown', function (e) { return _this.onMsPointerDown(e); }));
                _this.viewListeners.push(DOM.addDisposableListener(_this.wrapper, 'MSGestureTap', function (e) { return _this.onMsGestureTap(e); }));
                // these events come too fast, we throttle them
                _this.viewListeners.push(DOM.addDisposableThrottledListener(_this.wrapper, 'MSGestureChange', function (e) { return _this.onThrottledMsGestureChange(e); }, function (lastEvent, event) {
                    event.stopPropagation();
                    event.preventDefault();
                    var result = { translationY: event.translationY, translationX: event.translationX };
                    if (lastEvent) {
                        result.translationY += lastEvent.translationY;
                        result.translationX += lastEvent.translationX;
                    }
                    return result;
                }));
            }
            _this.viewListeners.push(DOM.addDisposableListener(window, 'dragover', function (e) { return _this.onDragOver(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(window, 'drop', function (e) { return _this.onDrop(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(window, 'dragend', function (e) { return _this.onDragEnd(e); }));
            _this.viewListeners.push(DOM.addDisposableListener(window, 'dragleave', function (e) { return _this.onDragOver(e); }));
            _this.wrapper.appendChild(_this.rowsContainer);
            _this.domNode.appendChild(_this.scrollableElement.getDomNode());
            container.appendChild(_this.domNode);
            _this.lastRenderTop = 0;
            _this.lastRenderHeight = 0;
            _this.didJustPressContextMenuKey = false;
            _this.currentDropTarget = null;
            _this.currentDropTargets = [];
            _this.shouldInvalidateDropReaction = false;
            _this.dragAndDropScrollInterval = null;
            _this.dragAndDropScrollTimeout = null;
            _this.onHiddenScrollTop = null;
            _this.onRowsChanged();
            _this.layout();
            _this.setupMSGesture();
            return _this;
        }
        TreeView.prototype.createViewItem = function (item) {
            return new ViewItem(this.context, item);
        };
        TreeView.prototype.getHTMLElement = function () {
            return this.domNode;
        };
        TreeView.prototype.focus = function () {
            this.domNode.focus();
        };
        TreeView.prototype.isFocused = function () {
            return document.activeElement === this.domNode;
        };
        TreeView.prototype.blur = function () {
            this.domNode.blur();
        };
        TreeView.prototype.onVisible = function () {
            this.scrollTop = this.onHiddenScrollTop;
            this.onHiddenScrollTop = null;
            this.setupMSGesture();
        };
        TreeView.prototype.setupMSGesture = function () {
            var _this = this;
            if (window.MSGesture) {
                this.msGesture = new MSGesture();
                setTimeout(function () { return _this.msGesture.target = _this.wrapper; }, 100); // TODO@joh, TODO@IETeam
            }
        };
        TreeView.prototype.onHidden = function () {
            this.onHiddenScrollTop = this.scrollTop;
        };
        TreeView.prototype.isTreeVisible = function () {
            return this.onHiddenScrollTop === null;
        };
        TreeView.prototype.layout = function (height) {
            if (!this.isTreeVisible()) {
                return;
            }
            this.viewHeight = height || DOM.getContentHeight(this.wrapper); // render
        };
        TreeView.prototype.render = function (scrollTop, viewHeight) {
            var i;
            var stop;
            var renderTop = scrollTop;
            var renderBottom = scrollTop + viewHeight;
            var thisRenderBottom = this.lastRenderTop + this.lastRenderHeight;
            // when view scrolls down, start rendering from the renderBottom
            for (i = this.indexAfter(renderBottom) - 1, stop = this.indexAt(Math.max(thisRenderBottom, renderTop)); i >= stop; i--) {
                this.insertItemInDOM(this.itemAtIndex(i));
            }
            // when view scrolls up, start rendering from either this.renderTop or renderBottom
            for (i = Math.min(this.indexAt(this.lastRenderTop), this.indexAfter(renderBottom)) - 1, stop = this.indexAt(renderTop); i >= stop; i--) {
                this.insertItemInDOM(this.itemAtIndex(i));
            }
            // when view scrolls down, start unrendering from renderTop
            for (i = this.indexAt(this.lastRenderTop), stop = Math.min(this.indexAt(renderTop), this.indexAfter(thisRenderBottom)); i < stop; i++) {
                this.removeItemFromDOM(this.itemAtIndex(i));
            }
            // when view scrolls up, start unrendering from either renderBottom this.renderTop
            for (i = Math.max(this.indexAfter(renderBottom), this.indexAt(this.lastRenderTop)), stop = this.indexAfter(thisRenderBottom); i < stop; i++) {
                this.removeItemFromDOM(this.itemAtIndex(i));
            }
            var topItem = this.itemAtIndex(this.indexAt(renderTop));
            if (topItem) {
                this.rowsContainer.style.top = (topItem.top - renderTop) + 'px';
            }
            this.lastRenderTop = renderTop;
            this.lastRenderHeight = renderBottom - renderTop;
        };
        TreeView.prototype.setModel = function (newModel) {
            var _this = this;
            this.releaseModel();
            this.model = newModel;
            this.modelListeners.push(this.model.addBulkListener2(function (e) { return _this.onModelEvents(e); }));
        };
        TreeView.prototype.onModelEvents = function (events) {
            var elementsToRefresh = [];
            for (var i = 0, len = events.length; i < len; i++) {
                var event = events[i];
                var data = event.getData();
                switch (event.getType()) {
                    case 'refreshing':
                        this.onRefreshing();
                        break;
                    case 'refreshed':
                        this.onRefreshed();
                        break;
                    case 'clearingInput':
                        this.onClearingInput(data);
                        break;
                    case 'setInput':
                        this.onSetInput(data);
                        break;
                    case 'item:childrenRefreshing':
                        this.onItemChildrenRefreshing(data);
                        break;
                    case 'item:childrenRefreshed':
                        this.onItemChildrenRefreshed(data);
                        break;
                    case 'item:refresh':
                        elementsToRefresh.push(data.item);
                        break;
                    case 'item:expanding':
                        this.onItemExpanding(data);
                        break;
                    case 'item:expanded':
                        this.onItemExpanded(data);
                        break;
                    case 'item:collapsing':
                        this.onItemCollapsing(data);
                        break;
                    case 'item:reveal':
                        this.onItemReveal(data);
                        break;
                    case 'item:addTrait':
                        this.onItemAddTrait(data);
                        break;
                    case 'item:removeTrait':
                        this.onItemRemoveTrait(data);
                        break;
                    case 'focus':
                        this.onModelFocusChange();
                        break;
                }
            }
            if (elementsToRefresh.length > 0) {
                this.onItemsRefresh(elementsToRefresh);
            }
        };
        TreeView.prototype.onRefreshing = function () {
            this.isRefreshing = true;
        };
        TreeView.prototype.onRefreshed = function () {
            this.isRefreshing = false;
            this.onRowsChanged();
        };
        TreeView.prototype.onRowsChanged = function (scrollTop) {
            if (scrollTop === void 0) { scrollTop = this.scrollTop; }
            if (this.isRefreshing) {
                return;
            }
            this.scrollTop = scrollTop;
        };
        TreeView.prototype.focusNextPage = function (eventPayload) {
            var _this = this;
            var lastPageIndex = this.indexAt(this.scrollTop + this.viewHeight);
            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
            var lastPageElement = this.itemAtIndex(lastPageIndex).model.getElement();
            var currentlyFocusedElement = this.model.getFocus();
            if (currentlyFocusedElement !== lastPageElement) {
                this.model.setFocus(lastPageElement, eventPayload);
            }
            else {
                var previousScrollTop = this.scrollTop;
                this.scrollTop += this.viewHeight;
                if (this.scrollTop !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () {
                        _this.focusNextPage(eventPayload);
                    }, 0);
                }
            }
        };
        TreeView.prototype.focusPreviousPage = function (eventPayload) {
            var _this = this;
            var firstPageIndex;
            if (this.scrollTop === 0) {
                firstPageIndex = this.indexAt(this.scrollTop);
            }
            else {
                firstPageIndex = this.indexAfter(this.scrollTop - 1);
            }
            var firstPageElement = this.itemAtIndex(firstPageIndex).model.getElement();
            var currentlyFocusedElement = this.model.getFocus();
            if (currentlyFocusedElement !== firstPageElement) {
                this.model.setFocus(firstPageElement, eventPayload);
            }
            else {
                var previousScrollTop = this.scrollTop;
                this.scrollTop -= this.viewHeight;
                if (this.scrollTop !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () {
                        _this.focusPreviousPage(eventPayload);
                    }, 0);
                }
            }
        };
        Object.defineProperty(TreeView.prototype, "viewHeight", {
            get: function () {
                return this.scrollableElement.getHeight();
            },
            set: function (viewHeight) {
                this.scrollableElement.updateState({
                    height: viewHeight,
                    scrollHeight: this.getTotalHeight()
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeView.prototype, "scrollTop", {
            get: function () {
                return this.scrollableElement.getScrollTop();
            },
            set: function (scrollTop) {
                this.scrollableElement.updateState({
                    scrollTop: scrollTop,
                    scrollHeight: this.getTotalHeight()
                });
            },
            enumerable: true,
            configurable: true
        });
        TreeView.prototype.getScrollPosition = function () {
            var height = this.getTotalHeight() - this.viewHeight;
            return height <= 0 ? 0 : this.scrollTop / height;
        };
        TreeView.prototype.setScrollPosition = function (pos) {
            var height = this.getTotalHeight() - this.viewHeight;
            this.scrollTop = height * pos;
        };
        // Events
        TreeView.prototype.onClearingInput = function (e) {
            var item = e.item;
            if (item) {
                this.onRemoveItems(new iterator_1.MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
                this.onRowsChanged();
            }
        };
        TreeView.prototype.onSetInput = function (e) {
            this.context.cache.garbageCollect();
            this.inputItem = new RootViewItem(this.context, e.item, this.wrapper);
            this.emit('viewItem:create', { item: this.inputItem.model });
        };
        TreeView.prototype.onItemChildrenRefreshing = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.loadingPromise = WinJS.TPromise.timeout(TreeView.LOADING_DECORATION_DELAY).then(function () {
                    viewItem.loadingPromise = null;
                    viewItem.loading = true;
                });
            }
            if (!e.isNested) {
                var childrenIds = [];
                var navigator = item.getNavigator();
                var childItem;
                while (childItem = navigator.next()) {
                    childrenIds.push(childItem.id);
                }
                this.refreshingPreviousChildrenIds[item.id] = childrenIds;
            }
        };
        TreeView.prototype.onItemChildrenRefreshed = function (e) {
            var _this = this;
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                if (viewItem.loadingPromise) {
                    viewItem.loadingPromise.cancel();
                    viewItem.loadingPromise = null;
                }
                viewItem.loading = false;
            }
            if (!e.isNested) {
                var previousChildrenIds = this.refreshingPreviousChildrenIds[item.id];
                var afterModelItems = [];
                var navigator = item.getNavigator();
                var childItem;
                while (childItem = navigator.next()) {
                    afterModelItems.push(childItem);
                }
                var skipDiff = Math.abs(previousChildrenIds.length - afterModelItems.length) > 1000;
                var diff = void 0;
                var doToInsertItemsAlreadyExist = void 0;
                if (!skipDiff) {
                    var lcs = new Diff.LcsDiff({
                        getLength: function () { return previousChildrenIds.length; },
                        getElementHash: function (i) { return previousChildrenIds[i]; }
                    }, {
                        getLength: function () { return afterModelItems.length; },
                        getElementHash: function (i) { return afterModelItems[i].id; }
                    }, null);
                    diff = lcs.ComputeDiff();
                    // this means that the result of the diff algorithm would result
                    // in inserting items that were already registered. this can only
                    // happen if the data provider returns bad ids OR if the sorting
                    // of the elements has changed
                    doToInsertItemsAlreadyExist = diff.some(function (d) {
                        if (d.modifiedLength > 0) {
                            for (var i = d.modifiedStart, len = d.modifiedStart + d.modifiedLength; i < len; i++) {
                                if (_this.items.hasOwnProperty(afterModelItems[i].id)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    });
                }
                // 50 is an optimization number, at some point we're better off
                // just replacing everything
                if (!skipDiff && !doToInsertItemsAlreadyExist && diff.length < 50) {
                    for (var i = 0, len = diff.length; i < len; i++) {
                        var diffChange = diff[i];
                        if (diffChange.originalLength > 0) {
                            this.onRemoveItems(new iterator_1.ArrayIterator(previousChildrenIds, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength));
                        }
                        if (diffChange.modifiedLength > 0) {
                            var beforeItem = afterModelItems[diffChange.modifiedStart - 1] || item;
                            beforeItem = beforeItem.getDepth() > 0 ? beforeItem : null;
                            this.onInsertItems(new iterator_1.ArrayIterator(afterModelItems, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength), beforeItem ? beforeItem.id : null);
                        }
                    }
                }
                else if (skipDiff || diff.length) {
                    this.onRemoveItems(new iterator_1.ArrayIterator(previousChildrenIds));
                    this.onInsertItems(new iterator_1.ArrayIterator(afterModelItems));
                }
                if (skipDiff || diff.length) {
                    this.onRowsChanged();
                }
            }
        };
        TreeView.prototype.onItemsRefresh = function (items) {
            var _this = this;
            this.onRefreshItemSet(items.filter(function (item) { return _this.items.hasOwnProperty(item.id); }));
            this.onRowsChanged();
        };
        TreeView.prototype.onItemExpanding = function (e) {
            var viewItem = this.items[e.item.id];
            if (viewItem) {
                viewItem.expanded = true;
            }
        };
        TreeView.prototype.onItemExpanded = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.expanded = true;
                var height = this.onInsertItems(item.getNavigator(), item.id);
                var scrollTop = this.scrollTop;
                if (viewItem.top + viewItem.height <= this.scrollTop) {
                    scrollTop += height;
                }
                this.onRowsChanged(scrollTop);
            }
        };
        TreeView.prototype.onItemCollapsing = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.expanded = false;
                this.onRemoveItems(new iterator_1.MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
                this.onRowsChanged();
            }
        };
        TreeView.prototype.getRelativeTop = function (item) {
            if (item && item.isVisible()) {
                var viewItem = this.items[item.id];
                if (viewItem) {
                    return (viewItem.top - this.scrollTop) / (this.viewHeight - viewItem.height);
                }
            }
            return -1;
        };
        TreeView.prototype.onItemReveal = function (e) {
            var item = e.item;
            var relativeTop = e.relativeTop;
            var viewItem = this.items[item.id];
            if (viewItem) {
                if (relativeTop !== null) {
                    relativeTop = relativeTop < 0 ? 0 : relativeTop;
                    relativeTop = relativeTop > 1 ? 1 : relativeTop;
                    // y = mx + b
                    var m = viewItem.height - this.viewHeight;
                    this.scrollTop = m * relativeTop + viewItem.top;
                }
                else {
                    var viewItemBottom = viewItem.top + viewItem.height;
                    var wrapperBottom = this.scrollTop + this.viewHeight;
                    if (viewItem.top < this.scrollTop) {
                        this.scrollTop = viewItem.top;
                    }
                    else if (viewItemBottom >= wrapperBottom) {
                        this.scrollTop = viewItemBottom - this.viewHeight;
                    }
                }
            }
        };
        TreeView.prototype.onItemAddTrait = function (e) {
            var item = e.item;
            var trait = e.trait;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.addClass(trait);
            }
            if (trait === 'highlighted') {
                DOM.addClass(this.domNode, trait);
                // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
                if (viewItem) {
                    this.highlightedItemWasDraggable = !!viewItem.draggable;
                    if (viewItem.draggable) {
                        viewItem.draggable = false;
                    }
                }
            }
        };
        TreeView.prototype.onItemRemoveTrait = function (e) {
            var item = e.item;
            var trait = e.trait;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.removeClass(trait);
            }
            if (trait === 'highlighted') {
                DOM.removeClass(this.domNode, trait);
                // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
                if (this.highlightedItemWasDraggable) {
                    viewItem.draggable = true;
                }
                this.highlightedItemWasDraggable = false;
            }
        };
        TreeView.prototype.onModelFocusChange = function () {
            var focus = this.model && this.model.getFocus();
            DOM.toggleClass(this.domNode, 'no-focused-item', !focus);
            // ARIA
            if (focus) {
                this.domNode.setAttribute('aria-activedescendant', strings.safeBtoa(this.context.dataSource.getId(this.context.tree, focus)));
            }
            else {
                this.domNode.removeAttribute('aria-activedescendant');
            }
        };
        // HeightMap "events"
        TreeView.prototype.onInsertItem = function (item) {
            var _this = this;
            item.onDragStart = function (e) { _this.onDragStart(item, e); };
            item.needsRender = true;
            this.refreshViewItem(item);
            this.items[item.id] = item;
        };
        TreeView.prototype.onRefreshItem = function (item, needsRender) {
            if (needsRender === void 0) { needsRender = false; }
            item.needsRender = item.needsRender || needsRender;
            this.refreshViewItem(item);
        };
        TreeView.prototype.onRemoveItem = function (item) {
            this.removeItemFromDOM(item);
            item.dispose();
            this.emit('viewItem:dispose', { item: this.inputItem.model });
            delete this.items[item.id];
        };
        // ViewItem refresh
        TreeView.prototype.refreshViewItem = function (item) {
            item.render();
            if (this.shouldBeRendered(item)) {
                this.insertItemInDOM(item);
            }
            else {
                this.removeItemFromDOM(item);
            }
        };
        // DOM Events
        TreeView.prototype.onClick = function (e) {
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            if (Browser.isIE && Date.now() - this.lastClickTimeStamp < 300) {
                // IE10+ doesn't set the detail property correctly. While IE10 simply
                // counts the number of clicks, IE11 reports always 1. To align with
                // other browser, we set the value to 2 if clicks events come in a 300ms
                // sequence.
                event.detail = 2;
            }
            this.lastClickTimeStamp = Date.now();
            this.context.controller.onClick(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onMouseDown = function (e) {
            this.didJustPressContextMenuKey = false;
            if (!this.context.controller.onMouseDown) {
                return;
            }
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {
                return;
            }
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            this.context.controller.onMouseDown(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onMouseUp = function (e) {
            if (!this.context.controller.onMouseUp) {
                return;
            }
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {
                return;
            }
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            this.context.controller.onMouseUp(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onTap = function (e) {
            var item = this.getItemAround(e.initialTarget);
            if (!item) {
                return;
            }
            this.context.controller.onTap(this.context.tree, item.model.getElement(), e);
        };
        TreeView.prototype.onTouchChange = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.scrollTop -= event.translationY;
        };
        TreeView.prototype.onContextMenu = function (event) {
            var resultEvent;
            var element;
            if (event instanceof KeyboardEvent || this.didJustPressContextMenuKey) {
                this.didJustPressContextMenuKey = false;
                var keyboardEvent = new Keyboard.StandardKeyboardEvent(event);
                element = this.model.getFocus();
                if (!element) {
                    return;
                }
                var id = this.context.dataSource.getId(this.context.tree, element);
                var viewItem = this.items[id];
                var position = DOM.getDomNodePagePosition(viewItem.element);
                resultEvent = new _.KeyboardContextMenuEvent(position.left + position.width, position.top, keyboardEvent);
            }
            else {
                var mouseEvent = new Mouse.StandardMouseEvent(event);
                var item = this.getItemAround(mouseEvent.target);
                if (!item) {
                    return;
                }
                element = item.model.getElement();
                resultEvent = new _.MouseContextMenuEvent(mouseEvent);
            }
            this.context.controller.onContextMenu(this.context.tree, element, resultEvent);
        };
        TreeView.prototype.onKeyDown = function (e) {
            var event = new Keyboard.StandardKeyboardEvent(e);
            this.didJustPressContextMenuKey = event.keyCode === 58 /* ContextMenu */ || (event.shiftKey && event.keyCode === 68 /* F10 */);
            if (this.didJustPressContextMenuKey) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            this.context.controller.onKeyDown(this.context.tree, event);
        };
        TreeView.prototype.onKeyUp = function (e) {
            if (this.didJustPressContextMenuKey) {
                this.onContextMenu(e);
            }
            this.didJustPressContextMenuKey = false;
            this.context.controller.onKeyUp(this.context.tree, new Keyboard.StandardKeyboardEvent(e));
        };
        TreeView.prototype.onDragStart = function (item, e) {
            if (this.model.getHighlight()) {
                return;
            }
            var element = item.model.getElement();
            var selection = this.model.getSelection();
            var elements;
            if (selection.indexOf(element) > -1) {
                elements = selection;
            }
            else {
                elements = [element];
            }
            e.dataTransfer.effectAllowed = 'copyMove';
            e.dataTransfer.setData('URL', item.uri);
            if (e.dataTransfer.setDragImage) {
                var label = void 0;
                if (this.context.dnd.getDragLabel) {
                    label = this.context.dnd.getDragLabel(this.context.tree, elements);
                }
                else {
                    label = String(elements.length);
                }
                var dragImage_1 = document.createElement('div');
                dragImage_1.className = 'monaco-tree-drag-image';
                dragImage_1.textContent = label;
                document.body.appendChild(dragImage_1);
                e.dataTransfer.setDragImage(dragImage_1, -10, -10);
                setTimeout(function () { return document.body.removeChild(dragImage_1); }, 0);
            }
            this.currentDragAndDropData = new dnd.ElementsDragAndDropData(elements);
            TreeView.currentExternalDragAndDropData = new dnd.ExternalElementsDragAndDropData(elements);
            this.context.dnd.onDragStart(this.context.tree, this.currentDragAndDropData, new Mouse.DragMouseEvent(e));
        };
        TreeView.prototype.setupDragAndDropScrollInterval = function () {
            var _this = this;
            var viewTop = DOM.getTopLeftOffset(this.wrapper).top;
            if (!this.dragAndDropScrollInterval) {
                this.dragAndDropScrollInterval = window.setInterval(function () {
                    if (_this.dragAndDropMouseY === undefined) {
                        return;
                    }
                    var diff = _this.dragAndDropMouseY - viewTop;
                    var scrollDiff = 0;
                    var upperLimit = _this.viewHeight - 35;
                    if (diff < 35) {
                        scrollDiff = Math.max(-14, 0.2 * (diff - 35));
                    }
                    else if (diff > upperLimit) {
                        scrollDiff = Math.min(14, 0.2 * (diff - upperLimit));
                    }
                    _this.scrollTop += scrollDiff;
                }, 10);
                this.cancelDragAndDropScrollTimeout();
                this.dragAndDropScrollTimeout = window.setTimeout(function () {
                    _this.cancelDragAndDropScrollInterval();
                    _this.dragAndDropScrollTimeout = null;
                }, 1000);
            }
        };
        TreeView.prototype.cancelDragAndDropScrollInterval = function () {
            if (this.dragAndDropScrollInterval) {
                window.clearInterval(this.dragAndDropScrollInterval);
                this.dragAndDropScrollInterval = null;
            }
            this.cancelDragAndDropScrollTimeout();
        };
        TreeView.prototype.cancelDragAndDropScrollTimeout = function () {
            if (this.dragAndDropScrollTimeout) {
                window.clearTimeout(this.dragAndDropScrollTimeout);
                this.dragAndDropScrollTimeout = null;
            }
        };
        TreeView.prototype.onDragOver = function (e) {
            var _this = this;
            var event = new Mouse.DragMouseEvent(e);
            var viewItem = this.getItemAround(event.target);
            if (!viewItem) {
                // dragging outside of tree
                if (this.currentDropTarget) {
                    // clear previously hovered element feedback
                    this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                    this.currentDropTargets = [];
                    if (this.currentDropPromise) {
                        this.currentDropPromise.cancel();
                        this.currentDropPromise = null;
                    }
                }
                this.cancelDragAndDropScrollInterval();
                this.currentDropTarget = null;
                this.currentDropElement = null;
                this.dragAndDropMouseY = null;
                return false;
            }
            // dragging inside the tree
            this.setupDragAndDropScrollInterval();
            this.dragAndDropMouseY = event.posy;
            if (!this.currentDragAndDropData) {
                // just started dragging
                if (TreeView.currentExternalDragAndDropData) {
                    this.currentDragAndDropData = TreeView.currentExternalDragAndDropData;
                }
                else {
                    if (!event.dataTransfer.types) {
                        return false;
                    }
                    this.currentDragAndDropData = new dnd.DesktopDragAndDropData();
                }
            }
            this.currentDragAndDropData.update(event);
            var element;
            var item = viewItem.model;
            var reaction;
            // check the bubble up behavior
            do {
                element = item ? item.getElement() : this.model.getInput();
                reaction = this.context.dnd.onDragOver(this.context.tree, this.currentDragAndDropData, element, event);
                if (!reaction || reaction.bubble !== _.DragOverBubble.BUBBLE_UP) {
                    break;
                }
                item = item && item.parent;
            } while (item);
            if (!item) {
                this.currentDropElement = null;
                return false;
            }
            var canDrop = reaction && reaction.accept;
            if (canDrop) {
                this.currentDropElement = item.getElement();
                event.preventDefault();
                event.dataTransfer.dropEffect = reaction.effect === _.DragOverEffect.COPY ? 'copy' : 'move';
            }
            else {
                this.currentDropElement = null;
            }
            // item is the model item where drop() should be called
            // can be null
            var currentDropTarget = item.id === this.inputItem.id ? this.inputItem : this.items[item.id];
            if (this.shouldInvalidateDropReaction || this.currentDropTarget !== currentDropTarget || !reactionEquals(this.currentDropElementReaction, reaction)) {
                this.shouldInvalidateDropReaction = false;
                if (this.currentDropTarget) {
                    this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                    this.currentDropTargets = [];
                    if (this.currentDropPromise) {
                        this.currentDropPromise.cancel();
                        this.currentDropPromise = null;
                    }
                }
                this.currentDropTarget = currentDropTarget;
                this.currentDropElementReaction = reaction;
                if (canDrop) {
                    // setup hover feedback for drop target
                    if (this.currentDropTarget) {
                        this.currentDropTarget.dropTarget = true;
                        this.currentDropTargets.push(this.currentDropTarget);
                    }
                    if (reaction.bubble === _.DragOverBubble.BUBBLE_DOWN) {
                        var nav = item.getNavigator();
                        var child;
                        while (child = nav.next()) {
                            viewItem = this.items[child.id];
                            if (viewItem) {
                                viewItem.dropTarget = true;
                                this.currentDropTargets.push(viewItem);
                            }
                        }
                    }
                    if (reaction.autoExpand) {
                        this.currentDropPromise = WinJS.TPromise.timeout(500)
                            .then(function () { return _this.context.tree.expand(_this.currentDropElement); })
                            .then(function () { return _this.shouldInvalidateDropReaction = true; });
                    }
                }
            }
            return true;
        };
        TreeView.prototype.onDrop = function (e) {
            if (this.currentDropElement) {
                var event = new Mouse.DragMouseEvent(e);
                event.preventDefault();
                this.currentDragAndDropData.update(event);
                this.context.dnd.drop(this.context.tree, this.currentDragAndDropData, this.currentDropElement, event);
                this.onDragEnd(e);
            }
            this.cancelDragAndDropScrollInterval();
        };
        TreeView.prototype.onDragEnd = function (e) {
            if (this.currentDropTarget) {
                this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                this.currentDropTargets = [];
            }
            if (this.currentDropPromise) {
                this.currentDropPromise.cancel();
                this.currentDropPromise = null;
            }
            this.cancelDragAndDropScrollInterval();
            this.currentDragAndDropData = null;
            TreeView.currentExternalDragAndDropData = null;
            this.currentDropElement = null;
            this.currentDropTarget = null;
            this.dragAndDropMouseY = null;
        };
        TreeView.prototype.onFocus = function () {
            if (!this.context.options.alwaysFocused) {
                DOM.addClass(this.domNode, 'focused');
            }
        };
        TreeView.prototype.onBlur = function () {
            if (!this.context.options.alwaysFocused) {
                DOM.removeClass(this.domNode, 'focused');
            }
            this.domNode.removeAttribute('aria-activedescendant'); // ARIA
        };
        // MS specific DOM Events
        TreeView.prototype.onMsPointerDown = function (event) {
            if (!this.msGesture) {
                return;
            }
            // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
            var pointerType = event.pointerType;
            if (pointerType === (event.MSPOINTER_TYPE_MOUSE || 'mouse')) {
                this.lastPointerType = 'mouse';
                return;
            }
            else if (pointerType === (event.MSPOINTER_TYPE_TOUCH || 'touch')) {
                this.lastPointerType = 'touch';
            }
            else {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            this.msGesture.addPointer(event.pointerId);
        };
        TreeView.prototype.onThrottledMsGestureChange = function (event) {
            this.scrollTop -= event.translationY;
        };
        TreeView.prototype.onMsGestureTap = function (event) {
            event.initialTarget = document.elementFromPoint(event.clientX, event.clientY);
            this.onTap(event);
        };
        // DOM changes
        TreeView.prototype.insertItemInDOM = function (item) {
            var elementAfter = null;
            var itemAfter = this.itemAfter(item);
            if (itemAfter && itemAfter.element) {
                elementAfter = itemAfter.element;
            }
            item.insertInDOM(this.rowsContainer, elementAfter);
        };
        TreeView.prototype.removeItemFromDOM = function (item) {
            item.removeFromDOM();
        };
        // Helpers
        TreeView.prototype.shouldBeRendered = function (item) {
            return item.top < this.lastRenderTop + this.lastRenderHeight && item.top + item.height > this.lastRenderTop;
        };
        TreeView.prototype.getItemAround = function (element) {
            var candidate = this.inputItem;
            do {
                if (element[TreeView.BINDING]) {
                    candidate = element[TreeView.BINDING];
                }
                if (element === this.wrapper || element === this.domNode) {
                    return candidate;
                }
                if (element === document.body) {
                    return null;
                }
            } while (element = element.parentElement);
        };
        // Cleanup
        TreeView.prototype.releaseModel = function () {
            if (this.model) {
                this.modelListeners = Lifecycle.dispose(this.modelListeners);
                this.model = null;
            }
        };
        TreeView.prototype.dispose = function () {
            // TODO@joao: improve
            this.scrollableElement.dispose();
            this.releaseModel();
            this.modelListeners = null;
            this.viewListeners = Lifecycle.dispose(this.viewListeners);
            if (this.domNode.parentNode) {
                this.domNode.parentNode.removeChild(this.domNode);
            }
            this.domNode = null;
            if (this.wrapperGesture) {
                this.wrapperGesture.dispose();
                this.wrapperGesture = null;
            }
            if (this.context.cache) {
                this.context.cache.dispose();
                this.context.cache = null;
            }
            _super.prototype.dispose.call(this);
        };
        return TreeView;
    }(treeViewModel_1.HeightMap));
    TreeView.BINDING = 'monaco-tree-row';
    TreeView.LOADING_DECORATION_DELAY = 800;
    TreeView.currentExternalDragAndDropData = null;
    exports.TreeView = TreeView;
});

define(__m[269/*vs/css!vs/base/browser/ui/selectBox/selectBox*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[270/*vs/base/browser/ui/selectBox/selectBox*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,12/*vs/base/common/event*/,40/*vs/base/browser/ui/widget*/,11/*vs/base/browser/dom*/,28/*vs/base/common/arrays*/,269/*vs/css!vs/base/browser/ui/selectBox/selectBox*/]), function (require, exports, lifecycle_1, event_1, widget_1, dom, arrays) {
    "use strict";
    var SelectBox = (function (_super) {
        __extends(SelectBox, _super);
        function SelectBox(options, selected) {
            var _this = _super.call(this) || this;
            _this.selectElement = document.createElement('select');
            _this.selectElement.className = 'select-box';
            _this.setOptions(options, selected);
            _this.toDispose = [];
            _this._onDidSelect = new event_1.Emitter();
            _this.toDispose.push(dom.addStandardDisposableListener(_this.selectElement, 'change', function (e) {
                _this.selectElement.title = e.target.value;
                _this._onDidSelect.fire(e.target.value);
            }));
            return _this;
        }
        Object.defineProperty(SelectBox.prototype, "onDidSelect", {
            get: function () {
                return this._onDidSelect.event;
            },
            enumerable: true,
            configurable: true
        });
        SelectBox.prototype.setOptions = function (options, selected, disabled) {
            var _this = this;
            if (!this.options || !arrays.equals(this.options, options)) {
                this.options = options;
                this.selectElement.options.length = 0;
                var i_1 = 0;
                this.options.forEach(function (option) {
                    _this.selectElement.add(_this.createOption(option, disabled === i_1++));
                });
            }
            this.select(selected);
        };
        SelectBox.prototype.select = function (index) {
            if (index >= 0 && index < this.options.length) {
                this.selected = index;
            }
            else if (this.selected < 0) {
                this.selected = 0;
            }
            this.selectElement.selectedIndex = this.selected;
            this.selectElement.title = this.options[this.selected];
        };
        SelectBox.prototype.focus = function () {
            if (this.selectElement) {
                this.selectElement.focus();
            }
        };
        Object.defineProperty(SelectBox.prototype, "enabled", {
            get: function () {
                return !this.selectElement.disabled;
            },
            set: function (value) {
                dom.toggleClass(this.container, 'disabled', !value);
                this.selectElement.disabled = !value;
            },
            enumerable: true,
            configurable: true
        });
        SelectBox.prototype.blur = function () {
            if (this.selectElement) {
                this.selectElement.blur();
            }
        };
        SelectBox.prototype.render = function (container) {
            this.container = container;
            dom.addClass(container, 'select-container');
            container.appendChild(this.selectElement);
            this.setOptions(this.options, this.selected);
        };
        SelectBox.prototype.createOption = function (value, disabled) {
            var option = document.createElement('option');
            option.value = value;
            option.text = value;
            option.disabled = disabled;
            return option;
        };
        SelectBox.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            _super.prototype.dispose.call(this);
        };
        return SelectBox;
    }(widget_1.Widget));
    exports.SelectBox = SelectBox;
});

define(__m[321/*vs/css!vs/base/parts/quickopen/browser/quickopen*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[322/*vs/css!vs/base/parts/tree/browser/tree*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[323/*vs/css!vs/editor/browser/standalone/media/standalone-tokens*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[324/*vs/css!vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[325/*vs/css!vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[326/*vs/css!vs/editor/browser/viewParts/decorations/decorations*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[327/*vs/css!vs/editor/browser/viewParts/glyphMargin/glyphMargin*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[329/*vs/css!vs/editor/browser/viewParts/indentGuides/indentGuides*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[331/*vs/css!vs/editor/browser/viewParts/lineNumbers/lineNumbers*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[332/*vs/css!vs/editor/browser/viewParts/lines/viewLines*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[333/*vs/css!vs/editor/browser/viewParts/linesDecorations/linesDecorations*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[334/*vs/css!vs/editor/browser/viewParts/marginDecorations/marginDecorations*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[335/*vs/css!vs/editor/browser/viewParts/overlayWidgets/overlayWidgets*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[338/*vs/css!vs/editor/browser/viewParts/rulers/rulers*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[342/*vs/css!vs/editor/browser/viewParts/scrollDecoration/scrollDecoration*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[343/*vs/css!vs/editor/browser/viewParts/selections/selections*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[346/*vs/css!vs/editor/browser/viewParts/viewCursors/viewCursors*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[347/*vs/css!vs/editor/browser/widget/media/diffEditor*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[349/*vs/css!vs/editor/browser/widget/media/editor*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[350/*vs/css!vs/editor/browser/widget/media/tokens*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[357/*vs/css!vs/editor/contrib/bracketMatching/browser/bracketMatching*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[359/*vs/css!vs/editor/contrib/clipboard/browser/clipboard*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[360/*vs/css!vs/editor/contrib/codelens/browser/codelens*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[363/*vs/css!vs/editor/contrib/find/browser/findWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[365/*vs/css!vs/editor/contrib/folding/browser/folding*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[367/*vs/css!vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[368/*vs/css!vs/editor/contrib/gotoError/browser/gotoError*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[369/*vs/css!vs/editor/contrib/hover/browser/hover*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[370/*vs/css!vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[373/*vs/css!vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[381/*vs/css!vs/editor/contrib/inspectTokens/browser/inspectTokens*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[397/*vs/css!vs/editor/contrib/links/browser/links*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[400/*vs/css!vs/editor/contrib/parameterHints/browser/parameterHints*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[401/*vs/css!vs/editor/contrib/quickFix/browser/lightBulbWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[403/*vs/css!vs/editor/contrib/quickOpen/browser/gotoLine*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[407/*vs/css!vs/editor/contrib/quickOpen/browser/quickOutline*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[408/*vs/css!vs/editor/contrib/referenceSearch/browser/referencesWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[411/*vs/css!vs/editor/contrib/rename/browser/renameInputField*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[412/*vs/css!vs/editor/contrib/snippet/browser/snippet*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[414/*vs/css!vs/editor/contrib/suggest/browser/suggest*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[416/*vs/css!vs/editor/contrib/wordHighlighter/browser/wordHighlighter*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[417/*vs/css!vs/editor/contrib/zoneWidget/browser/peekViewWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[418/*vs/css!vs/editor/contrib/zoneWidget/browser/zoneWidget*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[419/*vs/css!vs/platform/contextview/browser/contextMenuHandler*/], __M([5/*vs/css!vs/editor/editor.main*/]), {});
define(__m[424/*vs/editor/browser/config/charWidthReader*/], __M([1/*require*/,0/*exports*/,23/*vs/base/browser/browser*/]), function (require, exports, browser) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharWidthRequestType;
    (function (CharWidthRequestType) {
        CharWidthRequestType[CharWidthRequestType["Regular"] = 0] = "Regular";
        CharWidthRequestType[CharWidthRequestType["Italic"] = 1] = "Italic";
        CharWidthRequestType[CharWidthRequestType["Bold"] = 2] = "Bold";
    })(CharWidthRequestType = exports.CharWidthRequestType || (exports.CharWidthRequestType = {}));
    var CharWidthRequest = (function () {
        function CharWidthRequest(chr, type) {
            this.chr = chr;
            this.type = type;
            this.width = 0;
        }
        CharWidthRequest.prototype.fulfill = function (width) {
            this.width = width;
        };
        return CharWidthRequest;
    }());
    exports.CharWidthRequest = CharWidthRequest;
    var DomCharWidthReader = (function () {
        function DomCharWidthReader(bareFontInfo, requests) {
            this._bareFontInfo = bareFontInfo;
            this._requests = requests;
            this._container = null;
            this._testElements = null;
        }
        DomCharWidthReader.prototype.read = function () {
            // Create a test container with all these test elements
            this._createDomElements();
            // Add the container to the DOM
            document.body.appendChild(this._container);
            // Read character widths
            this._readFromDomElements();
            // Remove the container from the DOM
            document.body.removeChild(this._container);
            this._container = null;
            this._testElements = null;
        };
        DomCharWidthReader.prototype._createDomElements = function () {
            var container = document.createElement('div');
            container.style.position = 'absolute';
            container.style.top = '-50000px';
            container.style.width = '50000px';
            var regularDomNode = document.createElement('div');
            regularDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
            regularDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
            regularDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
            regularDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
            container.appendChild(regularDomNode);
            var boldDomNode = document.createElement('div');
            boldDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
            boldDomNode.style.fontWeight = 'bold';
            boldDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
            boldDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
            container.appendChild(boldDomNode);
            var italicDomNode = document.createElement('div');
            italicDomNode.style.fontFamily = this._bareFontInfo.fontFamily;
            italicDomNode.style.fontWeight = this._bareFontInfo.fontWeight;
            italicDomNode.style.fontSize = this._bareFontInfo.fontSize + 'px';
            italicDomNode.style.lineHeight = this._bareFontInfo.lineHeight + 'px';
            italicDomNode.style.fontStyle = 'italic';
            container.appendChild(italicDomNode);
            var testElements = [];
            for (var i = 0, len = this._requests.length; i < len; i++) {
                var request = this._requests[i];
                var parent_1 = void 0;
                if (request.type === 0 /* Regular */) {
                    parent_1 = regularDomNode;
                }
                if (request.type === 2 /* Bold */) {
                    parent_1 = boldDomNode;
                }
                if (request.type === 1 /* Italic */) {
                    parent_1 = italicDomNode;
                }
                parent_1.appendChild(document.createElement('br'));
                var testElement = document.createElement('span');
                DomCharWidthReader._render(testElement, request);
                parent_1.appendChild(testElement);
                testElements[i] = testElement;
            }
            this._container = container;
            this._testElements = testElements;
        };
        DomCharWidthReader._render = function (testElement, request) {
            if (request.chr === ' ') {
                var htmlString = '&nbsp;';
                // Repeat character 256 (2^8) times
                for (var i = 0; i < 8; i++) {
                    htmlString += htmlString;
                }
                testElement.innerHTML = htmlString;
            }
            else {
                var testString = request.chr;
                // Repeat character 256 (2^8) times
                for (var i = 0; i < 8; i++) {
                    testString += testString;
                }
                testElement.textContent = testString;
            }
        };
        DomCharWidthReader.prototype._readFromDomElements = function () {
            for (var i = 0, len = this._requests.length; i < len; i++) {
                var request = this._requests[i];
                var testElement = this._testElements[i];
                request.fulfill(testElement.offsetWidth / 256);
            }
        };
        return DomCharWidthReader;
    }());
    var CanvasCharWidthReader = (function () {
        function CanvasCharWidthReader(bareFontInfo, requests) {
            this._bareFontInfo = bareFontInfo;
            this._requests = requests;
        }
        CanvasCharWidthReader.prototype.read = function () {
            var canvasElement = document.createElement('canvas');
            var context = canvasElement.getContext('2d');
            context.font = CanvasCharWidthReader._createFontString(this._bareFontInfo);
            for (var i = 0, len = this._requests.length; i < len; i++) {
                var request = this._requests[i];
                if (request.type === 0 /* Regular */) {
                    request.fulfill(context.measureText(request.chr).width);
                }
            }
            context.font = CanvasCharWidthReader._createFontString(this._bareFontInfo, undefined, 'bold');
            for (var i = 0, len = this._requests.length; i < len; i++) {
                var request = this._requests[i];
                if (request.type === 2 /* Bold */) {
                    request.fulfill(context.measureText(request.chr).width);
                }
            }
            context.font = CanvasCharWidthReader._createFontString(this._bareFontInfo, 'italic');
            for (var i = 0, len = this._requests.length; i < len; i++) {
                var request = this._requests[i];
                if (request.type === 1 /* Italic */) {
                    request.fulfill(context.measureText(request.chr).width);
                }
            }
        };
        CanvasCharWidthReader._createFontString = function (bareFontInfo, overwriteFontStyle, overwriteFontWeight) {
            if (overwriteFontStyle === void 0) { overwriteFontStyle = 'normal'; }
            if (overwriteFontWeight === void 0) { overwriteFontWeight = bareFontInfo.fontWeight; }
            return this._doCreateFontString(overwriteFontStyle, overwriteFontWeight, bareFontInfo.fontSize, bareFontInfo.lineHeight, bareFontInfo.fontFamily);
        };
        CanvasCharWidthReader._doCreateFontString = function (fontStyle, fontWeight, fontSize, lineHeight, fontFamily) {
            // The full font syntax is:
            // style | variant | weight | stretch | size/line-height | fontFamily
            // (https://developer.mozilla.org/en-US/docs/Web/CSS/font)
            // But it appears Edge and IE11 cannot properly parse `stretch`.
            return fontStyle + " normal " + fontWeight + " " + fontSize + "px / " + lineHeight + "px " + fontFamily;
        };
        return CanvasCharWidthReader;
    }());
    function readCharWidths(bareFontInfo, requests) {
        // In IE11, it appears that ctx.measureText() always returns integer results.
        if (browser.isIE) {
            var reader = new DomCharWidthReader(bareFontInfo, requests);
            reader.read();
        }
        else {
            var reader = new CanvasCharWidthReader(bareFontInfo, requests);
            reader.read();
        }
    }
    exports.readCharWidths = readCharWidths;
});






define(__m[425/*vs/editor/browser/config/elementSizeObserver*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/]), function (require, exports, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ElementSizeObserver = (function (_super) {
        __extends(ElementSizeObserver, _super);
        function ElementSizeObserver(referenceDomElement, changeCallback) {
            var _this = _super.call(this) || this;
            _this.referenceDomElement = referenceDomElement;
            _this.changeCallback = changeCallback;
            _this.measureReferenceDomElementToken = -1;
            _this.width = -1;
            _this.height = -1;
            _this.measureReferenceDomElement(false);
            return _this;
        }
        ElementSizeObserver.prototype.dispose = function () {
            this.stopObserving();
            _super.prototype.dispose.call(this);
        };
        ElementSizeObserver.prototype.getWidth = function () {
            return this.width;
        };
        ElementSizeObserver.prototype.getHeight = function () {
            return this.height;
        };
        ElementSizeObserver.prototype.startObserving = function () {
            var _this = this;
            if (this.measureReferenceDomElementToken === -1) {
                this.measureReferenceDomElementToken = setInterval(function () { return _this.measureReferenceDomElement(true); }, 100);
            }
        };
        ElementSizeObserver.prototype.stopObserving = function () {
            if (this.measureReferenceDomElementToken !== -1) {
                clearInterval(this.measureReferenceDomElementToken);
                this.measureReferenceDomElementToken = -1;
            }
        };
        ElementSizeObserver.prototype.observe = function (dimension) {
            this.measureReferenceDomElement(true, dimension);
        };
        ElementSizeObserver.prototype.measureReferenceDomElement = function (callChangeCallback, dimension) {
            var observedWidth = 0;
            var observedHeight = 0;
            if (dimension) {
                observedWidth = dimension.width;
                observedHeight = dimension.height;
            }
            else if (this.referenceDomElement) {
                observedWidth = this.referenceDomElement.clientWidth;
                observedHeight = this.referenceDomElement.clientHeight;
            }
            observedWidth = Math.max(5, observedWidth);
            observedHeight = Math.max(5, observedHeight);
            if (this.width !== observedWidth || this.height !== observedHeight) {
                this.width = observedWidth;
                this.height = observedHeight;
                if (callChangeCallback) {
                    this.changeCallback();
                }
            }
        };
        return ElementSizeObserver;
    }(lifecycle_1.Disposable));
    exports.ElementSizeObserver = ElementSizeObserver;
});






define(__m[427/*vs/editor/browser/controller/input/textAreaWrapper*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/]), function (require, exports, event_1, lifecycle_1, browser, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ClipboardEventWrapper = (function () {
        function ClipboardEventWrapper(event) {
            this._event = event;
        }
        ClipboardEventWrapper.prototype.canUseTextData = function () {
            if (this._event.clipboardData) {
                return true;
            }
            if (window.clipboardData) {
                return true;
            }
            return false;
        };
        ClipboardEventWrapper.prototype.setTextData = function (text) {
            if (this._event.clipboardData) {
                this._event.clipboardData.setData('text/plain', text);
                this._event.preventDefault();
                return;
            }
            if (window.clipboardData) {
                window.clipboardData.setData('Text', text);
                this._event.preventDefault();
                return;
            }
            throw new Error('ClipboardEventWrapper.setTextData: Cannot use text data!');
        };
        ClipboardEventWrapper.prototype.getTextData = function () {
            if (this._event.clipboardData) {
                this._event.preventDefault();
                return this._event.clipboardData.getData('text/plain');
            }
            if (window.clipboardData) {
                this._event.preventDefault();
                return window.clipboardData.getData('Text');
            }
            throw new Error('ClipboardEventWrapper.getTextData: Cannot use text data!');
        };
        return ClipboardEventWrapper;
    }());
    var KeyboardEventWrapper = (function () {
        function KeyboardEventWrapper(actual) {
            this._actual = actual;
        }
        KeyboardEventWrapper.prototype.equals = function (keybinding) {
            return this._actual.equals(keybinding);
        };
        KeyboardEventWrapper.prototype.preventDefault = function () {
            this._actual.preventDefault();
        };
        KeyboardEventWrapper.prototype.isDefaultPrevented = function () {
            if (this._actual.browserEvent) {
                return this._actual.browserEvent.defaultPrevented;
            }
            return false;
        };
        return KeyboardEventWrapper;
    }());
    var TextAreaWrapper = (function (_super) {
        __extends(TextAreaWrapper, _super);
        function TextAreaWrapper(textArea) {
            var _this = _super.call(this) || this;
            _this._onKeyDown = _this._register(new event_1.Emitter());
            _this.onKeyDown = _this._onKeyDown.event;
            _this._onKeyUp = _this._register(new event_1.Emitter());
            _this.onKeyUp = _this._onKeyUp.event;
            _this._onKeyPress = _this._register(new event_1.Emitter());
            _this.onKeyPress = _this._onKeyPress.event;
            _this._onCompositionStart = _this._register(new event_1.Emitter());
            _this.onCompositionStart = _this._onCompositionStart.event;
            _this._onCompositionUpdate = _this._register(new event_1.Emitter());
            _this.onCompositionUpdate = _this._onCompositionUpdate.event;
            _this._onCompositionEnd = _this._register(new event_1.Emitter());
            _this.onCompositionEnd = _this._onCompositionEnd.event;
            _this._onInput = _this._register(new event_1.Emitter());
            _this.onInput = _this._onInput.event;
            _this._onCut = _this._register(new event_1.Emitter());
            _this.onCut = _this._onCut.event;
            _this._onCopy = _this._register(new event_1.Emitter());
            _this.onCopy = _this._onCopy.event;
            _this._onPaste = _this._register(new event_1.Emitter());
            _this.onPaste = _this._onPaste.event;
            _this._textArea = textArea;
            _this._register(dom.addStandardDisposableListener(_this._textArea, 'keydown', function (e) { return _this._onKeyDown.fire(new KeyboardEventWrapper(e)); }));
            _this._register(dom.addStandardDisposableListener(_this._textArea, 'keyup', function (e) { return _this._onKeyUp.fire(new KeyboardEventWrapper(e)); }));
            _this._register(dom.addStandardDisposableListener(_this._textArea, 'keypress', function (e) { return _this._onKeyPress.fire(new KeyboardEventWrapper(e)); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'compositionstart', function (e) { return _this._onCompositionStart.fire(e); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'compositionupdate', function (e) { return _this._onCompositionUpdate.fire(e); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'compositionend', function (e) { return _this._onCompositionEnd.fire(e); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'input', function (e) { return _this._onInput.fire(); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'cut', function (e) { return _this._onCut.fire(new ClipboardEventWrapper(e)); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'copy', function (e) { return _this._onCopy.fire(new ClipboardEventWrapper(e)); }));
            _this._register(dom.addDisposableListener(_this._textArea, 'paste', function (e) { return _this._onPaste.fire(new ClipboardEventWrapper(e)); }));
            return _this;
        }
        Object.defineProperty(TextAreaWrapper.prototype, "actual", {
            get: function () {
                return this._textArea;
            },
            enumerable: true,
            configurable: true
        });
        TextAreaWrapper.prototype.getValue = function () {
            // console.log('current value: ' + this._textArea.value);
            return this._textArea.value;
        };
        TextAreaWrapper.prototype.setValue = function (reason, value) {
            // console.log('reason: ' + reason + ', current value: ' + this._textArea.value + ' => new value: ' + value);
            this._textArea.value = value;
        };
        TextAreaWrapper.prototype.getSelectionStart = function () {
            return this._textArea.selectionStart;
        };
        TextAreaWrapper.prototype.getSelectionEnd = function () {
            return this._textArea.selectionEnd;
        };
        TextAreaWrapper.prototype.setSelectionRange = function (selectionStart, selectionEnd) {
            var activeElement = document.activeElement;
            if (activeElement === this._textArea) {
                this._textArea.setSelectionRange(selectionStart, selectionEnd);
            }
            else {
                this._setSelectionRangeJumpy(selectionStart, selectionEnd);
            }
        };
        TextAreaWrapper.prototype._setSelectionRangeJumpy = function (selectionStart, selectionEnd) {
            try {
                var scrollState = dom.saveParentsScrollTop(this._textArea);
                this._textArea.focus();
                this._textArea.setSelectionRange(selectionStart, selectionEnd);
                dom.restoreParentsScrollTop(this._textArea, scrollState);
            }
            catch (e) {
                // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)
                console.log('an error has been thrown!');
            }
        };
        TextAreaWrapper.prototype.isInOverwriteMode = function () {
            // In IE, pressing Insert will bring the typing into overwrite mode
            if (browser.isIE && document.queryCommandValue('OverWrite')) {
                return true;
            }
            return false;
        };
        return TextAreaWrapper;
    }(lifecycle_1.Disposable));
    exports.TextAreaWrapper = TextAreaWrapper;
});

define(__m[21/*vs/editor/browser/editorBrowser*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * @internal
     */
    exports.ClassNames = {
        TEXTAREA_COVER: 'textAreaCover',
        TEXTAREA: 'inputarea',
        LINES_CONTENT: 'lines-content',
        OVERFLOW_GUARD: 'overflow-guard',
        VIEW_LINES: 'view-lines',
        VIEW_LINE: 'view-line',
        SCROLLABLE_ELEMENT: 'editor-scrollable',
        CONTENT_WIDGETS: 'contentWidgets',
        OVERFLOWING_CONTENT_WIDGETS: 'overflowingContentWidgets',
        OVERLAY_WIDGETS: 'overlayWidgets',
        MARGIN_VIEW_OVERLAYS: 'margin-view-overlays',
        MARGIN: 'margin',
        LINE_NUMBERS: 'line-numbers',
        GLYPH_MARGIN: 'glyph-margin',
        SCROLL_DECORATION: 'scroll-decoration',
        VIEW_CURSORS_LAYER: 'cursors-layer',
        VIEW_ZONES: 'view-zones'
    };
    /**
     * A positioning preference for rendering content widgets.
     */
    var ContentWidgetPositionPreference;
    (function (ContentWidgetPositionPreference) {
        /**
         * Place the content widget exactly at a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
        /**
         * Place the content widget above a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
        /**
         * Place the content widget below a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
    })(ContentWidgetPositionPreference = exports.ContentWidgetPositionPreference || (exports.ContentWidgetPositionPreference = {}));
    /**
     * A positioning preference for rendering overlay widgets.
     */
    var OverlayWidgetPositionPreference;
    (function (OverlayWidgetPositionPreference) {
        /**
         * Position the overlay widget in the top right corner
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
        /**
         * Position the overlay widget in the bottom right corner
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
        /**
         * Position the overlay widget in the top center
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
    })(OverlayWidgetPositionPreference = exports.OverlayWidgetPositionPreference || (exports.OverlayWidgetPositionPreference = {}));
});






define(__m[104/*vs/editor/browser/editorDom*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,34/*vs/base/browser/mouseEvent*/,11/*vs/base/browser/dom*/,102/*vs/base/browser/globalMouseMoveMonitor*/]), function (require, exports, lifecycle_1, mouseEvent_1, dom, globalMouseMoveMonitor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Coordinates relative to the whole document (e.g. mouse event's pageX and pageY)
     */
    var PageCoordinates = (function () {
        function PageCoordinates(x, y) {
            this.x = x;
            this.y = y;
        }
        PageCoordinates.prototype.toClientCoordinates = function () {
            return new ClientCoordinates(this.x - dom.StandardWindow.scrollX, this.y - dom.StandardWindow.scrollY);
        };
        return PageCoordinates;
    }());
    exports.PageCoordinates = PageCoordinates;
    /**
     * Coordinates within the application's client area (i.e. origin is document's scroll position).
     *
     * For example, clicking in the top-left corner of the client area will
     * always result in a mouse event with a client.x value of 0, regardless
     * of whether the page is scrolled horizontally.
     */
    var ClientCoordinates = (function () {
        function ClientCoordinates(clientX, clientY) {
            this.clientX = clientX;
            this.clientY = clientY;
        }
        ClientCoordinates.prototype.toPageCoordinates = function () {
            return new PageCoordinates(this.clientX + dom.StandardWindow.scrollX, this.clientY + dom.StandardWindow.scrollY);
        };
        return ClientCoordinates;
    }());
    exports.ClientCoordinates = ClientCoordinates;
    /**
     * The position of the editor in the page.
     */
    var EditorPagePosition = (function () {
        function EditorPagePosition(x, y, width, height) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
        }
        return EditorPagePosition;
    }());
    exports.EditorPagePosition = EditorPagePosition;
    function createEditorPagePosition(editorViewDomNode) {
        var editorPos = dom.getDomNodePagePosition(editorViewDomNode);
        return new EditorPagePosition(editorPos.left, editorPos.top, editorPos.width, editorPos.height);
    }
    exports.createEditorPagePosition = createEditorPagePosition;
    var EditorMouseEvent = (function (_super) {
        __extends(EditorMouseEvent, _super);
        function EditorMouseEvent(e, editorViewDomNode) {
            var _this = _super.call(this, e) || this;
            _this.pos = new PageCoordinates(_this.posx, _this.posy);
            _this.editorPos = createEditorPagePosition(editorViewDomNode);
            return _this;
        }
        return EditorMouseEvent;
    }(mouseEvent_1.StandardMouseEvent));
    exports.EditorMouseEvent = EditorMouseEvent;
    var EditorMouseEventFactory = (function () {
        function EditorMouseEventFactory(editorViewDomNode) {
            this._editorViewDomNode = editorViewDomNode;
        }
        EditorMouseEventFactory.prototype._create = function (e) {
            return new EditorMouseEvent(e, this._editorViewDomNode);
        };
        EditorMouseEventFactory.prototype.onContextMenu = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'contextmenu', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseUp = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'mouseup', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseDown = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'mousedown', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseLeave = function (target, callback) {
            var _this = this;
            return dom.addDisposableNonBubblingMouseOutListener(target, function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseMoveThrottled = function (target, callback, merger, minimumTimeMs) {
            var _this = this;
            var myMerger = function (lastEvent, currentEvent) {
                return merger(lastEvent, _this._create(currentEvent));
            };
            return dom.addDisposableThrottledListener(target, 'mousemove', callback, myMerger, minimumTimeMs);
        };
        return EditorMouseEventFactory;
    }());
    exports.EditorMouseEventFactory = EditorMouseEventFactory;
    var GlobalEditorMouseMoveMonitor = (function (_super) {
        __extends(GlobalEditorMouseMoveMonitor, _super);
        function GlobalEditorMouseMoveMonitor(editorViewDomNode) {
            var _this = _super.call(this) || this;
            _this._editorViewDomNode = editorViewDomNode;
            _this._globalMouseMoveMonitor = _this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
            return _this;
        }
        GlobalEditorMouseMoveMonitor.prototype.startMonitoring = function (merger, mouseMoveCallback, onStopCallback) {
            var _this = this;
            var myMerger = function (lastEvent, currentEvent) {
                return merger(lastEvent, new EditorMouseEvent(currentEvent, _this._editorViewDomNode));
            };
            this._globalMouseMoveMonitor.startMonitoring(myMerger, mouseMoveCallback, onStopCallback);
        };
        return GlobalEditorMouseMoveMonitor;
    }(lifecycle_1.Disposable));
    exports.GlobalEditorMouseMoveMonitor = GlobalEditorMouseMoveMonitor;
});

define(__m[436/*vs/editor/browser/view/viewEventDispatcher*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/]), function (require, exports, eventEmitter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewEventDispatcher = (function () {
        function ViewEventDispatcher(eventHandlerGateKeeper) {
            this._eventHandlerGateKeeper = eventHandlerGateKeeper;
            this._eventHandlers = [];
            this._eventQueue = null;
            this._isConsumingQueue = false;
        }
        ViewEventDispatcher.prototype.addEventHandler = function (eventHandler) {
            for (var i = 0, len = this._eventHandlers.length; i < len; i++) {
                if (this._eventHandlers[i] === eventHandler) {
                    console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);
                }
            }
            this._eventHandlers.push(eventHandler);
        };
        ViewEventDispatcher.prototype.removeEventHandler = function (eventHandler) {
            for (var i = 0; i < this._eventHandlers.length; i++) {
                if (this._eventHandlers[i] === eventHandler) {
                    this._eventHandlers.splice(i, 1);
                    break;
                }
            }
        };
        ViewEventDispatcher.prototype.emit = function (eventType, data) {
            var event = new eventEmitter_1.EmitterEvent(eventType, data);
            if (this._eventQueue) {
                this._eventQueue.push(event);
            }
            else {
                this._eventQueue = [event];
            }
            if (!this._isConsumingQueue) {
                this.consumeQueue();
            }
        };
        ViewEventDispatcher.prototype.emitMany = function (events) {
            if (this._eventQueue) {
                this._eventQueue = this._eventQueue.concat(events);
            }
            else {
                this._eventQueue = events;
            }
            if (!this._isConsumingQueue) {
                this.consumeQueue();
            }
        };
        ViewEventDispatcher.prototype.consumeQueue = function () {
            var _this = this;
            this._eventHandlerGateKeeper(function () {
                try {
                    _this._isConsumingQueue = true;
                    _this._doConsumeQueue();
                }
                finally {
                    _this._isConsumingQueue = false;
                }
            });
        };
        ViewEventDispatcher.prototype._doConsumeQueue = function () {
            while (this._eventQueue) {
                // Empty event queue, as events might come in while sending these off
                var events = this._eventQueue;
                this._eventQueue = null;
                // Use a clone of the event handlers list, as they might remove themselves
                var eventHandlers = this._eventHandlers.slice(0);
                for (var i = 0, len = eventHandlers.length; i < len; i++) {
                    eventHandlers[i].handleEvents(events);
                }
            }
        };
        return ViewEventDispatcher;
    }());
    exports.ViewEventDispatcher = ViewEventDispatcher;
});

define(__m[106/*vs/editor/common/config/editorZoom*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/]), function (require, exports, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.EditorZoom = new (function () {
        function class_1() {
            this._zoomLevel = 0;
            this._onDidChangeZoomLevel = new event_1.Emitter();
            this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
        }
        class_1.prototype.getZoomLevel = function () {
            return this._zoomLevel;
        };
        class_1.prototype.setZoomLevel = function (zoomLevel) {
            zoomLevel = Math.min(Math.max(-9, zoomLevel), 9);
            if (this._zoomLevel === zoomLevel) {
                return;
            }
            this._zoomLevel = zoomLevel;
            this._onDidChangeZoomLevel.fire(this._zoomLevel);
        };
        return class_1;
    }());
});

define(__m[16/*vs/editor/common/core/position*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A position in the editor.
     */
    var Position = (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        /**
         * Test if this position equals other position
         */
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        /**
         * Test if position `a` equals position `b`
         */
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be false.
         */
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be true.
         */
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        /**
         * A function that compares positions, useful for sorting
         */
        Position.compare = function (a, b) {
            var aLineNumber = a.lineNumber | 0;
            var bLineNumber = b.lineNumber | 0;
            if (aLineNumber === bLineNumber) {
                var aColumn = a.column | 0;
                var bColumn = b.column | 0;
                return aColumn - bColumn;
            }
            return aLineNumber - bLineNumber;
        };
        /**
         * Clone this position.
         */
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        /**
         * Convert to a human-readable representation.
         */
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        /**
         * Create a `Position` from an `IPosition`.
         */
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        /**
         * Test if `obj` is an `IPosition`.
         */
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[4/*vs/editor/common/core/range*/], __M([1/*require*/,0/*exports*/,16/*vs/editor/common/core/position*/]), function (require, exports, position_1) {
    'use strict';
    /**
     * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
     */
    var Range = (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        /**
         * Test if this range is empty.
         */
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        /**
         * Test if `range` is empty.
         */
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        /**
         * Test if `position` is in `range`. If the position is at the edges, will return true.
         */
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        /**
         * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
         */
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.plusRange = function (a, b) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        /**
         * Test if this range equals other.
         */
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        /**
         * Test if range `a` equals `b`.
         */
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        /**
         * Clone this range.
         */
        Range.prototype.cloneRange = function () {
            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Transform to a user presentable string representation.
         */
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        /**
         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
         */
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        /**
         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
         */
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.prototype.collapseToStart = function () {
            return Range.collapseToStart(this);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.collapseToStart = function (range) {
            return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        };
        // ---
        /**
         * Create a `Range` from an `IRange`.
         */
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        /**
         * Test if `obj` is an `IRange`.
         */
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        /**
         * Test if the two ranges are touching in any way.
         */
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            var aStartLineNumber = a.startLineNumber | 0;
            var bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                var aStartColumn = a.startColumn | 0;
                var bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    var aEndLineNumber = a.endLineNumber | 0;
                    var bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        var aEndColumn = a.endColumn | 0;
                        var bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        /**
         * Test if the range spans multiple lines.
         */
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        return Range;
    }());
    exports.Range = Range;
});

define(__m[46/*vs/editor/common/core/editOperation*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditOperation = (function () {
        function EditOperation() {
        }
        EditOperation.insert = function (position, text) {
            return {
                identifier: null,
                range: new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                text: text,
                forceMoveMarkers: true
            };
        };
        EditOperation.delete = function (range) {
            return {
                identifier: null,
                range: range,
                text: null,
                forceMoveMarkers: true
            };
        };
        EditOperation.replace = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: false
            };
        };
        EditOperation.replaceMove = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: true
            };
        };
        return EditOperation;
    }());
    exports.EditOperation = EditOperation;
});

define(__m[441/*vs/editor/common/commands/trimTrailingWhitespaceCommand*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,46/*vs/editor/common/core/editOperation*/,4/*vs/editor/common/core/range*/]), function (require, exports, strings, editOperation_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TrimTrailingWhitespaceCommand = (function () {
        function TrimTrailingWhitespaceCommand(selection) {
            this.selection = selection;
        }
        TrimTrailingWhitespaceCommand.prototype.getEditOperations = function (model, builder) {
            var ops = trimTrailingWhitespace(model, []);
            for (var i = 0, len = ops.length; i < len; i++) {
                var op = ops[i];
                builder.addEditOperation(op.range, op.text);
            }
            this.selectionId = builder.trackSelection(this.selection);
        };
        TrimTrailingWhitespaceCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return TrimTrailingWhitespaceCommand;
    }());
    exports.TrimTrailingWhitespaceCommand = TrimTrailingWhitespaceCommand;
    /**
     * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.
     */
    function trimTrailingWhitespace(model, cursors) {
        // Sort cursors ascending
        cursors.sort(function (a, b) {
            if (a.lineNumber === b.lineNumber) {
                return a.column - b.column;
            }
            return a.lineNumber - b.lineNumber;
        });
        // Reduce multiple cursors on the same line and only keep the last one on the line
        for (var i = cursors.length - 2; i >= 0; i--) {
            if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
                // Remove cursor at `i`
                cursors.splice(i, 1);
            }
        }
        var r = [];
        var rLen = 0;
        var cursorIndex = 0;
        var cursorLen = cursors.length;
        for (var lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineContent = model.getLineContent(lineNumber);
            var maxLineColumn = lineContent.length + 1;
            var minEditColumn = 0;
            if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
                minEditColumn = cursors[cursorIndex].column;
                cursorIndex++;
                if (minEditColumn === maxLineColumn) {
                    // The cursor is at the end of the line => no edits for sure on this line
                    continue;
                }
            }
            if (lineContent.length === 0) {
                continue;
            }
            var lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
            var fromColumn = 0;
            if (lastNonWhitespaceIndex === -1) {
                // Entire line is whitespace
                fromColumn = 1;
            }
            else if (lastNonWhitespaceIndex !== lineContent.length - 1) {
                // There is trailing whitespace
                fromColumn = lastNonWhitespaceIndex + 2;
            }
            else {
                // There is no trailing whitespace
                continue;
            }
            fromColumn = Math.max(minEditColumn, fromColumn);
            r[rLen++] = editOperation_1.EditOperation.delete(new range_1.Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
        }
        return r;
    }
    exports.trimTrailingWhitespace = trimTrailingWhitespace;
});






define(__m[20/*vs/editor/common/core/selection*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The direction of a selection.
     */
    var SelectionDirection;
    (function (SelectionDirection) {
        /**
         * The selection starts above where it ends.
         */
        SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
        /**
         * The selection starts below where it ends.
         */
        SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
    })(SelectionDirection = exports.SelectionDirection || (exports.SelectionDirection = {}));
    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    var Selection = (function (_super) {
        __extends(Selection, _super);
        function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            var _this = _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) || this;
            _this.selectionStartLineNumber = selectionStartLineNumber;
            _this.selectionStartColumn = selectionStartColumn;
            _this.positionLineNumber = positionLineNumber;
            _this.positionColumn = positionColumn;
            return _this;
        }
        /**
         * Clone this selection.
         */
        Selection.prototype.clone = function () {
            return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);
        };
        /**
         * Transform to a human-readable representation.
         */
        Selection.prototype.toString = function () {
            return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
        };
        /**
         * Test if equals other selection.
         */
        Selection.prototype.equalsSelection = function (other) {
            return (Selection.selectionsEqual(this, other));
        };
        /**
         * Test if the two selections are equal.
         */
        Selection.selectionsEqual = function (a, b) {
            return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
                a.selectionStartColumn === b.selectionStartColumn &&
                a.positionLineNumber === b.positionLineNumber &&
                a.positionColumn === b.positionColumn);
        };
        /**
         * Get directions (LTR or RTL).
         */
        Selection.prototype.getDirection = function () {
            if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
                return SelectionDirection.LTR;
            }
            return SelectionDirection.RTL;
        };
        /**
         * Create a new selection with a different `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        };
        /**
         * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
         */
        Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
            }
            return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        };
        // ----
        /**
         * Create a `Selection` from an `ISelection`.
         */
        Selection.liftSelection = function (sel) {
            return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        };
        /**
         * `a` equals `b`.
         */
        Selection.selectionsArrEqual = function (a, b) {
            if (a && !b || !a && b) {
                return false;
            }
            if (!a && !b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0, len = a.length; i < len; i++) {
                if (!this.selectionsEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Test if `obj` is an `ISelection`.
         */
        Selection.isISelection = function (obj) {
            return (obj
                && (typeof obj.selectionStartLineNumber === 'number')
                && (typeof obj.selectionStartColumn === 'number')
                && (typeof obj.positionLineNumber === 'number')
                && (typeof obj.positionColumn === 'number'));
        };
        /**
         * Create with a direction.
         */
        Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
            if (direction === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        };
        return Selection;
    }(range_1.Range));
    exports.Selection = Selection;
});






define(__m[62/*vs/editor/common/commands/replaceCommand*/], __M([1/*require*/,0/*exports*/,20/*vs/editor/common/core/selection*/]), function (require, exports, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReplaceCommand = (function () {
        function ReplaceCommand(range, text) {
            this._range = range;
            this._text = text;
        }
        ReplaceCommand.prototype.getText = function () {
            return this._text;
        };
        ReplaceCommand.prototype.getRange = function () {
            return this._range;
        };
        ReplaceCommand.prototype.setRange = function (newRange) {
            this._range = newRange;
        };
        ReplaceCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(this._range, this._text);
        };
        ReplaceCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
        };
        return ReplaceCommand;
    }());
    exports.ReplaceCommand = ReplaceCommand;
    var ReplaceCommandWithoutChangingPosition = (function (_super) {
        __extends(ReplaceCommandWithoutChangingPosition, _super);
        function ReplaceCommandWithoutChangingPosition(range, text) {
            return _super.call(this, range, text) || this;
        }
        ReplaceCommandWithoutChangingPosition.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.startLineNumber, srcRange.startColumn);
        };
        return ReplaceCommandWithoutChangingPosition;
    }(ReplaceCommand));
    exports.ReplaceCommandWithoutChangingPosition = ReplaceCommandWithoutChangingPosition;
    var ReplaceCommandWithOffsetCursorState = (function (_super) {
        __extends(ReplaceCommandWithOffsetCursorState, _super);
        function ReplaceCommandWithOffsetCursorState(range, text, lineNumberDeltaOffset, columnDeltaOffset) {
            var _this = _super.call(this, range, text) || this;
            _this._columnDeltaOffset = columnDeltaOffset;
            _this._lineNumberDeltaOffset = lineNumberDeltaOffset;
            return _this;
        }
        ReplaceCommandWithOffsetCursorState.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset, srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset);
        };
        return ReplaceCommandWithOffsetCursorState;
    }(ReplaceCommand));
    exports.ReplaceCommandWithOffsetCursorState = ReplaceCommandWithOffsetCursorState;
    var ReplaceCommandThatPreservesSelection = (function (_super) {
        __extends(ReplaceCommandThatPreservesSelection, _super);
        function ReplaceCommandThatPreservesSelection(editRange, text, initialSelection) {
            var _this = _super.call(this, editRange, text) || this;
            _this._initialSelection = initialSelection;
            return _this;
        }
        ReplaceCommandThatPreservesSelection.prototype.getEditOperations = function (model, builder) {
            _super.prototype.getEditOperations.call(this, model, builder);
            this._selectionId = builder.trackSelection(this._initialSelection);
        };
        ReplaceCommandThatPreservesSelection.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._selectionId);
        };
        return ReplaceCommandThatPreservesSelection;
    }(ReplaceCommand));
    exports.ReplaceCommandThatPreservesSelection = ReplaceCommandThatPreservesSelection;
});

define(__m[466/*vs/editor/common/commands/surroundSelectionCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SurroundSelectionCommand = (function () {
        function SurroundSelectionCommand(range, charBeforeSelection, charAfterSelection) {
            this._range = range;
            this._charBeforeSelection = charBeforeSelection;
            this._charAfterSelection = charAfterSelection;
        }
        SurroundSelectionCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(new range_1.Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);
            builder.addEditOperation(new range_1.Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
        };
        SurroundSelectionCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var firstOperationRange = inverseEditOperations[0].range;
            var secondOperationRange = inverseEditOperations[1].range;
            return new selection_1.Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);
        };
        return SurroundSelectionCommand;
    }());
    exports.SurroundSelectionCommand = SurroundSelectionCommand;
});

define(__m[82/*vs/editor/common/core/token*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Token = (function () {
        function Token(offset, type, language) {
            this.offset = offset | 0; // @perf
            this.type = type;
            this.language = language;
        }
        Token.prototype.toString = function () {
            return '(' + this.offset + ', ' + this.type + ')';
        };
        return Token;
    }());
    exports.Token = Token;
    var TokenizationResult = (function () {
        function TokenizationResult(tokens, endState) {
            this.tokens = tokens;
            this.endState = endState;
        }
        return TokenizationResult;
    }());
    exports.TokenizationResult = TokenizationResult;
    var TokenizationResult2 = (function () {
        function TokenizationResult2(tokens, endState) {
            this.tokens = tokens;
            this.endState = endState;
        }
        return TokenizationResult2;
    }());
    exports.TokenizationResult2 = TokenizationResult2;
});

define(__m[80/*vs/editor/common/core/uint*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Uint8Matrix = (function () {
        function Uint8Matrix(rows, cols, defaultValue) {
            var data = new Uint8Array(rows * cols);
            for (var i = 0, len = rows * cols; i < len; i++) {
                data[i] = defaultValue;
            }
            this._data = data;
            this._rows = rows;
            this._cols = cols;
        }
        Uint8Matrix.prototype.get = function (row, col) {
            return this._data[row * this._cols + col];
        };
        Uint8Matrix.prototype.set = function (row, col, value) {
            this._data[row * this._cols + col] = value;
        };
        return Uint8Matrix;
    }());
    exports.Uint8Matrix = Uint8Matrix;
    var Constants;
    (function (Constants) {
        /**
         * MAX SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MAX_SAFE_SMALL_INTEGER"] = 1073741824] = "MAX_SAFE_SMALL_INTEGER";
        /**
         * MIN SMI (SMall Integer) as defined in v8.
         * one bit is lost for boxing/unboxing flag.
         * one bit is lost for sign flag.
         * See https://thibaultlaurens.github.io/javascript/2013/04/29/how-the-v8-engine-works/#tagged-values
         */
        Constants[Constants["MIN_SAFE_SMALL_INTEGER"] = -1073741824] = "MIN_SAFE_SMALL_INTEGER";
        /**
         * Max unsigned integer that fits on 8 bits.
         */
        Constants[Constants["MAX_UINT_8"] = 255] = "MAX_UINT_8";
        /**
         * Max unsigned integer that fits on 16 bits.
         */
        Constants[Constants["MAX_UINT_16"] = 65535] = "MAX_UINT_16";
        /**
         * Max unsigned integer that fits on 32 bits.
         */
        Constants[Constants["MAX_UINT_32"] = 4294967295] = "MAX_UINT_32";
    })(Constants = exports.Constants || (exports.Constants = {}));
    function toUint8(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 255 /* MAX_UINT_8 */) {
            return 255 /* MAX_UINT_8 */;
        }
        return v | 0;
    }
    exports.toUint8 = toUint8;
    function toUint32(v) {
        if (v < 0) {
            return 0;
        }
        if (v > 4294967295 /* MAX_UINT_32 */) {
            return 4294967295 /* MAX_UINT_32 */;
        }
        return v | 0;
    }
    exports.toUint32 = toUint32;
    function toUint32Array(arr) {
        var len = arr.length;
        var r = new Uint32Array(len);
        for (var i = 0; i < len; i++) {
            r[i] = toUint32(arr[i]);
        }
        return r;
    }
    exports.toUint32Array = toUint32Array;
});

define(__m[65/*vs/editor/common/core/characterClassifier*/], __M([1/*require*/,0/*exports*/,80/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A fast character classifier that uses a compact array for ASCII values.
     */
    var CharacterClassifier = (function () {
        function CharacterClassifier(_defaultValue) {
            var defaultValue = uint_1.toUint8(_defaultValue);
            this._defaultValue = defaultValue;
            this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
            this._map = new Map();
        }
        CharacterClassifier._createAsciiMap = function (defaultValue) {
            var asciiMap = new Uint8Array(256);
            for (var i = 0; i < 256; i++) {
                asciiMap[i] = defaultValue;
            }
            return asciiMap;
        };
        CharacterClassifier.prototype.set = function (charCode, _value) {
            var value = uint_1.toUint8(_value);
            if (charCode >= 0 && charCode < 256) {
                this._asciiMap[charCode] = value;
            }
            else {
                this._map.set(charCode, value);
            }
        };
        CharacterClassifier.prototype.get = function (charCode) {
            if (charCode >= 0 && charCode < 256) {
                return this._asciiMap[charCode];
            }
            else {
                return (this._map.get(charCode) || this._defaultValue);
            }
        };
        return CharacterClassifier;
    }());
    exports.CharacterClassifier = CharacterClassifier;
    var Boolean;
    (function (Boolean) {
        Boolean[Boolean["False"] = 0] = "False";
        Boolean[Boolean["True"] = 1] = "True";
    })(Boolean || (Boolean = {}));
    var CharacterSet = (function () {
        function CharacterSet() {
            this._actual = new CharacterClassifier(0 /* False */);
        }
        CharacterSet.prototype.add = function (charCode) {
            this._actual.set(charCode, 1 /* True */);
        };
        CharacterSet.prototype.has = function (charCode) {
            return (this._actual.get(charCode) === 1 /* True */);
        };
        return CharacterSet;
    }());
    exports.CharacterSet = CharacterSet;
});

define(__m[77/*vs/editor/common/core/viewLineToken*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A token on a line.
     */
    var ViewLineToken = (function () {
        function ViewLineToken(endIndex, type) {
            this.endIndex = endIndex;
            this.type = type;
        }
        ViewLineToken._equals = function (a, b) {
            return (a.endIndex === b.endIndex
                && a.type === b.type);
        };
        ViewLineToken.equalsArr = function (a, b) {
            var aLen = a.length;
            var bLen = b.length;
            if (aLen !== bLen) {
                return false;
            }
            for (var i = 0; i < aLen; i++) {
                if (!this._equals(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        return ViewLineToken;
    }());
    exports.ViewLineToken = ViewLineToken;
});






define(__m[494/*vs/editor/common/diff/diffComputer*/], __M([1/*require*/,0/*exports*/,95/*vs/base/common/diff/diff*/,9/*vs/base/common/strings*/]), function (require, exports, diff_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MAXIMUM_RUN_TIME = 5000; // 5 seconds
    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate) {
        var diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
        return diffAlgo.ComputeDiff();
    }
    var MarkerSequence = (function () {
        function MarkerSequence(buffer, startMarkers, endMarkers) {
            this.buffer = buffer;
            this.startMarkers = startMarkers;
            this.endMarkers = endMarkers;
        }
        MarkerSequence.prototype.equals = function (other) {
            if (!(other instanceof MarkerSequence)) {
                return false;
            }
            var otherMarkerSequence = other;
            if (this.getLength() !== otherMarkerSequence.getLength()) {
                return false;
            }
            for (var i = 0, len = this.getLength(); i < len; i++) {
                var myElement = this.getElementHash(i);
                var otherElement = otherMarkerSequence.getElementHash(i);
                if (myElement !== otherElement) {
                    return false;
                }
            }
            return true;
        };
        MarkerSequence.prototype.getLength = function () {
            return this.startMarkers.length;
        };
        MarkerSequence.prototype.getElementHash = function (i) {
            return this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);
        };
        MarkerSequence.prototype.getStartLineNumber = function (i) {
            if (i === this.startMarkers.length) {
                // This is the special case where a change happened after the last marker
                return this.startMarkers[i - 1].lineNumber + 1;
            }
            return this.startMarkers[i].lineNumber;
        };
        MarkerSequence.prototype.getStartColumn = function (i) {
            return this.startMarkers[i].column;
        };
        MarkerSequence.prototype.getEndLineNumber = function (i) {
            return this.endMarkers[i].lineNumber;
        };
        MarkerSequence.prototype.getEndColumn = function (i) {
            return this.endMarkers[i].column;
        };
        return MarkerSequence;
    }());
    var LineMarkerSequence = (function (_super) {
        __extends(LineMarkerSequence, _super);
        function LineMarkerSequence(lines, shouldIgnoreTrimWhitespace) {
            var _this = this;
            var i, length, pos;
            var buffer = '';
            var startMarkers = [], endMarkers = [], startColumn, endColumn;
            for (pos = 0, i = 0, length = lines.length; i < length; i++) {
                buffer += lines[i];
                startColumn = 1;
                endColumn = lines[i].length + 1;
                if (shouldIgnoreTrimWhitespace) {
                    startColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);
                    endColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);
                }
                startMarkers.push({
                    offset: pos + startColumn - 1,
                    lineNumber: i + 1,
                    column: startColumn
                });
                endMarkers.push({
                    offset: pos + endColumn - 1,
                    lineNumber: i + 1,
                    column: endColumn
                });
                pos += lines[i].length;
            }
            _this = _super.call(this, buffer, startMarkers, endMarkers) || this;
            return _this;
        }
        LineMarkerSequence._getFirstNonBlankColumn = function (txt, defaultValue) {
            var r = strings.firstNonWhitespaceIndex(txt);
            if (r === -1) {
                return defaultValue;
            }
            return r + 1;
        };
        LineMarkerSequence._getLastNonBlankColumn = function (txt, defaultValue) {
            var r = strings.lastNonWhitespaceIndex(txt);
            if (r === -1) {
                return defaultValue;
            }
            return r + 2;
        };
        LineMarkerSequence.prototype.getCharSequence = function (startIndex, endIndex) {
            var startMarkers = [], endMarkers = [], index, i, startMarker, endMarker;
            for (index = startIndex; index <= endIndex; index++) {
                startMarker = this.startMarkers[index];
                endMarker = this.endMarkers[index];
                for (i = startMarker.offset; i < endMarker.offset; i++) {
                    startMarkers.push({
                        offset: i,
                        lineNumber: startMarker.lineNumber,
                        column: startMarker.column + (i - startMarker.offset)
                    });
                    endMarkers.push({
                        offset: i + 1,
                        lineNumber: startMarker.lineNumber,
                        column: startMarker.column + (i - startMarker.offset) + 1
                    });
                }
            }
            return new MarkerSequence(this.buffer, startMarkers, endMarkers);
        };
        return LineMarkerSequence;
    }(MarkerSequence));
    var CharChange = (function () {
        function CharChange(diffChange, originalCharSequence, modifiedCharSequence) {
            if (diffChange.originalLength === 0) {
                this.originalStartLineNumber = 0;
                this.originalStartColumn = 0;
                this.originalEndLineNumber = 0;
                this.originalEndColumn = 0;
            }
            else {
                this.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
                this.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
                this.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
                this.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
            }
            if (diffChange.modifiedLength === 0) {
                this.modifiedStartLineNumber = 0;
                this.modifiedStartColumn = 0;
                this.modifiedEndLineNumber = 0;
                this.modifiedEndColumn = 0;
            }
            else {
                this.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
                this.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
                this.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
                this.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            }
        }
        return CharChange;
    }());
    function postProcessCharChanges(rawChanges) {
        if (rawChanges.length <= 1) {
            return rawChanges;
        }
        var result = [rawChanges[0]];
        var i, len, originalMatchingLength, modifiedMatchingLength, matchingLength, prevChange = result[0], currChange;
        for (i = 1, len = rawChanges.length; i < len; i++) {
            currChange = rawChanges[i];
            originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
            modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
            // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
            matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
            if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
                // Merge the current change into the previous one
                prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
                prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
            }
            else {
                // Add the current change
                result.push(currChange);
                prevChange = currChange;
            }
        }
        return result;
    }
    var LineChange = (function () {
        function LineChange(diffChange, originalLineSequence, modifiedLineSequence, continueProcessingPredicate, shouldPostProcessCharChanges) {
            if (diffChange.originalLength === 0) {
                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
                this.originalEndLineNumber = 0;
            }
            else {
                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
                this.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            }
            if (diffChange.modifiedLength === 0) {
                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
                this.modifiedEndLineNumber = 0;
            }
            else {
                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
                this.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            }
            if (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {
                var originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
                var modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
                var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);
                if (shouldPostProcessCharChanges) {
                    rawChanges = postProcessCharChanges(rawChanges);
                }
                this.charChanges = [];
                for (var i = 0, length = rawChanges.length; i < length; i++) {
                    this.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
                }
            }
        }
        return LineChange;
    }());
    var DiffComputer = (function () {
        function DiffComputer(originalLines, modifiedLines, opts) {
            this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
            this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
            this.maximumRunTimeMs = MAXIMUM_RUN_TIME;
            this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);
            this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);
            if (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {
                // Diff would be empty with `shouldIgnoreTrimWhitespace`
                this.shouldIgnoreTrimWhitespace = false;
                this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);
                this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);
            }
        }
        DiffComputer.prototype.computeDiff = function () {
            this.computationStartTime = (new Date()).getTime();
            var rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));
            var lineChanges = [];
            for (var i = 0, length = rawChanges.length; i < length; i++) {
                lineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));
            }
            return lineChanges;
        };
        DiffComputer.prototype._continueProcessingPredicate = function () {
            if (this.maximumRunTimeMs === 0) {
                return true;
            }
            var now = (new Date()).getTime();
            return now - this.computationStartTime < this.maximumRunTimeMs;
        };
        return DiffComputer;
    }());
    exports.DiffComputer = DiffComputer;
});

define(__m[495/*vs/editor/common/model/editStack*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditStack = (function () {
        function EditStack(model) {
            this.model = model;
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        }
        EditStack.prototype.pushStackElement = function () {
            if (this.currentOpenStackElement !== null) {
                this.past.push(this.currentOpenStackElement);
                this.currentOpenStackElement = null;
            }
        };
        EditStack.prototype.clear = function () {
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        };
        EditStack.prototype.pushEditOperation = function (beforeCursorState, editOperations, cursorStateComputer) {
            // No support for parallel universes :(
            this.future = [];
            if (!this.currentOpenStackElement) {
                this.currentOpenStackElement = {
                    beforeVersionId: this.model.getAlternativeVersionId(),
                    beforeCursorState: beforeCursorState,
                    editOperations: [],
                    afterCursorState: null,
                    afterVersionId: -1
                };
            }
            var inverseEditOperation = {
                operations: this.model.applyEdits(editOperations)
            };
            this.currentOpenStackElement.editOperations.push(inverseEditOperation);
            try {
                this.currentOpenStackElement.afterCursorState = cursorStateComputer ? cursorStateComputer(inverseEditOperation.operations) : null;
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                this.currentOpenStackElement.afterCursorState = null;
            }
            this.currentOpenStackElement.afterVersionId = this.model.getVersionId();
            return this.currentOpenStackElement.afterCursorState;
        };
        EditStack.prototype.undo = function () {
            this.pushStackElement();
            if (this.past.length > 0) {
                var pastStackElement = this.past.pop();
                try {
                    // Apply all operations in reverse order
                    for (var i = pastStackElement.editOperations.length - 1; i >= 0; i--) {
                        pastStackElement.editOperations[i] = {
                            operations: this.model.applyEdits(pastStackElement.editOperations[i].operations)
                        };
                    }
                }
                catch (e) {
                    this.clear();
                    return null;
                }
                this.future.push(pastStackElement);
                return {
                    selections: pastStackElement.beforeCursorState,
                    recordedVersionId: pastStackElement.beforeVersionId
                };
            }
            return null;
        };
        EditStack.prototype.redo = function () {
            if (this.future.length > 0) {
                if (this.currentOpenStackElement) {
                    throw new Error('How is this possible?');
                }
                var futureStackElement = this.future.pop();
                try {
                    // Apply all operations
                    for (var i = 0; i < futureStackElement.editOperations.length; i++) {
                        futureStackElement.editOperations[i] = {
                            operations: this.model.applyEdits(futureStackElement.editOperations[i].operations)
                        };
                    }
                }
                catch (e) {
                    this.clear();
                    return null;
                }
                this.past.push(futureStackElement);
                return {
                    selections: futureStackElement.afterCursorState,
                    recordedVersionId: futureStackElement.afterVersionId
                };
            }
            return null;
        };
        return EditStack;
    }());
    exports.EditStack = EditStack;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[497/*vs/editor/common/model/indentRanges*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    var IndentRange = (function () {
        function IndentRange(startLineNumber, endLineNumber, indent) {
            this.startLineNumber = startLineNumber;
            this.endLineNumber = endLineNumber;
            this.indent = indent;
        }
        IndentRange.deepCloneArr = function (indentRanges) {
            var result = [];
            for (var i = 0, len = indentRanges.length; i < len; i++) {
                var r = indentRanges[i];
                result[i] = new IndentRange(r.startLineNumber, r.endLineNumber, r.indent);
            }
            return result;
        };
        return IndentRange;
    }());
    exports.IndentRange = IndentRange;
    function computeRanges(model, minimumRangeSize) {
        if (minimumRangeSize === void 0) { minimumRangeSize = 1; }
        var result = [];
        var previousRegions = [];
        previousRegions.push({ indent: -1, line: model.getLineCount() + 1 }); // sentinel, to make sure there's at least one entry
        for (var line = model.getLineCount(); line > 0; line--) {
            var indent = model.getIndentLevel(line);
            if (indent === -1) {
                continue; // only whitespace
            }
            var previous = previousRegions[previousRegions.length - 1];
            if (previous.indent > indent) {
                // discard all regions with larger indent
                do {
                    previousRegions.pop();
                    previous = previousRegions[previousRegions.length - 1];
                } while (previous.indent > indent);
                // new folding range
                var endLineNumber = previous.line - 1;
                if (endLineNumber - line >= minimumRangeSize) {
                    result.push(new IndentRange(line, endLineNumber, indent));
                }
            }
            if (previous.indent === indent) {
                previous.line = line;
            }
            else {
                // new region with a bigger indent
                previousRegions.push({ indent: indent, line: line });
            }
        }
        return result.reverse();
    }
    exports.computeRanges = computeRanges;
});

define(__m[498/*vs/editor/common/model/indentationGuesser*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Compute the diff in spaces between two line's indentation.
     */
    function spacesDiff(a, aLength, b, bLength) {
        // This can go both ways (e.g.):
        //  - a: "\t"
        //  - b: "\t    "
        //  => This should count 1 tab and 4 spaces
        var i;
        for (i = 0; i < aLength && i < bLength; i++) {
            var aCharCode = a.charCodeAt(i);
            var bCharCode = b.charCodeAt(i);
            if (aCharCode !== bCharCode) {
                break;
            }
        }
        var aSpacesCnt = 0, aTabsCount = 0;
        for (var j = i; j < aLength; j++) {
            var aCharCode = a.charCodeAt(j);
            if (aCharCode === 32 /* Space */) {
                aSpacesCnt++;
            }
            else {
                aTabsCount++;
            }
        }
        var bSpacesCnt = 0, bTabsCount = 0;
        for (var j = i; j < bLength; j++) {
            var bCharCode = b.charCodeAt(j);
            if (bCharCode === 32 /* Space */) {
                bSpacesCnt++;
            }
            else {
                bTabsCount++;
            }
        }
        if (aSpacesCnt > 0 && aTabsCount > 0) {
            return 0;
        }
        if (bSpacesCnt > 0 && bTabsCount > 0) {
            return 0;
        }
        var tabsDiff = Math.abs(aTabsCount - bTabsCount);
        var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
        if (tabsDiff === 0) {
            return spacesDiff;
        }
        if (spacesDiff % tabsDiff === 0) {
            return spacesDiff / tabsDiff;
        }
        return 0;
    }
    function guessIndentation(lines, defaultTabSize, defaultInsertSpaces) {
        var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
        var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
        var previousLineText = ''; // content of latest line that contained non-whitespace chars
        var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
        var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8]; // limit guesses for `tabSize` to 2, 4, 6 or 8.
        var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(2,4,6,8) = 8
        var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
        for (var i = 0, len = lines.length; i < len; i++) {
            var currentLineText = lines[i];
            var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
            var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
            var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
            var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
            for (var j = 0, lenJ = currentLineText.length; j < lenJ; j++) {
                var charCode = currentLineText.charCodeAt(j);
                if (charCode === 9 /* Tab */) {
                    currentLineTabsCount++;
                }
                else if (charCode === 32 /* Space */) {
                    currentLineSpacesCount++;
                }
                else {
                    // Hit non whitespace character on this line
                    currentLineHasContent = true;
                    currentLineIndentation = j;
                    break;
                }
            }
            // Ignore empty or only whitespace lines
            if (!currentLineHasContent) {
                continue;
            }
            if (currentLineTabsCount > 0) {
                linesIndentedWithTabsCount++;
            }
            else if (currentLineSpacesCount > 1) {
                linesIndentedWithSpacesCount++;
            }
            var currentSpacesDiff = spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation);
            if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
                spacesDiffCount[currentSpacesDiff]++;
            }
            previousLineText = currentLineText;
            previousLineIndentation = currentLineIndentation;
        }
        // Take into account the last line as well
        var deltaSpacesCount = spacesDiff(previousLineText, previousLineIndentation, '', 0);
        if (deltaSpacesCount <= MAX_ALLOWED_TAB_SIZE_GUESS) {
            spacesDiffCount[deltaSpacesCount]++;
        }
        var insertSpaces = defaultInsertSpaces;
        if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
            insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
        }
        var tabSize = defaultTabSize;
        var tabSizeScore = (insertSpaces ? 0 : 0.1 * lines.length);
        // console.log("score threshold: " + tabSizeScore);
        ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {
            var possibleTabSizeScore = spacesDiffCount[possibleTabSize];
            if (possibleTabSizeScore > tabSizeScore) {
                tabSizeScore = possibleTabSizeScore;
                tabSize = possibleTabSize;
            }
        });
        // console.log('--------------------------');
        // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
        // console.log('spacesDiffCount: ' + spacesDiffCount);
        // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
        return {
            insertSpaces: insertSpaces,
            tabSize: tabSize
        };
    }
    exports.guessIndentation = guessIndentation;
});

define(__m[499/*vs/editor/common/model/tokenIterator*/], __M([1/*require*/,0/*exports*/,16/*vs/editor/common/core/position*/]), function (require, exports, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenInfo = (function () {
        function TokenInfo(actual, lineNumber) {
            this._actual = actual;
            this.lineNumber = lineNumber;
            this.startColumn = this._actual.startOffset + 1;
            this.endColumn = this._actual.endOffset + 1;
            this.type = this._actual.tokenType;
        }
        return TokenInfo;
    }());
    function findClosestNonEmptyLine(model, position) {
        var lineNumber = position.lineNumber;
        if (model.getLineMaxColumn(lineNumber) !== 1) {
            return position;
        }
        var lineCount = model.getLineCount();
        // we need to go up or down
        var distance = 1;
        while (true) {
            var aboveLineNumber = lineNumber - distance;
            var belowLineNumber = lineNumber + distance;
            if (aboveLineNumber < 1 && belowLineNumber > lineCount) {
                // No more lines above or below
                break;
            }
            if (aboveLineNumber >= 1) {
                var aboveMaxColumn = model.getLineMaxColumn(aboveLineNumber);
                if (aboveMaxColumn !== 1) {
                    // bingo!
                    return new position_1.Position(aboveLineNumber, aboveMaxColumn);
                }
            }
            if (belowLineNumber <= lineCount) {
                var belowMaxColumn = model.getLineMaxColumn(belowLineNumber);
                if (belowMaxColumn !== 1) {
                    // bingo!
                    return new position_1.Position(belowLineNumber, 1);
                }
            }
            distance++;
        }
        return null;
    }
    var TokenIterator = (function () {
        function TokenIterator(model, position) {
            this._model = model;
            this._lineCount = this._model.getLineCount();
            this._prev = null;
            this._next = null;
            position = findClosestNonEmptyLine(model, position);
            if (position) {
                var lineTokens = this._model.getLineTokens(position.lineNumber);
                var currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                if (currentToken) {
                    this._prev = this._next = new TokenInfo(currentToken, position.lineNumber);
                }
            }
        }
        TokenIterator.prototype._advanceNext = function () {
            if (!this._next) {
                return;
            }
            var lineNumber = this._next.lineNumber;
            var next = this._next._actual.next();
            while (!next && lineNumber < this._lineCount) {
                lineNumber++;
                var currentLineTokens = this._model.getLineTokens(lineNumber);
                next = currentLineTokens.firstToken();
            }
            this._prev = this._next;
            if (next) {
                this._next = new TokenInfo(next, lineNumber);
            }
            else {
                this._next = null;
            }
        };
        TokenIterator.prototype._advancePrev = function () {
            if (!this._prev) {
                return;
            }
            var lineNumber = this._prev.lineNumber;
            var prev = this._prev._actual.prev();
            while (!prev && lineNumber > 1) {
                lineNumber--;
                var currentLineTokens = this._model.getLineTokens(lineNumber);
                prev = currentLineTokens.lastToken();
            }
            this._next = this._prev;
            if (prev) {
                this._prev = new TokenInfo(prev, lineNumber);
            }
            else {
                this._prev = null;
            }
        };
        TokenIterator.prototype.hasNext = function () {
            return this._next !== null;
        };
        TokenIterator.prototype.next = function () {
            var result = this._next;
            this._advanceNext();
            return result;
        };
        TokenIterator.prototype.hasPrev = function () {
            return this._prev !== null;
        };
        TokenIterator.prototype.prev = function () {
            var result = this._prev;
            this._advancePrev();
            return result;
        };
        TokenIterator.prototype._invalidate = function () {
            // replace all public functions with errors
            var errorFn = function () {
                throw new Error('iteration isn\'t valid anymore');
            };
            this.hasNext = errorFn;
            this.next = errorFn;
            this.hasPrev = errorFn;
            this.prev = errorFn;
        };
        return TokenIterator;
    }());
    exports.TokenIterator = TokenIterator;
});

define(__m[141/*vs/editor/common/model/tokensBinaryEncoding*/], __M([1/*require*/,0/*exports*/,77/*vs/editor/common/core/viewLineToken*/]), function (require, exports, viewLineToken_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenMetadata = (function () {
        function TokenMetadata() {
        }
        TokenMetadata.toBinaryStr = function (metadata) {
            var r = metadata.toString(2);
            while (r.length < 32) {
                r = '0' + r;
            }
            return r;
        };
        TokenMetadata.printMetadata = function (metadata) {
            var languageId = TokenMetadata.getLanguageId(metadata);
            var tokenType = TokenMetadata.getTokenType(metadata);
            var fontStyle = TokenMetadata.getFontStyle(metadata);
            var foreground = TokenMetadata.getForeground(metadata);
            var background = TokenMetadata.getBackground(metadata);
            console.log({
                languageId: languageId,
                tokenType: tokenType,
                fontStyle: fontStyle,
                foreground: foreground,
                background: background,
            });
        };
        TokenMetadata.getLanguageId = function (metadata) {
            return (metadata & 255 /* LANGUAGEID_MASK */) >>> 0 /* LANGUAGEID_OFFSET */;
        };
        TokenMetadata.getTokenType = function (metadata) {
            return (metadata & 1792 /* TOKEN_TYPE_MASK */) >>> 8 /* TOKEN_TYPE_OFFSET */;
        };
        TokenMetadata.getFontStyle = function (metadata) {
            return (metadata & 14336 /* FONT_STYLE_MASK */) >>> 11 /* FONT_STYLE_OFFSET */;
        };
        TokenMetadata.getForeground = function (metadata) {
            return (metadata & 8372224 /* FOREGROUND_MASK */) >>> 14 /* FOREGROUND_OFFSET */;
        };
        TokenMetadata.getBackground = function (metadata) {
            return (metadata & 4286578688 /* BACKGROUND_MASK */) >>> 23 /* BACKGROUND_OFFSET */;
        };
        TokenMetadata._getClassNameFromMetadata = function (metadata) {
            var foreground = this.getForeground(metadata);
            var className = 'mtk' + foreground;
            var fontStyle = this.getFontStyle(metadata);
            if (fontStyle & 1 /* Italic */) {
                className += ' mtki';
            }
            if (fontStyle & 2 /* Bold */) {
                className += ' mtkb';
            }
            if (fontStyle & 4 /* Underline */) {
                className += ' mtku';
            }
            return className;
        };
        TokenMetadata.inflateArr = function (tokens, lineLength) {
            var result = [];
            for (var i = 0, len = (tokens.length >>> 1); i < len; i++) {
                var endOffset = (i + 1 < len ? tokens[((i + 1) << 1)] : lineLength);
                var metadata = tokens[(i << 1) + 1];
                result[i] = new viewLineToken_1.ViewLineToken(endOffset, this._getClassNameFromMetadata(metadata));
            }
            return result;
        };
        TokenMetadata.sliceAndInflate = function (tokens, startOffset, endOffset, deltaOffset, lineLength) {
            var tokenIndex = this.findIndexInSegmentsArray(tokens, startOffset);
            var result = [], resultLen = 0;
            for (var i = tokenIndex, len = (tokens.length >>> 1); i < len; i++) {
                var tokenStartOffset = tokens[(i << 1)];
                if (tokenStartOffset >= endOffset) {
                    break;
                }
                var tokenEndOffset = (i + 1 < len ? tokens[((i + 1) << 1)] : lineLength);
                var newEndOffset = tokenEndOffset - startOffset + deltaOffset;
                var metadata = tokens[(i << 1) + 1];
                result[resultLen++] = new viewLineToken_1.ViewLineToken(newEndOffset, this._getClassNameFromMetadata(metadata));
            }
            return result;
        };
        TokenMetadata.findIndexInSegmentsArray = function (tokens, desiredIndex) {
            var low = 0;
            var high = (tokens.length >>> 1) - 1;
            while (low < high) {
                var mid = low + Math.ceil((high - low) / 2);
                var value = tokens[(mid << 1)];
                if (value > desiredIndex) {
                    high = mid - 1;
                }
                else {
                    low = mid;
                }
            }
            return low;
        };
        return TokenMetadata;
    }());
    exports.TokenMetadata = TokenMetadata;
});

define(__m[76/*vs/editor/common/core/lineTokens*/], __M([1/*require*/,0/*exports*/,141/*vs/editor/common/model/tokensBinaryEncoding*/]), function (require, exports, tokensBinaryEncoding_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex)\b/;
    function toStandardTokenType(tokenType) {
        var m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);
        if (!m) {
            return 0 /* Other */;
        }
        switch (m[1]) {
            case 'comment':
                return 1 /* Comment */;
            case 'string':
                return 2 /* String */;
            case 'regex':
                return 4 /* RegEx */;
        }
        throw new Error('Unexpected match for standard token type!');
    }
    exports.toStandardTokenType = toStandardTokenType;
    var LineToken = (function () {
        function LineToken(colorMap, source, tokenIndex, tokenCount, startOffset, endOffset, metadata) {
            this._colorMap = colorMap;
            this._source = source;
            this._tokenIndex = tokenIndex;
            this._metadata = metadata;
            this.startOffset = startOffset;
            this.endOffset = endOffset;
            this.hasPrev = (this._tokenIndex > 0);
            this.hasNext = (this._tokenIndex + 1 < tokenCount);
        }
        Object.defineProperty(LineToken.prototype, "languageId", {
            get: function () {
                return tokensBinaryEncoding_1.TokenMetadata.getLanguageId(this._metadata);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "tokenType", {
            get: function () {
                return tokensBinaryEncoding_1.TokenMetadata.getTokenType(this._metadata);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "fontStyle", {
            get: function () {
                return tokensBinaryEncoding_1.TokenMetadata.getFontStyle(this._metadata);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "foregroundId", {
            get: function () {
                return tokensBinaryEncoding_1.TokenMetadata.getForeground(this._metadata);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "foreground", {
            get: function () {
                return this._colorMap[this.foregroundId];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "backgroundId", {
            get: function () {
                return tokensBinaryEncoding_1.TokenMetadata.getBackground(this._metadata);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LineToken.prototype, "background", {
            get: function () {
                return this._colorMap[this.backgroundId];
            },
            enumerable: true,
            configurable: true
        });
        LineToken.prototype.prev = function () {
            if (!this.hasPrev) {
                return null;
            }
            return this._source.tokenAt(this._tokenIndex - 1);
        };
        LineToken.prototype.next = function () {
            if (!this.hasNext) {
                return null;
            }
            return this._source.tokenAt(this._tokenIndex + 1);
        };
        return LineToken;
    }());
    exports.LineToken = LineToken;
    var LineTokens = (function () {
        function LineTokens(colorMap, tokens, text) {
            this._colorMap = colorMap;
            this._tokens = tokens;
            this._tokensCount = (this._tokens.length >>> 1);
            this._text = text;
            this._textLength = this._text.length;
        }
        LineTokens.prototype.getTokenCount = function () {
            return this._tokensCount;
        };
        LineTokens.prototype.getLineContent = function () {
            return this._text;
        };
        LineTokens.prototype.getLineLength = function () {
            return this._textLength;
        };
        LineTokens.prototype.getTokenStartOffset = function (tokenIndex) {
            return this._tokens[(tokenIndex << 1)];
        };
        LineTokens.prototype.getLanguageId = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return tokensBinaryEncoding_1.TokenMetadata.getLanguageId(metadata);
        };
        LineTokens.prototype.getStandardTokenType = function (tokenIndex) {
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return tokensBinaryEncoding_1.TokenMetadata.getTokenType(metadata);
        };
        LineTokens.prototype.getTokenEndOffset = function (tokenIndex) {
            if (tokenIndex + 1 < this._tokensCount) {
                return this._tokens[(tokenIndex + 1) << 1];
            }
            return this._textLength;
        };
        /**
         * Find the token containing offset `offset`.
         * ```
         *   For example, with the following tokens [0, 5), [5, 9), [9, infinity)
         *   Searching for 0, 1, 2, 3 or 4 will return 0.
         *   Searching for 5, 6, 7 or 8 will return 1.
         *   Searching for 9, 10, 11, ... will return 2.
         * ```
         * @param offset The search offset
         * @return The index of the token containing the offset.
         */
        LineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return tokensBinaryEncoding_1.TokenMetadata.findIndexInSegmentsArray(this._tokens, offset);
        };
        LineTokens.prototype.findTokenAtOffset = function (offset) {
            var tokenIndex = this.findTokenIndexAtOffset(offset);
            return this.tokenAt(tokenIndex);
        };
        LineTokens.prototype.tokenAt = function (tokenIndex) {
            var startOffset = this._tokens[(tokenIndex << 1)];
            var endOffset;
            if (tokenIndex + 1 < this._tokensCount) {
                endOffset = this._tokens[(tokenIndex + 1) << 1];
            }
            else {
                endOffset = this._textLength;
            }
            var metadata = this._tokens[(tokenIndex << 1) + 1];
            return new LineToken(this._colorMap, this, tokenIndex, this._tokensCount, startOffset, endOffset, metadata);
        };
        LineTokens.prototype.firstToken = function () {
            if (this._textLength === 0) {
                return null;
            }
            return this.tokenAt(0);
        };
        LineTokens.prototype.lastToken = function () {
            if (this._textLength === 0) {
                return null;
            }
            return this.tokenAt(this._tokensCount - 1);
        };
        LineTokens.prototype.inflate = function () {
            return tokensBinaryEncoding_1.TokenMetadata.inflateArr(this._tokens, this._textLength);
        };
        LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaOffset) {
            return tokensBinaryEncoding_1.TokenMetadata.sliceAndInflate(this._tokens, startOffset, endOffset, deltaOffset, this._textLength);
        };
        return LineTokens;
    }());
    exports.LineTokens = LineTokens;
});

define(__m[75/*vs/editor/common/model/modelLine*/], __M([1/*require*/,0/*exports*/,76/*vs/editor/common/core/lineTokens*/,16/*vs/editor/common/core/position*/]), function (require, exports, lineTokens_1, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineMarker = (function () {
        function LineMarker(id, internalDecorationId, position, stickToPreviousCharacter) {
            this.id = id;
            this.internalDecorationId = internalDecorationId;
            this.position = position;
            this.stickToPreviousCharacter = stickToPreviousCharacter;
        }
        LineMarker.prototype.toString = function () {
            return '{\'' + this.id + '\';' + this.position.toString() + ',' + this.stickToPreviousCharacter + '}';
        };
        LineMarker.prototype.updateLineNumber = function (markersTracker, lineNumber) {
            if (this.position.lineNumber === lineNumber) {
                return;
            }
            markersTracker.addChangedMarker(this);
            this.position = new position_1.Position(lineNumber, this.position.column);
        };
        LineMarker.prototype.updateColumn = function (markersTracker, column) {
            if (this.position.column === column) {
                return;
            }
            markersTracker.addChangedMarker(this);
            this.position = new position_1.Position(this.position.lineNumber, column);
        };
        LineMarker.prototype.updatePosition = function (markersTracker, position) {
            if (this.position.lineNumber === position.lineNumber && this.position.column === position.column) {
                return;
            }
            markersTracker.addChangedMarker(this);
            this.position = position;
        };
        LineMarker.prototype.setPosition = function (position) {
            this.position = position;
        };
        LineMarker.compareMarkers = function (a, b) {
            if (a.position.column === b.position.column) {
                return (a.stickToPreviousCharacter ? 0 : 1) - (b.stickToPreviousCharacter ? 0 : 1);
            }
            return a.position.column - b.position.column;
        };
        return LineMarker;
    }());
    exports.LineMarker = LineMarker;
    var MarkersTracker = (function () {
        function MarkersTracker() {
            this._changedDecorations = [];
            this._changedDecorationsLen = 0;
        }
        MarkersTracker.prototype.addChangedMarker = function (marker) {
            var internalDecorationId = marker.internalDecorationId;
            if (internalDecorationId !== 0) {
                this._changedDecorations[this._changedDecorationsLen++] = internalDecorationId;
            }
        };
        MarkersTracker.prototype.getDecorationIds = function () {
            return this._changedDecorations;
        };
        return MarkersTracker;
    }());
    exports.MarkersTracker = MarkersTracker;
    var NO_OP_TOKENS_ADJUSTER = {
        adjust: function () { },
        finish: function () { }
    };
    var NO_OP_MARKERS_ADJUSTER = {
        adjustDelta: function () { },
        adjustSet: function () { },
        finish: function () { }
    };
    var MarkerMoveSemantics;
    (function (MarkerMoveSemantics) {
        MarkerMoveSemantics[MarkerMoveSemantics["MarkerDefined"] = 0] = "MarkerDefined";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceMove"] = 1] = "ForceMove";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceStay"] = 2] = "ForceStay";
    })(MarkerMoveSemantics || (MarkerMoveSemantics = {}));
    /**
     * Returns:
     *  - 0 => the line consists of whitespace
     *  - otherwise => the indent level is returned value - 1
     */
    function computePlusOneIndentLevel(line, tabSize) {
        var indent = 0;
        var i = 0;
        var len = line.length;
        while (i < len) {
            var chCode = line.charCodeAt(i);
            if (chCode === 32 /* Space */) {
                indent++;
            }
            else if (chCode === 9 /* Tab */) {
                indent = indent - indent % tabSize + tabSize;
            }
            else {
                break;
            }
            i++;
        }
        if (i === len) {
            return 0; // line only consists of whitespace
        }
        return indent + 1;
    }
    var ModelLine = (function () {
        function ModelLine(lineNumber, text, tabSize) {
            this._lineNumber = lineNumber | 0;
            this._metadata = 0;
            this._setText(text, tabSize);
            this._state = null;
            this._lineTokens = null;
            this._markers = null;
        }
        Object.defineProperty(ModelLine.prototype, "lineNumber", {
            get: function () { return this._lineNumber; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelLine.prototype, "text", {
            get: function () { return this._text; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelLine.prototype, "isInvalid", {
            get: function () {
                return (this._metadata & 0x00000001) ? true : false;
            },
            set: function (value) {
                this._metadata = (this._metadata & 0xfffffffe) | (value ? 1 : 0);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns:
         *  - -1 => the line consists of whitespace
         *  - otherwise => the indent level is returned value
         */
        ModelLine.prototype.getIndentLevel = function () {
            return ((this._metadata & 0xfffffffe) >> 1) - 1;
        };
        ModelLine.prototype._setPlusOneIndentLevel = function (value) {
            this._metadata = (this._metadata & 0x00000001) | ((value & 0xefffffff) << 1);
        };
        ModelLine.prototype.updateTabSize = function (tabSize) {
            if (tabSize === 0) {
                // don't care mark
                this._metadata = this._metadata & 0x00000001;
            }
            else {
                this._setPlusOneIndentLevel(computePlusOneIndentLevel(this._text, tabSize));
            }
        };
        // --- BEGIN STATE
        ModelLine.prototype.resetTokenizationState = function () {
            this._state = null;
            this._lineTokens = null;
        };
        ModelLine.prototype.setState = function (state) {
            this._state = state;
        };
        ModelLine.prototype.getState = function () {
            return this._state || null;
        };
        // --- END STATE
        // --- BEGIN TOKENS
        ModelLine._getDefaultMetadata = function (topLevelLanguageId) {
            return ((topLevelLanguageId << 0 /* LANGUAGEID_OFFSET */)
                | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
                | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
                | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
                | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        };
        ModelLine.prototype.setTokens = function (topLevelLanguageId, tokens) {
            if (!tokens || tokens.length === 0) {
                this._lineTokens = null;
                return;
            }
            if (tokens.length === 2) {
                // there is one token
                if (tokens[0] === 0 && tokens[1] === ModelLine._getDefaultMetadata(topLevelLanguageId)) {
                    this._lineTokens = null;
                    return;
                }
            }
            this._lineTokens = tokens.buffer;
        };
        ModelLine.prototype.getTokens = function (topLevelLanguageId, colorMap) {
            var rawLineTokens = this._lineTokens;
            if (rawLineTokens) {
                return new lineTokens_1.LineTokens(colorMap, new Uint32Array(rawLineTokens), this._text);
            }
            var lineTokens = new Uint32Array(2);
            lineTokens[0] = 0;
            lineTokens[1] = ModelLine._getDefaultMetadata(topLevelLanguageId);
            return new lineTokens_1.LineTokens(colorMap, lineTokens, this._text);
        };
        // --- END TOKENS
        ModelLine.prototype._createTokensAdjuster = function () {
            var _this = this;
            if (!this._lineTokens) {
                // This line does not have real tokens, so there is nothing to adjust
                return NO_OP_TOKENS_ADJUSTER;
            }
            var lineTokens = new Uint32Array(this._lineTokens);
            var tokensLength = (lineTokens.length >>> 1);
            var tokenIndex = 0;
            var tokenStartOffset = 0;
            var removeTokensCount = 0;
            var adjust = function (toColumn, delta, minimumAllowedColumn) {
                // console.log(`------------------------------------------------------------------`);
                // console.log(`before call: tokenIndex: ${tokenIndex}: ${lineTokens}`);
                // console.log(`adjustTokens: ${toColumn} with delta: ${delta} and [${minimumAllowedColumn}]`);
                // console.log(`tokenStartOffset: ${tokenStartOffset}`);
                var minimumAllowedIndex = minimumAllowedColumn - 1;
                while (tokenStartOffset < toColumn && tokenIndex < tokensLength) {
                    if (tokenStartOffset > 0 && delta !== 0) {
                        // adjust token's `startIndex` by `delta`
                        var newTokenStartOffset = Math.max(minimumAllowedIndex, tokenStartOffset + delta);
                        lineTokens[(tokenIndex << 1)] = newTokenStartOffset;
                        // console.log(` * adjusted token start offset for token at ${tokenIndex}: ${newTokenStartOffset}`);
                        if (delta < 0) {
                            var tmpTokenIndex = tokenIndex;
                            while (tmpTokenIndex > 0) {
                                var prevTokenStartOffset = lineTokens[((tmpTokenIndex - 1) << 1)];
                                if (prevTokenStartOffset >= newTokenStartOffset) {
                                    if (prevTokenStartOffset !== 4294967295 /* MAX_UINT_32 */) {
                                        // console.log(` * marking for deletion token at ${tmpTokenIndex - 1}`);
                                        lineTokens[((tmpTokenIndex - 1) << 1)] = 4294967295 /* MAX_UINT_32 */;
                                        removeTokensCount++;
                                    }
                                    tmpTokenIndex--;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                    tokenIndex++;
                    if (tokenIndex < tokensLength) {
                        tokenStartOffset = lineTokens[(tokenIndex << 1)];
                    }
                }
                // console.log(`after call: tokenIndex: ${tokenIndex}: ${lineTokens}`);
            };
            var finish = function (delta, lineTextLength) {
                adjust(1073741824 /* MAX_SAFE_SMALL_INTEGER */, delta, 1);
                // Mark overflowing tokens for deletion & delete marked tokens
                _this._deleteMarkedTokens(_this._markOverflowingTokensForDeletion(removeTokensCount, lineTextLength));
            };
            return {
                adjust: adjust,
                finish: finish
            };
        };
        ModelLine.prototype._markOverflowingTokensForDeletion = function (removeTokensCount, lineTextLength) {
            if (!this._lineTokens) {
                return removeTokensCount;
            }
            var lineTokens = new Uint32Array(this._lineTokens);
            var tokensLength = (lineTokens.length >>> 1);
            if (removeTokensCount + 1 === tokensLength) {
                // no more removing, cannot end up without any tokens for mode transition reasons
                return removeTokensCount;
            }
            for (var tokenIndex = tokensLength - 1; tokenIndex > 0; tokenIndex--) {
                var tokenStartOffset = lineTokens[(tokenIndex << 1)];
                if (tokenStartOffset < lineTextLength) {
                    // valid token => stop iterating
                    return removeTokensCount;
                }
                // this token now overflows the text => mark it for removal
                if (tokenStartOffset !== 4294967295 /* MAX_UINT_32 */) {
                    // console.log(` * marking for deletion token at ${tokenIndex}`);
                    lineTokens[(tokenIndex << 1)] = 4294967295 /* MAX_UINT_32 */;
                    removeTokensCount++;
                    if (removeTokensCount + 1 === tokensLength) {
                        // no more removing, cannot end up without any tokens for mode transition reasons
                        return removeTokensCount;
                    }
                }
            }
            return removeTokensCount;
        };
        ModelLine.prototype._deleteMarkedTokens = function (removeTokensCount) {
            if (removeTokensCount === 0) {
                return;
            }
            var lineTokens = new Uint32Array(this._lineTokens);
            var tokensLength = (lineTokens.length >>> 1);
            var newTokens = new Uint32Array(((tokensLength - removeTokensCount) << 1)), newTokenIdx = 0;
            for (var i = 0; i < tokensLength; i++) {
                var startOffset = lineTokens[(i << 1)];
                if (startOffset === 4294967295 /* MAX_UINT_32 */) {
                    // marked for deletion
                    continue;
                }
                var metadata = lineTokens[(i << 1) + 1];
                newTokens[newTokenIdx++] = startOffset;
                newTokens[newTokenIdx++] = metadata;
            }
            this._lineTokens = newTokens.buffer;
        };
        ModelLine.prototype._setText = function (text, tabSize) {
            this._text = text;
            if (tabSize === 0) {
                // don't care mark
                this._metadata = this._metadata & 0x00000001;
            }
            else {
                this._setPlusOneIndentLevel(computePlusOneIndentLevel(text, tabSize));
            }
        };
        // private _printMarkers(): string {
        // 	if (!this._markers) {
        // 		return '[]';
        // 	}
        // 	if (this._markers.length === 0) {
        // 		return '[]';
        // 	}
        // 	var markers = this._markers;
        // 	var printMarker = (m:ILineMarker) => {
        // 		if (m.stickToPreviousCharacter) {
        // 			return '|' + m.column;
        // 		}
        // 		return m.column + '|';
        // 	};
        // 	return '[' + markers.map(printMarker).join(', ') + ']';
        // }
        ModelLine.prototype._createMarkersAdjuster = function (markersTracker) {
            if (!this._markers) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            if (this._markers.length === 0) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            this._markers.sort(LineMarker.compareMarkers);
            var markers = this._markers;
            var markersLength = markers.length;
            var markersIndex = 0;
            var marker = markers[markersIndex];
            // console.log('------------- INITIAL MARKERS: ' + this._printMarkers());
            var adjustMarkerBeforeColumn = function (toColumn, moveSemantics) {
                if (marker.position.column < toColumn) {
                    return true;
                }
                if (marker.position.column > toColumn) {
                    return false;
                }
                if (moveSemantics === 1 /* ForceMove */) {
                    return false;
                }
                if (moveSemantics === 2 /* ForceStay */) {
                    return true;
                }
                return marker.stickToPreviousCharacter;
            };
            var adjustDelta = function (toColumn, delta, minimumAllowedColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustDelta called: toColumn: ' + toColumn + ', delta: ' + delta + ', minimumAllowedColumn: ' + minimumAllowedColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    if (delta !== 0) {
                        var newColumn = Math.max(minimumAllowedColumn, marker.position.column + delta);
                        marker.updateColumn(markersTracker, newColumn);
                    }
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var adjustSet = function (toColumn, newColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustSet called: toColumn: ' + toColumn + ', newColumn: ' + newColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    marker.updateColumn(markersTracker, newColumn);
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var finish = function (delta, lineTextLength) {
                adjustDelta(1073741824 /* MAX_SAFE_SMALL_INTEGER */, delta, 1, 0 /* MarkerDefined */);
                // console.log('------------- FINAL MARKERS: ' + this._printMarkers());
            };
            return {
                adjustDelta: adjustDelta,
                adjustSet: adjustSet,
                finish: finish
            };
        };
        ModelLine.prototype.applyEdits = function (markersTracker, edits, tabSize) {
            var deltaColumn = 0;
            var resultText = this._text;
            var tokensAdjuster = this._createTokensAdjuster();
            var markersAdjuster = this._createMarkersAdjuster(markersTracker);
            for (var i = 0, len = edits.length; i < len; i++) {
                var edit = edits[i];
                // console.log();
                // console.log('=============================');
                // console.log('EDIT #' + i + ' [ ' + edit.startColumn + ' -> ' + edit.endColumn + ' ] : <<<' + edit.text + '>>>, forceMoveMarkers: ' + edit.forceMoveMarkers);
                // console.log('deltaColumn: ' + deltaColumn);
                var startColumn = deltaColumn + edit.startColumn;
                var endColumn = deltaColumn + edit.endColumn;
                var deletingCnt = endColumn - startColumn;
                var insertingCnt = edit.text.length;
                // Adjust tokens & markers before this edit
                // console.log('Adjust tokens & markers before this edit');
                tokensAdjuster.adjust(edit.startColumn - 1, deltaColumn, 1);
                markersAdjuster.adjustDelta(edit.startColumn, deltaColumn, 1, edit.forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > 0 ? 2 /* ForceStay */ : 0 /* MarkerDefined */));
                // Adjust tokens & markers for the common part of this edit
                var commonLength = Math.min(deletingCnt, insertingCnt);
                if (commonLength > 0) {
                    // console.log('Adjust tokens & markers for the common part of this edit');
                    tokensAdjuster.adjust(edit.startColumn - 1 + commonLength, deltaColumn, startColumn);
                    if (!edit.forceMoveMarkers) {
                        markersAdjuster.adjustDelta(edit.startColumn + commonLength, deltaColumn, startColumn, edit.forceMoveMarkers ? 1 /* ForceMove */ : (deletingCnt > insertingCnt ? 2 /* ForceStay */ : 0 /* MarkerDefined */));
                    }
                }
                // Perform the edit & update `deltaColumn`
                resultText = resultText.substring(0, startColumn - 1) + edit.text + resultText.substring(endColumn - 1);
                deltaColumn += insertingCnt - deletingCnt;
                // Adjust tokens & markers inside this edit
                // console.log('Adjust tokens & markers inside this edit');
                tokensAdjuster.adjust(edit.endColumn, deltaColumn, startColumn);
                markersAdjuster.adjustSet(edit.endColumn, startColumn + insertingCnt, edit.forceMoveMarkers ? 1 /* ForceMove */ : 0 /* MarkerDefined */);
            }
            // Wrap up tokens & markers; adjust remaining if needed
            tokensAdjuster.finish(deltaColumn, resultText.length);
            markersAdjuster.finish(deltaColumn, resultText.length);
            // Save the resulting text
            this._setText(resultText, tabSize);
            return deltaColumn;
        };
        ModelLine.prototype.split = function (markersTracker, splitColumn, forceMoveMarkers, tabSize) {
            // console.log('--> split @ ' + splitColumn + '::: ' + this._printMarkers());
            var myText = this._text.substring(0, splitColumn - 1);
            var otherText = this._text.substring(splitColumn - 1);
            var otherMarkers = null;
            if (this._markers) {
                this._markers.sort(LineMarker.compareMarkers);
                for (var i = 0, len = this._markers.length; i < len; i++) {
                    var marker = this._markers[i];
                    if (marker.position.column > splitColumn
                        || (marker.position.column === splitColumn
                            && (forceMoveMarkers
                                || !marker.stickToPreviousCharacter))) {
                        var myMarkers = this._markers.slice(0, i);
                        otherMarkers = this._markers.slice(i);
                        this._markers = myMarkers;
                        break;
                    }
                }
                if (otherMarkers) {
                    for (var i = 0, len = otherMarkers.length; i < len; i++) {
                        var marker = otherMarkers[i];
                        marker.updateColumn(markersTracker, marker.position.column - (splitColumn - 1));
                    }
                }
            }
            this._setText(myText, tabSize);
            // Mark overflowing tokens for deletion & delete marked tokens
            this._deleteMarkedTokens(this._markOverflowingTokensForDeletion(0, this._text.length));
            var otherLine = new ModelLine(this._lineNumber + 1, otherText, tabSize);
            if (otherMarkers) {
                otherLine.addMarkers(otherMarkers);
            }
            return otherLine;
        };
        ModelLine.prototype.append = function (markersTracker, other, tabSize) {
            // console.log('--> append: THIS :: ' + this._printMarkers());
            // console.log('--> append: OTHER :: ' + this._printMarkers());
            var thisTextLength = this._text.length;
            this._setText(this._text + other._text, tabSize);
            var otherRawTokens = other._lineTokens;
            if (otherRawTokens) {
                // Other has real tokens
                var otherTokens = new Uint32Array(otherRawTokens);
                // Adjust other tokens
                if (thisTextLength > 0) {
                    for (var i = 0, len = (otherTokens.length >>> 1); i < len; i++) {
                        otherTokens[(i << 1)] = otherTokens[(i << 1)] + thisTextLength;
                    }
                }
                // Append other tokens
                var myRawTokens = this._lineTokens;
                if (myRawTokens) {
                    // I have real tokens
                    var myTokens = new Uint32Array(myRawTokens);
                    var result = new Uint32Array(myTokens.length + otherTokens.length);
                    result.set(myTokens, 0);
                    result.set(otherTokens, myTokens.length);
                    this._lineTokens = result.buffer;
                }
                else {
                    // I don't have real tokens
                    this._lineTokens = otherTokens.buffer;
                }
            }
            if (other._markers) {
                // Other has markers
                var otherMarkers = other._markers;
                // Adjust other markers
                for (var i = 0, len = otherMarkers.length; i < len; i++) {
                    var marker = otherMarkers[i];
                    marker.updatePosition(markersTracker, new position_1.Position(this._lineNumber, marker.position.column + thisTextLength));
                }
                this.addMarkers(otherMarkers);
            }
        };
        ModelLine.prototype.addMarker = function (marker) {
            if (!this._markers) {
                this._markers = [marker];
            }
            else {
                this._markers.push(marker);
            }
        };
        ModelLine.prototype.addMarkers = function (markers) {
            if (markers.length === 0) {
                return;
            }
            if (!this._markers) {
                this._markers = markers.slice(0);
            }
            else {
                this._markers = this._markers.concat(markers);
            }
        };
        ModelLine.prototype.removeMarker = function (marker) {
            if (!this._markers) {
                return;
            }
            var index = this._indexOfMarkerId(marker.id);
            if (index < 0) {
                return;
            }
            if (this._markers.length === 1) {
                // was last marker on line
                this._markers = null;
            }
            else {
                this._markers.splice(index, 1);
            }
        };
        ModelLine.prototype.removeMarkers = function (deleteMarkers) {
            if (!this._markers) {
                return;
            }
            for (var i = 0, len = this._markers.length; i < len; i++) {
                var marker = this._markers[i];
                if (deleteMarkers[marker.id]) {
                    this._markers.splice(i, 1);
                    len--;
                    i--;
                }
            }
            if (this._markers.length === 0) {
                this._markers = null;
            }
        };
        ModelLine.prototype.getMarkers = function () {
            if (!this._markers) {
                return [];
            }
            return this._markers.slice(0);
        };
        ModelLine.prototype.updateLineNumber = function (markersTracker, newLineNumber) {
            if (this._lineNumber === newLineNumber) {
                return;
            }
            if (this._markers) {
                var markers = this._markers;
                for (var i = 0, len = markers.length; i < len; i++) {
                    var marker = markers[i];
                    marker.updateLineNumber(markersTracker, newLineNumber);
                }
            }
            this._lineNumber = newLineNumber;
        };
        ModelLine.prototype.deleteLine = function () {
            if (!this._markers) {
                return [];
            }
            return this._markers;
        };
        ModelLine.prototype._indexOfMarkerId = function (markerId) {
            var markers = this._markers;
            for (var i = 0, len = markers.length; i < len; i++) {
                if (markers[i].id === markerId) {
                    return i;
                }
            }
        };
        return ModelLine;
    }());
    exports.ModelLine = ModelLine;
});

define(__m[74/*vs/editor/common/model/wordHelper*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    /**
     * Create a word definition regular expression based on default word separators.
     * Optionally provide allowed separators that should be included in words.
     *
     * The default would look like this:
     * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        var usualSeparators = exports.USUAL_WORD_SEPARATORS;
        var source = '(-?\\d*\\.\\d\\w*)|([^';
        for (var i = 0; i < usualSeparators.length; i++) {
            if (allowInWords.indexOf(usualSeparators[i]) >= 0) {
                continue;
            }
            source += '\\' + usualSeparators[i];
        }
        source += '\\s]+)';
        return new RegExp(source, 'g');
    }
    // catches numbers (including floating numbers) in the first group, and alphanum in the second
    exports.DEFAULT_WORD_REGEXP = createWordRegExp();
    function ensureValidWordDefinition(wordDefinition) {
        var result = exports.DEFAULT_WORD_REGEXP;
        if (wordDefinition && (wordDefinition instanceof RegExp)) {
            if (!wordDefinition.global) {
                var flags = 'g';
                if (wordDefinition.ignoreCase) {
                    flags += 'i';
                }
                if (wordDefinition.multiline) {
                    flags += 'm';
                }
                result = new RegExp(wordDefinition.source, flags);
            }
            else {
                result = wordDefinition;
            }
        }
        result.lastIndex = 0;
        return result;
    }
    exports.ensureValidWordDefinition = ensureValidWordDefinition;
    function getWordAtPosFast(column, wordDefinition, text, textOffset) {
        // find whitespace enclosed text around column and match from there
        if (wordDefinition.test(' ')) {
            return getWordAtPosSlow(column, wordDefinition, text, textOffset);
        }
        var pos = column - 1 - textOffset;
        var start = text.lastIndexOf(' ', pos - 1) + 1;
        var end = text.indexOf(' ', pos);
        if (end === -1) {
            end = text.length;
        }
        wordDefinition.lastIndex = start;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index <= pos && wordDefinition.lastIndex >= pos) {
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
        // matches all words starting at the beginning
        // of the input until it finds a match that encloses
        // the desired column. slow but correct
        var pos = column - 1 - textOffset;
        wordDefinition.lastIndex = 0;
        var match;
        while (match = wordDefinition.exec(text)) {
            if (match.index > pos) {
                // |nW -> matched only after the pos
                return null;
            }
            else if (wordDefinition.lastIndex >= pos) {
                // W|W -> match encloses pos
                return {
                    word: match[0],
                    startColumn: textOffset + 1 + match.index,
                    endColumn: textOffset + 1 + wordDefinition.lastIndex
                };
            }
        }
        return null;
    }
    function getWordAtText(column, wordDefinition, text, textOffset) {
        var result = getWordAtPosFast(column, wordDefinition, text, textOffset);
        // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
        // in an undefined state and to not confuse other users of the wordDefinition
        // we reset the lastIndex
        wordDefinition.lastIndex = 0;
        return result;
    }
    exports.getWordAtText = getWordAtText;
});

define(__m[177/*vs/editor/common/modes/abstractMode*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FrankensteinMode = (function () {
        function FrankensteinMode(languageIdentifier) {
            this._languageIdentifier = languageIdentifier;
        }
        FrankensteinMode.prototype.getId = function () {
            return this._languageIdentifier.language;
        };
        FrankensteinMode.prototype.getLanguageIdentifier = function () {
            return this._languageIdentifier;
        };
        return FrankensteinMode;
    }());
    exports.FrankensteinMode = FrankensteinMode;
});

define(__m[54/*vs/editor/common/modes/languageConfiguration*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    var IndentAction;
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(IndentAction = exports.IndentAction || (exports.IndentAction = {}));
    /**
     * @internal
     */
    var StandardAutoClosingPairConditional = (function () {
        function StandardAutoClosingPairConditional(source) {
            this.open = source.open;
            this.close = source.close;
            // initially allowed in all tokens
            this._standardTokenMask = 0;
            if (Array.isArray(source.notIn)) {
                for (var i = 0, len = source.notIn.length; i < len; i++) {
                    var notIn = source.notIn[i];
                    switch (notIn) {
                        case 'string':
                            this._standardTokenMask |= 2 /* String */;
                            break;
                        case 'comment':
                            this._standardTokenMask |= 1 /* Comment */;
                            break;
                        case 'regex':
                            this._standardTokenMask |= 4 /* RegEx */;
                            break;
                    }
                }
            }
        }
        StandardAutoClosingPairConditional.prototype.isOK = function (standardToken) {
            return (this._standardTokenMask & standardToken) === 0;
        };
        return StandardAutoClosingPairConditional;
    }());
    exports.StandardAutoClosingPairConditional = StandardAutoClosingPairConditional;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[179/*vs/editor/common/modes/languageSelector*/], __M([1/*require*/,0/*exports*/,164/*vs/base/common/glob*/]), function (require, exports, glob_1) {
    'use strict';
    function matches(selection, uri, language) {
        return score(selection, uri, language) > 0;
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = matches;
    function score(selector, uri, language) {
        if (Array.isArray(selector)) {
            // for each
            var values = selector.map(function (item) { return score(item, uri, language); });
            return Math.max.apply(Math, values);
        }
        else if (typeof selector === 'string') {
            // compare language id
            if (selector === language) {
                return 10;
            }
            else if (selector === '*') {
                return 5;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            // all must match but only highest score counts
            var filter = selector;
            var valueLanguage = 0;
            var valueScheme = 0;
            var valuePattern = 0;
            // language id
            if (filter.language) {
                if (filter.language === language) {
                    valueLanguage = 10;
                }
                else if (filter.language === '*') {
                    valueLanguage = 5;
                }
                else {
                    return 0;
                }
            }
            // scheme
            if (filter.scheme) {
                if (filter.scheme === uri.scheme) {
                    valueScheme = 10;
                }
                else {
                    return 0;
                }
            }
            // match fsPath with pattern
            if (filter.pattern) {
                if (filter.pattern === uri.fsPath) {
                    valuePattern = 10;
                }
                else if (glob_1.match(filter.pattern, uri.fsPath)) {
                    valuePattern = 5;
                }
                else {
                    return 0;
                }
            }
            return Math.max(valueLanguage, valueScheme, valuePattern);
        }
    }
    exports.score = score;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[180/*vs/editor/common/modes/languageFeatureRegistry*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/,179/*vs/editor/common/modes/languageSelector*/]), function (require, exports, event_1, languageSelector_1) {
    'use strict';
    var LanguageFeatureRegistry = (function () {
        function LanguageFeatureRegistry() {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider) {
            var _this = this;
            var entry = {
                selector: selector,
                provider: provider,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return {
                dispose: function () {
                    if (entry) {
                        var idx = _this._entries.indexOf(entry);
                        if (idx >= 0) {
                            _this._entries.splice(idx, 1);
                            _this._lastCandidate = undefined;
                            _this._onDidChange.fire(_this._entries.length);
                            entry = undefined;
                        }
                    }
                }
            };
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model || model.isTooLargeForHavingARichMode()) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model || model.isTooLargeForHavingARichMode()) {
                return;
            }
            this._updateScores(model);
            for (var from = 0; from < this._entries.length; from++) {
                var entry = this._entries[from];
                if (entry._score > 0) {
                    callback(entry);
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.uri.toString(),
                language: model.getLanguageIdentifier().language
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.uri, model.getLanguageIdentifier().language);
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = LanguageFeatureRegistry;
});

define(__m[15/*vs/editor/common/modes*/], __M([1/*require*/,0/*exports*/,180/*vs/editor/common/modes/languageFeatureRegistry*/,12/*vs/base/common/event*/]), function (require, exports, languageFeatureRegistry_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Open ended enum at runtime
     * @internal
     */
    var LanguageId;
    (function (LanguageId) {
        LanguageId[LanguageId["Null"] = 0] = "Null";
        LanguageId[LanguageId["PlainText"] = 1] = "PlainText";
    })(LanguageId = exports.LanguageId || (exports.LanguageId = {}));
    /**
     * @internal
     */
    var LanguageIdentifier = (function () {
        function LanguageIdentifier(sid, iid) {
            this.language = sid;
            this.id = iid;
        }
        return LanguageIdentifier;
    }());
    exports.LanguageIdentifier = LanguageIdentifier;
    /**
     * A font style. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var FontStyle;
    (function (FontStyle) {
        FontStyle[FontStyle["NotSet"] = -1] = "NotSet";
        FontStyle[FontStyle["None"] = 0] = "None";
        FontStyle[FontStyle["Italic"] = 1] = "Italic";
        FontStyle[FontStyle["Bold"] = 2] = "Bold";
        FontStyle[FontStyle["Underline"] = 4] = "Underline";
    })(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
    /**
     * Open ended enum at runtime
     * @internal
     */
    var ColorId;
    (function (ColorId) {
        ColorId[ColorId["None"] = 0] = "None";
        ColorId[ColorId["DefaultForeground"] = 1] = "DefaultForeground";
        ColorId[ColorId["DefaultBackground"] = 2] = "DefaultBackground";
    })(ColorId = exports.ColorId || (exports.ColorId = {}));
    /**
     * A standard token type. Values are 2^x such that a bit mask can be used.
     * @internal
     */
    var StandardTokenType;
    (function (StandardTokenType) {
        StandardTokenType[StandardTokenType["Other"] = 0] = "Other";
        StandardTokenType[StandardTokenType["Comment"] = 1] = "Comment";
        StandardTokenType[StandardTokenType["String"] = 2] = "String";
        StandardTokenType[StandardTokenType["RegEx"] = 4] = "RegEx";
    })(StandardTokenType = exports.StandardTokenType || (exports.StandardTokenType = {}));
    /**
     * Helpers to manage the "collapsed" metadata of an entire StackElement stack.
     * The following assumptions have been made:
     *  - languageId < 256 => needs 8 bits
     *  - unique color count < 512 => needs 9 bits
     *
     * The binary format is:
     * - -------------------------------------------
     *     3322 2222 2222 1111 1111 1100 0000 0000
     *     1098 7654 3210 9876 5432 1098 7654 3210
     * - -------------------------------------------
     *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx
     *     bbbb bbbb bfff ffff ffFF FTTT LLLL LLLL
     * - -------------------------------------------
     *  - L = LanguageId (8 bits)
     *  - T = StandardTokenType (3 bits)
     *  - F = FontStyle (3 bits)
     *  - f = foreground color (9 bits)
     *  - b = background color (9 bits)
     *
     * @internal
     */
    var MetadataConsts;
    (function (MetadataConsts) {
        MetadataConsts[MetadataConsts["LANGUAGEID_MASK"] = 255] = "LANGUAGEID_MASK";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_MASK"] = 1792] = "TOKEN_TYPE_MASK";
        MetadataConsts[MetadataConsts["FONT_STYLE_MASK"] = 14336] = "FONT_STYLE_MASK";
        MetadataConsts[MetadataConsts["FOREGROUND_MASK"] = 8372224] = "FOREGROUND_MASK";
        MetadataConsts[MetadataConsts["BACKGROUND_MASK"] = 4286578688] = "BACKGROUND_MASK";
        MetadataConsts[MetadataConsts["LANGUAGEID_OFFSET"] = 0] = "LANGUAGEID_OFFSET";
        MetadataConsts[MetadataConsts["TOKEN_TYPE_OFFSET"] = 8] = "TOKEN_TYPE_OFFSET";
        MetadataConsts[MetadataConsts["FONT_STYLE_OFFSET"] = 11] = "FONT_STYLE_OFFSET";
        MetadataConsts[MetadataConsts["FOREGROUND_OFFSET"] = 14] = "FOREGROUND_OFFSET";
        MetadataConsts[MetadataConsts["BACKGROUND_OFFSET"] = 23] = "BACKGROUND_OFFSET";
    })(MetadataConsts = exports.MetadataConsts || (exports.MetadataConsts = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(DocumentHighlightKind = exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    /**
     * @internal
     */
    (function (SymbolKind) {
        /**
         * @internal
         */
        function from(kind) {
            switch (kind) {
                case SymbolKind.Method:
                    return 'method';
                case SymbolKind.Function:
                    return 'function';
                case SymbolKind.Constructor:
                    return 'constructor';
                case SymbolKind.Variable:
                    return 'variable';
                case SymbolKind.Class:
                    return 'class';
                case SymbolKind.Interface:
                    return 'interface';
                case SymbolKind.Namespace:
                    return 'namespace';
                case SymbolKind.Package:
                    return 'package';
                case SymbolKind.Module:
                    return 'module';
                case SymbolKind.Property:
                    return 'property';
                case SymbolKind.Enum:
                    return 'enum';
                case SymbolKind.String:
                    return 'string';
                case SymbolKind.File:
                    return 'file';
                case SymbolKind.Array:
                    return 'array';
                case SymbolKind.Number:
                    return 'number';
                case SymbolKind.Boolean:
                    return 'boolean';
                case SymbolKind.Object:
                    return 'object';
                case SymbolKind.Key:
                    return 'key';
                case SymbolKind.Null:
                    return 'null';
            }
            return 'property';
        }
        SymbolKind.from = from;
        /**
         * @internal
         */
        function to(type) {
            switch (type) {
                case 'method':
                    return SymbolKind.Method;
                case 'function':
                    return SymbolKind.Function;
                case 'constructor':
                    return SymbolKind.Constructor;
                case 'variable':
                    return SymbolKind.Variable;
                case 'class':
                    return SymbolKind.Class;
                case 'interface':
                    return SymbolKind.Interface;
                case 'namespace':
                    return SymbolKind.Namespace;
                case 'package':
                    return SymbolKind.Package;
                case 'module':
                    return SymbolKind.Module;
                case 'property':
                    return SymbolKind.Property;
                case 'enum':
                    return SymbolKind.Enum;
                case 'string':
                    return SymbolKind.String;
                case 'file':
                    return SymbolKind.File;
                case 'array':
                    return SymbolKind.Array;
                case 'number':
                    return SymbolKind.Number;
                case 'boolean':
                    return SymbolKind.Boolean;
                case 'object':
                    return SymbolKind.Object;
                case 'key':
                    return SymbolKind.Key;
                case 'null':
                    return SymbolKind.Null;
            }
            return SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    // --- feature registries ------
    /**
     * @internal
     */
    exports.ReferenceProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.RenameProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SuggestRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SignatureHelpProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.HoverProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentSymbolProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentHighlightProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.TypeDefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeLensProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeActionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentRangeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.OnTypeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.LinkProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    var TokenizationRegistryImpl = (function () {
        function TokenizationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._map = Object.create(null);
            this._colorMap = null;
        }
        /**
         * Fire a change event for a language.
         * This is useful for languages that embed other languages.
         */
        TokenizationRegistryImpl.prototype.fire = function (languages) {
            this._onDidChange.fire({ languages: languages });
        };
        TokenizationRegistryImpl.prototype.register = function (language, support) {
            var _this = this;
            this._map[language] = support;
            this.fire([language]);
            return {
                dispose: function () {
                    if (_this._map[language] !== support) {
                        return;
                    }
                    delete _this._map[language];
                    _this.fire([language]);
                }
            };
        };
        TokenizationRegistryImpl.prototype.get = function (language) {
            return (this._map[language] || null);
        };
        TokenizationRegistryImpl.prototype.setColorMap = function (colorMap) {
            this._colorMap = colorMap;
            this.fire(Object.keys(this._map));
        };
        TokenizationRegistryImpl.prototype.getColorMap = function () {
            return this._colorMap;
        };
        return TokenizationRegistryImpl;
    }());
    exports.TokenizationRegistryImpl = TokenizationRegistryImpl;
    /**
     * @internal
     */
    exports.TokenizationRegistry = new TokenizationRegistryImpl();
});

define(__m[182/*vs/editor/common/modes/linkComputer*/], __M([1/*require*/,0/*exports*/,65/*vs/editor/common/core/characterClassifier*/,80/*vs/editor/common/core/uint*/]), function (require, exports, characterClassifier_1, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var State;
    (function (State) {
        State[State["Invalid"] = 0] = "Invalid";
        State[State["Start"] = 1] = "Start";
        State[State["H"] = 2] = "H";
        State[State["HT"] = 3] = "HT";
        State[State["HTT"] = 4] = "HTT";
        State[State["HTTP"] = 5] = "HTTP";
        State[State["F"] = 6] = "F";
        State[State["FI"] = 7] = "FI";
        State[State["FIL"] = 8] = "FIL";
        State[State["BeforeColon"] = 9] = "BeforeColon";
        State[State["AfterColon"] = 10] = "AfterColon";
        State[State["AlmostThere"] = 11] = "AlmostThere";
        State[State["End"] = 12] = "End";
        State[State["Accept"] = 13] = "Accept";
    })(State || (State = {}));
    var StateMachine = (function () {
        function StateMachine(edges) {
            var maxCharCode = 0;
            var maxState = 0 /* Invalid */;
            for (var i = 0, len = edges.length; i < len; i++) {
                var _a = edges[i], from = _a[0], chCode = _a[1], to = _a[2];
                if (chCode > maxCharCode) {
                    maxCharCode = chCode;
                }
                if (from > maxState) {
                    maxState = from;
                }
                if (to > maxState) {
                    maxState = to;
                }
            }
            maxCharCode++;
            maxState++;
            var states = new uint_1.Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);
            for (var i = 0, len = edges.length; i < len; i++) {
                var _b = edges[i], from = _b[0], chCode = _b[1], to = _b[2];
                states.set(from, chCode, to);
            }
            this._states = states;
            this._maxCharCode = maxCharCode;
        }
        StateMachine.prototype.nextState = function (currentState, chCode) {
            if (chCode < 0 || chCode >= this._maxCharCode) {
                return 0 /* Invalid */;
            }
            return this._states.get(currentState, chCode);
        };
        return StateMachine;
    }());
    // State machine for http:// or https:// or file://
    var _stateMachine = null;
    function getStateMachine() {
        if (_stateMachine === null) {
            _stateMachine = new StateMachine([
                [1 /* Start */, 104 /* h */, 2 /* H */],
                [1 /* Start */, 72 /* H */, 2 /* H */],
                [1 /* Start */, 102 /* f */, 6 /* F */],
                [1 /* Start */, 70 /* F */, 6 /* F */],
                [2 /* H */, 116 /* t */, 3 /* HT */],
                [2 /* H */, 84 /* T */, 3 /* HT */],
                [3 /* HT */, 116 /* t */, 4 /* HTT */],
                [3 /* HT */, 84 /* T */, 4 /* HTT */],
                [4 /* HTT */, 112 /* p */, 5 /* HTTP */],
                [4 /* HTT */, 80 /* P */, 5 /* HTTP */],
                [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],
                [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],
                [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],
                [6 /* F */, 105 /* i */, 7 /* FI */],
                [6 /* F */, 73 /* I */, 7 /* FI */],
                [7 /* FI */, 108 /* l */, 8 /* FIL */],
                [7 /* FI */, 76 /* L */, 8 /* FIL */],
                [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],
                [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],
                [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],
                [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],
                [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],
            ]);
        }
        return _stateMachine;
    }
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["None"] = 0] = "None";
        CharacterClass[CharacterClass["ForceTermination"] = 1] = "ForceTermination";
        CharacterClass[CharacterClass["CannotEndIn"] = 2] = "CannotEndIn";
    })(CharacterClass || (CharacterClass = {}));
    var classifier = (function () {
        var result = new characterClassifier_1.CharacterClassifier(0 /* None */);
        var FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"、。｡､，．：；？！＠＃＄％＆＊‘“〈《「『【〔（［｛｢｣｝］）〕】』」》〉”’｀～…';
        for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            result.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);
        }
        var CANNOT_END_WITH_CHARACTERS = '.,;';
        for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            result.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);
        }
        return result;
    })();
    var LinkComputer = (function () {
        function LinkComputer() {
        }
        LinkComputer._createLink = function (line, lineNumber, linkBeginIndex, linkEndIndex) {
            // Do not allow to end link in certain characters...
            var lastIncludedCharIndex = linkEndIndex - 1;
            do {
                var chCode = line.charCodeAt(lastIncludedCharIndex);
                var chClass = classifier.get(chCode);
                if (chClass !== 2 /* CannotEndIn */) {
                    break;
                }
                lastIncludedCharIndex--;
            } while (lastIncludedCharIndex > linkBeginIndex);
            return {
                range: {
                    startLineNumber: lineNumber,
                    startColumn: linkBeginIndex + 1,
                    endLineNumber: lineNumber,
                    endColumn: lastIncludedCharIndex + 2
                },
                url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
            };
        };
        LinkComputer.computeLinks = function (model) {
            var stateMachine = getStateMachine();
            var result = [];
            for (var i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
                var line = model.getLineContent(i);
                var len = line.length;
                var j = 0;
                var linkBeginIndex = 0;
                var state = 1 /* Start */;
                var hasOpenParens = false;
                var hasOpenSquareBracket = false;
                var hasOpenCurlyBracket = false;
                while (j < len) {
                    var resetStateMachine = false;
                    var chCode = line.charCodeAt(j);
                    if (state === 13 /* Accept */) {
                        var chClass = void 0;
                        switch (chCode) {
                            case 40 /* OpenParen */:
                                hasOpenParens = true;
                                chClass = 0 /* None */;
                                break;
                            case 41 /* CloseParen */:
                                chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);
                                break;
                            case 91 /* OpenSquareBracket */:
                                hasOpenSquareBracket = true;
                                chClass = 0 /* None */;
                                break;
                            case 93 /* CloseSquareBracket */:
                                chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);
                                break;
                            case 123 /* OpenCurlyBrace */:
                                hasOpenCurlyBracket = true;
                                chClass = 0 /* None */;
                                break;
                            case 125 /* CloseCurlyBrace */:
                                chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);
                                break;
                            default:
                                chClass = classifier.get(chCode);
                        }
                        // Check if character terminates link
                        if (chClass === 1 /* ForceTermination */) {
                            result.push(LinkComputer._createLink(line, i, linkBeginIndex, j));
                            resetStateMachine = true;
                        }
                    }
                    else if (state === 12 /* End */) {
                        var chClass = classifier.get(chCode);
                        // Check if character terminates link
                        if (chClass === 1 /* ForceTermination */) {
                            resetStateMachine = true;
                        }
                        else {
                            state = 13 /* Accept */;
                        }
                    }
                    else {
                        state = stateMachine.nextState(state, chCode);
                        if (state === 0 /* Invalid */) {
                            resetStateMachine = true;
                        }
                    }
                    if (resetStateMachine) {
                        state = 1 /* Start */;
                        hasOpenParens = false;
                        hasOpenSquareBracket = false;
                        hasOpenCurlyBracket = false;
                        // Record where the link started
                        linkBeginIndex = j + 1;
                    }
                    j++;
                }
                if (state === 13 /* Accept */) {
                    result.push(LinkComputer._createLink(line, i, linkBeginIndex, len));
                }
            }
            return result;
        };
        return LinkComputer;
    }());
    /**
     * Returns an array of all links contains in the provided
     * document. *Note* that this operation is computational
     * expensive and should not run in the UI thread.
     */
    function computeLinks(model) {
        if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
            // Unknown caller!
            return [];
        }
        return LinkComputer.computeLinks(model);
    }
    exports.computeLinks = computeLinks;
});

define(__m[168/*vs/editor/common/modes/monarch/monarchCommon*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * This module exports common types and functionality shared between
     * the Monarch compiler that compiles JSON to ILexer, and the Monarch
     * Tokenizer (that highlights at runtime)
     */
    /*
     * Type definitions to be used internally to Monarch.
     * Inside monarch we use fully typed definitions and compiled versions of the more abstract JSON descriptions.
     */
    var MonarchBracket;
    (function (MonarchBracket) {
        MonarchBracket[MonarchBracket["None"] = 0] = "None";
        MonarchBracket[MonarchBracket["Open"] = 1] = "Open";
        MonarchBracket[MonarchBracket["Close"] = -1] = "Close";
    })(MonarchBracket = exports.MonarchBracket || (exports.MonarchBracket = {}));
    // Small helper functions
    /**
     * Is a string null, undefined, or empty?
     */
    function empty(s) {
        return (s ? false : true);
    }
    exports.empty = empty;
    /**
     * Puts a string to lower case if 'ignoreCase' is set.
     */
    function fixCase(lexer, str) {
        return (lexer.ignoreCase && str ? str.toLowerCase() : str);
    }
    exports.fixCase = fixCase;
    /**
     * Ensures there are no bad characters in a CSS token class.
     */
    function sanitize(s) {
        return s.replace(/[&<>'"_]/g, '-'); // used on all output token CSS classes
    }
    exports.sanitize = sanitize;
    // Logging
    /**
     * Logs a message.
     */
    function log(lexer, msg) {
        console.log(lexer.languageId + ": " + msg);
    }
    exports.log = log;
    // Throwing errors
    /**
     * Throws error. May actually just log the error and continue.
     */
    function throwError(lexer, msg) {
        throw new Error(lexer.languageId + ": " + msg);
    }
    exports.throwError = throwError;
    // Helper functions for rule finding and substitution
    /**
     * substituteMatches is used on lexer strings and can substitutes predefined patterns:
     * 		$$  => $
     * 		$#  => id
     * 		$n  => matched entry n
     * 		@attr => contents of lexer[attr]
     *
     * See documentation for more info
     */
    function substituteMatches(lexer, str, id, matches, state) {
        var re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
        var stateMatches = null;
        return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {
            if (!empty(dollar)) {
                return '$'; // $$
            }
            if (!empty(hash)) {
                return fixCase(lexer, id); // default $#
            }
            if (!empty(n) && n < matches.length) {
                return fixCase(lexer, matches[n]); // $n
            }
            if (!empty(attr) && lexer && typeof (lexer[attr]) === 'string') {
                return lexer[attr]; //@attribute
            }
            if (stateMatches === null) {
                stateMatches = state.split('.');
                stateMatches.unshift(state);
            }
            if (!empty(s) && s < stateMatches.length) {
                return fixCase(lexer, stateMatches[s]); //$Sn
            }
            return '';
        });
    }
    exports.substituteMatches = substituteMatches;
    /**
     * Find the tokenizer rules for a specific state (i.e. next action)
     */
    function findRules(lexer, state) {
        while (state && state.length > 0) {
            var rules = lexer.tokenizer[state];
            if (rules) {
                return rules;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return null;
    }
    exports.findRules = findRules;
    /**
     * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.
     * This is used during compilation where we may know the defined states
     * but not yet whether the corresponding rules are correct.
     */
    function stateExists(lexer, state) {
        while (state && state.length > 0) {
            var exist = lexer.stateNames[state];
            if (exist) {
                return true;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return false;
    }
    exports.stateExists = stateExists;
});

define(__m[184/*vs/editor/common/modes/monarch/monarchCompile*/], __M([1/*require*/,0/*exports*/,36/*vs/base/common/objects*/,168/*vs/editor/common/modes/monarch/monarchCommon*/]), function (require, exports, objects, monarchCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * Type helpers
     *
     * Note: this is just for sanity checks on the JSON description which is
     * helpful for the programmer. No checks are done anymore once the lexer is
     * already 'compiled and checked'.
     *
     */
    function isArrayOf(elemType, obj) {
        if (!obj) {
            return false;
        }
        if (!(Array.isArray(obj))) {
            return false;
        }
        var idx;
        for (idx in obj) {
            if (obj.hasOwnProperty(idx)) {
                if (!(elemType(obj[idx]))) {
                    return false;
                }
            }
        }
        return true;
    }
    function bool(prop, def, onerr) {
        if (typeof (prop) === 'boolean') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    function string(prop, def, onerr) {
        if (typeof (prop) === 'string') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    // Lexer helpers
    /**
     * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set.
     * Also replaces @\w+ or sequences with the content of the specified attribute
     */
    function compileRegExp(lexer, str) {
        if (typeof (str) !== 'string') {
            return null;
        }
        var n = 0;
        while (str.indexOf('@') >= 0 && n < 5) {
            n++;
            str = str.replace(/@(\w+)/g, function (s, attr) {
                var sub = '';
                if (typeof (lexer[attr]) === 'string') {
                    sub = lexer[attr];
                }
                else if (lexer[attr] && lexer[attr] instanceof RegExp) {
                    sub = lexer[attr].source;
                }
                else {
                    if (lexer[attr] === undefined) {
                        monarchCommon.throwError(lexer, 'language definition does not contain attribute \'' + attr + '\', used at: ' + str);
                    }
                    else {
                        monarchCommon.throwError(lexer, 'attribute reference \'' + attr + '\' must be a string, used at: ' + str);
                    }
                }
                return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');
            });
        }
        return new RegExp(str, (lexer.ignoreCase ? 'i' : ''));
    }
    /**
     * Compiles guard functions for case matches.
     * This compiles 'cases' attributes into efficient match functions.
     *
     */
    function selectScrutinee(id, matches, state, num) {
        if (num < 0) {
            return id;
        }
        if (num < matches.length) {
            return matches[num];
        }
        if (num >= 100) {
            num = num - 100;
            var parts = state.split('.');
            parts.unshift(state);
            if (num < parts.length) {
                return parts[num];
            }
        }
        return null;
    }
    function createGuard(lexer, ruleName, tkey, val) {
        // get the scrutinee and pattern
        var scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn
        var oppat = tkey;
        var matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
        if (matches) {
            if (matches[3]) {
                scrut = parseInt(matches[3]);
                if (matches[2]) {
                    scrut = scrut + 100; // if [sS] present
                }
            }
            oppat = matches[4];
        }
        // get operator
        var op = '~';
        var pat = oppat;
        if (!oppat || oppat.length === 0) {
            op = '!=';
            pat = '';
        }
        else if (/^\w*$/.test(pat)) {
            op = '==';
        }
        else {
            matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
            if (matches) {
                op = matches[1];
                pat = matches[2];
            }
        }
        // set the tester function
        var tester;
        // special case a regexp that matches just words
        if ((op === '~' || op === '!~') && /^(\w|\|)*$/.test(pat)) {
            var inWords = objects.createKeywordMatcher(pat.split('|'), lexer.ignoreCase);
            tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '@' || op === '!@') {
            var words = lexer[pat];
            if (!words) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' is not defined, in rule: ' + ruleName);
            }
            if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' must be an array of strings, in rule: ' + ruleName);
            }
            var inWords = objects.createKeywordMatcher(words, lexer.ignoreCase);
            tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '~' || op === '!~') {
            if (pat.indexOf('$') < 0) {
                // precompile regular expression
                var re = compileRegExp(lexer, '^' + pat + '$');
                tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };
            }
            else {
                tester = function (s, id, matches, state) {
                    var re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');
                    return re.test(s);
                };
            }
        }
        else {
            if (pat.indexOf('$') < 0) {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s) { return (op === '==' ? s === patx : s !== patx); };
            }
            else {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s, id, matches, state, eos) {
                    var patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);
                    return (op === '==' ? s === patexp : s !== patexp);
                };
            }
        }
        // return the branch object
        if (scrut === -1) {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    return tester(id, id, matches, state, eos);
                }
            };
        }
        else {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    var scrutinee = selectScrutinee(id, matches, state, scrut);
                    return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);
                }
            };
        }
    }
    /**
     * Compiles an action: i.e. optimize regular expressions and case matches
     * and do many sanity checks.
     *
     * This is called only during compilation but if the lexer definition
     * contains user functions as actions (which is usually not allowed), then this
     * may be called during lexing. It is important therefore to compile common cases efficiently
     */
    function compileAction(lexer, ruleName, action) {
        if (!action) {
            return { token: '' };
        }
        else if (typeof (action) === 'string') {
            return action; // { token: action };
        }
        else if (action.token || action.token === '') {
            if (typeof (action.token) !== 'string') {
                monarchCommon.throwError(lexer, 'a \'token\' attribute must be of type string, in rule: ' + ruleName);
                return { token: '' };
            }
            else {
                // only copy specific typed fields (only happens once during compile Lexer)
                var newAction = { token: action.token };
                if (action.token.indexOf('$') >= 0) {
                    newAction.tokenSubst = true;
                }
                if (typeof (action.bracket) === 'string') {
                    if (action.bracket === '@open') {
                        newAction.bracket = 1 /* Open */;
                    }
                    else if (action.bracket === '@close') {
                        newAction.bracket = -1 /* Close */;
                    }
                    else {
                        monarchCommon.throwError(lexer, 'a \'bracket\' attribute must be either \'@open\' or \'@close\', in rule: ' + ruleName);
                    }
                }
                if (action.next) {
                    if (typeof (action.next) !== 'string') {
                        monarchCommon.throwError(lexer, 'the next state must be a string value in rule: ' + ruleName);
                    }
                    else {
                        var next = action.next;
                        if (!/^(@pop|@push|@popall)$/.test(next)) {
                            if (next[0] === '@') {
                                next = next.substr(1); // peel off starting @ sign
                            }
                            if (next.indexOf('$') < 0) {
                                if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {
                                    monarchCommon.throwError(lexer, 'the next state \'' + action.next + '\' is not defined in rule: ' + ruleName);
                                }
                            }
                        }
                        newAction.next = next;
                    }
                }
                if (typeof (action.goBack) === 'number') {
                    newAction.goBack = action.goBack;
                }
                if (typeof (action.switchTo) === 'string') {
                    newAction.switchTo = action.switchTo;
                }
                if (typeof (action.log) === 'string') {
                    newAction.log = action.log;
                }
                if (typeof (action.nextEmbedded) === 'string') {
                    newAction.nextEmbedded = action.nextEmbedded;
                    lexer.usesEmbedded = true;
                }
                return newAction;
            }
        }
        else if (Array.isArray(action)) {
            var results = [];
            var idx;
            for (idx in action) {
                if (action.hasOwnProperty(idx)) {
                    results[idx] = compileAction(lexer, ruleName, action[idx]);
                }
            }
            return { group: results };
        }
        else if (action.cases) {
            // build an array of test cases
            var cases = [];
            // for each case, push a test function and result value
            var tkey;
            for (tkey in action.cases) {
                if (action.cases.hasOwnProperty(tkey)) {
                    var val = compileAction(lexer, ruleName, action.cases[tkey]);
                    // what kind of case
                    if (tkey === '@default' || tkey === '@' || tkey === '') {
                        cases.push({ test: null, value: val, name: tkey });
                    }
                    else if (tkey === '@eos') {
                        cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });
                    }
                    else {
                        cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture
                    }
                }
            }
            // create a matching function
            var def = lexer.defaultToken;
            return {
                test: function (id, matches, state, eos) {
                    var idx;
                    for (idx in cases) {
                        if (cases.hasOwnProperty(idx)) {
                            var didmatch = (!cases[idx].test || cases[idx].test(id, matches, state, eos));
                            if (didmatch) {
                                return cases[idx].value;
                            }
                        }
                    }
                    return def;
                }
            };
        }
        else {
            monarchCommon.throwError(lexer, 'an action must be a string, an object with a \'token\' or \'cases\' attribute, or an array of actions; in rule: ' + ruleName);
            return '';
        }
    }
    /**
     * Helper class for creating matching rules
     */
    var Rule = (function () {
        function Rule(name) {
            this.regex = new RegExp('');
            this.action = { token: '' };
            this.matchOnlyAtLineStart = false;
            this.name = '';
            this.name = name;
        }
        Rule.prototype.setRegex = function (lexer, re) {
            var sregex;
            if (typeof (re) === 'string') {
                sregex = re;
            }
            else if (re instanceof RegExp) {
                sregex = re.source;
            }
            else {
                monarchCommon.throwError(lexer, 'rules must start with a match string or regular expression: ' + this.name);
            }
            this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');
            this.name = this.name + ': ' + sregex;
            this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');
        };
        Rule.prototype.setAction = function (lexer, act) {
            this.action = compileAction(lexer, this.name, act);
        };
        return Rule;
    }());
    /**
     * Compiles a json description function into json where all regular expressions,
     * case matches etc, are compiled and all include rules are expanded.
     * We also compile the bracket definitions, supply defaults, and do many sanity checks.
     * If the 'jsonStrict' parameter is 'false', we allow at certain locations
     * regular expression objects and functions that get called during lexing.
     * (Currently we have no samples that need this so perhaps we should always have
     * jsonStrict to true).
     */
    function compile(languageId, json) {
        if (!json || typeof (json) !== 'object') {
            throw new Error('Monarch: expecting a language definition object');
        }
        // Create our lexer
        var lexer = {};
        lexer.languageId = languageId;
        lexer.noThrow = false; // raise exceptions during compilation
        lexer.maxStack = 100;
        // Set standard fields: be defensive about types
        lexer.start = string(json.start);
        lexer.ignoreCase = bool(json.ignoreCase, false);
        lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);
        lexer.defaultToken = string(json.defaultToken, 'source', function () { monarchCommon.throwError(lexer, 'the \'defaultToken\' must be a string'); });
        lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action
        // For calling compileAction later on
        var lexerMin = json;
        lexerMin.languageId = languageId;
        lexerMin.ignoreCase = lexer.ignoreCase;
        lexerMin.noThrow = lexer.noThrow;
        lexerMin.usesEmbedded = lexer.usesEmbedded;
        lexerMin.stateNames = json.tokenizer;
        lexerMin.defaultToken = lexer.defaultToken;
        // Compile an array of rules into newrules where RegExp objects are created.
        function addRules(state, newrules, rules) {
            var idx;
            for (idx in rules) {
                if (rules.hasOwnProperty(idx)) {
                    var rule = rules[idx];
                    var include = rule.include;
                    if (include) {
                        if (typeof (include) !== 'string') {
                            monarchCommon.throwError(lexer, 'an \'include\' attribute must be a string at: ' + state);
                        }
                        if (include[0] === '@') {
                            include = include.substr(1); // peel off starting @
                        }
                        if (!json.tokenizer[include]) {
                            monarchCommon.throwError(lexer, 'include target \'' + include + '\' is not defined at: ' + state);
                        }
                        addRules(state + '.' + include, newrules, json.tokenizer[include]);
                    }
                    else {
                        var newrule = new Rule(state);
                        // Set up new rule attributes
                        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
                            newrule.setRegex(lexerMin, rule[0]);
                            if (rule.length >= 3) {
                                if (typeof (rule[1]) === 'string') {
                                    newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
                                }
                                else if (typeof (rule[1]) === 'object') {
                                    var rule1 = rule[1];
                                    rule1.next = rule[2];
                                    newrule.setAction(lexerMin, rule1);
                                }
                                else {
                                    monarchCommon.throwError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);
                                }
                            }
                            else {
                                newrule.setAction(lexerMin, rule[1]);
                            }
                        }
                        else {
                            if (!rule.regex) {
                                monarchCommon.throwError(lexer, 'a rule must either be an array, or an object with a \'regex\' or \'include\' field at: ' + state);
                            }
                            if (rule.name) {
                                newrule.name = string(rule.name);
                            }
                            if (rule.matchOnlyAtStart) {
                                newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart);
                            }
                            newrule.setRegex(lexerMin, rule.regex);
                            newrule.setAction(lexerMin, rule.action);
                        }
                        newrules.push(newrule);
                    }
                }
            }
        }
        // compile the tokenizer rules
        if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {
            monarchCommon.throwError(lexer, 'a language definition must define the \'tokenizer\' attribute as an object');
        }
        lexer.tokenizer = [];
        var key;
        for (key in json.tokenizer) {
            if (json.tokenizer.hasOwnProperty(key)) {
                if (!lexer.start) {
                    lexer.start = key;
                }
                var rules = json.tokenizer[key];
                lexer.tokenizer[key] = new Array();
                addRules('tokenizer.' + key, lexer.tokenizer[key], rules);
            }
        }
        lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction
        // Set simple brackets
        if (json.brackets) {
            if (!(Array.isArray(json.brackets))) {
                monarchCommon.throwError(lexer, 'the \'brackets\' attribute must be defined as an array');
            }
        }
        else {
            json.brackets = [
                { open: '{', close: '}', token: 'delimiter.curly' },
                { open: '[', close: ']', token: 'delimiter.square' },
                { open: '(', close: ')', token: 'delimiter.parenthesis' },
                { open: '<', close: '>', token: 'delimiter.angle' }
            ];
        }
        var brackets = [];
        for (var bracketIdx in json.brackets) {
            if (json.brackets.hasOwnProperty(bracketIdx)) {
                var desc = json.brackets[bracketIdx];
                if (desc && Array.isArray(desc) && desc.length === 3) {
                    desc = { token: desc[2], open: desc[0], close: desc[1] };
                }
                if (desc.open === desc.close) {
                    monarchCommon.throwError(lexer, 'open and close brackets in a \'brackets\' attribute must be different: ' + desc.open +
                        '\n hint: use the \'bracket\' attribute if matching on equal brackets is required.');
                }
                if (typeof (desc.open) === 'string' && typeof (desc.token) === 'string') {
                    brackets.push({
                        token: string(desc.token) + lexer.tokenPostfix,
                        open: monarchCommon.fixCase(lexer, string(desc.open)),
                        close: monarchCommon.fixCase(lexer, string(desc.close))
                    });
                }
                else {
                    monarchCommon.throwError(lexer, 'every element in the \'brackets\' array must be a \'{open,close,token}\' object or array');
                }
            }
        }
        lexer.brackets = brackets;
        // Disable throw so the syntax highlighter goes, no matter what
        lexer.noThrow = true;
        return lexer;
    }
    exports.compile = compile;
});

define(__m[64/*vs/editor/common/modes/nullMode*/], __M([1/*require*/,0/*exports*/,15/*vs/editor/common/modes*/,82/*vs/editor/common/core/token*/]), function (require, exports, modes_1, token_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NullStateImpl = (function () {
        function NullStateImpl() {
        }
        NullStateImpl.prototype.clone = function () {
            return this;
        };
        NullStateImpl.prototype.equals = function (other) {
            return (this === other);
        };
        return NullStateImpl;
    }());
    exports.NULL_STATE = new NullStateImpl();
    exports.NULL_MODE_ID = 'vs.editor.nullMode';
    exports.NULL_LANGUAGE_IDENTIFIER = new modes_1.LanguageIdentifier(exports.NULL_MODE_ID, 0 /* Null */);
    function nullTokenize(modeId, buffer, state, deltaOffset) {
        return new token_1.TokenizationResult([new token_1.Token(deltaOffset, '', modeId)], state);
    }
    exports.nullTokenize = nullTokenize;
    function nullTokenize2(languageId, buffer, state, deltaOffset) {
        var tokens = new Uint32Array(2);
        tokens[0] = deltaOffset;
        tokens[1] = ((languageId << 0 /* LANGUAGEID_OFFSET */)
            | (0 /* Other */ << 8 /* TOKEN_TYPE_OFFSET */)
            | (0 /* None */ << 11 /* FONT_STYLE_OFFSET */)
            | (1 /* DefaultForeground */ << 14 /* FOREGROUND_OFFSET */)
            | (2 /* DefaultBackground */ << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        return new token_1.TokenizationResult2(tokens, state);
    }
    exports.nullTokenize2 = nullTokenize2;
});

define(__m[186/*vs/editor/common/modes/monarch/monarchLexer*/], __M([1/*require*/,0/*exports*/,15/*vs/editor/common/modes*/,168/*vs/editor/common/modes/monarch/monarchCommon*/,82/*vs/editor/common/core/token*/,64/*vs/editor/common/modes/nullMode*/]), function (require, exports, modes, monarchCommon, token_1, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CACHE_STACK_DEPTH = 5;
    /**
     * Reuse the same stack elements up to a certain depth.
     */
    var MonarchStackElementFactory = (function () {
        function MonarchStackElementFactory(maxCacheDepth) {
            this._maxCacheDepth = maxCacheDepth;
            this._entries = Object.create(null);
        }
        MonarchStackElementFactory.create = function (parent, state) {
            return this._INSTANCE.create(parent, state);
        };
        MonarchStackElementFactory.prototype.create = function (parent, state) {
            if (parent !== null && parent.depth >= this._maxCacheDepth) {
                // no caching above a certain depth
                return new MonarchStackElement(parent, state);
            }
            var stackElementId = MonarchStackElement.getStackElementId(parent);
            if (stackElementId.length > 0) {
                stackElementId += '|';
            }
            stackElementId += state;
            var result = this._entries[stackElementId];
            if (result) {
                return result;
            }
            result = new MonarchStackElement(parent, state);
            this._entries[stackElementId] = result;
            return result;
        };
        return MonarchStackElementFactory;
    }());
    MonarchStackElementFactory._INSTANCE = new MonarchStackElementFactory(CACHE_STACK_DEPTH);
    exports.MonarchStackElementFactory = MonarchStackElementFactory;
    var MonarchStackElement = (function () {
        function MonarchStackElement(parent, state) {
            this.parent = parent;
            this.state = state;
            this.depth = (this.parent ? this.parent.depth : 0) + 1;
        }
        MonarchStackElement.getStackElementId = function (element) {
            var result = '';
            while (element !== null) {
                if (result.length > 0) {
                    result += '|';
                }
                result += element.state;
                element = element.parent;
            }
            return result;
        };
        MonarchStackElement._equals = function (a, b) {
            while (a !== null && b !== null) {
                if (a === b) {
                    return true;
                }
                if (a.state !== b.state) {
                    return false;
                }
                a = a.parent;
                b = b.parent;
            }
            if (a === null && b === null) {
                return true;
            }
            return false;
        };
        MonarchStackElement.prototype.equals = function (other) {
            return MonarchStackElement._equals(this, other);
        };
        MonarchStackElement.prototype.push = function (state) {
            return MonarchStackElementFactory.create(this, state);
        };
        MonarchStackElement.prototype.pop = function () {
            return this.parent;
        };
        MonarchStackElement.prototype.popall = function () {
            var result = this;
            while (result.parent) {
                result = result.parent;
            }
            return result;
        };
        MonarchStackElement.prototype.switchTo = function (state) {
            return MonarchStackElementFactory.create(this.parent, state);
        };
        return MonarchStackElement;
    }());
    exports.MonarchStackElement = MonarchStackElement;
    var EmbeddedModeData = (function () {
        function EmbeddedModeData(modeId, state) {
            this.modeId = modeId;
            this.state = state;
        }
        EmbeddedModeData.prototype.equals = function (other) {
            return (this.modeId === other.modeId
                && this.state.equals(other.state));
        };
        EmbeddedModeData.prototype.clone = function () {
            var stateClone = this.state.clone();
            // save an object
            if (stateClone === this.state) {
                return this;
            }
            return new EmbeddedModeData(this.modeId, this.state);
        };
        return EmbeddedModeData;
    }());
    exports.EmbeddedModeData = EmbeddedModeData;
    /**
     * Reuse the same line states up to a certain depth.
     */
    var MonarchLineStateFactory = (function () {
        function MonarchLineStateFactory(maxCacheDepth) {
            this._maxCacheDepth = maxCacheDepth;
            this._entries = Object.create(null);
        }
        MonarchLineStateFactory.create = function (stack, embeddedModeData) {
            return this._INSTANCE.create(stack, embeddedModeData);
        };
        MonarchLineStateFactory.prototype.create = function (stack, embeddedModeData) {
            if (embeddedModeData !== null) {
                // no caching when embedding
                return new MonarchLineState(stack, embeddedModeData);
            }
            if (stack !== null && stack.depth >= this._maxCacheDepth) {
                // no caching above a certain depth
                return new MonarchLineState(stack, embeddedModeData);
            }
            var stackElementId = MonarchStackElement.getStackElementId(stack);
            var result = this._entries[stackElementId];
            if (result) {
                return result;
            }
            result = new MonarchLineState(stack, null);
            this._entries[stackElementId] = result;
            return result;
        };
        return MonarchLineStateFactory;
    }());
    MonarchLineStateFactory._INSTANCE = new MonarchLineStateFactory(CACHE_STACK_DEPTH);
    exports.MonarchLineStateFactory = MonarchLineStateFactory;
    var MonarchLineState = (function () {
        function MonarchLineState(stack, embeddedModeData) {
            this.stack = stack;
            this.embeddedModeData = embeddedModeData;
        }
        MonarchLineState.prototype.clone = function () {
            var embeddedModeDataClone = this.embeddedModeData ? this.embeddedModeData.clone() : null;
            // save an object
            if (embeddedModeDataClone === this.embeddedModeData) {
                return this;
            }
            return MonarchLineStateFactory.create(this.stack, this.embeddedModeData);
        };
        MonarchLineState.prototype.equals = function (other) {
            if (!(other instanceof MonarchLineState)) {
                return false;
            }
            if (!this.stack.equals(other.stack)) {
                return false;
            }
            if (this.embeddedModeData === null && other.embeddedModeData === null) {
                return true;
            }
            if (this.embeddedModeData === null || other.embeddedModeData === null) {
                return false;
            }
            return this.embeddedModeData.equals(other.embeddedModeData);
        };
        return MonarchLineState;
    }());
    exports.MonarchLineState = MonarchLineState;
    var hasOwnProperty = Object.hasOwnProperty;
    var MonarchClassicTokensCollector = (function () {
        function MonarchClassicTokensCollector() {
            this._tokens = [];
            this._language = null;
            this._lastTokenType = null;
            this._lastTokenLanguage = null;
        }
        MonarchClassicTokensCollector.prototype.enterMode = function (startOffset, modeId) {
            this._language = modeId;
        };
        MonarchClassicTokensCollector.prototype.emit = function (startOffset, type) {
            if (this._lastTokenType === type && this._lastTokenLanguage === this._language) {
                return;
            }
            this._lastTokenType = type;
            this._lastTokenLanguage = this._language;
            this._tokens.push(new token_1.Token(startOffset, type, this._language));
        };
        MonarchClassicTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {
            var nestedModeId = embeddedModeData.modeId;
            var embeddedModeState = embeddedModeData.state;
            var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);
            if (!nestedModeTokenizationSupport) {
                this.enterMode(offsetDelta, nestedModeId);
                this.emit(offsetDelta, '');
                return embeddedModeState;
            }
            var nestedResult = nestedModeTokenizationSupport.tokenize(embeddedModeLine, embeddedModeState, offsetDelta);
            this._tokens = this._tokens.concat(nestedResult.tokens);
            this._lastTokenType = null;
            this._lastTokenLanguage = null;
            this._language = null;
            return nestedResult.endState;
        };
        MonarchClassicTokensCollector.prototype.finalize = function (endState) {
            return new token_1.TokenizationResult(this._tokens, endState);
        };
        return MonarchClassicTokensCollector;
    }());
    var MonarchModernTokensCollector = (function () {
        function MonarchModernTokensCollector(modeService, theme) {
            this._modeService = modeService;
            this._theme = theme;
            this._prependTokens = null;
            this._tokens = [];
            this._currentLanguageId = 0 /* Null */;
            this._lastTokenMetadata = 0;
        }
        MonarchModernTokensCollector.prototype.enterMode = function (startOffset, modeId) {
            this._currentLanguageId = this._modeService.getLanguageIdentifier(modeId).id;
        };
        MonarchModernTokensCollector.prototype.emit = function (startOffset, type) {
            var metadata = this._theme.match(this._currentLanguageId, type);
            if (this._lastTokenMetadata === metadata) {
                return;
            }
            this._lastTokenMetadata = metadata;
            this._tokens.push(startOffset);
            this._tokens.push(metadata);
        };
        MonarchModernTokensCollector._merge = function (a, b, c) {
            var aLen = (a !== null ? a.length : 0);
            var bLen = b.length;
            var cLen = (c !== null ? c.length : 0);
            if (aLen === 0 && bLen === 0 && cLen === 0) {
                return new Uint32Array(0);
            }
            if (aLen === 0 && bLen === 0) {
                return c;
            }
            if (bLen === 0 && cLen === 0) {
                return a;
            }
            var result = new Uint32Array(aLen + bLen + cLen);
            if (a !== null) {
                result.set(a);
            }
            for (var i = 0; i < bLen; i++) {
                result[aLen + i] = b[i];
            }
            if (c !== null) {
                result.set(c, aLen + bLen);
            }
            return result;
        };
        MonarchModernTokensCollector.prototype.nestedModeTokenize = function (embeddedModeLine, embeddedModeData, offsetDelta) {
            var nestedModeId = embeddedModeData.modeId;
            var embeddedModeState = embeddedModeData.state;
            var nestedModeTokenizationSupport = modes.TokenizationRegistry.get(nestedModeId);
            if (!nestedModeTokenizationSupport) {
                this.enterMode(offsetDelta, nestedModeId);
                this.emit(offsetDelta, '');
                return embeddedModeState;
            }
            var nestedResult = nestedModeTokenizationSupport.tokenize2(embeddedModeLine, embeddedModeState, offsetDelta);
            this._prependTokens = MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, nestedResult.tokens);
            this._tokens = [];
            this._currentLanguageId = 0;
            this._lastTokenMetadata = 0;
            return nestedResult.endState;
        };
        MonarchModernTokensCollector.prototype.finalize = function (endState) {
            return new token_1.TokenizationResult2(MonarchModernTokensCollector._merge(this._prependTokens, this._tokens, null), endState);
        };
        return MonarchModernTokensCollector;
    }());
    var MonarchTokenizer = (function () {
        function MonarchTokenizer(modeService, standaloneColorService, modeId, lexer) {
            var _this = this;
            this._modeService = modeService;
            this._standaloneColorService = standaloneColorService;
            this._modeId = modeId;
            this._lexer = lexer;
            this._embeddedModes = Object.create(null);
            // Set up listening for embedded modes
            var emitting = false;
            this._tokenizationRegistryListener = modes.TokenizationRegistry.onDidChange(function (e) {
                if (emitting) {
                    return;
                }
                var isOneOfMyEmbeddedModes = false;
                for (var i = 0, len = e.languages.length; i < len; i++) {
                    var language = e.languages[i];
                    if (_this._embeddedModes[language]) {
                        isOneOfMyEmbeddedModes = true;
                        break;
                    }
                }
                if (isOneOfMyEmbeddedModes) {
                    emitting = true;
                    modes.TokenizationRegistry.fire([_this._modeId]);
                    emitting = false;
                }
            });
        }
        MonarchTokenizer.prototype.dispose = function () {
            this._tokenizationRegistryListener.dispose();
        };
        MonarchTokenizer.prototype.getInitialState = function () {
            var rootState = MonarchStackElementFactory.create(null, this._lexer.start);
            return MonarchLineStateFactory.create(rootState, null);
        };
        MonarchTokenizer.prototype.tokenize = function (line, lineState, offsetDelta) {
            var tokensCollector = new MonarchClassicTokensCollector();
            var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
            return tokensCollector.finalize(endLineState);
        };
        MonarchTokenizer.prototype.tokenize2 = function (line, lineState, offsetDelta) {
            var tokensCollector = new MonarchModernTokensCollector(this._modeService, this._standaloneColorService.getTheme());
            var endLineState = this._tokenize(line, lineState, offsetDelta, tokensCollector);
            return tokensCollector.finalize(endLineState);
        };
        MonarchTokenizer.prototype._tokenize = function (line, lineState, offsetDelta, collector) {
            if (lineState.embeddedModeData) {
                return this._nestedTokenize(line, lineState, offsetDelta, collector);
            }
            else {
                return this._myTokenize(line, lineState, offsetDelta, collector);
            }
        };
        MonarchTokenizer.prototype._findLeavingNestedModeOffset = function (line, state) {
            var rules = this._lexer.tokenizer[state.stack.state];
            if (!rules) {
                rules = monarchCommon.findRules(this._lexer, state.stack.state); // do parent matching
                if (!rules) {
                    monarchCommon.throwError(this._lexer, 'tokenizer state is not defined: ' + state.stack.state);
                }
            }
            var popOffset = -1;
            var hasEmbeddedPopRule = false;
            for (var idx in rules) {
                if (!hasOwnProperty.call(rules, idx)) {
                    continue;
                }
                var rule = rules[idx];
                if (rule.action.nextEmbedded !== '@pop') {
                    continue;
                }
                hasEmbeddedPopRule = true;
                var regex = rule.regex;
                var regexSource = rule.regex.source;
                if (regexSource.substr(0, 4) === '^(?:' && regexSource.substr(regexSource.length - 1, 1) === ')') {
                    regex = new RegExp(regexSource.substr(4, regexSource.length - 5), regex.ignoreCase ? 'i' : '');
                }
                var result = line.search(regex);
                if (result === -1) {
                    continue;
                }
                if (popOffset === -1 || result < popOffset) {
                    popOffset = result;
                }
            }
            if (!hasEmbeddedPopRule) {
                monarchCommon.throwError(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + state.stack.state);
            }
            return popOffset;
        };
        MonarchTokenizer.prototype._nestedTokenize = function (line, lineState, offsetDelta, tokensCollector) {
            var popOffset = this._findLeavingNestedModeOffset(line, lineState);
            if (popOffset === -1) {
                // tokenization will not leave nested mode
                var nestedEndState = tokensCollector.nestedModeTokenize(line, lineState.embeddedModeData, offsetDelta);
                return MonarchLineStateFactory.create(lineState.stack, new EmbeddedModeData(lineState.embeddedModeData.modeId, nestedEndState));
            }
            var nestedModeLine = line.substring(0, popOffset);
            if (nestedModeLine.length > 0) {
                // tokenize with the nested mode
                tokensCollector.nestedModeTokenize(nestedModeLine, lineState.embeddedModeData, offsetDelta);
            }
            var restOfTheLine = line.substring(popOffset);
            return this._myTokenize(restOfTheLine, lineState, offsetDelta + popOffset, tokensCollector);
        };
        MonarchTokenizer.prototype._myTokenize = function (line, lineState, offsetDelta, tokensCollector) {
            tokensCollector.enterMode(offsetDelta, this._modeId);
            var lineLength = line.length;
            var embeddedModeData = lineState.embeddedModeData;
            var stack = lineState.stack;
            var pos = 0;
            // regular expression group matching
            // these never need cloning or equality since they are only used within a line match
            var groupActions = null;
            var groupMatches = null;
            var groupMatched = null;
            var groupRule = null;
            while (pos < lineLength) {
                var pos0 = pos;
                var stackLen0 = stack.depth;
                var groupLen0 = groupActions ? groupActions.length : 0;
                var state = stack.state;
                var matches = null;
                var matched = null;
                var action = null;
                var rule = null;
                var enteringEmbeddedMode = null;
                // check if we need to process group matches first
                if (groupActions) {
                    matches = groupMatches;
                    matched = groupMatched.shift();
                    action = groupActions.shift();
                    rule = groupRule;
                    // cleanup if necessary
                    if (groupActions.length === 0) {
                        groupActions = null;
                        groupMatches = null;
                        groupMatched = null;
                        groupRule = null;
                    }
                }
                else {
                    // otherwise we match on the token stream
                    if (pos >= lineLength) {
                        // nothing to do
                        break;
                    }
                    // get the rules for this state
                    var rules = this._lexer.tokenizer[state];
                    if (!rules) {
                        rules = monarchCommon.findRules(this._lexer, state); // do parent matching
                        if (!rules) {
                            monarchCommon.throwError(this._lexer, 'tokenizer state is not defined: ' + state);
                        }
                    }
                    // try each rule until we match
                    var restOfLine = line.substr(pos);
                    for (var idx in rules) {
                        if (hasOwnProperty.call(rules, idx)) {
                            var rule_1 = rules[idx];
                            if (pos === 0 || !rule_1.matchOnlyAtLineStart) {
                                matches = restOfLine.match(rule_1.regex);
                                if (matches) {
                                    matched = matches[0];
                                    action = rule_1.action;
                                    break;
                                }
                            }
                        }
                    }
                }
                // We matched 'rule' with 'matches' and 'action'
                if (!matches) {
                    matches = [''];
                    matched = '';
                }
                if (!action) {
                    // bad: we didn't match anything, and there is no action to take
                    // we need to advance the stream or we get progress trouble
                    if (pos < lineLength) {
                        matches = [line.charAt(pos)];
                        matched = matches[0];
                    }
                    action = this._lexer.defaultToken;
                }
                // advance stream
                pos += matched.length;
                // maybe call action function (used for 'cases')
                while (action.test) {
                    action = action.test(matched, matches, state, pos === lineLength);
                }
                var result = null;
                // set the result: either a string or an array of actions
                if (typeof action === 'string' || Array.isArray(action)) {
                    result = action;
                }
                else if (action.group) {
                    result = action.group;
                }
                else if (action.token !== null && action.token !== undefined) {
                    result = action.token;
                    // do $n replacements?
                    if (action.tokenSubst) {
                        result = monarchCommon.substituteMatches(this._lexer, result, matched, matches, state);
                    }
                    // enter embedded mode?
                    if (action.nextEmbedded) {
                        if (action.nextEmbedded === '@pop') {
                            if (!embeddedModeData) {
                                monarchCommon.throwError(this._lexer, 'cannot pop embedded mode if not inside one');
                            }
                            embeddedModeData = null;
                        }
                        else if (embeddedModeData) {
                            monarchCommon.throwError(this._lexer, 'cannot enter embedded mode from within an embedded mode');
                        }
                        else {
                            enteringEmbeddedMode = monarchCommon.substituteMatches(this._lexer, action.nextEmbedded, matched, matches, state);
                        }
                    }
                    // state transformations
                    if (action.goBack) {
                        pos = Math.max(0, pos - action.goBack);
                    }
                    if (action.switchTo && typeof action.switchTo === 'string') {
                        var nextState = monarchCommon.substituteMatches(this._lexer, action.switchTo, matched, matches, state); // switch state without a push...
                        if (nextState[0] === '@') {
                            nextState = nextState.substr(1); // peel off starting '@'
                        }
                        if (!monarchCommon.findRules(this._lexer, nextState)) {
                            monarchCommon.throwError(this._lexer, 'trying to switch to a state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                        }
                        else {
                            stack = stack.switchTo(nextState);
                        }
                    }
                    else if (action.transform && typeof action.transform === 'function') {
                        monarchCommon.throwError(this._lexer, 'action.transform not supported');
                    }
                    else if (action.next) {
                        if (action.next === '@push') {
                            if (stack.depth >= this._lexer.maxStack) {
                                monarchCommon.throwError(this._lexer, 'maximum tokenizer stack size reached: [' +
                                    stack.state + ',' + stack.parent.state + ',...]');
                            }
                            else {
                                stack = stack.push(state);
                            }
                        }
                        else if (action.next === '@pop') {
                            if (stack.depth <= 1) {
                                monarchCommon.throwError(this._lexer, 'trying to pop an empty stack in rule: ' + rule.name);
                            }
                            else {
                                stack = stack.pop();
                            }
                        }
                        else if (action.next === '@popall') {
                            stack = stack.popall();
                        }
                        else {
                            var nextState = monarchCommon.substituteMatches(this._lexer, action.next, matched, matches, state);
                            if (nextState[0] === '@') {
                                nextState = nextState.substr(1); // peel off starting '@'
                            }
                            if (!monarchCommon.findRules(this._lexer, nextState)) {
                                monarchCommon.throwError(this._lexer, 'trying to set a next state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                            }
                            else {
                                stack = stack.push(nextState);
                            }
                        }
                    }
                    if (action.log && typeof (action.log) === 'string') {
                        monarchCommon.log(this._lexer, this._lexer.languageId + ': ' + monarchCommon.substituteMatches(this._lexer, action.log, matched, matches, state));
                    }
                }
                // check result
                if (result === null) {
                    monarchCommon.throwError(this._lexer, 'lexer rule has no well-defined action in rule: ' + rule.name);
                }
                // is the result a group match?
                if (Array.isArray(result)) {
                    if (groupActions && groupActions.length > 0) {
                        monarchCommon.throwError(this._lexer, 'groups cannot be nested: ' + rule.name);
                    }
                    if (matches.length !== result.length + 1) {
                        monarchCommon.throwError(this._lexer, 'matched number of groups does not match the number of actions in rule: ' + rule.name);
                    }
                    var totalLen = 0;
                    for (var i = 1; i < matches.length; i++) {
                        totalLen += matches[i].length;
                    }
                    if (totalLen !== matched.length) {
                        monarchCommon.throwError(this._lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + rule.name);
                    }
                    groupMatches = matches;
                    groupMatched = matches.slice(1);
                    groupActions = result.slice(0);
                    groupRule = rule;
                    pos -= matched.length;
                    // call recursively to initiate first result match
                    continue;
                }
                else {
                    // regular result
                    // check for '@rematch'
                    if (result === '@rematch') {
                        pos -= matched.length;
                        matched = ''; // better set the next state too..
                        matches = null;
                        result = '';
                    }
                    // check progress
                    if (matched.length === 0) {
                        if (stackLen0 !== stack.depth || state !== stack.state || (!groupActions ? 0 : groupActions.length) !== groupLen0) {
                            continue;
                        }
                        else {
                            monarchCommon.throwError(this._lexer, 'no progress in tokenizer in rule: ' + rule.name);
                            pos = lineLength; // must make progress or editor loops
                        }
                    }
                    // return the result (and check for brace matching)
                    // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions
                    var tokenType = null;
                    if (result.indexOf('@brackets') === 0) {
                        var rest = result.substr('@brackets'.length);
                        var bracket = findBracket(this._lexer, matched);
                        if (!bracket) {
                            monarchCommon.throwError(this._lexer, '@brackets token returned but no bracket defined as: ' + matched);
                            bracket = { token: '', bracketType: 0 /* None */ };
                        }
                        tokenType = monarchCommon.sanitize(bracket.token + rest);
                    }
                    else {
                        var token = (result === '' ? '' : result + this._lexer.tokenPostfix);
                        tokenType = monarchCommon.sanitize(token);
                    }
                    tokensCollector.emit(pos0 + offsetDelta, tokenType);
                }
                if (enteringEmbeddedMode) {
                    // substitute language alias to known modes to support syntax highlighting
                    var enteringEmbeddedModeId = this._modeService.getModeIdForLanguageName(enteringEmbeddedMode);
                    if (enteringEmbeddedModeId) {
                        enteringEmbeddedMode = enteringEmbeddedModeId;
                    }
                    var embeddedModeData_1 = this._getNestedEmbeddedModeData(enteringEmbeddedMode);
                    if (pos < lineLength) {
                        // there is content from the embedded mode on this line
                        var restOfLine = line.substr(pos);
                        return this._nestedTokenize(restOfLine, MonarchLineStateFactory.create(stack, embeddedModeData_1), offsetDelta + pos, tokensCollector);
                    }
                    else {
                        return MonarchLineStateFactory.create(stack, embeddedModeData_1);
                    }
                }
            }
            return MonarchLineStateFactory.create(stack, embeddedModeData);
        };
        MonarchTokenizer.prototype._getNestedEmbeddedModeData = function (mimetypeOrModeId) {
            var nestedMode = this._locateMode(mimetypeOrModeId);
            if (nestedMode) {
                var tokenizationSupport = modes.TokenizationRegistry.get(nestedMode.getId());
                if (tokenizationSupport) {
                    return new EmbeddedModeData(nestedMode.getId(), tokenizationSupport.getInitialState());
                }
            }
            var nestedModeId = nestedMode ? nestedMode.getId() : nullMode_1.NULL_MODE_ID;
            return new EmbeddedModeData(nestedModeId, nullMode_1.NULL_STATE);
        };
        MonarchTokenizer.prototype._locateMode = function (mimetypeOrModeId) {
            if (!mimetypeOrModeId || !this._modeService.isRegisteredMode(mimetypeOrModeId)) {
                return null;
            }
            var modeId = this._modeService.getModeId(mimetypeOrModeId);
            // Fire mode loading event
            this._modeService.getOrCreateMode(modeId);
            var mode = this._modeService.getMode(modeId);
            if (mode) {
                // Re-emit tokenizationSupport change events from all modes that I ever embedded
                this._embeddedModes[modeId] = true;
                return mode;
            }
            this._embeddedModes[modeId] = true;
            return null;
        };
        return MonarchTokenizer;
    }());
    exports.MonarchTokenizer = MonarchTokenizer;
    /**
     * Searches for a bracket in the 'brackets' attribute that matches the input.
     */
    function findBracket(lexer, matched) {
        if (!matched) {
            return null;
        }
        matched = monarchCommon.fixCase(lexer, matched);
        var brackets = lexer.brackets;
        for (var i = 0; i < brackets.length; i++) {
            var bracket = brackets[i];
            if (bracket.open === matched) {
                return { token: bracket.token, bracketType: 1 /* Open */ };
            }
            else if (bracket.close === matched) {
                return { token: bracket.token, bracketType: -1 /* Close */ };
            }
        }
        return null;
    }
    function createTokenizationSupport(modeService, standaloneColorService, modeId, lexer) {
        return new MonarchTokenizer(modeService, standaloneColorService, modeId, lexer);
    }
    exports.createTokenizationSupport = createTokenizationSupport;
});

define(__m[81/*vs/editor/common/modes/supports*/], __M([1/*require*/,0/*exports*/,15/*vs/editor/common/modes*/]), function (require, exports, modes) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createScopedLineTokens(context, offset) {
        var tokenCount = context.getTokenCount();
        var tokenIndex = context.findTokenIndexAtOffset(offset);
        var desiredLanguageId = context.getLanguageId(tokenIndex);
        var lastTokenIndex = tokenIndex;
        while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {
            lastTokenIndex++;
        }
        var firstTokenIndex = tokenIndex;
        while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {
            firstTokenIndex--;
        }
        return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getTokenStartOffset(firstTokenIndex), context.getTokenEndOffset(lastTokenIndex));
    }
    exports.createScopedLineTokens = createScopedLineTokens;
    var ScopedLineTokens = (function () {
        function ScopedLineTokens(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
            this._actual = actual;
            this.languageId = languageId;
            this._firstTokenIndex = firstTokenIndex;
            this._lastTokenIndex = lastTokenIndex;
            this.firstCharOffset = firstCharOffset;
            this._lastCharOffset = lastCharOffset;
        }
        ScopedLineTokens.prototype.getLineContent = function () {
            var actualLineContent = this._actual.getLineContent();
            return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);
        };
        ScopedLineTokens.prototype.getTokenCount = function () {
            return this._lastTokenIndex - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.findTokenIndexAtOffset = function (offset) {
            return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
        };
        ScopedLineTokens.prototype.getTokenStartOffset = function (tokenIndex) {
            return this._actual.getTokenStartOffset(tokenIndex + this._firstTokenIndex) - this.firstCharOffset;
        };
        ScopedLineTokens.prototype.getStandardTokenType = function (tokenIndex) {
            return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
        };
        return ScopedLineTokens;
    }());
    exports.ScopedLineTokens = ScopedLineTokens;
    var IgnoreBracketsInTokens;
    (function (IgnoreBracketsInTokens) {
        IgnoreBracketsInTokens[IgnoreBracketsInTokens["value"] = 7] = "value";
    })(IgnoreBracketsInTokens || (IgnoreBracketsInTokens = {}));
    function ignoreBracketsInToken(standardTokenType) {
        return (standardTokenType & 7 /* value */) !== 0;
    }
    exports.ignoreBracketsInToken = ignoreBracketsInToken;
});

define(__m[188/*vs/editor/common/modes/supports/characterPair*/], __M([1/*require*/,0/*exports*/,54/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharacterPairSupport = (function () {
        function CharacterPairSupport(config) {
            if (config.autoClosingPairs) {
                this._autoClosingPairs = config.autoClosingPairs.map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            }
            else if (config.brackets) {
                this._autoClosingPairs = config.brackets.map(function (b) { return new languageConfiguration_1.StandardAutoClosingPairConditional({ open: b[0], close: b[1] }); });
            }
            else {
                this._autoClosingPairs = [];
            }
            this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
        }
        CharacterPairSupport.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs;
        };
        CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, column) {
            // Always complete on empty line
            if (context.getTokenCount() === 0) {
                return true;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 2);
            var standardTokenType = context.getStandardTokenType(tokenIndex);
            for (var i = 0; i < this._autoClosingPairs.length; ++i) {
                var autoClosingPair = this._autoClosingPairs[i];
                if (autoClosingPair.open === character) {
                    return autoClosingPair.isOK(standardTokenType);
                }
            }
            return true;
        };
        CharacterPairSupport.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs;
        };
        return CharacterPairSupport;
    }());
    exports.CharacterPairSupport = CharacterPairSupport;
});

define(__m[189/*vs/editor/common/modes/supports/inplaceReplaceSupport*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BasicInplaceReplace = (function () {
        function BasicInplaceReplace() {
            this._defaultValueSet = [
                ['true', 'false'],
                ['True', 'False'],
                ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
                ['public', 'protected', 'private'],
            ];
        }
        BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {
            if (range1 && text1) {
                var result = this.doNavigateValueSet(text1, up);
                if (result) {
                    return {
                        range: range1,
                        value: result
                    };
                }
            }
            if (range2 && text2) {
                var result = this.doNavigateValueSet(text2, up);
                if (result) {
                    return {
                        range: range2,
                        value: result
                    };
                }
            }
            return null;
        };
        BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {
            var numberResult = this.numberReplace(text, up);
            if (numberResult !== null) {
                return numberResult;
            }
            return this.textReplace(text, up);
        };
        BasicInplaceReplace.prototype.numberReplace = function (value, up) {
            var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)), n1 = Number(value), n2 = parseFloat(value);
            if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
                if (n1 === 0 && !up) {
                    return null; // don't do negative
                }
                else {
                    n1 = Math.floor(n1 * precision);
                    n1 += up ? precision : -precision;
                    return String(n1 / precision);
                }
            }
            return null;
        };
        BasicInplaceReplace.prototype.textReplace = function (value, up) {
            return this.valueSetsReplace(this._defaultValueSet, value, up);
        };
        BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {
            var result = null;
            for (var i = 0, len = valueSets.length; result === null && i < len; i++) {
                result = this.valueSetReplace(valueSets[i], value, up);
            }
            return result;
        };
        BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {
            var idx = valueSet.indexOf(value);
            if (idx >= 0) {
                idx += up ? +1 : -1;
                if (idx < 0) {
                    idx = valueSet.length - 1;
                }
                else {
                    idx %= valueSet.length;
                }
                return valueSet[idx];
            }
            return null;
        };
        return BasicInplaceReplace;
    }());
    BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
    exports.BasicInplaceReplace = BasicInplaceReplace;
});

define(__m[190/*vs/editor/common/modes/supports/onEnter*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,9/*vs/base/common/strings*/,54/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, errors_1, strings, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OnEnterSupport = (function () {
        function OnEnterSupport(opts) {
            opts = opts || {};
            opts.brackets = opts.brackets || [
                ['(', ')'],
                ['{', '}'],
                ['[', ']']
            ];
            this._brackets = opts.brackets.map(function (bracket) {
                return {
                    open: bracket[0],
                    openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                    close: bracket[1],
                    closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
                };
            });
            this._regExpRules = opts.regExpRules || [];
            this._indentationRules = opts.indentationRules;
        }
        OnEnterSupport.prototype.onEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
            // (1): `regExpRules`
            for (var i = 0, len = this._regExpRules.length; i < len; i++) {
                var rule = this._regExpRules[i];
                if (rule.beforeText.test(beforeEnterText)) {
                    if (rule.afterText) {
                        if (rule.afterText.test(afterEnterText)) {
                            return rule.action;
                        }
                    }
                    else {
                        return rule.action;
                    }
                }
            }
            // (2): Special indent-outdent
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return OnEnterSupport._INDENT_OUTDENT;
                    }
                }
            }
            // (3): Indentation Support
            if (this._indentationRules) {
                if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (/^\s/.test(beforeEnterText)) {
                    // No reason to run regular expressions if there is nothing to outdent from
                    if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(afterEnterText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                    if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(oneLineAboveText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                }
            }
            // (4): Open bracket based logic
            if (beforeEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return OnEnterSupport._INDENT;
                    }
                }
            }
            return null;
        };
        OnEnterSupport._createOpenBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(0))) {
                str = '\\b' + str;
            }
            str += '\\s*$';
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._createCloseBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(str.length - 1))) {
                str = str + '\\b';
            }
            str = '^\\s*' + str;
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._safeRegExp = function (def) {
            try {
                return new RegExp(def);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
                return null;
            }
        };
        return OnEnterSupport;
    }());
    OnEnterSupport._INDENT = { indentAction: languageConfiguration_1.IndentAction.Indent };
    OnEnterSupport._INDENT_OUTDENT = { indentAction: languageConfiguration_1.IndentAction.IndentOutdent };
    OnEnterSupport._OUTDENT = { indentAction: languageConfiguration_1.IndentAction.Outdent };
    exports.OnEnterSupport = OnEnterSupport;
});

define(__m[73/*vs/editor/common/modes/supports/richEditBrackets*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditBracket = (function () {
        function RichEditBracket(languageIdentifier, open, close, forwardRegex, reversedRegex) {
            this.languageIdentifier = languageIdentifier;
            this.open = open;
            this.close = close;
            this.forwardRegex = forwardRegex;
            this.reversedRegex = reversedRegex;
        }
        return RichEditBracket;
    }());
    exports.RichEditBracket = RichEditBracket;
    var RichEditBrackets = (function () {
        function RichEditBrackets(languageIdentifier, brackets) {
            var _this = this;
            this.brackets = brackets.map(function (b) {
                return new RichEditBracket(languageIdentifier, b[0], b[1], getRegexForBracketPair({ open: b[0], close: b[1] }), getReversedRegexForBracketPair({ open: b[0], close: b[1] }));
            });
            this.forwardRegex = getRegexForBrackets(this.brackets);
            this.reversedRegex = getReversedRegexForBrackets(this.brackets);
            this.textIsBracket = {};
            this.textIsOpenBracket = {};
            var maxBracketLength = 0;
            this.brackets.forEach(function (b) {
                _this.textIsBracket[b.open.toLowerCase()] = b;
                _this.textIsBracket[b.close.toLowerCase()] = b;
                _this.textIsOpenBracket[b.open.toLowerCase()] = true;
                _this.textIsOpenBracket[b.close.toLowerCase()] = false;
                maxBracketLength = Math.max(maxBracketLength, b.open.length);
                maxBracketLength = Math.max(maxBracketLength, b.close.length);
            });
            this.maxBracketLength = maxBracketLength;
        }
        return RichEditBrackets;
    }());
    exports.RichEditBrackets = RichEditBrackets;
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createOrRegex([input.open, input.close]);
    });
    var getReversedRegexForBracketPair = once(function (input) { return input.open + ";" + input.close; }, function (input) {
        return createOrRegex([toReversedString(input.open), toReversedString(input.close)]);
    });
    var getRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(b.open);
            pieces.push(b.close);
        });
        return createOrRegex(pieces);
    });
    var getReversedRegexForBrackets = once(function (input) { return input.map(function (b) { return b.open + ";" + b.close; }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(toReversedString(b.open));
            pieces.push(toReversedString(b.close));
        });
        return createOrRegex(pieces);
    });
    function createOrRegex(pieces) {
        var regexStr = "(" + pieces.map(strings.escapeRegExpCharacters).join(')|(') + ")";
        return strings.createRegExp(regexStr, true);
    }
    var toReversedString = (function () {
        function reverse(str) {
            var reversedStr = '';
            for (var i = str.length - 1; i >= 0; i--) {
                reversedStr += str.charAt(i);
            }
            return reversedStr;
        }
        var lastInput = null;
        var lastOutput = null;
        return function toReversedString(str) {
            if (lastInput !== str) {
                lastInput = str;
                lastOutput = reverse(lastInput);
            }
            return lastOutput;
        };
    })();
    var BracketsUtils = (function () {
        function BracketsUtils() {
        }
        BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
            var m = reversedText.match(reversedBracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = reversedText.length - m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
        };
        BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
            var reversedLineText = toReversedString(lineText);
            var reversedTokenText = reversedLineText.substring(lineText.length - currentTokenEnd, lineText.length - currentTokenStart);
            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedTokenText, currentTokenStart);
        };
        BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
            var m = text.match(bracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
        };
        BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
        };
        return BracketsUtils;
    }());
    exports.BracketsUtils = BracketsUtils;
});

define(__m[192/*vs/editor/common/modes/supports/electricCharacter*/], __M([1/*require*/,0/*exports*/,81/*vs/editor/common/modes/supports*/,73/*vs/editor/common/modes/supports/richEditBrackets*/,54/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, supports_1, richEditBrackets_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BracketElectricCharacterSupport = (function () {
        function BracketElectricCharacterSupport(richEditBrackets, autoClosePairs, contribution) {
            contribution = contribution || {};
            this._richEditBrackets = richEditBrackets;
            this._complexAutoClosePairs = autoClosePairs.filter(function (pair) { return pair.open.length > 1 && !!pair.close; }).map(function (el) { return new languageConfiguration_1.StandardAutoClosingPairConditional(el); });
            if (contribution.docComment) {
                // IDocComment is legacy, only partially supported
                this._complexAutoClosePairs.push(new languageConfiguration_1.StandardAutoClosingPairConditional({ open: contribution.docComment.open, close: contribution.docComment.close }));
            }
        }
        BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
            var result = [];
            if (this._richEditBrackets) {
                for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                    var bracketPair = this._richEditBrackets.brackets[i];
                    var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                    result.push(lastChar);
                }
            }
            // auto close
            for (var _i = 0, _a = this._complexAutoClosePairs; _i < _a.length; _i++) {
                var pair = _a[_i];
                result.push(pair.open.charAt(pair.open.length - 1));
            }
            // Filter duplicate entries
            result = result.filter(function (item, pos, array) {
                return array.indexOf(item) === pos;
            });
            return result;
        };
        BracketElectricCharacterSupport.prototype.onElectricCharacter = function (character, context, column) {
            return (this._onElectricAutoClose(character, context, column) ||
                this._onElectricAutoIndent(character, context, column));
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoIndent = function (character, context, column) {
            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
                return null;
            }
            var tokenIndex = context.findTokenIndexAtOffset(column - 1);
            if (supports_1.ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {
                return null;
            }
            var reversedBracketRegex = this._richEditBrackets.reversedRegex;
            var text = context.getLineContent().substring(0, column - 1) + character;
            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, text, 0, text.length);
            if (!r) {
                return null;
            }
            var bracketText = text.substring(r.startColumn - 1, r.endColumn - 1);
            bracketText = bracketText.toLowerCase();
            var isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];
            if (isOpen) {
                return null;
            }
            return {
                matchOpenBracket: bracketText
            };
        };
        BracketElectricCharacterSupport.prototype._onElectricAutoClose = function (character, context, column) {
            if (!this._complexAutoClosePairs.length) {
                return null;
            }
            var line = context.getLineContent();
            for (var i = 0, len = this._complexAutoClosePairs.length; i < len; i++) {
                var pair = this._complexAutoClosePairs[i];
                // See if the right electric character was pressed
                if (character !== pair.open.charAt(pair.open.length - 1)) {
                    continue;
                }
                // check if the full open bracket matches
                var actual = line.substring(line.length - pair.open.length + 1) + character;
                if (actual !== pair.open) {
                    continue;
                }
                var lastTokenIndex = context.findTokenIndexAtOffset(column - 1);
                var lastTokenStandardType = context.getStandardTokenType(lastTokenIndex);
                // If we're in a scope listed in 'notIn', do nothing
                if (!pair.isOK(lastTokenStandardType)) {
                    continue;
                }
                // If this line already contains the closing tag, do nothing.
                if (line.indexOf(pair.close, column - 1) >= 0) {
                    continue;
                }
                return { appendText: pair.close };
            }
            return null;
        };
        return BracketElectricCharacterSupport;
    }());
    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
});

define(__m[37/*vs/editor/common/modes/languageConfigurationRegistry*/], __M([1/*require*/,0/*exports*/,188/*vs/editor/common/modes/supports/characterPair*/,192/*vs/editor/common/modes/supports/electricCharacter*/,190/*vs/editor/common/modes/supports/onEnter*/,73/*vs/editor/common/modes/supports/richEditBrackets*/,12/*vs/base/common/event*/,10/*vs/base/common/errors*/,9/*vs/base/common/strings*/,74/*vs/editor/common/model/wordHelper*/,81/*vs/editor/common/modes/supports*/,54/*vs/editor/common/modes/languageConfiguration*/]), function (require, exports, characterPair_1, electricCharacter_1, onEnter_1, richEditBrackets_1, event_1, errors_1, strings, wordHelper_1, supports_1, languageConfiguration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditSupport = (function () {
        function RichEditSupport(languageIdentifier, previous, rawConf) {
            var prev = null;
            if (previous) {
                prev = previous._conf;
            }
            this._conf = RichEditSupport._mergeConf(prev, rawConf);
            if (this._conf.brackets) {
                this.brackets = new richEditBrackets_1.RichEditBrackets(languageIdentifier, this._conf.brackets);
            }
            this.onEnter = RichEditSupport._handleOnEnter(this._conf);
            this.comments = RichEditSupport._handleComments(this._conf);
            this.characterPair = new characterPair_1.CharacterPairSupport(this._conf);
            this.electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(this.brackets, this.characterPair.getAutoClosingPairs(), this._conf.__electricCharacterSupport);
            this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;
        }
        RichEditSupport._mergeConf = function (prev, current) {
            return {
                comments: (prev ? current.comments || prev.comments : current.comments),
                brackets: (prev ? current.brackets || prev.brackets : current.brackets),
                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
                autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
                surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
            };
        };
        RichEditSupport._handleOnEnter = function (conf) {
            // on enter
            var onEnter = {};
            var empty = true;
            if (conf.brackets) {
                empty = false;
                onEnter.brackets = conf.brackets;
            }
            if (conf.indentationRules) {
                empty = false;
                onEnter.indentationRules = conf.indentationRules;
            }
            if (conf.onEnterRules) {
                empty = false;
                onEnter.regExpRules = conf.onEnterRules;
            }
            if (!empty) {
                return new onEnter_1.OnEnterSupport(onEnter);
            }
            return null;
        };
        RichEditSupport._handleComments = function (conf) {
            var commentRule = conf.comments;
            if (!commentRule) {
                return null;
            }
            // comment configuration
            var comments = {};
            if (commentRule.lineComment) {
                comments.lineCommentToken = commentRule.lineComment;
            }
            if (commentRule.blockComment) {
                var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
                comments.blockCommentStartToken = blockStart;
                comments.blockCommentEndToken = blockEnd;
            }
            return comments;
        };
        return RichEditSupport;
    }());
    exports.RichEditSupport = RichEditSupport;
    var LanguageConfigurationRegistryImpl = (function () {
        function LanguageConfigurationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._entries = [];
        }
        LanguageConfigurationRegistryImpl.prototype.register = function (languageIdentifier, configuration) {
            var _this = this;
            var previous = this._getRichEditSupport(languageIdentifier.id);
            var current = new RichEditSupport(languageIdentifier, previous, configuration);
            this._entries[languageIdentifier.id] = current;
            this._onDidChange.fire(void 0);
            return {
                dispose: function () {
                    if (_this._entries[languageIdentifier.id] === current) {
                        _this._entries[languageIdentifier.id] = previous;
                        _this._onDidChange.fire(void 0);
                    }
                }
            };
        };
        LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (languageId) {
            return this._entries[languageId] || null;
        };
        // begin electricCharacter
        LanguageConfigurationRegistryImpl.prototype._getElectricCharacterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.electricCharacter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getElectricCharacters = function (languageId) {
            var electricCharacterSupport = this._getElectricCharacterSupport(languageId);
            if (!electricCharacterSupport) {
                return [];
            }
            return electricCharacterSupport.getElectricCharacters();
        };
        /**
         * Should return opening bracket type to match indentation with
         */
        LanguageConfigurationRegistryImpl.prototype.onElectricCharacter = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var electricCharacterSupport = this._getElectricCharacterSupport(scopedLineTokens.languageId);
            if (!electricCharacterSupport) {
                return null;
            }
            return electricCharacterSupport.onElectricCharacter(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end electricCharacter
        LanguageConfigurationRegistryImpl.prototype.getComments = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.comments || null;
        };
        // begin characterPair
        LanguageConfigurationRegistryImpl.prototype._getCharacterPairSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.characterPair || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getAutoClosingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getAutoClosingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.getSurroundingPairs = function (languageId) {
            var characterPairSupport = this._getCharacterPairSupport(languageId);
            if (!characterPairSupport) {
                return [];
            }
            return characterPairSupport.getSurroundingPairs();
        };
        LanguageConfigurationRegistryImpl.prototype.shouldAutoClosePair = function (character, context, column) {
            var scopedLineTokens = supports_1.createScopedLineTokens(context, column - 1);
            var characterPairSupport = this._getCharacterPairSupport(scopedLineTokens.languageId);
            if (!characterPairSupport) {
                return false;
            }
            return characterPairSupport.shouldAutoClosePair(character, scopedLineTokens, column - scopedLineTokens.firstCharOffset);
        };
        // end characterPair
        LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return wordHelper_1.ensureValidWordDefinition(null);
            }
            return wordHelper_1.ensureValidWordDefinition(value.wordDefinition || null);
        };
        // begin onEnter
        LanguageConfigurationRegistryImpl.prototype._getOnEnterSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.onEnter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
            var lineTokens = model.getLineTokens(lineNumber, false);
            var scopedLineTokens = supports_1.createScopedLineTokens(lineTokens, column - 1);
            var onEnterSupport = this._getOnEnterSupport(scopedLineTokens.languageId);
            if (!onEnterSupport) {
                return null;
            }
            var scopedLineText = scopedLineTokens.getLineContent();
            var beforeEnterText = scopedLineText.substr(0, column - 1 - scopedLineTokens.firstCharOffset);
            var afterEnterText = scopedLineText.substr(column - 1 - scopedLineTokens.firstCharOffset);
            var oneLineAboveText = '';
            if (lineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
                // This is not the first line and the entire line belongs to this mode
                var oneLineAboveLineTokens = model.getLineTokens(lineNumber - 1, false);
                var oneLineAboveMaxColumn = model.getLineMaxColumn(lineNumber - 1);
                var oneLineAboveScopedLineTokens = supports_1.createScopedLineTokens(oneLineAboveLineTokens, oneLineAboveMaxColumn - 1);
                if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {
                    // The line above ends with text belonging to the same mode
                    oneLineAboveText = oneLineAboveScopedLineTokens.getLineContent();
                }
            }
            var result = null;
            try {
                result = onEnterSupport.onEnter(oneLineAboveText, beforeEnterText, afterEnterText);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            return result;
        };
        LanguageConfigurationRegistryImpl.prototype.getEnterActionAtPosition = function (model, lineNumber, column) {
            var lineText = model.getLineContent(lineNumber);
            var indentation = strings.getLeadingWhitespace(lineText);
            if (indentation.length > column - 1) {
                indentation = indentation.substring(0, column - 1);
            }
            var enterAction = this.getRawEnterActionAtPosition(model, lineNumber, column);
            if (!enterAction) {
                enterAction = {
                    indentAction: languageConfiguration_1.IndentAction.None,
                    appendText: '',
                };
            }
            else {
                if (!enterAction.appendText) {
                    if ((enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) ||
                        (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent)) {
                        enterAction.appendText = '\t';
                    }
                    else {
                        enterAction.appendText = '';
                    }
                }
            }
            if (enterAction.removeText) {
                indentation = indentation.substring(0, indentation.length - 1);
            }
            return {
                enterAction: enterAction,
                indentation: indentation
            };
        };
        // end onEnter
        LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (languageId) {
            var value = this._getRichEditSupport(languageId);
            if (!value) {
                return null;
            }
            return value.brackets || null;
        };
        return LanguageConfigurationRegistryImpl;
    }());
    exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;
    exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
});

define(__m[194/*vs/editor/common/modes/supports/tokenization*/], __M([1/*require*/,0/*exports*/,76/*vs/editor/common/core/lineTokens*/]), function (require, exports, lineTokens_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ParsedThemeRule = (function () {
        function ParsedThemeRule(token, index, fontStyle, foreground, background) {
            this.token = token;
            this.index = index;
            this.fontStyle = fontStyle;
            this.foreground = foreground;
            this.background = background;
        }
        return ParsedThemeRule;
    }());
    exports.ParsedThemeRule = ParsedThemeRule;
    /**
     * Parse a raw theme into rules.
     */
    function parseTheme(source) {
        if (!source || !Array.isArray(source)) {
            return [];
        }
        var result = [], resultLen = 0;
        for (var i = 0, len = source.length; i < len; i++) {
            var entry = source[i];
            var fontStyle = -1 /* NotSet */;
            if (typeof entry.fontStyle === 'string') {
                fontStyle = 0 /* None */;
                var segments = entry.fontStyle.split(' ');
                for (var j = 0, lenJ = segments.length; j < lenJ; j++) {
                    var segment = segments[j];
                    switch (segment) {
                        case 'italic':
                            fontStyle = fontStyle | 1 /* Italic */;
                            break;
                        case 'bold':
                            fontStyle = fontStyle | 2 /* Bold */;
                            break;
                        case 'underline':
                            fontStyle = fontStyle | 4 /* Underline */;
                            break;
                    }
                }
            }
            var foreground = null;
            if (typeof entry.foreground === 'string') {
                foreground = entry.foreground;
            }
            var background = null;
            if (typeof entry.background === 'string') {
                background = entry.background;
            }
            result[resultLen++] = new ParsedThemeRule(entry.token || '', i, fontStyle, foreground, background);
        }
        return result;
    }
    exports.parseTheme = parseTheme;
    /**
     * Resolve rules (i.e. inheritance).
     */
    function resolveParsedThemeRules(parsedThemeRules) {
        // Sort rules lexicographically, and then by index if necessary
        parsedThemeRules.sort(function (a, b) {
            var r = strcmp(a.token, b.token);
            if (r !== 0) {
                return r;
            }
            return a.index - b.index;
        });
        // Determine defaults
        var defaultFontStyle = 0 /* None */;
        var defaultForeground = '000000';
        var defaultBackground = 'ffffff';
        while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {
            var incomingDefaults = parsedThemeRules.shift();
            if (incomingDefaults.fontStyle !== -1 /* NotSet */) {
                defaultFontStyle = incomingDefaults.fontStyle;
            }
            if (incomingDefaults.foreground !== null) {
                defaultForeground = incomingDefaults.foreground;
            }
            if (incomingDefaults.background !== null) {
                defaultBackground = incomingDefaults.background;
            }
        }
        var colorMap = new ColorMap();
        // ensure default foreground gets id 1 and default background gets id 2
        var defaults = new ThemeTrieElementRule(defaultFontStyle, colorMap.getId(defaultForeground), colorMap.getId(defaultBackground));
        var root = new ThemeTrieElement(defaults);
        for (var i = 0, len = parsedThemeRules.length; i < len; i++) {
            var rule = parsedThemeRules[i];
            root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));
        }
        return new Theme(colorMap, root);
    }
    var ColorMap = (function () {
        function ColorMap() {
            this._lastColorId = 0;
            this._id2color = [];
            this._color2id = new Map();
        }
        ColorMap.prototype.getId = function (color) {
            if (color === null) {
                return 0;
            }
            color = color.toUpperCase();
            if (!/^[0-9A-F]{6}$/.test(color)) {
                throw new Error('Illegal color name: ' + color);
            }
            var value = this._color2id.get(color);
            if (value) {
                return value;
            }
            value = ++this._lastColorId;
            this._color2id.set(color, value);
            this._id2color[value] = color;
            return value;
        };
        ColorMap.prototype.getColorMap = function () {
            return this._id2color.slice(0);
        };
        return ColorMap;
    }());
    exports.ColorMap = ColorMap;
    var Theme = (function () {
        function Theme(colorMap, root) {
            this._colorMap = colorMap;
            this._root = root;
            this._cache = new Map();
        }
        Theme.createFromRawTheme = function (source) {
            return this.createFromParsedTheme(parseTheme(source));
        };
        Theme.createFromParsedTheme = function (source) {
            return resolveParsedThemeRules(source);
        };
        Theme.prototype.getColorMap = function () {
            return this._colorMap.getColorMap();
        };
        /**
         * used for testing purposes
         */
        Theme.prototype.getThemeTrieElement = function () {
            return this._root.toExternalThemeTrieElement();
        };
        Theme.prototype._match = function (token) {
            var result = this._cache.get(token);
            if (typeof result === 'undefined') {
                result = this._root.match(token);
                this._cache.set(token, result);
            }
            return result;
        };
        Theme.prototype.match = function (languageId, token) {
            var rule = this._match(token);
            var standardToken = lineTokens_1.toStandardTokenType(token);
            return (rule.metadata
                | (standardToken << 8 /* TOKEN_TYPE_OFFSET */)
                | (languageId << 0 /* LANGUAGEID_OFFSET */)) >>> 0;
        };
        return Theme;
    }());
    exports.Theme = Theme;
    function strcmp(a, b) {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    }
    exports.strcmp = strcmp;
    var ThemeTrieElementRule = (function () {
        function ThemeTrieElementRule(fontStyle, foreground, background) {
            this._fontStyle = fontStyle;
            this._foreground = foreground;
            this._background = background;
            this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)
                | (this._foreground << 14 /* FOREGROUND_OFFSET */)
                | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        }
        ThemeTrieElementRule.prototype.clone = function () {
            return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);
        };
        ThemeTrieElementRule.cloneArr = function (arr) {
            var r = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                r[i] = arr[i].clone();
            }
            return r;
        };
        ThemeTrieElementRule.prototype.acceptOverwrite = function (fontStyle, foreground, background) {
            if (fontStyle !== -1 /* NotSet */) {
                this._fontStyle = fontStyle;
            }
            if (foreground !== 0 /* None */) {
                this._foreground = foreground;
            }
            if (background !== 0 /* None */) {
                this._background = background;
            }
            this.metadata = ((this._fontStyle << 11 /* FONT_STYLE_OFFSET */)
                | (this._foreground << 14 /* FOREGROUND_OFFSET */)
                | (this._background << 23 /* BACKGROUND_OFFSET */)) >>> 0;
        };
        return ThemeTrieElementRule;
    }());
    exports.ThemeTrieElementRule = ThemeTrieElementRule;
    var ExternalThemeTrieElement = (function () {
        function ExternalThemeTrieElement(mainRule, children) {
            this.mainRule = mainRule;
            this.children = children || Object.create(null);
        }
        return ExternalThemeTrieElement;
    }());
    exports.ExternalThemeTrieElement = ExternalThemeTrieElement;
    var ThemeTrieElement = (function () {
        function ThemeTrieElement(mainRule) {
            this._mainRule = mainRule;
            this._children = new Map();
        }
        /**
         * used for testing purposes
         */
        ThemeTrieElement.prototype.toExternalThemeTrieElement = function () {
            var children = Object.create(null);
            this._children.forEach(function (element, index) {
                children[index] = element.toExternalThemeTrieElement();
            });
            return new ExternalThemeTrieElement(this._mainRule, children);
        };
        ThemeTrieElement.prototype.match = function (token) {
            if (token === '') {
                return this._mainRule;
            }
            var dotIndex = token.indexOf('.');
            var head;
            var tail;
            if (dotIndex === -1) {
                head = token;
                tail = '';
            }
            else {
                head = token.substring(0, dotIndex);
                tail = token.substring(dotIndex + 1);
            }
            var child = this._children.get(head);
            if (typeof child !== 'undefined') {
                return child.match(tail);
            }
            return this._mainRule;
        };
        ThemeTrieElement.prototype.insert = function (token, fontStyle, foreground, background) {
            if (token === '') {
                // Merge into the main rule
                this._mainRule.acceptOverwrite(fontStyle, foreground, background);
                return;
            }
            var dotIndex = token.indexOf('.');
            var head;
            var tail;
            if (dotIndex === -1) {
                head = token;
                tail = '';
            }
            else {
                head = token.substring(0, dotIndex);
                tail = token.substring(dotIndex + 1);
            }
            var child = this._children.get(head);
            if (typeof child === 'undefined') {
                child = new ThemeTrieElement(this._mainRule.clone());
                this._children.set(head, child);
            }
            child.insert(tail, fontStyle, foreground, background);
        };
        return ThemeTrieElement;
    }());
    exports.ThemeTrieElement = ThemeTrieElement;
});

define(__m[133/*vs/editor/common/modes/textToHtmlTokenizer*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,15/*vs/editor/common/modes*/,64/*vs/editor/common/modes/nullMode*/,76/*vs/editor/common/core/lineTokens*/]), function (require, exports, strings, modes_1, nullMode_1, lineTokens_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function tokenizeToString(text, languageId) {
        return _tokenizeToString(text, _getSafeTokenizationSupport(languageId));
    }
    exports.tokenizeToString = tokenizeToString;
    function _getSafeTokenizationSupport(languageId) {
        var tokenizationSupport = modes_1.TokenizationRegistry.get(languageId);
        if (tokenizationSupport) {
            return tokenizationSupport;
        }
        return {
            getInitialState: function () { return nullMode_1.NULL_STATE; },
            tokenize: undefined,
            tokenize2: function (buffer, state, deltaOffset) { return nullMode_1.nullTokenize2(0 /* Null */, buffer, state, deltaOffset); }
        };
    }
    function _tokenizeToString(text, tokenizationSupport) {
        var result = "<div class=\"monaco-tokenized-source\">";
        var lines = text.split(/\r\n|\r|\n/);
        var currentState = tokenizationSupport.getInitialState();
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            if (i > 0) {
                result += "<br/>";
            }
            var tokenizationResult = tokenizationSupport.tokenize2(line, currentState, 0);
            var lineTokens = new lineTokens_1.LineTokens(null, tokenizationResult.tokens, line);
            var viewLineTokens = lineTokens.inflate();
            var startOffset = 0;
            for (var j = 0, lenJ = viewLineTokens.length; j < lenJ; j++) {
                var viewLineToken = viewLineTokens[j];
                result += "<span class=\"" + viewLineToken.type + "\">" + strings.escape(line.substring(startOffset, viewLineToken.endIndex)) + "</span>";
                startOffset = viewLineToken.endIndex;
            }
            currentState = tokenizationResult.endState;
        }
        result += "</div>";
        return result;
    }
});

define(__m[196/*vs/editor/common/services/abstractCodeEditorService*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/]), function (require, exports, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractCodeEditorService = (function () {
        function AbstractCodeEditorService() {
            this._codeEditors = Object.create(null);
            this._onCodeEditorAdd = new event_1.Emitter();
            this._onCodeEditorRemove = new event_1.Emitter();
        }
        AbstractCodeEditorService.prototype.addCodeEditor = function (editor) {
            this._codeEditors[editor.getId()] = editor;
            this._onCodeEditorAdd.fire(editor);
        };
        Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorAdd", {
            get: function () {
                return this._onCodeEditorAdd.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractCodeEditorService.prototype.removeCodeEditor = function (editor) {
            if (delete this._codeEditors[editor.getId()]) {
                this._onCodeEditorRemove.fire(editor);
            }
        };
        Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorRemove", {
            get: function () {
                return this._onCodeEditorRemove.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractCodeEditorService.prototype.getCodeEditor = function (editorId) {
            return this._codeEditors[editorId] || null;
        };
        AbstractCodeEditorService.prototype.listCodeEditors = function () {
            var _this = this;
            return Object.keys(this._codeEditors).map(function (id) { return _this._codeEditors[id]; });
        };
        AbstractCodeEditorService.prototype.getFocusedCodeEditor = function () {
            var editorWithWidgetFocus = null;
            var editors = this.listCodeEditors();
            for (var i = 0; i < editors.length; i++) {
                var editor = editors[i];
                if (editor.isFocused()) {
                    // bingo!
                    return editor;
                }
                if (editor.hasWidgetFocus()) {
                    editorWithWidgetFocus = editor;
                }
            }
            return editorWithWidgetFocus;
        };
        return AbstractCodeEditorService;
    }());
    exports.AbstractCodeEditorService = AbstractCodeEditorService;
});

define(__m[136/*vs/editor/common/standalone/standaloneBase*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/,32/*vs/base/common/keyCodes*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,6/*vs/base/common/winjs.base*/,138/*vs/base/common/cancellation*/,82/*vs/editor/common/core/token*/,27/*vs/base/common/uri*/]), function (require, exports, event_1, keyCodes_1, position_1, range_1, selection_1, winjs_base_1, cancellation_1, token_1, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --------------------------------------------
    // This is repeated here so it can be exported
    // --------------------------------------------
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity = exports.Severity || (exports.Severity = {}));
    // --------------------------------------------
    // This is repeated here so it can be exported
    // --------------------------------------------
    var KeyMod = (function () {
        function KeyMod() {
        }
        KeyMod.chord = function (firstPart, secondPart) {
            return keyCodes_1.KeyChord(firstPart, secondPart);
        };
        return KeyMod;
    }());
    KeyMod.CtrlCmd = 2048 /* CtrlCmd */;
    KeyMod.Shift = 1024 /* Shift */;
    KeyMod.Alt = 512 /* Alt */;
    KeyMod.WinCtrl = 256 /* WinCtrl */;
    exports.KeyMod = KeyMod;
    // --------------------------------------------
    // This is repeated here so it can be exported
    // --------------------------------------------
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
     * But these are "more general", as they should work across browsers & OS`s.
     */
    var KeyCode;
    (function (KeyCode) {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
        KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
        KeyCode[KeyCode["Tab"] = 2] = "Tab";
        KeyCode[KeyCode["Enter"] = 3] = "Enter";
        KeyCode[KeyCode["Shift"] = 4] = "Shift";
        KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
        KeyCode[KeyCode["Alt"] = 6] = "Alt";
        KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
        KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
        KeyCode[KeyCode["Escape"] = 9] = "Escape";
        KeyCode[KeyCode["Space"] = 10] = "Space";
        KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
        KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
        KeyCode[KeyCode["End"] = 13] = "End";
        KeyCode[KeyCode["Home"] = 14] = "Home";
        KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
        KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
        KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
        KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
        KeyCode[KeyCode["Insert"] = 19] = "Insert";
        KeyCode[KeyCode["Delete"] = 20] = "Delete";
        KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
        KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
        KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
        KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
        KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
        KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
        KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
        KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
        KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
        KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
        KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
        KeyCode[KeyCode["Meta"] = 57] = "Meta";
        KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
        KeyCode[KeyCode["F1"] = 59] = "F1";
        KeyCode[KeyCode["F2"] = 60] = "F2";
        KeyCode[KeyCode["F3"] = 61] = "F3";
        KeyCode[KeyCode["F4"] = 62] = "F4";
        KeyCode[KeyCode["F5"] = 63] = "F5";
        KeyCode[KeyCode["F6"] = 64] = "F6";
        KeyCode[KeyCode["F7"] = 65] = "F7";
        KeyCode[KeyCode["F8"] = 66] = "F8";
        KeyCode[KeyCode["F9"] = 67] = "F9";
        KeyCode[KeyCode["F10"] = 68] = "F10";
        KeyCode[KeyCode["F11"] = 69] = "F11";
        KeyCode[KeyCode["F12"] = 70] = "F12";
        KeyCode[KeyCode["F13"] = 71] = "F13";
        KeyCode[KeyCode["F14"] = 72] = "F14";
        KeyCode[KeyCode["F15"] = 73] = "F15";
        KeyCode[KeyCode["F16"] = 74] = "F16";
        KeyCode[KeyCode["F17"] = 75] = "F17";
        KeyCode[KeyCode["F18"] = 76] = "F18";
        KeyCode[KeyCode["F19"] = 77] = "F19";
        KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
        KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
        KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
        KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
        KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
        KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
        KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
        KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
        KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
        KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
        KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
        KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
        KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
        KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
        KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
        KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
        KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        KeyCode[KeyCode["MAX_VALUE"] = 109] = "MAX_VALUE";
    })(KeyCode = exports.KeyCode || (exports.KeyCode = {}));
    function createMonacoBaseAPI() {
        return {
            editor: undefined,
            languages: undefined,
            CancellationTokenSource: cancellation_1.CancellationTokenSource,
            Emitter: event_1.Emitter,
            KeyCode: KeyCode,
            KeyMod: KeyMod,
            Keybinding: keyCodes_1.Keybinding,
            Position: position_1.Position,
            Range: range_1.Range,
            Selection: selection_1.Selection,
            SelectionDirection: selection_1.SelectionDirection,
            Severity: Severity,
            Promise: winjs_base_1.TPromise,
            Uri: uri_1.default,
            Token: token_1.Token
        };
    }
    exports.createMonacoBaseAPI = createMonacoBaseAPI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[198/*vs/editor/common/standalone/themes*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    /* -------------------------------- Begin vs tokens -------------------------------- */
    exports.vs = [
        { token: '', foreground: '000000' },
        { token: 'invalid', foreground: 'cd3131' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '001188' },
        { token: 'variable.predefined', foreground: '4864AA' },
        { token: 'constant', foreground: 'dd0000' },
        { token: 'comment', foreground: '008000' },
        { token: 'number', foreground: '09885A' },
        { token: 'number.hex', foreground: '3030c0' },
        { token: 'regexp', foreground: '800000' },
        { token: 'annotation', foreground: '808080' },
        { token: 'type', foreground: '008080' },
        { token: 'delimiter', foreground: '000000' },
        { token: 'delimiter.html', foreground: '383838' },
        { token: 'delimiter.xml', foreground: '0000FF' },
        { token: 'tag', foreground: '800000' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta.scss', foreground: '800000' },
        { token: 'metatag', foreground: 'e00000' },
        { token: 'metatag.content.html', foreground: 'FF0000' },
        { token: 'metatag.html', foreground: '808080' },
        { token: 'metatag.xml', foreground: '808080' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '863B00' },
        { token: 'string.key.json', foreground: 'A31515' },
        { token: 'string.value.json', foreground: '0451A5' },
        { token: 'attribute.name', foreground: 'FF0000' },
        { token: 'attribute.value', foreground: '0451A5' },
        { token: 'attribute.value.number', foreground: '09885A' },
        { token: 'attribute.value.unit', foreground: '09885A' },
        { token: 'attribute.value.html', foreground: '0000FF' },
        { token: 'attribute.value.xml', foreground: '0000FF' },
        { token: 'string', foreground: 'A31515' },
        { token: 'string.html', foreground: '0000FF' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'string.yaml', foreground: '0451A5' },
        { token: 'keyword', foreground: '0000FF' },
        { token: 'keyword.json', foreground: '0451A5' },
        { token: 'keyword.flow', foreground: 'AF00DB' },
        { token: 'keyword.flow.scss', foreground: '0000FF' },
        { token: 'operator.scss', foreground: '666666' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '666666' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ];
    /* -------------------------------- End vs tokens -------------------------------- */
    /* -------------------------------- Begin vs-dark tokens -------------------------------- */
    exports.vs_dark = [
        { token: '', foreground: 'D4D4D4' },
        { token: 'invalid', foreground: 'f44747' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '74B0DF' },
        { token: 'variable.predefined', foreground: '4864AA' },
        { token: 'variable.parameter', foreground: '9CDCFE' },
        { token: 'constant', foreground: '569CD6' },
        { token: 'comment', foreground: '608B4E' },
        { token: 'number', foreground: 'B5CEA8' },
        { token: 'number.hex', foreground: '5BB498' },
        { token: 'regexp', foreground: 'B46695' },
        { token: 'annotation', foreground: 'cc6666' },
        { token: 'type', foreground: '3DC9B0' },
        { token: 'delimiter', foreground: 'DCDCDC' },
        { token: 'delimiter.html', foreground: '808080' },
        { token: 'delimiter.xml', foreground: '808080' },
        { token: 'tag', foreground: '569CD6' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta.scss', foreground: 'A79873' },
        { token: 'meta.tag', foreground: 'CE9178' },
        { token: 'metatag', foreground: 'DD6A6F' },
        { token: 'metatag.content.html', foreground: '9CDCFE' },
        { token: 'metatag.html', foreground: '569CD6' },
        { token: 'metatag.xml', foreground: '569CD6' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '9CDCFE' },
        { token: 'string.key.json', foreground: '9CDCFE' },
        { token: 'string.value.json', foreground: 'CE9178' },
        { token: 'attribute.name', foreground: '9CDCFE' },
        { token: 'attribute.value', foreground: 'CE9178' },
        { token: 'attribute.value.number.css', foreground: 'B5CEA8' },
        { token: 'attribute.value.unit.css', foreground: 'B5CEA8' },
        { token: 'attribute.value.hex.css', foreground: 'D4D4D4' },
        { token: 'string', foreground: 'CE9178' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'keyword', foreground: '569CD6' },
        { token: 'keyword.flow', foreground: 'C586C0' },
        { token: 'keyword.json', foreground: 'CE9178' },
        { token: 'keyword.flow.scss', foreground: '569CD6' },
        { token: 'operator.scss', foreground: '909090' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '909090' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ];
    /* -------------------------------- End vs-dark tokens -------------------------------- */
    /* -------------------------------- Begin hc-black tokens -------------------------------- */
    exports.hc_black = [
        { token: '', foreground: 'FFFFFF' },
        { token: 'invalid', foreground: 'f44747' },
        { token: 'emphasis', fontStyle: 'italic' },
        { token: 'strong', fontStyle: 'bold' },
        { token: 'variable', foreground: '1AEBFF' },
        { token: 'variable.parameter', foreground: '9CDCFE' },
        { token: 'constant', foreground: '569CD6' },
        { token: 'comment', foreground: '608B4E' },
        { token: 'number', foreground: 'FFFFFF' },
        { token: 'regexp', foreground: 'C0C0C0' },
        { token: 'annotation', foreground: '569CD6' },
        { token: 'type', foreground: '3DC9B0' },
        { token: 'delimiter', foreground: 'FFFF00' },
        { token: 'delimiter.html', foreground: 'FFFF00' },
        { token: 'tag', foreground: '569CD6' },
        { token: 'tag.id.jade', foreground: '4F76AC' },
        { token: 'tag.class.jade', foreground: '4F76AC' },
        { token: 'meta', foreground: 'D4D4D4' },
        { token: 'meta.tag', foreground: 'CE9178' },
        { token: 'metatag', foreground: '569CD6' },
        { token: 'metatag.content.html', foreground: '1AEBFF' },
        { token: 'metatag.html', foreground: '569CD6' },
        { token: 'metatag.xml', foreground: '569CD6' },
        { token: 'metatag.php', fontStyle: 'bold' },
        { token: 'key', foreground: '9CDCFE' },
        { token: 'string.key', foreground: '9CDCFE' },
        { token: 'string.value', foreground: 'CE9178' },
        { token: 'attribute.name', foreground: '569CD6' },
        { token: 'attribute.value', foreground: '3FF23F' },
        { token: 'string', foreground: 'CE9178' },
        { token: 'string.sql', foreground: 'FF0000' },
        { token: 'keyword', foreground: '569CD6' },
        { token: 'keyword.flow', foreground: 'C586C0' },
        { token: 'operator.sql', foreground: '778899' },
        { token: 'operator.swift', foreground: '909090' },
        { token: 'predefined.sql', foreground: 'FF00FF' },
    ];
});
/* -------------------------------- End hc-black tokens -------------------------------- */

define(__m[199/*vs/editor/browser/services/standaloneColorServiceImpl*/], __M([1/*require*/,0/*exports*/,194/*vs/editor/common/modes/supports/tokenization*/,198/*vs/editor/common/standalone/themes*/,11/*vs/base/browser/dom*/,15/*vs/editor/common/modes*/]), function (require, exports, tokenization_1, themes_1, dom, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KnownTheme = (function () {
        function KnownTheme(cssClassName, rules) {
            this.cssClassName = cssClassName;
            this.rules = rules;
        }
        return KnownTheme;
    }());
    var VS_THEME_NAME = 'vs';
    var VS_DARK_THEME_NAME = 'vs-dark';
    var HC_BLACK_THEME_NAME = 'hc-black';
    function isBuiltinTheme(themeName) {
        return (themeName === VS_THEME_NAME
            || themeName === VS_DARK_THEME_NAME
            || themeName === HC_BLACK_THEME_NAME);
    }
    function getBuiltinRules(builtinTheme) {
        switch (builtinTheme) {
            case VS_THEME_NAME:
                return themes_1.vs;
            case VS_DARK_THEME_NAME:
                return themes_1.vs_dark;
            case HC_BLACK_THEME_NAME:
                return themes_1.hc_black;
        }
    }
    var StandaloneColorServiceImpl = (function () {
        function StandaloneColorServiceImpl() {
            this._knownThemes = new Map();
            this._knownThemes.set(VS_THEME_NAME, new KnownTheme(VS_THEME_NAME, getBuiltinRules(VS_THEME_NAME)));
            this._knownThemes.set(VS_DARK_THEME_NAME, new KnownTheme(VS_DARK_THEME_NAME, getBuiltinRules(VS_DARK_THEME_NAME)));
            this._knownThemes.set(HC_BLACK_THEME_NAME, new KnownTheme(HC_BLACK_THEME_NAME, getBuiltinRules(HC_BLACK_THEME_NAME)));
            this._styleElement = dom.createStyleSheet();
            this._styleElement.className = 'monaco-tokens-styles';
            this.setTheme(VS_THEME_NAME);
        }
        StandaloneColorServiceImpl._generateCSS = function (colorMap) {
            var rules = [];
            for (var i = 1, len = colorMap.length; i < len; i++) {
                var color = colorMap[i];
                rules[i] = ".mtk" + i + " { color: #" + color + "; }";
            }
            rules.push('.mtki { font-style: italic; }');
            rules.push('.mtkb { font-weight: bold; }');
            rules.push('.mtku { text-decoration: underline; }');
            return rules.join('\n');
        };
        StandaloneColorServiceImpl.prototype.defineTheme = function (themeName, themeData) {
            if (!/^[a-z0-9\-]+$/i.test(themeName) || isBuiltinTheme(themeName)) {
                throw new Error('Illegal theme name!');
            }
            if (!isBuiltinTheme(themeData.base)) {
                throw new Error('Illegal theme base!');
            }
            var cssClassName = themeData.base + ' ' + themeName;
            var rules = [];
            if (themeData.inherit) {
                rules = rules.concat(getBuiltinRules(themeData.base));
            }
            rules = rules.concat(themeData.rules);
            this._knownThemes.set(themeName, new KnownTheme(cssClassName, rules));
        };
        StandaloneColorServiceImpl.prototype.getTheme = function () {
            return this._theme;
        };
        StandaloneColorServiceImpl.prototype.setTheme = function (themeName) {
            var themeData;
            if (this._knownThemes.has(themeName)) {
                themeData = this._knownThemes.get(themeName);
            }
            else {
                themeData = this._knownThemes.get(VS_THEME_NAME);
            }
            this._theme = tokenization_1.Theme.createFromRawTheme(themeData.rules);
            var colorMap = this._theme.getColorMap();
            var cssRules = StandaloneColorServiceImpl._generateCSS(colorMap);
            this._styleElement.innerHTML = cssRules;
            modes_1.TokenizationRegistry.setColorMap(colorMap);
            return themeData.cssClassName;
        };
        return StandaloneColorServiceImpl;
    }());
    exports.StandaloneColorServiceImpl = StandaloneColorServiceImpl;
});

define(__m[83/*vs/editor/common/view/renderingContext*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RenderingContext = (function () {
        function RenderingContext(viewLines, layoutProvider, linesViewportData) {
            this._viewLines = viewLines;
            this._layoutProvider = layoutProvider;
            this.linesViewportData = linesViewportData;
            this.scrollWidth = this._layoutProvider.getScrollWidth();
            this.scrollHeight = this._layoutProvider.getScrollHeight();
            this.visibleRange = this.linesViewportData.visibleRange;
            this.bigNumbersDelta = this.linesViewportData.bigNumbersDelta;
            var vInfo = this._layoutProvider.getCurrentViewport();
            this.viewportWidth = vInfo.width;
            this.viewportHeight = vInfo.height;
            this.viewportLeft = vInfo.left;
            this.viewportTop = vInfo.top;
        }
        RenderingContext.prototype.getScrolledTopFromAbsoluteTop = function (absoluteTop) {
            return this._layoutProvider.getScrolledTopFromAbsoluteTop(absoluteTop);
        };
        RenderingContext.prototype.getViewportVerticalOffsetForLineNumber = function (lineNumber) {
            var verticalOffset = this._layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
            var scrolledTop = this._layoutProvider.getScrolledTopFromAbsoluteTop(verticalOffset);
            return scrolledTop;
        };
        RenderingContext.prototype.lineIsVisible = function (lineNumber) {
            return (this.linesViewportData.visibleRange.startLineNumber <= lineNumber
                && lineNumber <= this.linesViewportData.visibleRange.endLineNumber);
        };
        RenderingContext.prototype.getDecorationsInViewport = function () {
            return this.linesViewportData.getDecorationsInViewport();
        };
        RenderingContext.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
            return this._viewLines.linesVisibleRangesForRange(range, includeNewLines);
        };
        RenderingContext.prototype.visibleRangeForPosition = function (position) {
            var deltaTop = this.linesViewportData.visibleRangesDeltaTop;
            var visibleRanges = this._viewLines.visibleRangesForRange2(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), deltaTop);
            if (!visibleRanges) {
                return null;
            }
            return visibleRanges[0];
        };
        return RenderingContext;
    }());
    exports.RenderingContext = RenderingContext;
    var LineVisibleRanges = (function () {
        function LineVisibleRanges(lineNumber, ranges) {
            this.lineNumber = lineNumber;
            this.ranges = ranges;
        }
        return LineVisibleRanges;
    }());
    exports.LineVisibleRanges = LineVisibleRanges;
    var VisibleRange = (function () {
        function VisibleRange(top, left, width) {
            this.top = top | 0;
            this.left = left | 0;
            this.width = width | 0;
        }
        return VisibleRange;
    }());
    exports.VisibleRange = VisibleRange;
    var HorizontalRange = (function () {
        function HorizontalRange(left, width) {
            this.left = Math.round(left);
            this.width = Math.round(width);
        }
        HorizontalRange.prototype.toString = function () {
            return "[" + this.left + "," + this.width + "]";
        };
        return HorizontalRange;
    }());
    exports.HorizontalRange = HorizontalRange;
});

define(__m[201/*vs/editor/browser/viewParts/lines/rangeUtil*/], __M([1/*require*/,0/*exports*/,83/*vs/editor/common/view/renderingContext*/]), function (require, exports, renderingContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FloatHorizontalRange = (function () {
        function FloatHorizontalRange(left, width) {
            this.left = left;
            this.width = width;
        }
        FloatHorizontalRange.prototype.toString = function () {
            return "[" + this.left + "," + this.width + "]";
        };
        FloatHorizontalRange.compare = function (a, b) {
            return a.left - b.left;
        };
        return FloatHorizontalRange;
    }());
    var RangeUtil = (function () {
        function RangeUtil() {
        }
        RangeUtil._createRange = function () {
            if (!this._handyReadyRange) {
                this._handyReadyRange = document.createRange();
            }
            return this._handyReadyRange;
        };
        RangeUtil._detachRange = function (range, endNode) {
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            range.selectNodeContents(endNode);
        };
        RangeUtil._readClientRects = function (startElement, startOffset, endElement, endOffset, endNode) {
            var range = this._createRange();
            try {
                range.setStart(startElement, startOffset);
                range.setEnd(endElement, endOffset);
                return range.getClientRects();
            }
            catch (e) {
                // This is life ...
                return null;
            }
            finally {
                this._detachRange(range, endNode);
            }
        };
        RangeUtil._mergeAdjacentRanges = function (ranges) {
            if (ranges.length === 1) {
                // There is nothing to merge
                return [new renderingContext_1.HorizontalRange(ranges[0].left, ranges[0].width)];
            }
            ranges.sort(FloatHorizontalRange.compare);
            var result = [], resultLen = 0;
            var prevLeft = ranges[0].left;
            var prevWidth = ranges[0].width;
            for (var i = 1, len = ranges.length; i < len; i++) {
                var range = ranges[i];
                var myLeft = range.left;
                var myWidth = range.width;
                if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {
                    prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);
                }
                else {
                    result[resultLen++] = new renderingContext_1.HorizontalRange(prevLeft, prevWidth);
                    prevLeft = myLeft;
                    prevWidth = myWidth;
                }
            }
            result[resultLen++] = new renderingContext_1.HorizontalRange(prevLeft, prevWidth);
            return result;
        };
        RangeUtil._createHorizontalRangesFromClientRects = function (clientRects, clientRectDeltaLeft) {
            if (!clientRects || clientRects.length === 0) {
                return null;
            }
            // We go through FloatHorizontalRange because it has been observed in bi-di text
            // that the clientRects are not coming in sorted from the browser
            var result = [];
            for (var i = 0, len = clientRects.length; i < len; i++) {
                var clientRect = clientRects[i];
                result[i] = new FloatHorizontalRange(Math.max(0, clientRect.left - clientRectDeltaLeft), clientRect.width);
            }
            return this._mergeAdjacentRanges(result);
        };
        RangeUtil.readHorizontalRanges = function (domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, endNode) {
            // Panic check
            var min = 0;
            var max = domNode.children.length - 1;
            if (min > max) {
                return null;
            }
            startChildIndex = Math.min(max, Math.max(min, startChildIndex));
            endChildIndex = Math.min(max, Math.max(min, endChildIndex));
            // If crossing over to a span only to select offset 0, then use the previous span's maximum offset
            // Chrome is buggy and doesn't handle 0 offsets well sometimes.
            if (startChildIndex !== endChildIndex) {
                if (endChildIndex > 0 && endOffset === 0) {
                    endChildIndex--;
                    endOffset = Number.MAX_VALUE;
                }
            }
            var startElement = domNode.children[startChildIndex].firstChild;
            var endElement = domNode.children[endChildIndex].firstChild;
            if (!startElement || !endElement) {
                return null;
            }
            startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));
            endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));
            var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);
            return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft);
        };
        return RangeUtil;
    }());
    exports.RangeUtil = RangeUtil;
});

define(__m[202/*vs/editor/common/view/viewContext*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewContext = (function () {
        function ViewContext(configuration, model, privateViewEventBus, addEventHandler, removeEventHandler) {
            this.configuration = configuration;
            this.model = model;
            this.privateViewEventBus = privateViewEventBus;
            this.addEventHandler = addEventHandler;
            this.removeEventHandler = removeEventHandler;
        }
        return ViewContext;
    }());
    exports.ViewContext = ViewContext;
});

define(__m[116/*vs/editor/common/viewLayout/viewLineParts*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Decoration = (function () {
        function Decoration(startColumn, endColumn, className, insertsBeforeOrAfter) {
            this.startColumn = startColumn;
            this.endColumn = endColumn;
            this.className = className;
            this.insertsBeforeOrAfter = insertsBeforeOrAfter;
        }
        Decoration._equals = function (a, b) {
            return (a.startColumn === b.startColumn
                && a.endColumn === b.endColumn
                && a.className === b.className
                && a.insertsBeforeOrAfter === b.insertsBeforeOrAfter);
        };
        Decoration.equalsArr = function (a, b) {
            var aLen = a.length;
            var bLen = b.length;
            if (aLen !== bLen) {
                return false;
            }
            for (var i = 0; i < aLen; i++) {
                if (!Decoration._equals(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        Decoration.filter = function (lineDecorations, lineNumber, minLineColumn, maxLineColumn) {
            if (lineDecorations.length === 0) {
                return [];
            }
            var result = [], resultLen = 0;
            for (var i = 0, len = lineDecorations.length; i < len; i++) {
                var d = lineDecorations[i];
                var range = d.range;
                if (range.endLineNumber < lineNumber || range.startLineNumber > lineNumber) {
                    // Ignore decorations that sit outside this line
                    continue;
                }
                if (range.isEmpty()) {
                    // Ignore empty range decorations
                    continue;
                }
                var startColumn = (range.startLineNumber === lineNumber ? range.startColumn : minLineColumn);
                var endColumn = (range.endLineNumber === lineNumber ? range.endColumn : maxLineColumn);
                if (endColumn <= 1) {
                    // An empty decoration (endColumn === 1)
                    continue;
                }
                result[resultLen++] = new Decoration(startColumn, endColumn, d.inlineClassName, d.insertsBeforeOrAfter);
            }
            return result;
        };
        Decoration.compare = function (a, b) {
            if (a.startColumn === b.startColumn) {
                if (a.endColumn === b.endColumn) {
                    if (a.className < b.className) {
                        return -1;
                    }
                    if (a.className > b.className) {
                        return 1;
                    }
                    return 0;
                }
                return a.endColumn - b.endColumn;
            }
            return a.startColumn - b.startColumn;
        };
        return Decoration;
    }());
    exports.Decoration = Decoration;
    var DecorationSegment = (function () {
        function DecorationSegment(startOffset, endOffset, className) {
            this.startOffset = startOffset;
            this.endOffset = endOffset;
            this.className = className;
        }
        return DecorationSegment;
    }());
    exports.DecorationSegment = DecorationSegment;
    var Stack = (function () {
        function Stack() {
            this.stopOffsets = [];
            this.classNames = [];
            this.count = 0;
        }
        Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {
            while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {
                var i = 0;
                // Take all equal stopping offsets
                while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {
                    i++;
                }
                // Basically we are consuming the first i + 1 elements of the stack
                result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));
                nextStartOffset = this.stopOffsets[i] + 1;
                // Consume them
                this.stopOffsets.splice(0, i + 1);
                this.classNames.splice(0, i + 1);
                this.count -= (i + 1);
            }
            if (this.count > 0 && nextStartOffset < maxStopOffset) {
                result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));
                nextStartOffset = maxStopOffset;
            }
            return nextStartOffset;
        };
        Stack.prototype.insert = function (stopOffset, className) {
            if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {
                // Insert at the end
                this.stopOffsets.push(stopOffset);
                this.classNames.push(className);
            }
            else {
                // Find the insertion position for `stopOffset`
                for (var i = 0; i < this.count; i++) {
                    if (this.stopOffsets[i] >= stopOffset) {
                        this.stopOffsets.splice(i, 0, stopOffset);
                        this.classNames.splice(i, 0, className);
                        break;
                    }
                }
            }
            this.count++;
            return;
        };
        return Stack;
    }());
    var LineDecorationsNormalizer = (function () {
        function LineDecorationsNormalizer() {
        }
        /**
         * Normalize line decorations. Overlapping decorations will generate multiple segments
         */
        LineDecorationsNormalizer.normalize = function (lineDecorations) {
            if (lineDecorations.length === 0) {
                return [];
            }
            var result = [];
            var stack = new Stack();
            var nextStartOffset = 0;
            for (var i = 0, len = lineDecorations.length; i < len; i++) {
                var d = lineDecorations[i];
                var currentStartOffset = d.startColumn - 1;
                var currentEndOffset = d.endColumn - 2;
                nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);
                if (stack.count === 0) {
                    nextStartOffset = currentStartOffset;
                }
                stack.insert(currentEndOffset, d.className);
            }
            stack.consumeLowerThan(1073741824 /* MAX_SAFE_SMALL_INTEGER */, nextStartOffset, result);
            return result;
        };
        return LineDecorationsNormalizer;
    }());
    exports.LineDecorationsNormalizer = LineDecorationsNormalizer;
});

define(__m[117/*vs/editor/common/viewLayout/viewLineRenderer*/], __M([1/*require*/,0/*exports*/,77/*vs/editor/common/core/viewLineToken*/,116/*vs/editor/common/viewLayout/viewLineParts*/,9/*vs/base/common/strings*/]), function (require, exports, viewLineToken_1, viewLineParts_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RenderWhitespace;
    (function (RenderWhitespace) {
        RenderWhitespace[RenderWhitespace["None"] = 0] = "None";
        RenderWhitespace[RenderWhitespace["Boundary"] = 1] = "Boundary";
        RenderWhitespace[RenderWhitespace["All"] = 2] = "All";
    })(RenderWhitespace = exports.RenderWhitespace || (exports.RenderWhitespace = {}));
    var RenderLineInput = (function () {
        function RenderLineInput(fontIsMonospace, lineContent, mightContainRTL, fauxIndentLength, lineTokens, lineDecorations, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters) {
            this.fontIsMonospace = fontIsMonospace;
            this.lineContent = lineContent;
            this.mightContainRTL = mightContainRTL;
            this.fauxIndentLength = fauxIndentLength;
            this.lineTokens = lineTokens;
            this.lineDecorations = lineDecorations;
            this.tabSize = tabSize;
            this.spaceWidth = spaceWidth;
            this.stopRenderingLineAfter = stopRenderingLineAfter;
            this.renderWhitespace = (renderWhitespace === 'all'
                ? 2 /* All */
                : renderWhitespace === 'boundary'
                    ? 1 /* Boundary */
                    : 0 /* None */);
            this.renderControlCharacters = renderControlCharacters;
        }
        RenderLineInput.prototype.equals = function (other) {
            return (this.fontIsMonospace === other.fontIsMonospace
                && this.lineContent === other.lineContent
                && this.mightContainRTL === other.mightContainRTL
                && this.fauxIndentLength === other.fauxIndentLength
                && this.tabSize === other.tabSize
                && this.spaceWidth === other.spaceWidth
                && this.stopRenderingLineAfter === other.stopRenderingLineAfter
                && this.renderWhitespace === other.renderWhitespace
                && this.renderControlCharacters === other.renderControlCharacters
                && viewLineParts_1.Decoration.equalsArr(this.lineDecorations, other.lineDecorations)
                && viewLineToken_1.ViewLineToken.equalsArr(this.lineTokens, other.lineTokens));
        };
        return RenderLineInput;
    }());
    exports.RenderLineInput = RenderLineInput;
    var CharacterMappingConstants;
    (function (CharacterMappingConstants) {
        CharacterMappingConstants[CharacterMappingConstants["PART_INDEX_MASK"] = 4294901760] = "PART_INDEX_MASK";
        CharacterMappingConstants[CharacterMappingConstants["CHAR_INDEX_MASK"] = 65535] = "CHAR_INDEX_MASK";
        CharacterMappingConstants[CharacterMappingConstants["CHAR_INDEX_OFFSET"] = 0] = "CHAR_INDEX_OFFSET";
        CharacterMappingConstants[CharacterMappingConstants["PART_INDEX_OFFSET"] = 16] = "PART_INDEX_OFFSET";
    })(CharacterMappingConstants = exports.CharacterMappingConstants || (exports.CharacterMappingConstants = {}));
    /**
     * Provides a both direction mapping between a line's character and its rendered position.
     */
    var CharacterMapping = (function () {
        function CharacterMapping(length, partCount) {
            this.length = length;
            this._data = new Uint32Array(this.length);
            this._partLengths = new Uint16Array(partCount);
        }
        CharacterMapping.getPartIndex = function (partData) {
            return (partData & 4294901760 /* PART_INDEX_MASK */) >>> 16 /* PART_INDEX_OFFSET */;
        };
        CharacterMapping.getCharIndex = function (partData) {
            return (partData & 65535 /* CHAR_INDEX_MASK */) >>> 0 /* CHAR_INDEX_OFFSET */;
        };
        CharacterMapping.prototype.setPartData = function (charOffset, partIndex, charIndex) {
            var partData = ((partIndex << 16 /* PART_INDEX_OFFSET */)
                | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
            this._data[charOffset] = partData;
        };
        CharacterMapping.prototype.setPartLength = function (partIndex, length) {
            this._partLengths[partIndex] = length;
        };
        CharacterMapping.prototype.getPartLengths = function () {
            return this._partLengths;
        };
        CharacterMapping.prototype.charOffsetToPartData = function (charOffset) {
            if (this.length === 0) {
                return 0;
            }
            if (charOffset < 0) {
                return this._data[0];
            }
            if (charOffset >= this.length) {
                return this._data[this.length - 1];
            }
            return this._data[charOffset];
        };
        CharacterMapping.prototype.partDataToCharOffset = function (partIndex, partLength, charIndex) {
            if (this.length === 0) {
                return 0;
            }
            var searchEntry = ((partIndex << 16 /* PART_INDEX_OFFSET */)
                | (charIndex << 0 /* CHAR_INDEX_OFFSET */)) >>> 0;
            var min = 0;
            var max = this.length - 1;
            while (min + 1 < max) {
                var mid = ((min + max) >>> 1);
                var midEntry = this._data[mid];
                if (midEntry === searchEntry) {
                    return mid;
                }
                else if (midEntry > searchEntry) {
                    max = mid;
                }
                else {
                    min = mid;
                }
            }
            if (min === max) {
                return min;
            }
            var minEntry = this._data[min];
            var maxEntry = this._data[max];
            if (minEntry === searchEntry) {
                return min;
            }
            if (maxEntry === searchEntry) {
                return max;
            }
            var minPartIndex = CharacterMapping.getPartIndex(minEntry);
            var minCharIndex = CharacterMapping.getCharIndex(minEntry);
            var maxPartIndex = CharacterMapping.getPartIndex(maxEntry);
            var maxCharIndex;
            if (minPartIndex !== maxPartIndex) {
                // sitting between parts
                maxCharIndex = partLength;
            }
            else {
                maxCharIndex = CharacterMapping.getCharIndex(maxEntry);
            }
            var minEntryDistance = charIndex - minCharIndex;
            var maxEntryDistance = maxCharIndex - charIndex;
            if (minEntryDistance <= maxEntryDistance) {
                return min;
            }
            return max;
        };
        return CharacterMapping;
    }());
    exports.CharacterMapping = CharacterMapping;
    var RenderLineOutput = (function () {
        function RenderLineOutput(characterMapping, output, containsRTL, containsForeignElements) {
            this.characterMapping = characterMapping;
            this.output = output;
            this.containsRTL = containsRTL;
            this.containsForeignElements = containsForeignElements;
        }
        return RenderLineOutput;
    }());
    exports.RenderLineOutput = RenderLineOutput;
    function renderViewLine(input) {
        if (input.lineContent.length === 0) {
            return new RenderLineOutput(new CharacterMapping(0, 0), 
            // This is basically for IE's hit test to work
            '<span><span>&nbsp;</span></span>', false, false);
        }
        return _renderLine(resolveRenderLineInput(input));
    }
    exports.renderViewLine = renderViewLine;
    var ResolvedRenderLineInput = (function () {
        function ResolvedRenderLineInput(fontIsMonospace, lineContent, len, isOverflowing, tokens, containsForeignElements, tabSize, containsRTL, spaceWidth, renderWhitespace, renderControlCharacters) {
            this.fontIsMonospace = fontIsMonospace;
            this.lineContent = lineContent;
            this.len = len;
            this.isOverflowing = isOverflowing;
            this.tokens = tokens;
            this.containsForeignElements = containsForeignElements;
            this.tabSize = tabSize;
            this.containsRTL = containsRTL;
            this.spaceWidth = spaceWidth;
            this.renderWhitespace = renderWhitespace;
            this.renderControlCharacters = renderControlCharacters;
            //
        }
        return ResolvedRenderLineInput;
    }());
    function resolveRenderLineInput(input) {
        var fontIsMonospace = input.fontIsMonospace;
        var lineContent = input.lineContent;
        var isOverflowing;
        var len;
        if (input.stopRenderingLineAfter !== -1 && input.stopRenderingLineAfter < lineContent.length) {
            isOverflowing = true;
            len = input.stopRenderingLineAfter;
        }
        else {
            isOverflowing = false;
            len = lineContent.length;
        }
        var tokens = removeOverflowing(input.lineTokens, len);
        if (input.renderWhitespace === 2 /* All */ || input.renderWhitespace === 1 /* Boundary */) {
            tokens = _applyRenderWhitespace(lineContent, len, tokens, input.fauxIndentLength, input.tabSize, fontIsMonospace, input.renderWhitespace === 1 /* Boundary */);
        }
        var containsForeignElements = false;
        if (input.lineDecorations.length > 0) {
            for (var i = 0, len_1 = input.lineDecorations.length; i < len_1; i++) {
                var lineDecoration = input.lineDecorations[i];
                if (lineDecoration.insertsBeforeOrAfter) {
                    containsForeignElements = true;
                    break;
                }
            }
            tokens = _applyInlineDecorations(lineContent, len, tokens, input.lineDecorations);
        }
        var containsRTL = false;
        if (input.mightContainRTL) {
            containsRTL = strings.containsRTL(lineContent);
        }
        if (!containsRTL) {
            tokens = splitLargeTokens(tokens);
        }
        return new ResolvedRenderLineInput(fontIsMonospace, lineContent, len, isOverflowing, tokens, containsForeignElements, input.tabSize, containsRTL, input.spaceWidth, input.renderWhitespace, input.renderControlCharacters);
    }
    /**
     * In the rendering phase, characters are always looped until token.endIndex.
     * Ensure that all tokens end before `len` and the last one ends precisely at `len`.
     */
    function removeOverflowing(tokens, len) {
        if (tokens.length === 0) {
            return tokens;
        }
        if (tokens[tokens.length - 1].endIndex === len) {
            return tokens;
        }
        var result = [];
        for (var tokenIndex = 0, tokensLen = tokens.length; tokenIndex < tokensLen; tokenIndex++) {
            var endIndex = tokens[tokenIndex].endIndex;
            if (endIndex === len) {
                result[tokenIndex] = tokens[tokenIndex];
                break;
            }
            if (endIndex > len) {
                result[tokenIndex] = new viewLineToken_1.ViewLineToken(len, tokens[tokenIndex].type);
                break;
            }
            result[tokenIndex] = tokens[tokenIndex];
        }
        return result;
    }
    /**
     * written as a const enum to get value inlining.
     */
    var Constants;
    (function (Constants) {
        Constants[Constants["LongToken"] = 50] = "LongToken";
    })(Constants || (Constants = {}));
    /**
     * See https://github.com/Microsoft/vscode/issues/6885.
     * It appears that having very large spans causes very slow reading of character positions.
     * So here we try to avoid that.
     */
    function splitLargeTokens(tokens) {
        var lastTokenEndIndex = 0;
        var result = [], resultLen = 0;
        for (var i = 0, len = tokens.length; i < len; i++) {
            var token = tokens[i];
            var tokenEndIndex = token.endIndex;
            var diff = (tokenEndIndex - lastTokenEndIndex);
            if (diff > 50 /* LongToken */) {
                var tokenType = token.type;
                var piecesCount = Math.ceil(diff / 50 /* LongToken */);
                for (var j = 1; j < piecesCount; j++) {
                    var pieceEndIndex = lastTokenEndIndex + (j * 50 /* LongToken */);
                    result[resultLen++] = new viewLineToken_1.ViewLineToken(pieceEndIndex, tokenType);
                }
                result[resultLen++] = new viewLineToken_1.ViewLineToken(tokenEndIndex, tokenType);
            }
            else {
                result[resultLen++] = token;
            }
            lastTokenEndIndex = tokenEndIndex;
        }
        return result;
    }
    /**
     * Whitespace is rendered by "replacing" tokens with a special-purpose `vs-whitespace` type that is later recognized in the rendering phase.
     * Moreover, a token is created for every visual indent because on some fonts the glyphs used for rendering whitespace (&rarr; or &middot;) do not have the same width as &nbsp;.
     * The rendering phase will generate `style="width:..."` for these tokens.
     */
    function _applyRenderWhitespace(lineContent, len, tokens, fauxIndentLength, tabSize, fontIsMonospace, onlyBoundary) {
        var result = [], resultLen = 0;
        var tokenIndex = 0;
        var tokenType = tokens[tokenIndex].type;
        var tokenEndIndex = tokens[tokenIndex].endIndex;
        if (fauxIndentLength > 0) {
            result[resultLen++] = new viewLineToken_1.ViewLineToken(fauxIndentLength, '');
        }
        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
        var lastNonWhitespaceIndex;
        if (firstNonWhitespaceIndex === -1) {
            // The entire line is whitespace
            firstNonWhitespaceIndex = len;
            lastNonWhitespaceIndex = len;
        }
        else {
            lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
        }
        var tmpIndent = 0;
        for (var charIndex = 0; charIndex < fauxIndentLength; charIndex++) {
            var chCode = lineContent.charCodeAt(charIndex);
            if (chCode === 9 /* Tab */) {
                tmpIndent = tabSize;
            }
            else {
                tmpIndent++;
            }
        }
        tmpIndent = tmpIndent % tabSize;
        var wasInWhitespace = false;
        for (var charIndex = fauxIndentLength; charIndex < len; charIndex++) {
            var chCode = lineContent.charCodeAt(charIndex);
            var isInWhitespace = void 0;
            if (charIndex < firstNonWhitespaceIndex || charIndex > lastNonWhitespaceIndex) {
                // in leading or trailing whitespace
                isInWhitespace = true;
            }
            else if (chCode === 9 /* Tab */) {
                // a tab character is rendered both in all and boundary cases
                isInWhitespace = true;
            }
            else if (chCode === 32 /* Space */) {
                // hit a space character
                if (onlyBoundary) {
                    // rendering only boundary whitespace
                    if (wasInWhitespace) {
                        isInWhitespace = true;
                    }
                    else {
                        var nextChCode = (charIndex + 1 < len ? lineContent.charCodeAt(charIndex + 1) : 0 /* Null */);
                        isInWhitespace = (nextChCode === 32 /* Space */ || nextChCode === 9 /* Tab */);
                    }
                }
                else {
                    isInWhitespace = true;
                }
            }
            else {
                isInWhitespace = false;
            }
            if (wasInWhitespace) {
                // was in whitespace token
                if (!isInWhitespace || (!fontIsMonospace && tmpIndent >= tabSize)) {
                    // leaving whitespace token or entering a new indent
                    result[resultLen++] = new viewLineToken_1.ViewLineToken(charIndex, 'vs-whitespace');
                    tmpIndent = tmpIndent % tabSize;
                }
            }
            else {
                // was in regular token
                if (charIndex === tokenEndIndex || (isInWhitespace && charIndex > fauxIndentLength)) {
                    result[resultLen++] = new viewLineToken_1.ViewLineToken(charIndex, tokenType);
                    tmpIndent = tmpIndent % tabSize;
                }
            }
            if (chCode === 9 /* Tab */) {
                tmpIndent = tabSize;
            }
            else {
                tmpIndent++;
            }
            wasInWhitespace = isInWhitespace;
            if (charIndex === tokenEndIndex) {
                tokenIndex++;
                tokenType = tokens[tokenIndex].type;
                tokenEndIndex = tokens[tokenIndex].endIndex;
            }
        }
        if (wasInWhitespace) {
            // was in whitespace token
            result[resultLen++] = new viewLineToken_1.ViewLineToken(len, 'vs-whitespace');
        }
        else {
            // was in regular token
            result[resultLen++] = new viewLineToken_1.ViewLineToken(len, tokenType);
        }
        return result;
    }
    /**
     * Inline decorations are "merged" on top of tokens.
     * Special care must be taken when multiple inline decorations are at play and they overlap.
     */
    function _applyInlineDecorations(lineContent, len, tokens, _lineDecorations) {
        _lineDecorations.sort(viewLineParts_1.Decoration.compare);
        var lineDecorations = viewLineParts_1.LineDecorationsNormalizer.normalize(_lineDecorations);
        var lineDecorationsLen = lineDecorations.length;
        var lineDecorationIndex = 0;
        var result = [], resultLen = 0, lastResultEndIndex = 0;
        for (var tokenIndex = 0, len_2 = tokens.length; tokenIndex < len_2; tokenIndex++) {
            var token = tokens[tokenIndex];
            var tokenEndIndex = token.endIndex;
            var tokenType = token.type;
            while (lineDecorationIndex < lineDecorationsLen && lineDecorations[lineDecorationIndex].startOffset < tokenEndIndex) {
                var lineDecoration = lineDecorations[lineDecorationIndex];
                if (lineDecoration.startOffset > lastResultEndIndex) {
                    lastResultEndIndex = lineDecoration.startOffset;
                    result[resultLen++] = new viewLineToken_1.ViewLineToken(lastResultEndIndex, tokenType);
                }
                if (lineDecoration.endOffset + 1 <= tokenEndIndex) {
                    lastResultEndIndex = lineDecoration.endOffset + 1;
                    result[resultLen++] = new viewLineToken_1.ViewLineToken(lastResultEndIndex, tokenType + ' ' + lineDecoration.className);
                    lineDecorationIndex++;
                }
                else {
                    break;
                }
            }
            if (tokenEndIndex > lastResultEndIndex) {
                lastResultEndIndex = tokenEndIndex;
                result[resultLen++] = new viewLineToken_1.ViewLineToken(lastResultEndIndex, tokenType);
            }
        }
        return result;
    }
    /**
     * This function is on purpose not split up into multiple functions to allow runtime type inference (i.e. performance reasons).
     * Notice how all the needed data is fully resolved and passed in (i.e. no other calls).
     */
    function _renderLine(input) {
        var fontIsMonospace = input.fontIsMonospace;
        var containsForeignElements = input.containsForeignElements;
        var lineContent = input.lineContent;
        var len = input.len;
        var isOverflowing = input.isOverflowing;
        var tokens = input.tokens;
        var tabSize = input.tabSize;
        var containsRTL = input.containsRTL;
        var spaceWidth = input.spaceWidth;
        var renderWhitespace = input.renderWhitespace;
        var renderControlCharacters = input.renderControlCharacters;
        var characterMapping = new CharacterMapping(len + 1, tokens.length);
        var charIndex = 0;
        var tabsCharDelta = 0;
        var charOffsetInPart = 0;
        var out = '<span>';
        for (var tokenIndex = 0, tokensLen = tokens.length; tokenIndex < tokensLen; tokenIndex++) {
            var token = tokens[tokenIndex];
            var tokenEndIndex = token.endIndex;
            var tokenType = token.type;
            var tokenRendersWhitespace = (renderWhitespace !== 0 /* None */ && (tokenType.indexOf('vs-whitespace') >= 0));
            charOffsetInPart = 0;
            if (tokenRendersWhitespace) {
                var partContentCnt = 0;
                var partContent = '';
                for (; charIndex < tokenEndIndex; charIndex++) {
                    characterMapping.setPartData(charIndex, tokenIndex, charOffsetInPart);
                    var charCode = lineContent.charCodeAt(charIndex);
                    if (charCode === 9 /* Tab */) {
                        var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                        tabsCharDelta += insertSpacesCount - 1;
                        charOffsetInPart += insertSpacesCount - 1;
                        if (insertSpacesCount > 0) {
                            partContent += '&rarr;';
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                        while (insertSpacesCount > 0) {
                            partContent += '&nbsp;';
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                    }
                    else {
                        // must be CharCode.Space
                        partContent += '&middot;';
                        partContentCnt++;
                    }
                    charOffsetInPart++;
                }
                characterMapping.setPartLength(tokenIndex, partContentCnt);
                if (fontIsMonospace) {
                    out += "<span class=\"" + tokenType + "\">" + partContent + "</span>";
                }
                else {
                    out += "<span class=\"" + tokenType + "\" style=\"width:" + spaceWidth * partContentCnt + "px\">" + partContent + "</span>";
                }
            }
            else {
                var partContentCnt = 0;
                var partContent = '';
                for (; charIndex < tokenEndIndex; charIndex++) {
                    characterMapping.setPartData(charIndex, tokenIndex, charOffsetInPart);
                    var charCode = lineContent.charCodeAt(charIndex);
                    switch (charCode) {
                        case 9 /* Tab */:
                            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                            tabsCharDelta += insertSpacesCount - 1;
                            charOffsetInPart += insertSpacesCount - 1;
                            while (insertSpacesCount > 0) {
                                partContent += '&nbsp;';
                                partContentCnt++;
                                insertSpacesCount--;
                            }
                            break;
                        case 32 /* Space */:
                            partContent += '&nbsp;';
                            partContentCnt++;
                            break;
                        case 60 /* LessThan */:
                            partContent += '&lt;';
                            partContentCnt++;
                            break;
                        case 62 /* GreaterThan */:
                            partContent += '&gt;';
                            partContentCnt++;
                            break;
                        case 38 /* Ampersand */:
                            partContent += '&amp;';
                            partContentCnt++;
                            break;
                        case 0 /* Null */:
                            partContent += '&#00;';
                            partContentCnt++;
                            break;
                        case 65279 /* UTF8_BOM */:
                        case 8232 /* LINE_SEPARATOR_2028 */:
                            partContent += '\ufffd';
                            partContentCnt++;
                            break;
                        case 13 /* CarriageReturn */:
                            // zero width space, because carriage return would introduce a line break
                            partContent += '&#8203';
                            partContentCnt++;
                            break;
                        default:
                            if (renderControlCharacters && charCode < 32) {
                                partContent += String.fromCharCode(9216 + charCode);
                                partContentCnt++;
                            }
                            else {
                                partContent += String.fromCharCode(charCode);
                                partContentCnt++;
                            }
                    }
                    charOffsetInPart++;
                }
                characterMapping.setPartLength(tokenIndex, partContentCnt);
                if (containsRTL) {
                    out += "<span dir=\"ltr\" class=\"" + tokenType + "\">" + partContent + "</span>";
                }
                else {
                    out += "<span class=\"" + tokenType + "\">" + partContent + "</span>";
                }
            }
        }
        // When getting client rects for the last character, we will position the
        // text range at the end of the span, insteaf of at the beginning of next span
        characterMapping.setPartData(len, tokens.length - 1, charOffsetInPart);
        if (isOverflowing) {
            out += "<span class=\"vs-whitespace\">&hellip;</span>";
        }
        out += '</span>';
        return new RenderLineOutput(characterMapping, out, containsRTL, containsForeignElements);
    }
});

define(__m[144/*vs/editor/browser/standalone/colorizer*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,15/*vs/editor/common/modes*/,117/*vs/editor/common/viewLayout/viewLineRenderer*/,77/*vs/editor/common/core/viewLineToken*/,76/*vs/editor/common/core/lineTokens*/,9/*vs/base/common/strings*/]), function (require, exports, winjs_base_1, modes_1, viewLineRenderer_1, viewLineToken_1, lineTokens_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Colorizer = (function () {
        function Colorizer() {
        }
        Colorizer.colorizeElement = function (standaloneColorService, modeService, domNode, options) {
            options = options || {};
            var theme = options.theme || 'vs';
            var mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');
            if (!mimeType) {
                console.error('Mode not detected');
                return;
            }
            standaloneColorService.setTheme(theme);
            var text = domNode.firstChild.nodeValue;
            domNode.className += 'monaco-editor ' + theme;
            var render = function (str) {
                domNode.innerHTML = str;
            };
            return this.colorize(modeService, text, mimeType, options).then(render, function (err) { return console.error(err); }, render);
        };
        Colorizer._tokenizationSupportChangedPromise = function (language) {
            var listener = null;
            var stopListening = function () {
                if (listener) {
                    listener.dispose();
                    listener = null;
                }
            };
            return new winjs_base_1.TPromise(function (c, e, p) {
                listener = modes_1.TokenizationRegistry.onDidChange(function (e) {
                    if (e.languages.indexOf(language) >= 0) {
                        stopListening();
                        c(void 0);
                    }
                });
            }, stopListening);
        };
        Colorizer.colorize = function (modeService, text, mimeType, options) {
            if (strings.startsWithUTF8BOM(text)) {
                text = text.substr(1);
            }
            var lines = text.split(/\r\n|\r|\n/);
            var language = modeService.getModeId(mimeType);
            options = options || {};
            if (typeof options.tabSize === 'undefined') {
                options.tabSize = 4;
            }
            // Send out the event to create the mode
            modeService.getOrCreateMode(language);
            var tokenizationSupport = modes_1.TokenizationRegistry.get(language);
            if (tokenizationSupport) {
                return winjs_base_1.TPromise.as(_colorize(lines, options.tabSize, tokenizationSupport));
            }
            // wait 500ms for mode to load, then give up
            return winjs_base_1.TPromise.any([this._tokenizationSupportChangedPromise(language), winjs_base_1.TPromise.timeout(500)]).then(function (_) {
                var tokenizationSupport = modes_1.TokenizationRegistry.get(language);
                if (tokenizationSupport) {
                    return _colorize(lines, options.tabSize, tokenizationSupport);
                }
                return _fakeColorize(lines, options.tabSize);
            });
        };
        Colorizer.colorizeLine = function (line, mightContainRTL, tokens, tabSize) {
            if (tabSize === void 0) { tabSize = 4; }
            var renderResult = viewLineRenderer_1.renderViewLine(new viewLineRenderer_1.RenderLineInput(false, line, mightContainRTL, 0, tokens, [], tabSize, 0, -1, 'none', false));
            return renderResult.output;
        };
        Colorizer.colorizeModelLine = function (model, lineNumber, tabSize) {
            if (tabSize === void 0) { tabSize = 4; }
            var content = model.getLineContent(lineNumber);
            var tokens = model.getLineTokens(lineNumber, false);
            var inflatedTokens = tokens.inflate();
            return this.colorizeLine(content, model.mightContainRTL(), inflatedTokens, tabSize);
        };
        return Colorizer;
    }());
    exports.Colorizer = Colorizer;
    function _colorize(lines, tabSize, tokenizationSupport) {
        return _actualColorize(lines, tabSize, tokenizationSupport);
    }
    function _fakeColorize(lines, tabSize) {
        var html = [];
        for (var i = 0, length_1 = lines.length; i < length_1; i++) {
            var line = lines[i];
            var renderResult = viewLineRenderer_1.renderViewLine(new viewLineRenderer_1.RenderLineInput(false, line, false, 0, [new viewLineToken_1.ViewLineToken(line.length, '')], [], tabSize, 0, -1, 'none', false));
            html = html.concat(renderResult.output);
            html.push('<br/>');
        }
        return html.join('');
    }
    function _actualColorize(lines, tabSize, tokenizationSupport) {
        var html = [];
        var state = tokenizationSupport.getInitialState();
        var colorMap = modes_1.TokenizationRegistry.getColorMap();
        for (var i = 0, length_2 = lines.length; i < length_2; i++) {
            var line = lines[i];
            var tokenizeResult = tokenizationSupport.tokenize2(line, state, 0);
            var lineTokens = new lineTokens_1.LineTokens(colorMap, tokenizeResult.tokens, line);
            var renderResult = viewLineRenderer_1.renderViewLine(new viewLineRenderer_1.RenderLineInput(false, line, true /* check for RTL */, 0, lineTokens.inflate(), [], tabSize, 0, -1, 'none', false));
            html = html.concat(renderResult.output);
            html.push('<br/>');
            state = tokenizeResult.endState;
        }
        return html.join('');
    }
});






define(__m[206/*vs/editor/browser/viewParts/lines/viewLine*/], __M([1/*require*/,0/*exports*/,23/*vs/base/browser/browser*/,9/*vs/base/common/strings*/,29/*vs/base/browser/styleMutator*/,116/*vs/editor/common/viewLayout/viewLineParts*/,117/*vs/editor/common/viewLayout/viewLineRenderer*/,21/*vs/editor/browser/editorBrowser*/,201/*vs/editor/browser/viewParts/lines/rangeUtil*/,83/*vs/editor/common/view/renderingContext*/]), function (require, exports, browser, strings, styleMutator_1, viewLineParts_1, viewLineRenderer_1, editorBrowser_1, rangeUtil_1, renderingContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DomReadingContext = (function () {
        function DomReadingContext(domNode, endNode) {
            this._domNode = domNode;
            this._clientRectDeltaLeft = 0;
            this._clientRectDeltaLeftRead = false;
            this.endNode = endNode;
        }
        Object.defineProperty(DomReadingContext.prototype, "clientRectDeltaLeft", {
            get: function () {
                if (!this._clientRectDeltaLeftRead) {
                    this._clientRectDeltaLeftRead = true;
                    this._clientRectDeltaLeft = this._domNode.getBoundingClientRect().left;
                }
                return this._clientRectDeltaLeft;
            },
            enumerable: true,
            configurable: true
        });
        return DomReadingContext;
    }());
    exports.DomReadingContext = DomReadingContext;
    var ViewLine = (function () {
        function ViewLine(context) {
            this._context = context;
            this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
            this._renderControlCharacters = this._context.configuration.editor.viewInfo.renderControlCharacters;
            this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
            this._fontIsMonospace = this._context.configuration.editor.fontInfo.isMonospace;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
            this._isMaybeInvalid = true;
            this._renderedViewLine = null;
        }
        // --- begin IVisibleLineData
        ViewLine.prototype.getDomNode = function () {
            if (this._renderedViewLine && this._renderedViewLine.domNode) {
                return this._renderedViewLine.domNode.domNode;
            }
            return null;
        };
        ViewLine.prototype.setDomNode = function (domNode) {
            if (this._renderedViewLine) {
                this._renderedViewLine.domNode = styleMutator_1.createFastDomNode(domNode);
            }
            else {
                throw new Error('I have no rendered view line to set the dom node to...');
            }
        };
        ViewLine.prototype.onContentChanged = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onTokensChanged = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onModelDecorationsChanged = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.renderWhitespace) {
                this._isMaybeInvalid = true;
                this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
            }
            if (e.viewInfo.renderControlCharacters) {
                this._isMaybeInvalid = true;
                this._renderControlCharacters = this._context.configuration.editor.viewInfo.renderControlCharacters;
            }
            if (e.fontInfo) {
                this._isMaybeInvalid = true;
                this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
                this._fontIsMonospace = this._context.configuration.editor.fontInfo.isMonospace;
            }
            if (e.lineHeight) {
                this._isMaybeInvalid = true;
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.stopRenderingLineAfter) {
                this._isMaybeInvalid = true;
                this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
            }
        };
        ViewLine.prototype.shouldUpdateHTML = function (startLineNumber, lineNumber, inlineDecorations) {
            if (this._isMaybeInvalid === false) {
                // it appears that nothing relevant has changed
                return false;
            }
            this._isMaybeInvalid = false;
            var model = this._context.model;
            var actualInlineDecorations = viewLineParts_1.Decoration.filter(inlineDecorations, lineNumber, model.getLineMinColumn(lineNumber), model.getLineMaxColumn(lineNumber));
            var lineContent = model.getLineContent(lineNumber);
            var renderLineInput = new viewLineRenderer_1.RenderLineInput(this._fontIsMonospace, lineContent, model.mightContainRTL(), model.getLineMinColumn(lineNumber) - 1, model.getLineTokens(lineNumber), actualInlineDecorations, model.getTabSize(), this._spaceWidth, this._stopRenderingLineAfter, this._renderWhitespace, this._renderControlCharacters);
            if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {
                // no need to do anything, we have the same render input
                return false;
            }
            var output = viewLineRenderer_1.renderViewLine(renderLineInput);
            var renderedViewLine = null;
            if (this._fontIsMonospace && !output.containsForeignElements) {
                var isRegularASCII = true;
                if (model.mightContainNonBasicASCII()) {
                    isRegularASCII = strings.isBasicASCII(lineContent);
                }
                if (isRegularASCII && lineContent.length < 1000) {
                    // Browser rounding errors have been observed in Chrome and IE, so using the fast
                    // view line only for short lines. Please test before removing the length check...
                    renderedViewLine = new FastRenderedViewLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, output);
                }
            }
            if (!renderedViewLine) {
                var isWhitespaceOnly = /^\s*$/.test(renderLineInput.lineContent);
                renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, isWhitespaceOnly, output);
            }
            this._renderedViewLine = renderedViewLine;
            return true;
        };
        ViewLine.prototype.getLineOuterHTML = function (out, lineNumber, deltaTop) {
            out.push("<div lineNumber=\"" + lineNumber + "\" style=\"top:" + deltaTop + "px;height:" + this._lineHeight + "px;\" class=\"" + editorBrowser_1.ClassNames.VIEW_LINE + "\">");
            out.push(this.getLineInnerHTML(lineNumber));
            out.push("</div>");
        };
        ViewLine.prototype.getLineInnerHTML = function (lineNumber) {
            return this._renderedViewLine.html;
        };
        ViewLine.prototype.layoutLine = function (lineNumber, deltaTop) {
            this._renderedViewLine.domNode.setLineNumber(String(lineNumber));
            this._renderedViewLine.domNode.setTop(deltaTop);
            this._renderedViewLine.domNode.setHeight(this._lineHeight);
        };
        // --- end IVisibleLineData
        ViewLine.prototype.getWidth = function () {
            if (!this._renderedViewLine) {
                return 0;
            }
            return this._renderedViewLine.getWidth();
        };
        ViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
            return this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, context);
        };
        ViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
            return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);
        };
        return ViewLine;
    }());
    exports.ViewLine = ViewLine;
    /**
     * A rendered line which is guaranteed to contain only regular ASCII and is rendered with a monospace font.
     */
    var FastRenderedViewLine = (function () {
        function FastRenderedViewLine(domNode, renderLineInput, renderLineOutput) {
            this.domNode = domNode;
            this.input = renderLineInput;
            this.html = renderLineOutput.output;
            this._characterMapping = renderLineOutput.characterMapping;
            this._charWidth = renderLineInput.spaceWidth;
            this._charOffset = FastRenderedViewLine._createCharOffset(renderLineOutput.characterMapping);
        }
        FastRenderedViewLine._createCharOffset = function (characterMapping) {
            var partLengths = characterMapping.getPartLengths();
            var len = characterMapping.length;
            var result = new Uint32Array(len);
            var currentPartIndex = 0;
            var currentPartOffset = 0;
            for (var ch = 0; ch < len; ch++) {
                var partData = characterMapping.charOffsetToPartData(ch);
                var partIndex = viewLineRenderer_1.CharacterMapping.getPartIndex(partData);
                var charIndex = viewLineRenderer_1.CharacterMapping.getCharIndex(partData);
                while (currentPartIndex < partIndex) {
                    currentPartOffset += partLengths[currentPartIndex];
                    currentPartIndex++;
                }
                result[ch] = currentPartOffset + charIndex;
            }
            return result;
        };
        FastRenderedViewLine.prototype.getWidth = function () {
            if (this._charOffset.length === 0) {
                return 0;
            }
            var lastCharOffset = this._charOffset[this._charOffset.length - 1];
            return lastCharOffset * this._charWidth;
        };
        FastRenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
            startColumn = startColumn | 0; // @perf
            endColumn = endColumn | 0; // @perf
            var stopRenderingLineAfter = this.input.stopRenderingLineAfter | 0; // @perf
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {
                // This range is obviously not visible
                return null;
            }
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {
                startColumn = stopRenderingLineAfter;
            }
            if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {
                endColumn = stopRenderingLineAfter;
            }
            if (this._charOffset.length === 0) {
                return [new renderingContext_1.HorizontalRange(0, 0)];
            }
            var startCharOffset = this._charOffset[startColumn - 1];
            var endCharOffset = this._charOffset[endColumn - 1];
            return [new renderingContext_1.HorizontalRange(this._charWidth * startCharOffset, this._charWidth * (endCharOffset - startCharOffset))];
        };
        FastRenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
            var spanNodeTextContentLength = spanNode.textContent.length;
            var spanIndex = -1;
            while (spanNode) {
                spanNode = spanNode.previousSibling;
                spanIndex++;
            }
            var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
            return charOffset + 1;
        };
        return FastRenderedViewLine;
    }());
    /**
     * Every time we render a line, we save what we have rendered in an instance of this class.
     */
    var RenderedViewLine = (function () {
        function RenderedViewLine(domNode, renderLineInput, isWhitespaceOnly, renderLineOutput) {
            this.domNode = domNode;
            this.input = renderLineInput;
            this.html = renderLineOutput.output;
            this._characterMapping = renderLineOutput.characterMapping;
            this._isWhitespaceOnly = isWhitespaceOnly;
            this._cachedWidth = -1;
            this._pixelOffsetCache = null;
            if (!renderLineOutput.containsRTL) {
                this._pixelOffsetCache = new Int32Array(this._characterMapping.length + 1);
                for (var column = 0, len = this._characterMapping.length; column <= len; column++) {
                    this._pixelOffsetCache[column] = -1;
                }
            }
        }
        // --- Reading from the DOM methods
        RenderedViewLine.prototype._getReadingTarget = function () {
            return this.domNode.domNode.firstChild;
        };
        /**
         * Width of the line in pixels
         */
        RenderedViewLine.prototype.getWidth = function () {
            if (this._cachedWidth === -1) {
                this._cachedWidth = this._getReadingTarget().offsetWidth;
            }
            return this._cachedWidth;
        };
        /**
         * Visible ranges for a model range
         */
        RenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, context) {
            startColumn = startColumn | 0; // @perf
            endColumn = endColumn | 0; // @perf
            var stopRenderingLineAfter = this.input.stopRenderingLineAfter | 0; // @perf
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {
                // This range is obviously not visible
                return null;
            }
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {
                startColumn = stopRenderingLineAfter;
            }
            if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {
                endColumn = stopRenderingLineAfter;
            }
            if (this._pixelOffsetCache !== null) {
                // the text is LTR
                var startOffset = this._readPixelOffset(startColumn, context);
                if (startOffset === -1) {
                    return null;
                }
                var endOffset = this._readPixelOffset(endColumn, context);
                if (endOffset === -1) {
                    return null;
                }
                return [new renderingContext_1.HorizontalRange(startOffset, endOffset - startOffset)];
            }
            return this._readVisibleRangesForRange(startColumn, endColumn, context);
        };
        RenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {
            if (startColumn === endColumn) {
                var pixelOffset = this._readPixelOffset(startColumn, context);
                if (pixelOffset === -1) {
                    return null;
                }
                else {
                    return [new renderingContext_1.HorizontalRange(pixelOffset, 0)];
                }
            }
            else {
                return this._readRawVisibleRangesForRange(startColumn, endColumn, context);
            }
        };
        RenderedViewLine.prototype._readPixelOffset = function (column, context) {
            if (this._pixelOffsetCache !== null) {
                // the text is LTR
                var cachedPixelOffset = this._pixelOffsetCache[column];
                if (cachedPixelOffset !== -1) {
                    return cachedPixelOffset;
                }
                var result = this._actualReadPixelOffset(column, context);
                this._pixelOffsetCache[column] = result;
                return result;
            }
            return this._actualReadPixelOffset(column, context);
        };
        RenderedViewLine.prototype._actualReadPixelOffset = function (column, context) {
            if (this._characterMapping.length === 0) {
                // This line is empty
                return 0;
            }
            if (column === this._characterMapping.length && this._isWhitespaceOnly) {
                // This branch helps in the case of whitespace only lines which have a width set
                return this.getWidth();
            }
            var partData = this._characterMapping.charOffsetToPartData(column - 1);
            var partIndex = viewLineRenderer_1.CharacterMapping.getPartIndex(partData);
            var charOffsetInPart = viewLineRenderer_1.CharacterMapping.getCharIndex(partData);
            var r = rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), partIndex, charOffsetInPart, partIndex, charOffsetInPart, context.clientRectDeltaLeft, context.endNode);
            if (!r || r.length === 0) {
                return -1;
            }
            return r[0].left;
        };
        RenderedViewLine.prototype._readRawVisibleRangesForRange = function (startColumn, endColumn, context) {
            if (startColumn === 1 && endColumn === this._characterMapping.length) {
                // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line
                return [new renderingContext_1.HorizontalRange(0, this.getWidth())];
            }
            var startPartData = this._characterMapping.charOffsetToPartData(startColumn - 1);
            var startPartIndex = viewLineRenderer_1.CharacterMapping.getPartIndex(startPartData);
            var startCharOffsetInPart = viewLineRenderer_1.CharacterMapping.getCharIndex(startPartData);
            var endPartData = this._characterMapping.charOffsetToPartData(endColumn - 1);
            var endPartIndex = viewLineRenderer_1.CharacterMapping.getPartIndex(endPartData);
            var endCharOffsetInPart = viewLineRenderer_1.CharacterMapping.getCharIndex(endPartData);
            return rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, context.clientRectDeltaLeft, context.endNode);
        };
        /**
         * Returns the column for the text found at a specific offset inside a rendered dom node
         */
        RenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
            var spanNodeTextContentLength = spanNode.textContent.length;
            var spanIndex = -1;
            while (spanNode) {
                spanNode = spanNode.previousSibling;
                spanIndex++;
            }
            var charOffset = this._characterMapping.partDataToCharOffset(spanIndex, spanNodeTextContentLength, offset);
            return charOffset + 1;
        };
        return RenderedViewLine;
    }());
    var WebKitRenderedViewLine = (function (_super) {
        __extends(WebKitRenderedViewLine, _super);
        function WebKitRenderedViewLine() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        WebKitRenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, context) {
            var output = _super.prototype._readVisibleRangesForRange.call(this, startColumn, endColumn, context);
            if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._characterMapping.length)) {
                return output;
            }
            // WebKit is buggy and returns an expanded range (to contain words in some cases)
            // The last client rect is enlarged (I think)
            // This is an attempt to patch things up
            // Find position of previous column
            var beforeEndPixelOffset = this._readPixelOffset(endColumn - 1, context);
            // Find position of last column
            var endPixelOffset = this._readPixelOffset(endColumn, context);
            if (beforeEndPixelOffset !== -1 && endPixelOffset !== -1) {
                var isLTR = (beforeEndPixelOffset <= endPixelOffset);
                var lastRange = output[output.length - 1];
                if (isLTR && lastRange.left < endPixelOffset) {
                    // Trim down the width of the last visible range to not go after the last column's position
                    lastRange.width = endPixelOffset - lastRange.left;
                }
            }
            return output;
        };
        return WebKitRenderedViewLine;
    }(RenderedViewLine));
    var createRenderedLine = (function () {
        if (browser.isWebKit) {
            return createWebKitRenderedLine;
        }
        return createNormalRenderedLine;
    })();
    function createWebKitRenderedLine(domNode, renderLineInput, isWhitespaceOnly, renderLineOutput) {
        return new WebKitRenderedViewLine(domNode, renderLineInput, isWhitespaceOnly, renderLineOutput);
    }
    function createNormalRenderedLine(domNode, renderLineInput, isWhitespaceOnly, renderLineOutput) {
        return new RenderedViewLine(domNode, renderLineInput, isWhitespaceOnly, renderLineOutput);
    }
});

define(__m[207/*vs/editor/common/viewLayout/viewLinesViewportData*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewLinesViewportData = (function () {
        function ViewLinesViewportData(partialData, visibleRange, completelyVisibleLinesRange, decorationsData) {
            this.viewportTop = partialData.viewportTop | 0;
            this.viewportHeight = partialData.viewportHeight | 0;
            this.bigNumbersDelta = partialData.bigNumbersDelta | 0;
            this.visibleRangesDeltaTop = partialData.visibleRangesDeltaTop | 0;
            this.startLineNumber = partialData.startLineNumber | 0;
            this.endLineNumber = partialData.endLineNumber | 0;
            this.relativeVerticalOffset = partialData.relativeVerticalOffset;
            this.visibleRange = visibleRange;
            this.completelyVisibleLinesRange = completelyVisibleLinesRange;
            this._decorations = decorationsData.decorations;
            this._inlineDecorations = decorationsData.inlineDecorations;
        }
        ViewLinesViewportData.prototype.getDecorationsInViewport = function () {
            return this._decorations;
        };
        ViewLinesViewportData.prototype.getInlineDecorationsForLineInViewport = function (lineNumber) {
            lineNumber = lineNumber | 0;
            return this._inlineDecorations[lineNumber - this.startLineNumber];
        };
        return ViewLinesViewportData;
    }());
    exports.ViewLinesViewportData = ViewLinesViewportData;
});

define(__m[208/*vs/editor/common/viewLayout/whitespaceComputer*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Represent whitespaces in between lines and provide fast CRUD management methods.
     * The whitespaces are sorted ascending by `afterLineNumber`.
     */
    var WhitespaceComputer = (function () {
        function WhitespaceComputer() {
            this.heights = [];
            this.ids = [];
            this.afterLineNumbers = [];
            this.ordinals = [];
            this.prefixSum = [];
            this.prefixSumValidIndex = -1;
            this.whitespaceId2Index = {};
            this.lastWhitespaceId = 0;
        }
        /**
         * Find the insertion index for a new value inside a sorted array of values.
         * If the value is already present in the sorted array, the insertion index will be after the already existing value.
         */
        WhitespaceComputer.findInsertionIndex = function (sortedArray, value, ordinals, valueOrdinal) {
            var low = 0, high = sortedArray.length, mid;
            while (low < high) {
                mid = ((low + high) >>> 1);
                if (value === sortedArray[mid]) {
                    if (valueOrdinal < ordinals[mid]) {
                        high = mid;
                    }
                    else {
                        low = mid + 1;
                    }
                }
                else if (value < sortedArray[mid]) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            return low;
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        WhitespaceComputer.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
            afterLineNumber = afterLineNumber | 0;
            ordinal = ordinal | 0;
            heightInPx = heightInPx | 0;
            var id = (++this.lastWhitespaceId);
            var insertionIndex = WhitespaceComputer.findInsertionIndex(this.afterLineNumbers, afterLineNumber, this.ordinals, ordinal);
            this.insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx);
            return id;
        };
        WhitespaceComputer.prototype.insertWhitespaceAtIndex = function (id, insertIndex, afterLineNumber, ordinal, heightInPx) {
            id = id | 0;
            insertIndex = insertIndex | 0;
            afterLineNumber = afterLineNumber | 0;
            ordinal = ordinal | 0;
            heightInPx = heightInPx | 0;
            this.heights.splice(insertIndex, 0, heightInPx);
            this.ids.splice(insertIndex, 0, id);
            this.afterLineNumbers.splice(insertIndex, 0, afterLineNumber);
            this.ordinals.splice(insertIndex, 0, ordinal);
            this.prefixSum.splice(insertIndex, 0, 0);
            var keys = Object.keys(this.whitespaceId2Index);
            for (var i = 0, len = keys.length; i < len; i++) {
                var sid = keys[i];
                var oldIndex = this.whitespaceId2Index[sid];
                if (oldIndex >= insertIndex) {
                    this.whitespaceId2Index[sid] = oldIndex + 1;
                }
            }
            this.whitespaceId2Index[id.toString()] = insertIndex;
            this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, insertIndex - 1);
        };
        WhitespaceComputer.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            id = id | 0;
            newAfterLineNumber = newAfterLineNumber | 0;
            newHeight = newHeight | 0;
            var hasChanges = false;
            hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;
            hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;
            return hasChanges;
        };
        /**
         * Change the height of an existing whitespace
         *
         * @param id The whitespace to change
         * @param newHeightInPx The new height of the whitespace, in pixels
         * @return Returns true if the whitespace is found and if the new height is different than the old height
         */
        WhitespaceComputer.prototype.changeWhitespaceHeight = function (id, newHeightInPx) {
            id = id | 0;
            newHeightInPx = newHeightInPx | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                if (this.heights[index] !== newHeightInPx) {
                    this.heights[index] = newHeightInPx;
                    this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, index - 1);
                    return true;
                }
            }
            return false;
        };
        /**
         * Change the line number after which an existing whitespace flows.
         *
         * @param id The whitespace to change
         * @param newAfterLineNumber The new line number the whitespace will follow
         * @return Returns true if the whitespace is found and if the new line number is different than the old line number
         */
        WhitespaceComputer.prototype.changeWhitespaceAfterLineNumber = function (id, newAfterLineNumber) {
            id = id | 0;
            newAfterLineNumber = newAfterLineNumber | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                if (this.afterLineNumbers[index] !== newAfterLineNumber) {
                    // `afterLineNumber` changed for this whitespace
                    // Record old ordinal
                    var ordinal = this.ordinals[index];
                    // Record old height
                    var heightInPx = this.heights[index];
                    // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace
                    this.removeWhitespace(id);
                    // And add it again
                    var insertionIndex = WhitespaceComputer.findInsertionIndex(this.afterLineNumbers, newAfterLineNumber, this.ordinals, ordinal);
                    this.insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx);
                    return true;
                }
            }
            return false;
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        WhitespaceComputer.prototype.removeWhitespace = function (id) {
            id = id | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                delete this.whitespaceId2Index[sid];
                this.removeWhitespaceAtIndex(index);
                return true;
            }
            return false;
        };
        WhitespaceComputer.prototype.removeWhitespaceAtIndex = function (removeIndex) {
            removeIndex = removeIndex | 0;
            this.heights.splice(removeIndex, 1);
            this.ids.splice(removeIndex, 1);
            this.afterLineNumbers.splice(removeIndex, 1);
            this.ordinals.splice(removeIndex, 1);
            this.prefixSum.splice(removeIndex, 1);
            this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, removeIndex - 1);
            var keys = Object.keys(this.whitespaceId2Index);
            for (var i = 0, len = keys.length; i < len; i++) {
                var sid = keys[i];
                var oldIndex = this.whitespaceId2Index[sid];
                if (oldIndex >= removeIndex) {
                    this.whitespaceId2Index[sid] = oldIndex - 1;
                }
            }
        };
        /**
         * Notify the computer that lines have been deleted (a continuous zone of lines).
         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
         *
         * @param fromLineNumber The line number at which the deletion started, inclusive
         * @param toLineNumber The line number at which the deletion ended, inclusive
         */
        WhitespaceComputer.prototype.onModelLinesDeleted = function (fromLineNumber, toLineNumber) {
            fromLineNumber = fromLineNumber | 0;
            toLineNumber = toLineNumber | 0;
            var afterLineNumber, i, len;
            for (i = 0, len = this.afterLineNumbers.length; i < len; i++) {
                afterLineNumber = this.afterLineNumbers[i];
                if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {
                    // The line this whitespace was after has been deleted
                    //  => move whitespace to before first deleted line
                    this.afterLineNumbers[i] = fromLineNumber - 1;
                }
                else if (afterLineNumber > toLineNumber) {
                    // The line this whitespace was after has been moved up
                    //  => move whitespace up
                    this.afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);
                }
            }
        };
        /**
         * Notify the computer that lines have been inserted (a continuous zone of lines).
         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
         *
         * @param fromLineNumber The line number at which the insertion started, inclusive
         * @param toLineNumber The line number at which the insertion ended, inclusive.
         */
        WhitespaceComputer.prototype.onModelLinesInserted = function (fromLineNumber, toLineNumber) {
            fromLineNumber = fromLineNumber | 0;
            toLineNumber = toLineNumber | 0;
            var afterLineNumber, i, len;
            for (i = 0, len = this.afterLineNumbers.length; i < len; i++) {
                afterLineNumber = this.afterLineNumbers[i];
                if (fromLineNumber <= afterLineNumber) {
                    this.afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);
                }
            }
        };
        /**
         * Get the sum of all the whitespaces.
         */
        WhitespaceComputer.prototype.getTotalHeight = function () {
            if (this.heights.length === 0) {
                return 0;
            }
            return this.getAccumulatedHeight(this.heights.length - 1);
        };
        /**
         * Return the sum of the heights of the whitespaces at [0..index].
         * This includes the whitespace at `index`.
         *
         * @param index The index of the whitespace.
         * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
         */
        WhitespaceComputer.prototype.getAccumulatedHeight = function (index) {
            index = index | 0;
            var startIndex = Math.max(0, this.prefixSumValidIndex + 1);
            if (startIndex === 0) {
                this.prefixSum[0] = this.heights[0];
                startIndex++;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.heights[i];
            }
            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);
            return this.prefixSum[index];
        };
        /**
         * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.
         *
         * @param lineNumber The line number whitespaces should be before.
         * @return The sum of the heights of the whitespaces before `lineNumber`.
         */
        WhitespaceComputer.prototype.getAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            var lastWhitespaceBeforeLineNumber = this.findLastWhitespaceBeforeLineNumber(lineNumber);
            if (lastWhitespaceBeforeLineNumber === -1) {
                return 0;
            }
            return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);
        };
        WhitespaceComputer.prototype.findLastWhitespaceBeforeLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            // Find the whitespace before line number
            var afterLineNumbers = this.afterLineNumbers;
            var low = 0;
            var high = afterLineNumbers.length - 1;
            while (low <= high) {
                var delta = (high - low) | 0;
                var halfDelta = (delta / 2) | 0;
                var mid = (low + halfDelta) | 0;
                if (afterLineNumbers[mid] < lineNumber) {
                    if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {
                        return mid;
                    }
                    else {
                        low = (mid + 1) | 0;
                    }
                }
                else {
                    high = (mid - 1) | 0;
                }
            }
            return -1;
        };
        WhitespaceComputer.prototype.findFirstWhitespaceAfterLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            var lastWhitespaceBeforeLineNumber = this.findLastWhitespaceBeforeLineNumber(lineNumber);
            var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;
            if (firstWhitespaceAfterLineNumber < this.heights.length) {
                return firstWhitespaceAfterLineNumber;
            }
            return -1;
        };
        /**
         * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
         * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
         */
        WhitespaceComputer.prototype.getFirstWhitespaceIndexAfterLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            return this.findFirstWhitespaceAfterLineNumber(lineNumber);
        };
        /**
         * The number of whitespaces.
         */
        WhitespaceComputer.prototype.getCount = function () {
            return this.heights.length;
        };
        /**
         * Get the `afterLineNumber` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `afterLineNumber` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getAfterLineNumberForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.afterLineNumbers[index];
        };
        /**
         * Get the `id` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `id` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getIdForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.ids[index];
        };
        /**
         * Get the `height` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `height` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getHeightForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.heights[index];
        };
        WhitespaceComputer.prototype.getWhitespaces = function (deviceLineHeight) {
            deviceLineHeight = deviceLineHeight | 0;
            var result = [];
            for (var i = 0; i < this.heights.length; i++) {
                result.push({
                    id: this.ids[i],
                    afterLineNumber: this.afterLineNumbers[i],
                    heightInLines: this.heights[i] / deviceLineHeight
                });
            }
            return result;
        };
        return WhitespaceComputer;
    }());
    exports.WhitespaceComputer = WhitespaceComputer;
});

define(__m[209/*vs/editor/common/viewLayout/verticalObjects*/], __M([1/*require*/,0/*exports*/,208/*vs/editor/common/viewLayout/whitespaceComputer*/]), function (require, exports, whitespaceComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Layouting of objects that take vertical space (by having a height) and push down other objects.
     *
     * These objects are basically either text (lines) or spaces between those lines (whitespaces).
     * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).
     * This is written with no knowledge of an editor in mind.
     */
    var VerticalObjects = (function () {
        function VerticalObjects() {
            this.linesCount = 0;
            this.whitespaces = new whitespaceComputer_1.WhitespaceComputer();
        }
        /**
         * Set the number of lines.
         *
         * @param newLineCount New number of lines.
         */
        VerticalObjects.prototype.replaceLines = function (newLineCount) {
            this.linesCount = newLineCount;
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        VerticalObjects.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
            return this.whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx);
        };
        VerticalObjects.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        VerticalObjects.prototype.removeWhitespace = function (id) {
            return this.whitespaces.removeWhitespace(id);
        };
        /**
         * Notify the layouter that lines have been deleted (a continuous zone of lines).
         *
         * @param fromLineNumber The line number at which the deletion started, inclusive
         * @param toLineNumber The line number at which the deletion ended, inclusive
         */
        VerticalObjects.prototype.onModelLinesDeleted = function (fromLineNumber, toLineNumber) {
            this.linesCount -= (toLineNumber - fromLineNumber + 1);
            this.whitespaces.onModelLinesDeleted(fromLineNumber, toLineNumber);
        };
        /**
         * Notify the layouter that lines have been inserted (a continuous zone of lines).
         *
         * @param fromLineNumber The line number at which the insertion started, inclusive
         * @param toLineNumber The line number at which the insertion ended, inclusive.
         */
        VerticalObjects.prototype.onModelLinesInserted = function (fromLineNumber, toLineNumber) {
            this.linesCount += (toLineNumber - fromLineNumber + 1);
            this.whitespaces.onModelLinesInserted(fromLineNumber, toLineNumber);
        };
        /**
         * Get the sum of heights for all objects.
         *
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The sum of heights for all objects.
         */
        VerticalObjects.prototype.getTotalHeight = function (deviceLineHeight) {
            deviceLineHeight = deviceLineHeight | 0;
            var linesHeight = deviceLineHeight * this.linesCount;
            var whitespacesHeight = this.whitespaces.getTotalHeight();
            return linesHeight + whitespacesHeight;
        };
        /**
         * Get the vertical offset (the sum of heights for all objects above) a certain line number.
         *
         * @param lineNumber The line number
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The sum of heights for all objects above `lineNumber`.
         */
        VerticalObjects.prototype.getVerticalOffsetForLineNumber = function (lineNumber, deviceLineHeight) {
            lineNumber = lineNumber | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var previousLinesHeight;
            if (lineNumber > 1) {
                previousLinesHeight = deviceLineHeight * (lineNumber - 1);
            }
            else {
                previousLinesHeight = 0;
            }
            var previousWhitespacesHeight = this.whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
            return previousLinesHeight + previousWhitespacesHeight;
        };
        /**
         * Returns the accumulated height of whitespaces before the given line number.
         *
         * @param lineNumber The line number
         */
        VerticalObjects.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            return this.whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
        };
        /**
         * Returns if there is any whitespace in the document.
         */
        VerticalObjects.prototype.hasWhitespace = function () {
            return this.whitespaces.getCount() > 0;
        };
        VerticalObjects.prototype.isAfterLines = function (verticalOffset, deviceLineHeight) {
            var totalHeight = this.getTotalHeight(deviceLineHeight);
            return verticalOffset > totalHeight;
        };
        /**
         * Find the first line number that is at or after vertical offset `verticalOffset`.
         * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
         * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
         *
         * @param verticalOffset The vertical offset to search at.
         * @param deviceLineHeight The height, in piexels, for one rendered line.
         * @return The line number at or after vertical offset `verticalOffset`.
         */
        VerticalObjects.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            if (verticalOffset < 0) {
                return 1;
            }
            var minLineNumber = 1;
            var linesCount = this.linesCount | 0;
            var maxLineNumber = linesCount;
            while (minLineNumber < maxLineNumber) {
                var midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;
                var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber, deviceLineHeight) | 0;
                if (verticalOffset >= midLineNumberVerticalOffset + deviceLineHeight) {
                    // vertical offset is after mid line number
                    minLineNumber = midLineNumber + 1;
                }
                else if (verticalOffset >= midLineNumberVerticalOffset) {
                    // Hit
                    return midLineNumber;
                }
                else {
                    // vertical offset is before mid line number, but mid line number could still be what we're searching for
                    maxLineNumber = midLineNumber;
                }
            }
            if (minLineNumber > linesCount) {
                return linesCount;
            }
            return minLineNumber;
        };
        /**
         * Get the line that appears visually in the center between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The line number that is closest to the center between `verticalOffset1` and `verticalOffset2`.
         */
        VerticalObjects.prototype.getCenteredLineInViewport = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var viewportData = this.getLinesViewportData(verticalOffset1, verticalOffset2, deviceLineHeight);
            var verticalCenter = (verticalOffset2 - verticalOffset1) / 2;
            var currentLineActualTop, currentLineActualBottom;
            for (var lineNumber = viewportData.startLineNumber; lineNumber <= viewportData.endLineNumber; lineNumber++) {
                currentLineActualTop = viewportData.visibleRangesDeltaTop + viewportData.relativeVerticalOffset[lineNumber - viewportData.startLineNumber];
                currentLineActualBottom = currentLineActualTop + deviceLineHeight;
                if ((currentLineActualTop <= verticalCenter && verticalCenter < currentLineActualBottom) || currentLineActualTop > verticalCenter) {
                    return lineNumber;
                }
            }
            return viewportData.endLineNumber;
        };
        /**
         * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport.
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
         */
        VerticalObjects.prototype.getLinesViewportData = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            // Find first line number
            // We don't live in a perfect world, so the line number might start before or after verticalOffset1
            var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1, deviceLineHeight) | 0;
            var endLineNumber = this.linesCount | 0;
            var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber, deviceLineHeight) | 0;
            // Also keep track of what whitespace we've got
            var whitespaceIndex = this.whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;
            var whitespaceCount = this.whitespaces.getCount() | 0;
            var currentWhitespaceHeight;
            var currentWhitespaceAfterLineNumber;
            if (whitespaceIndex === -1) {
                whitespaceIndex = whitespaceCount;
                currentWhitespaceAfterLineNumber = endLineNumber + 1;
                currentWhitespaceHeight = 0;
            }
            else {
                currentWhitespaceAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
                currentWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
            }
            var currentVerticalOffset = startLineNumberVerticalOffset;
            var currentLineRelativeOffset = currentVerticalOffset;
            // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down
            var STEP_SIZE = 500000;
            var bigNumbersDelta = 0;
            if (startLineNumberVerticalOffset >= STEP_SIZE) {
                // Compute a delta that guarantees that lines are positioned at `lineHeight` increments
                bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;
                bigNumbersDelta = Math.floor(bigNumbersDelta / deviceLineHeight) * deviceLineHeight;
                currentLineRelativeOffset -= bigNumbersDelta;
            }
            var linesOffsets = [];
            // Figure out how far the lines go
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                // Count current line height in the vertical offsets
                currentVerticalOffset += deviceLineHeight;
                linesOffsets.push(currentLineRelativeOffset);
                // Next line starts immediately after this one
                currentLineRelativeOffset += deviceLineHeight;
                while (currentWhitespaceAfterLineNumber === lineNumber) {
                    // Push down next line with the height of the current whitespace
                    currentLineRelativeOffset += currentWhitespaceHeight;
                    // Count current whitespace in the vertical offsets
                    currentVerticalOffset += currentWhitespaceHeight;
                    whitespaceIndex++;
                    if (whitespaceIndex >= whitespaceCount) {
                        currentWhitespaceAfterLineNumber = endLineNumber + 1;
                    }
                    else {
                        currentWhitespaceAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
                        currentWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
                    }
                }
                if (currentVerticalOffset >= verticalOffset2) {
                    // We have covered the entire viewport area, time to stop
                    endLineNumber = lineNumber;
                    break;
                }
            }
            return {
                viewportTop: verticalOffset1 - bigNumbersDelta,
                viewportHeight: verticalOffset2 - verticalOffset1,
                bigNumbersDelta: bigNumbersDelta,
                startLineNumber: startLineNumber,
                endLineNumber: endLineNumber,
                visibleRangesDeltaTop: -(verticalOffset1 - bigNumbersDelta),
                relativeVerticalOffset: linesOffsets
            };
        };
        VerticalObjects.prototype.getVerticalOffsetForWhitespaceIndex = function (whitespaceIndex, deviceLineHeight) {
            whitespaceIndex = whitespaceIndex | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var afterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);
            var previousLinesHeight;
            if (afterLineNumber >= 1) {
                previousLinesHeight = deviceLineHeight * afterLineNumber;
            }
            else {
                previousLinesHeight = 0;
            }
            var previousWhitespacesHeight;
            if (whitespaceIndex > 0) {
                previousWhitespacesHeight = this.whitespaces.getAccumulatedHeight(whitespaceIndex - 1);
            }
            else {
                previousWhitespacesHeight = 0;
            }
            return previousLinesHeight + previousWhitespacesHeight;
        };
        VerticalObjects.prototype.getWhitespaceIndexAtOrAfterVerticallOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var midWhitespaceIndex, minWhitespaceIndex = 0, maxWhitespaceIndex = this.whitespaces.getCount() - 1, midWhitespaceVerticalOffset, midWhitespaceHeight;
            if (maxWhitespaceIndex < 0) {
                return -1;
            }
            // Special case: nothing to be found
            var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex, deviceLineHeight);
            var maxWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);
            if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {
                return -1;
            }
            while (minWhitespaceIndex < maxWhitespaceIndex) {
                midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);
                midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex, deviceLineHeight);
                midWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);
                if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {
                    // vertical offset is after whitespace
                    minWhitespaceIndex = midWhitespaceIndex + 1;
                }
                else if (verticalOffset >= midWhitespaceVerticalOffset) {
                    // Hit
                    return midWhitespaceIndex;
                }
                else {
                    // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for
                    maxWhitespaceIndex = midWhitespaceIndex;
                }
            }
            return minWhitespaceIndex;
        };
        /**
         * Get exactly the whitespace that is layouted at `verticalOffset`.
         *
         * @param verticalOffset The vertical offset.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
         */
        VerticalObjects.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset, deviceLineHeight);
            if (candidateIndex < 0) {
                return null;
            }
            if (candidateIndex >= this.whitespaces.getCount()) {
                return null;
            }
            var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex, deviceLineHeight);
            if (candidateTop > verticalOffset) {
                return null;
            }
            var candidateHeight = this.whitespaces.getHeightForWhitespaceIndex(candidateIndex);
            var candidateId = this.whitespaces.getIdForWhitespaceIndex(candidateIndex);
            var candidateAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);
            return {
                id: candidateId,
                afterLineNumber: candidateAfterLineNumber,
                verticalOffset: candidateTop,
                height: candidateHeight
            };
        };
        /**
         * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport.
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
         */
        VerticalObjects.prototype.getWhitespaceViewportData = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1, deviceLineHeight);
            var endIndex = this.whitespaces.getCount() - 1;
            if (startIndex < 0) {
                return [];
            }
            var result = [], i, top, height;
            for (i = startIndex; i <= endIndex; i++) {
                top = this.getVerticalOffsetForWhitespaceIndex(i, deviceLineHeight);
                height = this.whitespaces.getHeightForWhitespaceIndex(i);
                if (top >= verticalOffset2) {
                    break;
                }
                result.push({
                    id: this.whitespaces.getIdForWhitespaceIndex(i),
                    afterLineNumber: this.whitespaces.getAfterLineNumberForWhitespaceIndex(i),
                    verticalOffset: top,
                    height: height
                });
            }
            return result;
        };
        VerticalObjects.prototype.getWhitespaces = function (deviceLineHeight) {
            return this.whitespaces.getWhitespaces(deviceLineHeight);
        };
        return VerticalObjects;
    }());
    exports.VerticalObjects = VerticalObjects;
});

define(__m[210/*vs/editor/common/viewLayout/linesLayout*/], __M([1/*require*/,0/*exports*/,209/*vs/editor/common/viewLayout/verticalObjects*/,4/*vs/editor/common/core/range*/,207/*vs/editor/common/viewLayout/viewLinesViewportData*/]), function (require, exports, verticalObjects_1, range_1, viewLinesViewportData_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Layouting of objects that take vertical space (by having a height) and push down other objects.
     *
     * These objects are basically either text (lines) or spaces between those lines (whitespaces).
     * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).
     * This is a thin wrapper around VerticalObjects.VerticalObjects, with knowledge of the editor.
     */
    var LinesLayout = (function () {
        function LinesLayout(configuration, model) {
            this.configuration = configuration;
            this._lineHeight = this.configuration.editor.lineHeight;
            this._scrollBeyondLastLine = this.configuration.editor.viewInfo.scrollBeyondLastLine;
            this.model = model;
            this.verticalObjects = new verticalObjects_1.VerticalObjects();
            this.verticalObjects.replaceLines(model.getLineCount());
        }
        LinesLayout.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this.configuration.editor.lineHeight;
            }
            if (e.viewInfo.scrollBeyondLastLine) {
                this._scrollBeyondLastLine = this.configuration.editor.viewInfo.scrollBeyondLastLine;
            }
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        LinesLayout.prototype.insertWhitespace = function (afterLineNumber, ordinal, height) {
            return this.verticalObjects.insertWhitespace(afterLineNumber, ordinal, height);
        };
        LinesLayout.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.verticalObjects.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        LinesLayout.prototype.removeWhitespace = function (id) {
            return this.verticalObjects.removeWhitespace(id);
        };
        /**
         * Event handler, call when the model associated to this view has been flushed.
         */
        LinesLayout.prototype.onModelFlushed = function () {
            this.verticalObjects.replaceLines(this.model.getLineCount());
        };
        /**
         * Event handler, call when the model has had lines deleted.
         */
        LinesLayout.prototype.onModelLinesDeleted = function (e) {
            this.verticalObjects.onModelLinesDeleted(e.fromLineNumber, e.toLineNumber);
        };
        /**
         * Event handler, call when the model has had lines inserted.
         */
        LinesLayout.prototype.onModelLinesInserted = function (e) {
            this.verticalObjects.onModelLinesInserted(e.fromLineNumber, e.toLineNumber);
        };
        /**
         * Get the vertical offset (the sum of heights for all objects above) a certain line number.
         *
         * @param lineNumber The line number
         * @return The sum of heights for all objects above `lineNumber`.
         */
        LinesLayout.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
            return this.verticalObjects.getVerticalOffsetForLineNumber(lineNumber, this._lineHeight);
        };
        LinesLayout.prototype.getLinesTotalHeight = function () {
            return this.verticalObjects.getTotalHeight(this._lineHeight);
        };
        /**
         * Get the sum of heights for all objects and compute basically the `scrollHeight` for the editor content.
         *
         * Take into account the `scrollBeyondLastLine` and `reserveHorizontalScrollbarHeight` and produce a scrollHeight that is at least as large as `viewport`.height.
         *
         * @param viewport The viewport.
         * @param reserveHorizontalScrollbarHeight The height of the horizontal scrollbar.
         * @return Basically, the `scrollHeight` for the editor content.
         */
        LinesLayout.prototype.getTotalHeight = function (viewport, reserveHorizontalScrollbarHeight) {
            var totalLinesHeight = this.getLinesTotalHeight();
            //		if (this.context.configuration.editor.autoSize) {
            //			return linesHeight;
            //		}
            if (this._scrollBeyondLastLine) {
                totalLinesHeight += viewport.height - this._lineHeight;
            }
            else {
                totalLinesHeight += reserveHorizontalScrollbarHeight;
            }
            return Math.max(viewport.height, totalLinesHeight);
        };
        LinesLayout.prototype.isAfterLines = function (verticalOffset) {
            return this.verticalObjects.isAfterLines(verticalOffset, this._lineHeight);
        };
        /**
         * Find the first line number that is at or after vertical offset `verticalOffset`.
         * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
         * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
         *
         * @param verticalOffset The vertical offset to search at.
         * @return The line number at or after vertical offset `verticalOffset`.
         */
        LinesLayout.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset) {
            return this.verticalObjects.getLineNumberAtOrAfterVerticalOffset(verticalOffset, this._lineHeight);
        };
        /**
         * Get the height, in pixels, for line `lineNumber`.
         *
         * @param lineNumber The line number
         * @return The height, in pixels, for line `lineNumber`.
         */
        LinesLayout.prototype.getHeightForLineNumber = function (lineNumber) {
            return this._lineHeight;
        };
        /**
         * Get a list of whitespaces that are positioned inside `viewport`.
         *
         * @param viewport The viewport.
         * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
         */
        LinesLayout.prototype.getWhitespaceViewportData = function (visibleBox) {
            return this.verticalObjects.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
        };
        LinesLayout.prototype.getWhitespaces = function () {
            return this.verticalObjects.getWhitespaces(this._lineHeight);
        };
        /**
         * Get exactly the whitespace that is layouted at `verticalOffset`.
         *
         * @param verticalOffset The vertical offset.
         * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
         */
        LinesLayout.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
            return this.verticalObjects.getWhitespaceAtVerticalOffset(verticalOffset, this._lineHeight);
        };
        /**
         * Get all the lines and their relative vertical offsets that are positioned inside `viewport`.
         *
         * @param viewport The viewport.
         * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
         */
        LinesLayout.prototype.getLinesViewportData = function (visibleBox) {
            var partialData = this.verticalObjects.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
            var decorationsData = this.model.getDecorationsViewportData(partialData.startLineNumber, partialData.endLineNumber);
            var visibleRange = new range_1.Range(partialData.startLineNumber, 1, partialData.endLineNumber, this.model.getLineMaxColumn(partialData.endLineNumber));
            var startLineNumber = partialData.startLineNumber === partialData.endLineNumber || partialData.relativeVerticalOffset[0] >= partialData.viewportTop ? partialData.startLineNumber : partialData.startLineNumber + 1;
            var endLineNumber = partialData.relativeVerticalOffset[partialData.relativeVerticalOffset.length - 1] + this._lineHeight <= partialData.viewportTop + partialData.viewportHeight ? partialData.endLineNumber : partialData.endLineNumber - 1;
            var visibleRangeWithCompleteLines = new range_1.Range(startLineNumber, 1, endLineNumber, this.model.getLineMaxColumn(endLineNumber));
            return new viewLinesViewportData_1.ViewLinesViewportData(partialData, visibleRange, visibleRangeWithCompleteLines, decorationsData);
        };
        /**
         * Get the line that appears visually in the center of `viewport`.
         *
         * @param viewport The viewport.
         * @return The line number that is closest to the center of `viewport`.
         */
        LinesLayout.prototype.getCenteredLineInViewport = function (visibleBox) {
            return this.verticalObjects.getCenteredLineInViewport(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
        };
        /**
         * Returns the accumulated height of whitespaces before the given line number.
         *
         * @param lineNumber The line number
         */
        LinesLayout.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            return this.verticalObjects.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);
        };
        /**
         * Returns if there is any whitespace in the document.
         */
        LinesLayout.prototype.hasWhitespace = function () {
            return this.verticalObjects.hasWhitespace();
        };
        return LinesLayout;
    }());
    exports.LinesLayout = LinesLayout;
});

define(__m[85/*vs/editor/common/viewModel/prefixSumComputer*/], __M([1/*require*/,0/*exports*/,80/*vs/editor/common/core/uint*/]), function (require, exports, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PrefixSumIndexOfResult = (function () {
        function PrefixSumIndexOfResult(index, remainder) {
            this.index = index;
            this.remainder = remainder;
        }
        return PrefixSumIndexOfResult;
    }());
    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
    var PrefixSumComputer = (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = new Uint32Array(values.length);
            this.prefixSumValidIndex = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {
            insertIndex = uint_1.toUint32(insertIndex);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            var insertValuesLen = insertValues.length;
            if (insertValuesLen === 0) {
                return;
            }
            this.values = new Uint32Array(oldValues.length + insertValuesLen);
            this.values.set(oldValues.subarray(0, insertIndex), 0);
            this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
            this.values.set(insertValues, insertIndex);
            if (insertIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = insertIndex - 1;
            }
            this.prefixSum = new Uint32Array(this.values.length);
            if (this.prefixSumValidIndex >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex + 1));
            }
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            index = uint_1.toUint32(index);
            value = uint_1.toUint32(value);
            if (this.values[index] === value) {
                return;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = index - 1;
            }
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            startIndex = uint_1.toUint32(startIndex);
            cnt = uint_1.toUint32(cnt);
            var oldValues = this.values;
            var oldPrefixSum = this.prefixSum;
            if (startIndex >= oldValues.length) {
                return;
            }
            var maxCnt = oldValues.length - startIndex;
            if (cnt >= maxCnt) {
                cnt = maxCnt;
            }
            if (cnt === 0) {
                return;
            }
            this.values = new Uint32Array(oldValues.length - cnt);
            this.values.set(oldValues.subarray(0, startIndex), 0);
            this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
            this.prefixSum = new Uint32Array(this.values.length);
            if (startIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = startIndex - 1;
            }
            if (this.prefixSumValidIndex >= 0) {
                this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex + 1));
            }
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this.getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            if (index < 0) {
                return 0;
            }
            index = uint_1.toUint32(index);
            if (index <= this.prefixSumValidIndex) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            var low = 0;
            var high = this.values.length - 1;
            var mid;
            var midStop;
            var midStart;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.getAccumulatedValue(mid);
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
});

define(__m[212/*vs/editor/common/model/mirrorModel2*/], __M([1/*require*/,0/*exports*/,85/*vs/editor/common/viewModel/prefixSumComputer*/]), function (require, exports, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MirrorModel2 = (function () {
        function MirrorModel2(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
        }
        MirrorModel2.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorModel2.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel2.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorModel2.prototype.onEvents = function (events) {
            var newEOL = null;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.eol) {
                    newEOL = e.eol;
                }
            }
            if (newEOL && newEOL !== this._eol) {
                this._eol = newEOL;
                this._lineStarts = null;
            }
            // Update my lines
            var lastVersionId = -1;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._acceptDeleteRange(e.range);
                this._acceptInsertText({
                    lineNumber: e.range.startLineNumber,
                    column: e.range.startColumn
                }, e.text);
                lastVersionId = Math.max(lastVersionId, e.versionId);
            }
            if (lastVersionId !== -1) {
                this._versionId = lastVersionId;
            }
        };
        MirrorModel2.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var eolLength = this._eol.length;
                var linesLength = this._lines.length;
                var lineStartValues = new Uint32Array(linesLength);
                for (var i = 0; i < linesLength; i++) {
                    lineStartValues[i] = this._lines[i].length + eolLength;
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorModel2.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorModel2.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorModel2.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Uint32Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorModel2;
    }());
    exports.MirrorModel2 = MirrorModel2;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[213/*vs/editor/common/services/editorSimpleWorker*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,494/*vs/editor/common/diff/diffComputer*/,95/*vs/base/common/diff/diff*/,16/*vs/editor/common/core/position*/,212/*vs/editor/common/model/mirrorModel2*/,182/*vs/editor/common/modes/linkComputer*/,189/*vs/editor/common/modes/supports/inplaceReplaceSupport*/,74/*vs/editor/common/model/wordHelper*/,136/*vs/editor/common/standalone/standaloneBase*/]), function (require, exports, uri_1, winjs_base_1, range_1, diffComputer_1, diff_1, position_1, mirrorModel2_1, linkComputer_1, inplaceReplaceSupport_1, wordHelper_1, standaloneBase_1) {
    'use strict';
    /**
     * @internal
     */
    var MirrorModel = (function (_super) {
        __extends(MirrorModel, _super);
        function MirrorModel() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(MirrorModel.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MirrorModel.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MirrorModel.prototype, "eol", {
            get: function () {
                return this._eol;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel.prototype.getValue = function () {
            return this.getText();
        };
        MirrorModel.prototype.getLinesContent = function () {
            return this._lines.slice(0);
        };
        MirrorModel.prototype.getLineCount = function () {
            return this._lines.length;
        };
        MirrorModel.prototype.getLineContent = function (lineNumber) {
            return this._lines[lineNumber - 1];
        };
        MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {
            var wordAtText = wordHelper_1.getWordAtText(position.column, wordHelper_1.ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
            if (wordAtText) {
                return new range_1.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
            }
            return null;
        };
        MirrorModel.prototype.getWordUntilPosition = function (position, wordDefinition) {
            var wordAtPosition = this.getWordAtPosition(position, wordDefinition);
            if (!wordAtPosition) {
                return {
                    word: '',
                    startColumn: position.column,
                    endColumn: position.column
                };
            }
            return {
                word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),
                startColumn: wordAtPosition.startColumn,
                endColumn: position.column
            };
        };
        MirrorModel.prototype._getAllWords = function (wordDefinition) {
            var _this = this;
            var result = [];
            this._lines.forEach(function (line) {
                _this._wordenize(line, wordDefinition).forEach(function (info) {
                    result.push(line.substring(info.start, info.end));
                });
            });
            return result;
        };
        MirrorModel.prototype.getAllUniqueWords = function (wordDefinition, skipWordOnce) {
            var foundSkipWord = false;
            var uniqueWords = Object.create(null);
            return this._getAllWords(wordDefinition).filter(function (word) {
                if (skipWordOnce && !foundSkipWord && skipWordOnce === word) {
                    foundSkipWord = true;
                    return false;
                }
                else if (uniqueWords[word]) {
                    return false;
                }
                else {
                    uniqueWords[word] = true;
                    return true;
                }
            });
        };
        // TODO@Joh, TODO@Alex - remove these and make sure the super-things work
        MirrorModel.prototype._wordenize = function (content, wordDefinition) {
            var result = [];
            var match;
            wordDefinition.lastIndex = 0; // reset lastIndex just to be sure
            while (match = wordDefinition.exec(content)) {
                if (match[0].length === 0) {
                    // it did match the empty string
                    break;
                }
                result.push({ start: match.index, end: match.index + match[0].length });
            }
            return result;
        };
        MirrorModel.prototype.getValueInRange = function (range) {
            range = this._validateRange(range);
            if (range.startLineNumber === range.endLineNumber) {
                return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
            }
            var lineEnding = this._eol, startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        MirrorModel.prototype.offsetAt = function (position) {
            position = this._validatePosition(position);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);
        };
        MirrorModel.prototype.positionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].length;
            // Ensure we return a valid position
            return {
                lineNumber: 1 + out.index,
                column: 1 + Math.min(out.remainder, lineLength)
            };
        };
        MirrorModel.prototype._validateRange = function (range) {
            var start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
            var end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
            if (start.lineNumber !== range.startLineNumber
                || start.column !== range.startColumn
                || end.lineNumber !== range.endLineNumber
                || end.column !== range.endColumn) {
                return {
                    startLineNumber: start.lineNumber,
                    startColumn: start.column,
                    endLineNumber: end.lineNumber,
                    endColumn: end.column
                };
            }
            return range;
        };
        MirrorModel.prototype._validatePosition = function (position) {
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('bad position');
            }
            var lineNumber = position.lineNumber, column = position.column;
            var hasChanged = false;
            if (lineNumber < 1) {
                lineNumber = 1;
                column = 1;
                hasChanged = true;
            }
            else if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
                column = this._lines[lineNumber - 1].length + 1;
                hasChanged = true;
            }
            else {
                var maxCharacter = this._lines[lineNumber - 1].length + 1;
                if (column < 1) {
                    column = 1;
                    hasChanged = true;
                }
                else if (column > maxCharacter) {
                    column = maxCharacter;
                    hasChanged = true;
                }
            }
            if (!hasChanged) {
                return position;
            }
            else {
                return { lineNumber: lineNumber, column: column };
            }
        };
        return MirrorModel;
    }(mirrorModel2_1.MirrorModel2));
    /**
     * @internal
     */
    var BaseEditorSimpleWorker = (function () {
        function BaseEditorSimpleWorker() {
            this._foreignModule = null;
        }
        // ---- BEGIN diff --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {
            var original = this._getModel(originalUrl);
            var modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            var originalLines = original.getLinesContent();
            var modifiedLines = modified.getLinesContent();
            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {
                shouldPostProcessCharChanges: true,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldConsiderTrimWhitespaceInEmptyCase: true
            });
            return winjs_base_1.TPromise.as(diffComputer.computeDiff());
        };
        BaseEditorSimpleWorker.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {
            var original = this._getModel(originalUrl);
            var modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            var originalLines = original.getLinesContent();
            var modifiedLines = modified.getLinesContent();
            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {
                shouldPostProcessCharChanges: false,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldConsiderTrimWhitespaceInEmptyCase: false
            });
            return winjs_base_1.TPromise.as(diffComputer.computeDiff());
        };
        BaseEditorSimpleWorker.prototype.computeMoreMinimalEdits = function (modelUrl, edits, ranges) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return winjs_base_1.TPromise.as(edits);
            }
            var result = [];
            for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                var _a = edits_1[_i], range = _a.range, text = _a.text;
                var original = model.getValueInRange(range);
                text = text.replace(/\r\n|\n|\r/g, model.eol);
                if (original === text) {
                    // noop
                    continue;
                }
                // make sure diff won't take too long
                if (Math.max(text.length, original.length) > BaseEditorSimpleWorker._diffLimit) {
                    result.push({ range: range, text: text });
                    continue;
                }
                // compute diff between original and edit.text
                var changes = diff_1.stringDiff(original, text);
                var editOffset = model.offsetAt(range_1.Range.lift(range).getStartPosition());
                for (var _b = 0, changes_1 = changes; _b < changes_1.length; _b++) {
                    var change = changes_1[_b];
                    var start = model.positionAt(editOffset + change.originalStart);
                    var end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                    var newEdit = {
                        text: text.substr(change.modifiedStart, change.modifiedLength),
                        range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                    };
                    if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                        result.push(newEdit);
                    }
                }
            }
            return winjs_base_1.TPromise.as(result);
        };
        // ---- END minimal edits ---------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.computeLinks = function (modelUrl) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            return winjs_base_1.TPromise.as(linkComputer_1.computeLinks(model));
        };
        // ---- BEGIN suggest --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {
            var model = this._getModel(modelUrl);
            if (model) {
                var suggestions = [];
                var wordDefRegExp = new RegExp(wordDef, wordDefFlags);
                var currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;
                for (var _i = 0, _a = model.getAllUniqueWords(wordDefRegExp); _i < _a.length; _i++) {
                    var word = _a[_i];
                    if (word !== currentWord && isNaN(Number(word))) {
                        suggestions.push({
                            type: 'text',
                            label: word,
                            insertText: word,
                            noAutoAccept: true,
                            overwriteBefore: currentWord.length
                        });
                    }
                }
                return winjs_base_1.TPromise.as({ suggestions: suggestions });
            }
        };
        // ---- END suggest --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            var wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
                range = {
                    startLineNumber: range.startLineNumber,
                    startColumn: range.startColumn,
                    endLineNumber: range.endLineNumber,
                    endColumn: range.endColumn + 1
                };
            }
            var selectionText = model.getValueInRange(range);
            var wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            var word = null;
            if (wordRange !== null) {
                word = model.getValueInRange(wordRange);
            }
            var result = inplaceReplaceSupport_1.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return winjs_base_1.TPromise.as(result);
        };
        // ---- BEGIN foreign module support --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.loadForeignModule = function (moduleId, createData) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                // Use the global require to be sure to get the global config
                self.require([moduleId], function (foreignModule) {
                    var ctx = {
                        getMirrorModels: function () {
                            return _this._getModels();
                        }
                    };
                    _this._foreignModule = foreignModule.create(ctx, createData);
                    var methods = [];
                    for (var prop in _this._foreignModule) {
                        if (typeof _this._foreignModule[prop] === 'function') {
                            methods.push(prop);
                        }
                    }
                    c(methods);
                }, e);
            });
        };
        // foreign method request
        BaseEditorSimpleWorker.prototype.fmr = function (method, args) {
            if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));
            }
            try {
                return winjs_base_1.TPromise.as(this._foreignModule[method].apply(this._foreignModule, args));
            }
            catch (e) {
                return winjs_base_1.TPromise.wrapError(e);
            }
        };
        return BaseEditorSimpleWorker;
    }());
    // ---- END diff --------------------------------------------------------------------------
    // ---- BEGIN minimal edits ---------------------------------------------------------------
    BaseEditorSimpleWorker._diffLimit = 10000;
    exports.BaseEditorSimpleWorker = BaseEditorSimpleWorker;
    /**
     * @internal
     */
    var EditorSimpleWorkerImpl = (function (_super) {
        __extends(EditorSimpleWorkerImpl, _super);
        function EditorSimpleWorkerImpl() {
            var _this = _super.call(this) || this;
            _this._models = Object.create(null);
            return _this;
        }
        EditorSimpleWorkerImpl.prototype.dispose = function () {
            this._models = Object.create(null);
        };
        EditorSimpleWorkerImpl.prototype._getModel = function (uri) {
            return this._models[uri];
        };
        EditorSimpleWorkerImpl.prototype._getModels = function () {
            var _this = this;
            var all = [];
            Object.keys(this._models).forEach(function (key) { return all.push(_this._models[key]); });
            return all;
        };
        EditorSimpleWorkerImpl.prototype.acceptNewModel = function (data) {
            this._models[data.url] = new MirrorModel(uri_1.default.parse(data.url), data.value.lines, data.value.EOL, data.versionId);
        };
        EditorSimpleWorkerImpl.prototype.acceptModelChanged = function (strURL, events) {
            if (!this._models[strURL]) {
                return;
            }
            var model = this._models[strURL];
            model.onEvents(events);
        };
        EditorSimpleWorkerImpl.prototype.acceptRemovedModel = function (strURL) {
            if (!this._models[strURL]) {
                return;
            }
            delete this._models[strURL];
        };
        return EditorSimpleWorkerImpl;
    }(BaseEditorSimpleWorker));
    exports.EditorSimpleWorkerImpl = EditorSimpleWorkerImpl;
    /**
     * Called on the worker side
     * @internal
     */
    function create() {
        return new EditorSimpleWorkerImpl();
    }
    exports.create = create;
    var global = self;
    var isWebWorker = (typeof global.importScripts === 'function');
    if (isWebWorker) {
        global.monaco = standaloneBase_1.createMonacoBaseAPI();
    }
});

define(__m[146/*vs/editor/common/viewModel/viewModel*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InlineDecoration = (function () {
        function InlineDecoration(range, inlineClassName, insertsBeforeOrAfter) {
            this.range = range;
            this.inlineClassName = inlineClassName;
            this.insertsBeforeOrAfter = insertsBeforeOrAfter;
        }
        return InlineDecoration;
    }());
    exports.InlineDecoration = InlineDecoration;
    var ViewModelDecoration = (function () {
        function ViewModelDecoration(source) {
            this.range = null;
            this.source = source;
        }
        return ViewModelDecoration;
    }());
    exports.ViewModelDecoration = ViewModelDecoration;
});

define(__m[215/*vs/editor/contrib/caretOperations/common/moveCaretCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveCaretCommand = (function () {
        function MoveCaretCommand(selection, isMovingLeft) {
            this._selection = selection;
            this._isMovingLeft = isMovingLeft;
        }
        MoveCaretCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._selectionId = builder.trackSelection(s);
            if (s.startLineNumber !== s.endLineNumber) {
                return;
            }
            if (this._isMovingLeft && s.startColumn === 0) {
                return;
            }
            else if (!this._isMovingLeft && s.endColumn === model.getLineMaxColumn(s.startLineNumber)) {
                return;
            }
            var lineNumber = s.selectionStartLineNumber;
            var lineContent = model.getLineContent(lineNumber);
            var left;
            var middle;
            var right;
            if (this._isMovingLeft) {
                left = lineContent.substring(0, s.startColumn - 2);
                middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
                right = lineContent.substring(s.startColumn - 2, s.startColumn - 1) + lineContent.substring(s.endColumn - 1);
            }
            else {
                left = lineContent.substring(0, s.startColumn - 1) + lineContent.substring(s.endColumn - 1, s.endColumn);
                middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
                right = lineContent.substring(s.endColumn);
            }
            var newLineContent = left + middle + right;
            builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber)), null);
            builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, 1), newLineContent);
            this._cutStartIndex = s.startColumn + (this._isMovingLeft ? -1 : 1);
            this._cutEndIndex = this._cutStartIndex + s.endColumn - s.startColumn;
            this._moved = true;
        };
        MoveCaretCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moved) {
                result = result.setStartPosition(result.startLineNumber, this._cutStartIndex);
                result = result.setEndPosition(result.startLineNumber, this._cutEndIndex);
            }
            return result;
        };
        return MoveCaretCommand;
    }());
    exports.MoveCaretCommand = MoveCaretCommand;
});

define(__m[147/*vs/editor/contrib/comment/common/blockCommentCommand*/], __M([1/*require*/,0/*exports*/,46/*vs/editor/common/core/editOperation*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/]), function (require, exports, editOperation_1, position_1, range_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BlockCommentCommand = (function () {
        function BlockCommentCommand(selection) {
            this._selection = selection;
            this._usedEndToken = null;
        }
        BlockCommentCommand._haystackHasNeedleAtOffset = function (haystack, needle, offset) {
            if (offset < 0) {
                return false;
            }
            var needleLength = needle.length;
            var haystackLength = haystack.length;
            if (offset + needleLength > haystackLength) {
                return false;
            }
            for (var i = 0; i < needleLength; i++) {
                if (haystack.charCodeAt(offset + i) !== needle.charCodeAt(i)) {
                    return false;
                }
            }
            return true;
        };
        BlockCommentCommand.prototype._createOperationsForBlockComment = function (selection, config, model, builder) {
            var startLineNumber = selection.startLineNumber;
            var startColumn = selection.startColumn;
            var endLineNumber = selection.endLineNumber;
            var endColumn = selection.endColumn;
            var startToken = config.blockCommentStartToken;
            var endToken = config.blockCommentEndToken;
            var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startColumn - 1 + startToken.length);
            var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, endColumn - 1 - endToken.length);
            var ops;
            if (startTokenIndex !== -1 && endTokenIndex !== -1) {
                ops = BlockCommentCommand._createRemoveBlockCommentOperations({
                    startLineNumber: startLineNumber,
                    startColumn: startTokenIndex + 1 + startToken.length,
                    endLineNumber: endLineNumber,
                    endColumn: endTokenIndex + 1
                }, startToken, endToken);
            }
            else {
                ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);
                this._usedEndToken = ops.length === 1 ? endToken : null;
            }
            for (var i = 0; i < ops.length; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
            }
        };
        BlockCommentCommand._createRemoveBlockCommentOperations = function (r, startToken, endToken) {
            var res = [];
            if (!range_1.Range.isEmpty(r)) {
                // Remove block comment start
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
                // Remove block comment end
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
            }
            else {
                // Remove both continuously
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
            }
            return res;
        };
        BlockCommentCommand._createAddBlockCommentOperations = function (r, startToken, endToken) {
            var res = [];
            if (!range_1.Range.isEmpty(r)) {
                // Insert block comment start
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.startLineNumber, r.startColumn), startToken));
                // Insert block comment end
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.endLineNumber, r.endColumn), endToken));
            }
            else {
                // Insert both continuously
                res.push(editOperation_1.EditOperation.replace(new range_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + endToken));
            }
            return res;
        };
        BlockCommentCommand.prototype.getEditOperations = function (model, builder) {
            var startLineNumber = this._selection.startLineNumber;
            var startColumn = this._selection.startColumn;
            var endLineNumber = this._selection.endLineNumber;
            var endColumn = this._selection.endColumn;
            var languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
            var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);
            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
                // Mode does not support block comments
                return;
            }
            this._createOperationsForBlockComment({
                startLineNumber: startLineNumber,
                startColumn: startColumn,
                endLineNumber: endLineNumber,
                endColumn: endColumn
            }, config, model, builder);
        };
        BlockCommentCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            if (inverseEditOperations.length === 2) {
                var startTokenEditOperation = inverseEditOperations[0];
                var endTokenEditOperation = inverseEditOperations[1];
                return new selection_1.Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
            }
            else {
                var srcRange = inverseEditOperations[0].range;
                var deltaColumn = this._usedEndToken ? -this._usedEndToken.length : 0;
                return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
            }
        };
        return BlockCommentCommand;
    }());
    exports.BlockCommentCommand = BlockCommentCommand;
});

define(__m[217/*vs/editor/contrib/comment/common/lineCommentCommand*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,46/*vs/editor/common/core/editOperation*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,147/*vs/editor/contrib/comment/common/blockCommentCommand*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/]), function (require, exports, strings, editOperation_1, position_1, range_1, selection_1, blockCommentCommand_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Type;
    (function (Type) {
        Type[Type["Toggle"] = 0] = "Toggle";
        Type[Type["ForceAdd"] = 1] = "ForceAdd";
        Type[Type["ForceRemove"] = 2] = "ForceRemove";
    })(Type = exports.Type || (exports.Type = {}));
    var LineCommentCommand = (function () {
        function LineCommentCommand(selection, tabSize, type) {
            this._selection = selection;
            this._tabSize = tabSize;
            this._type = type;
            this._deltaColumn = 0;
        }
        /**
         * Do an initial pass over the lines and gather info about the line comment string.
         * Returns null if any of the lines doesn't support a line comment string.
         */
        LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {
            var commentStrForLanguage = [];
            var lines = [];
            for (var i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
                var lineNumber = startLineNumber + i;
                var languageId = model.getLanguageIdAtPosition(lineNumber, 1);
                // Find the commentStr for this line, if none is found then bail out: we cannot do line comments
                var commentStr = void 0;
                if (commentStrForLanguage[languageId]) {
                    commentStr = commentStrForLanguage[languageId];
                }
                else {
                    var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);
                    commentStr = (config ? config.lineCommentToken : null);
                    if (!commentStr) {
                        // Mode does not support line comments
                        return null;
                    }
                    commentStrForLanguage[languageId] = commentStr;
                }
                lines.push({
                    ignore: false,
                    commentStr: commentStr,
                    commentStrOffset: 0,
                    commentStrLength: commentStr.length
                });
            }
            return lines;
        };
        /**
         * Analyze lines and decide which lines are relevant and what the toggle should do.
         * Also, build up several offsets and lengths useful in the generation of editor operations.
         */
        LineCommentCommand._analyzeLines = function (type, model, lines, startLineNumber) {
            var lineData, lineContentStartOffset, commentStrEndOffset, i, lineCount, lineNumber, shouldRemoveComments, lineContent, onlyWhitespaceLines = true;
            if (type === 0 /* Toggle */) {
                shouldRemoveComments = true;
            }
            else if (type === 1 /* ForceAdd */) {
                shouldRemoveComments = false;
            }
            else {
                shouldRemoveComments = true;
            }
            for (i = 0, lineCount = lines.length; i < lineCount; i++) {
                lineData = lines[i];
                lineNumber = startLineNumber + i;
                lineContent = model.getLineContent(lineNumber);
                lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);
                if (lineContentStartOffset === -1) {
                    // Empty or whitespace only line
                    if (type === 0 /* Toggle */) {
                        lineData.ignore = true;
                    }
                    else if (type === 1 /* ForceAdd */) {
                        lineData.ignore = true;
                    }
                    else {
                        lineData.ignore = true;
                    }
                    lineData.commentStrOffset = lineContent.length;
                    continue;
                }
                onlyWhitespaceLines = false;
                lineData.ignore = false;
                lineData.commentStrOffset = lineContentStartOffset;
                if (shouldRemoveComments && !blockCommentCommand_1.BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
                    if (type === 0 /* Toggle */) {
                        // Every line so far has been a line comment, but this one is not
                        shouldRemoveComments = false;
                    }
                    else if (type === 1 /* ForceAdd */) {
                    }
                    else {
                        lineData.ignore = true;
                    }
                }
                if (shouldRemoveComments) {
                    commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
                    if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32 /* Space */) {
                        lineData.commentStrLength += 1;
                    }
                }
            }
            if (type === 0 /* Toggle */ && onlyWhitespaceLines) {
                // For only whitespace lines, we insert comments
                shouldRemoveComments = false;
                // Also, no longer ignore them
                for (i = 0, lineCount = lines.length; i < lineCount; i++) {
                    lines[i].ignore = false;
                }
            }
            return {
                supported: true,
                shouldRemoveComments: shouldRemoveComments,
                lines: lines
            };
        };
        /**
         * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
         */
        LineCommentCommand._gatherPreflightData = function (type, model, startLineNumber, endLineNumber) {
            var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
            if (lines === null) {
                return {
                    supported: false,
                    shouldRemoveComments: false,
                    lines: null
                };
            }
            return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);
        };
        /**
         * Given a successful analysis, execute either insert line comments, either remove line comments
         */
        LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {
            var ops;
            if (data.shouldRemoveComments) {
                ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
            }
            else {
                LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
                ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);
            }
            var cursorPosition = new position_1.Position(s.positionLineNumber, s.positionColumn);
            for (var i = 0, len = ops.length; i < len; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
                if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {
                    this._deltaColumn = ops[i].text.length;
                }
            }
            this._selectionId = builder.trackSelection(s);
        };
        LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {
            var startLineNumber = s.startLineNumber;
            var endLineNumber = s.endLineNumber;
            var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
            var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
            var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
            if (startTokenIndex !== -1 && endTokenIndex === -1) {
                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
                endLineNumber = startLineNumber;
            }
            if (startTokenIndex === -1 && endTokenIndex !== -1) {
                startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
                startLineNumber = endLineNumber;
            }
            if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
                startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
                if (startTokenIndex !== -1) {
                    endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
                }
            }
            if (startTokenIndex !== -1 && endTokenIndex !== -1) {
                return blockCommentCommand_1.BlockCommentCommand._createRemoveBlockCommentOperations({
                    startLineNumber: startLineNumber,
                    startColumn: startTokenIndex + startToken.length + 1,
                    endLineNumber: endLineNumber,
                    endColumn: endTokenIndex + 1
                }, startToken, endToken);
            }
            return null;
        };
        /**
         * Given an unsuccessful analysis, delegate to the block comment command
         */
        LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {
            var languageId = model.getLanguageIdAtPosition(s.startLineNumber, s.startColumn);
            var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(languageId);
            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
                // Mode does not support block comments
                return;
            }
            var startToken = config.blockCommentStartToken;
            var endToken = config.blockCommentEndToken;
            var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
            if (!ops) {
                if (s.isEmpty()) {
                    var lineContent = model.getLineContent(s.startLineNumber);
                    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
                    if (firstNonWhitespaceIndex === -1) {
                        // Line is empty or contains only whitespace
                        firstNonWhitespaceIndex = lineContent.length;
                    }
                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations({
                        startLineNumber: s.startLineNumber,
                        startColumn: firstNonWhitespaceIndex + 1,
                        endLineNumber: s.startLineNumber,
                        endColumn: lineContent.length + 1
                    }, startToken, endToken);
                }
                else {
                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations({
                        startLineNumber: s.startLineNumber,
                        startColumn: model.getLineFirstNonWhitespaceColumn(s.startLineNumber),
                        endLineNumber: s.endLineNumber,
                        endColumn: model.getLineMaxColumn(s.endLineNumber)
                    }, startToken, endToken);
                }
                if (ops.length === 1) {
                    this._deltaColumn = startToken.length;
                }
            }
            this._selectionId = builder.trackSelection(s);
            for (var i = 0; i < ops.length; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
            }
        };
        LineCommentCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._moveEndPositionDown = false;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._moveEndPositionDown = true;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            var data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);
            if (data.supported) {
                return this._executeLineComments(model, builder, data, s);
            }
            return this._executeBlockComment(model, builder, s);
        };
        LineCommentCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moveEndPositionDown) {
                result = result.setEndPosition(result.endLineNumber + 1, 1);
            }
            return new selection_1.Selection(result.startLineNumber, result.startColumn + this._deltaColumn, result.endLineNumber, result.endColumn + this._deltaColumn);
        };
        /**
         * Generate edit operations in the remove line comment case
         */
        LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {
            var i, len, lineData, res = [];
            for (i = 0, len = lines.length; i < len; i++) {
                lineData = lines[i];
                if (lineData.ignore) {
                    continue;
                }
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
            }
            return res;
        };
        /**
         * Generate edit operations in the add line comment case
         */
        LineCommentCommand._createAddLineCommentsOperations = function (lines, startLineNumber) {
            var i, len, lineData, res = [];
            for (i = 0, len = lines.length; i < len; i++) {
                lineData = lines[i];
                if (lineData.ignore) {
                    continue;
                }
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));
            }
            return res;
        };
        // TODO@Alex -> duplicated in characterHardWrappingLineMapper
        LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
            if (isTab) {
                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
            }
            return currentVisibleColumn + columnSize;
        };
        /**
         * Adjust insertion points to have them vertically aligned in the add line comment case
         */
        LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {
            var minVisibleColumn = Number.MAX_VALUE, i, len, lineContent, j, lenJ, currentVisibleColumn;
            for (i = 0, len = lines.length; i < len; i++) {
                if (lines[i].ignore) {
                    continue;
                }
                lineContent = model.getLineContent(startLineNumber + i);
                currentVisibleColumn = 0;
                for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);
                }
                if (currentVisibleColumn < minVisibleColumn) {
                    minVisibleColumn = currentVisibleColumn;
                }
            }
            minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
            for (i = 0, len = lines.length; i < len; i++) {
                if (lines[i].ignore) {
                    continue;
                }
                lineContent = model.getLineContent(startLineNumber + i);
                currentVisibleColumn = 0;
                for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9 /* Tab */, 1);
                }
                if (currentVisibleColumn > minVisibleColumn) {
                    lines[i].commentStrOffset = j - 1;
                }
                else {
                    lines[i].commentStrOffset = j;
                }
            }
        };
        return LineCommentCommand;
    }());
    exports.LineCommentCommand = LineCommentCommand;
});






define(__m[122/*vs/editor/contrib/diffNavigator/common/diffNavigator*/], __M([1/*require*/,0/*exports*/,63/*vs/base/common/assert*/,25/*vs/base/common/eventEmitter*/,36/*vs/base/common/objects*/,4/*vs/editor/common/core/range*/,3/*vs/base/common/lifecycle*/]), function (require, exports, assert, eventEmitter_1, objects, range_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var defaultOptions = {
        followsCaret: true,
        ignoreCharChanges: true,
        alwaysRevealFirst: true
    };
    /**
     * Create a new diff navigator for the provided diff editor.
     */
    var DiffNavigator = (function (_super) {
        __extends(DiffNavigator, _super);
        function DiffNavigator(editor, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, [
                DiffNavigator.Events.UPDATED
            ]) || this;
            _this.editor = editor;
            _this.options = objects.mixin(options, defaultOptions, false);
            _this.disposed = false;
            _this.toUnbind = [];
            _this.nextIdx = -1;
            _this.ranges = [];
            _this.ignoreSelectionChange = false;
            _this.revealFirst = _this.options.alwaysRevealFirst;
            // hook up to diff editor for diff, disposal, and caret move
            _this.toUnbind.push(_this.editor.onDidDispose(function () { return _this.dispose(); }));
            _this.toUnbind.push(_this.editor.onDidUpdateDiff(function () { return _this.onDiffUpdated(); }));
            if (_this.options.followsCaret) {
                _this.toUnbind.push(_this.editor.getModifiedEditor().onDidChangeCursorPosition(function (e) {
                    if (_this.ignoreSelectionChange) {
                        return;
                    }
                    _this.nextIdx = -1;
                }));
            }
            if (_this.options.alwaysRevealFirst) {
                _this.toUnbind.push(_this.editor.getModifiedEditor().onDidChangeModel(function (e) {
                    _this.revealFirst = true;
                }));
            }
            // init things
            _this.init();
            return _this;
        }
        DiffNavigator.prototype.init = function () {
            var changes = this.editor.getLineChanges();
            if (!changes) {
                return;
            }
        };
        DiffNavigator.prototype.onDiffUpdated = function () {
            this.init();
            this.compute(this.editor.getLineChanges());
            if (this.revealFirst) {
                // Only reveal first on first non-null changes
                if (this.editor.getLineChanges() !== null) {
                    this.revealFirst = false;
                    this.nextIdx = -1;
                    this.next();
                }
            }
        };
        DiffNavigator.prototype.compute = function (lineChanges) {
            var _this = this;
            // new ranges
            this.ranges = [];
            if (lineChanges) {
                // create ranges from changes
                lineChanges.forEach(function (lineChange) {
                    if (!_this.options.ignoreCharChanges && lineChange.charChanges) {
                        lineChange.charChanges.forEach(function (charChange) {
                            _this.ranges.push({
                                rhs: true,
                                range: new range_1.Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)
                            });
                        });
                    }
                    else {
                        _this.ranges.push({
                            rhs: true,
                            range: new range_1.Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)
                        });
                    }
                });
            }
            // sort
            this.ranges.sort(function (left, right) {
                if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {
                    return -1;
                }
                else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            this.emit(DiffNavigator.Events.UPDATED, {});
        };
        DiffNavigator.prototype.initIdx = function (fwd) {
            var found = false;
            var position = this.editor.getPosition();
            for (var i = 0, len = this.ranges.length; i < len && !found; i++) {
                var range = this.ranges[i].range;
                if (position.isBeforeOrEqual(range.getStartPosition())) {
                    this.nextIdx = i + (fwd ? 0 : -1);
                    found = true;
                }
            }
            if (!found) {
                // after the last change
                this.nextIdx = fwd ? 0 : this.ranges.length - 1;
            }
            if (this.nextIdx < 0) {
                this.nextIdx = this.ranges.length - 1;
            }
        };
        DiffNavigator.prototype.move = function (fwd) {
            assert.ok(!this.disposed, 'Illegal State - diff navigator has been disposed');
            if (!this.canNavigate()) {
                return;
            }
            if (this.nextIdx === -1) {
                this.initIdx(fwd);
            }
            else if (fwd) {
                this.nextIdx += 1;
                if (this.nextIdx >= this.ranges.length) {
                    this.nextIdx = 0;
                }
            }
            else {
                this.nextIdx -= 1;
                if (this.nextIdx < 0) {
                    this.nextIdx = this.ranges.length - 1;
                }
            }
            var info = this.ranges[this.nextIdx];
            this.ignoreSelectionChange = true;
            try {
                var pos = info.range.getStartPosition();
                this.editor.setPosition(pos);
                this.editor.revealPositionInCenter(pos);
            }
            finally {
                this.ignoreSelectionChange = false;
            }
        };
        DiffNavigator.prototype.canNavigate = function () {
            return this.ranges && this.ranges.length > 0;
        };
        DiffNavigator.prototype.next = function () {
            this.move(true);
        };
        DiffNavigator.prototype.previous = function () {
            this.move(false);
        };
        DiffNavigator.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
            this.ranges = null;
            this.disposed = true;
            _super.prototype.dispose.call(this);
        };
        return DiffNavigator;
    }(eventEmitter_1.EventEmitter));
    DiffNavigator.Events = {
        UPDATED: 'navigation.updated'
    };
    exports.DiffNavigator = DiffNavigator;
});

define(__m[219/*vs/editor/contrib/find/common/findState*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,4/*vs/editor/common/core/range*/]), function (require, exports, eventEmitter_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindReplaceState = (function () {
        function FindReplaceState() {
            this._searchString = '';
            this._replaceString = '';
            this._isRevealed = false;
            this._isReplaceRevealed = false;
            this._isRegex = false;
            this._wholeWord = false;
            this._matchCase = false;
            this._searchScope = null;
            this._matchesPosition = 0;
            this._matchesCount = 0;
            this._currentMatch = null;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
        }
        Object.defineProperty(FindReplaceState.prototype, "searchString", {
            get: function () { return this._searchString; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "replaceString", {
            get: function () { return this._replaceString; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isRevealed", {
            get: function () { return this._isRevealed; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isReplaceRevealed", {
            get: function () { return this._isReplaceRevealed; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isRegex", {
            get: function () { return this._isRegex; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "wholeWord", {
            get: function () { return this._wholeWord; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchCase", {
            get: function () { return this._matchCase; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "searchScope", {
            get: function () { return this._searchScope; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchesPosition", {
            get: function () { return this._matchesPosition; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchesCount", {
            get: function () { return this._matchesCount; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "currentMatch", {
            get: function () { return this._currentMatch; },
            enumerable: true,
            configurable: true
        });
        FindReplaceState.prototype.dispose = function () {
            this._eventEmitter.dispose();
        };
        FindReplaceState.prototype.addChangeListener = function (listener) {
            return this._eventEmitter.addListener2(FindReplaceState._CHANGED_EVENT, listener);
        };
        FindReplaceState.prototype.changeMatchInfo = function (matchesPosition, matchesCount, currentMatch) {
            var changeEvent = {
                moveCursor: false,
                updateHistory: false,
                searchString: false,
                replaceString: false,
                isRevealed: false,
                isReplaceRevealed: false,
                isRegex: false,
                wholeWord: false,
                matchCase: false,
                searchScope: false,
                matchesPosition: false,
                matchesCount: false,
                currentMatch: false
            };
            var somethingChanged = false;
            if (matchesCount === 0) {
                matchesPosition = 0;
            }
            if (matchesPosition > matchesCount) {
                matchesPosition = matchesCount;
            }
            if (this._matchesPosition !== matchesPosition) {
                this._matchesPosition = matchesPosition;
                changeEvent.matchesPosition = true;
                somethingChanged = true;
            }
            if (this._matchesCount !== matchesCount) {
                this._matchesCount = matchesCount;
                changeEvent.matchesCount = true;
                somethingChanged = true;
            }
            if (typeof currentMatch !== 'undefined') {
                if (!range_1.Range.equalsRange(this._currentMatch, currentMatch)) {
                    this._currentMatch = currentMatch;
                    changeEvent.currentMatch = true;
                    somethingChanged = true;
                }
            }
            if (somethingChanged) {
                this._eventEmitter.emit(FindReplaceState._CHANGED_EVENT, changeEvent);
            }
        };
        FindReplaceState.prototype.change = function (newState, moveCursor, updateHistory) {
            if (updateHistory === void 0) { updateHistory = true; }
            var changeEvent = {
                moveCursor: moveCursor,
                updateHistory: updateHistory,
                searchString: false,
                replaceString: false,
                isRevealed: false,
                isReplaceRevealed: false,
                isRegex: false,
                wholeWord: false,
                matchCase: false,
                searchScope: false,
                matchesPosition: false,
                matchesCount: false,
                currentMatch: false
            };
            var somethingChanged = false;
            if (typeof newState.searchString !== 'undefined') {
                if (this._searchString !== newState.searchString) {
                    this._searchString = newState.searchString;
                    changeEvent.searchString = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.replaceString !== 'undefined') {
                if (this._replaceString !== newState.replaceString) {
                    this._replaceString = newState.replaceString;
                    changeEvent.replaceString = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isRevealed !== 'undefined') {
                if (this._isRevealed !== newState.isRevealed) {
                    this._isRevealed = newState.isRevealed;
                    changeEvent.isRevealed = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isReplaceRevealed !== 'undefined') {
                if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
                    this._isReplaceRevealed = newState.isReplaceRevealed;
                    changeEvent.isReplaceRevealed = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isRegex !== 'undefined') {
                if (this._isRegex !== newState.isRegex) {
                    this._isRegex = newState.isRegex;
                    changeEvent.isRegex = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.wholeWord !== 'undefined') {
                if (this._wholeWord !== newState.wholeWord) {
                    this._wholeWord = newState.wholeWord;
                    changeEvent.wholeWord = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.matchCase !== 'undefined') {
                if (this._matchCase !== newState.matchCase) {
                    this._matchCase = newState.matchCase;
                    changeEvent.matchCase = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.searchScope !== 'undefined') {
                if (!range_1.Range.equalsRange(this._searchScope, newState.searchScope)) {
                    this._searchScope = newState.searchScope;
                    changeEvent.searchScope = true;
                    somethingChanged = true;
                }
            }
            if (somethingChanged) {
                this._eventEmitter.emit(FindReplaceState._CHANGED_EVENT, changeEvent);
            }
        };
        return FindReplaceState;
    }());
    FindReplaceState._CHANGED_EVENT = 'changed';
    exports.FindReplaceState = FindReplaceState;
});

define(__m[220/*vs/editor/contrib/find/common/replaceAllCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReplaceAllCommand = (function () {
        function ReplaceAllCommand(editorSelection, ranges, replaceStrings) {
            this._editorSelection = editorSelection;
            this._ranges = ranges;
            this._replaceStrings = replaceStrings;
        }
        ReplaceAllCommand.prototype.getEditOperations = function (model, builder) {
            if (this._ranges.length > 0) {
                // Collect all edit operations
                var ops = [];
                for (var i = 0; i < this._ranges.length; i++) {
                    ops.push({
                        range: this._ranges[i],
                        text: this._replaceStrings[i]
                    });
                }
                // Sort them in ascending order by range starts
                ops.sort(function (o1, o2) {
                    return range_1.Range.compareRangesUsingStarts(o1.range, o2.range);
                });
                // Merge operations that touch each other
                var resultOps = [];
                var previousOp = ops[0];
                for (var i = 1; i < ops.length; i++) {
                    if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
                        // These operations are one after another and can be merged
                        previousOp.range = previousOp.range.plusRange(ops[i].range);
                        previousOp.text = previousOp.text + ops[i].text;
                    }
                    else {
                        resultOps.push(previousOp);
                        previousOp = ops[i];
                    }
                }
                resultOps.push(previousOp);
                for (var i = 0; i < resultOps.length; i++) {
                    builder.addEditOperation(resultOps[i].range, resultOps[i].text);
                }
            }
            this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
        };
        ReplaceAllCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._trackedEditorSelectionId);
        };
        return ReplaceAllCommand;
    }());
    exports.ReplaceAllCommand = ReplaceAllCommand;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[221/*vs/editor/contrib/find/common/replacePattern*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    var ReplacePattern = (function () {
        function ReplacePattern(pieces) {
            if (!pieces || pieces.length === 0) {
                this._staticValue = '';
                this._pieces = null;
            }
            else if (pieces.length === 1 && pieces[0].staticValue !== null) {
                this._staticValue = pieces[0].staticValue;
                this._pieces = null;
            }
            else {
                this._staticValue = null;
                this._pieces = pieces;
            }
        }
        ReplacePattern.fromStaticValue = function (value) {
            return new ReplacePattern([ReplacePiece.staticValue(value)]);
        };
        Object.defineProperty(ReplacePattern.prototype, "hasReplacementPatterns", {
            get: function () {
                return this._staticValue === null;
            },
            enumerable: true,
            configurable: true
        });
        ReplacePattern.prototype.buildReplaceString = function (matches) {
            if (this._staticValue) {
                return this._staticValue;
            }
            var result = '';
            for (var i = 0, len = this._pieces.length; i < len; i++) {
                var piece = this._pieces[i];
                if (piece.staticValue !== null) {
                    // static value ReplacePiece
                    result += piece.staticValue;
                    continue;
                }
                // match index ReplacePiece
                result += ReplacePattern._substitute(piece.matchIndex, matches);
            }
            return result;
        };
        ReplacePattern._substitute = function (matchIndex, matches) {
            if (matchIndex === 0) {
                return matches[0];
            }
            var remainder = '';
            while (matchIndex > 0) {
                if (matchIndex < matches.length) {
                    return matches[matchIndex] + remainder;
                }
                remainder = String(matchIndex % 10) + remainder;
                matchIndex = Math.floor(matchIndex / 10);
            }
            return '$' + remainder;
        };
        return ReplacePattern;
    }());
    exports.ReplacePattern = ReplacePattern;
    /**
     * A replace piece can either be a static string or an index to a specific match.
     */
    var ReplacePiece = (function () {
        function ReplacePiece(staticValue, matchIndex) {
            this.staticValue = staticValue;
            this.matchIndex = matchIndex;
        }
        ReplacePiece.staticValue = function (value) {
            return new ReplacePiece(value, -1);
        };
        ReplacePiece.matchIndex = function (index) {
            return new ReplacePiece(null, index);
        };
        return ReplacePiece;
    }());
    exports.ReplacePiece = ReplacePiece;
    var ReplacePieceBuilder = (function () {
        function ReplacePieceBuilder(source) {
            this._source = source;
            this._lastCharIndex = 0;
            this._result = [];
            this._resultLen = 0;
            this._currentStaticPiece = '';
        }
        ReplacePieceBuilder.prototype.emitUnchanged = function (toCharIndex) {
            this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
            this._lastCharIndex = toCharIndex;
        };
        ReplacePieceBuilder.prototype.emitStatic = function (value, toCharIndex) {
            this._emitStatic(value);
            this._lastCharIndex = toCharIndex;
        };
        ReplacePieceBuilder.prototype._emitStatic = function (value) {
            if (value.length === 0) {
                return;
            }
            this._currentStaticPiece += value;
        };
        ReplacePieceBuilder.prototype.emitMatchIndex = function (index, toCharIndex) {
            if (this._currentStaticPiece.length !== 0) {
                this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
                this._currentStaticPiece = '';
            }
            this._result[this._resultLen++] = ReplacePiece.matchIndex(index);
            this._lastCharIndex = toCharIndex;
        };
        ReplacePieceBuilder.prototype.finalize = function () {
            this.emitUnchanged(this._source.length);
            if (this._currentStaticPiece.length !== 0) {
                this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
                this._currentStaticPiece = '';
            }
            return new ReplacePattern(this._result);
        };
        return ReplacePieceBuilder;
    }());
    /**
     * \n			=> inserts a LF
     * \t			=> inserts a TAB
     * \\			=> inserts a "\".
     * $$			=> inserts a "$".
     * $& and $0	=> inserts the matched substring.
     * $n			=> Where n is a non-negative integer lesser than 100, inserts the nth parenthesized submatch string
     * everything else stays untouched
     *
     * Also see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter
     */
    function parseReplaceString(replaceString) {
        if (!replaceString || replaceString.length === 0) {
            return new ReplacePattern(null);
        }
        var result = new ReplacePieceBuilder(replaceString);
        for (var i = 0, len = replaceString.length; i < len; i++) {
            var chCode = replaceString.charCodeAt(i);
            if (chCode === 92 /* Backslash */) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a \
                    break;
                }
                var nextChCode = replaceString.charCodeAt(i);
                // let replaceWithCharacter: string = null;
                switch (nextChCode) {
                    case 92 /* Backslash */:
                        // \\ => inserts a "\"
                        result.emitUnchanged(i - 1);
                        result.emitStatic('\\', i + 1);
                        break;
                    case 110 /* n */:
                        // \n => inserts a LF
                        result.emitUnchanged(i - 1);
                        result.emitStatic('\n', i + 1);
                        break;
                    case 116 /* t */:
                        // \t => inserts a TAB
                        result.emitUnchanged(i - 1);
                        result.emitStatic('\t', i + 1);
                        break;
                }
                continue;
            }
            if (chCode === 36 /* DollarSign */) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a $
                    break;
                }
                var nextChCode = replaceString.charCodeAt(i);
                if (nextChCode === 36 /* DollarSign */) {
                    // $$ => inserts a "$"
                    result.emitUnchanged(i - 1);
                    result.emitStatic('$', i + 1);
                    continue;
                }
                if (nextChCode === 48 /* Digit0 */ || nextChCode === 38 /* Ampersand */) {
                    // $& and $0 => inserts the matched substring.
                    result.emitUnchanged(i - 1);
                    result.emitMatchIndex(0, i + 1);
                    continue;
                }
                if (49 /* Digit1 */ <= nextChCode && nextChCode <= 57 /* Digit9 */) {
                    // $n
                    var matchIndex = nextChCode - 48 /* Digit0 */;
                    // peek next char to probe for $nn
                    if (i + 1 < len) {
                        var nextNextChCode = replaceString.charCodeAt(i + 1);
                        if (48 /* Digit0 */ <= nextNextChCode && nextNextChCode <= 57 /* Digit9 */) {
                            // $nn
                            // move to next char
                            i++;
                            matchIndex = matchIndex * 10 + (nextNextChCode - 48 /* Digit0 */);
                            result.emitUnchanged(i - 2);
                            result.emitMatchIndex(matchIndex, i + 1);
                            continue;
                        }
                    }
                    result.emitUnchanged(i - 1);
                    result.emitMatchIndex(matchIndex, i + 1);
                    continue;
                }
            }
        }
        return result.finalize();
    }
    exports.parseReplaceString = parseReplaceString;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[222/*vs/editor/contrib/folding/common/folding*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    "use strict";
    exports.ID = 'editor.contrib.folding';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[223/*vs/editor/contrib/folding/common/indentFoldStrategy*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    function computeRanges(model) {
        // we get here a clone of the model's indent ranges
        return model.getIndentRanges();
    }
    exports.computeRanges = computeRanges;
    /**
     * Limits the number of folding ranges by removing ranges with larger indent levels
     */
    function limitByIndent(ranges, maxEntries) {
        if (ranges.length <= maxEntries) {
            return ranges;
        }
        var indentOccurrences = [];
        ranges.forEach(function (r) {
            if (r.indent < 1000) {
                indentOccurrences[r.indent] = (indentOccurrences[r.indent] || 0) + 1;
            }
        });
        var maxIndent = indentOccurrences.length;
        for (var i = 0; i < indentOccurrences.length; i++) {
            if (indentOccurrences[i]) {
                maxEntries -= indentOccurrences[i];
                if (maxEntries < 0) {
                    maxIndent = i;
                    break;
                }
            }
        }
        return ranges.filter(function (r) { return r.indent < maxIndent; });
    }
    exports.limitByIndent = limitByIndent;
});

define(__m[224/*vs/editor/contrib/format/common/formatCommand*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditOperationsCommand = (function () {
        function EditOperationsCommand(edits, initialSelection) {
            this._edits = edits;
            this._initialSelection = initialSelection;
        }
        EditOperationsCommand.prototype.getEditOperations = function (model, builder) {
            this._edits
                .map(function (edit) { return EditOperationsCommand.trimEdit(edit, model); })
                .filter(function (edit) { return edit !== null; }) // produced above in case the edit.text is identical to the existing text
                .forEach(function (edit) { return builder.addEditOperation(range_1.Range.lift(edit.range), edit.text); });
            var selectionIsSet = false;
            if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
                if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&
                    this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, true);
                }
                else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&
                    this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, false);
                }
            }
            if (!selectionIsSet) {
                this._selectionId = builder.trackSelection(this._initialSelection);
            }
        };
        EditOperationsCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._selectionId);
        };
        EditOperationsCommand.fixLineTerminators = function (edit, model) {
            edit.text = edit.text.replace(/\r\n|\r|\n/g, model.getEOL());
        };
        /**
         * This is used to minimize the edits by removing changes that appear on the edges of the range which are identical
         * to the current text.
         *
         * The reason this was introduced is to allow better selection tracking of the current cursor and solve
         * bug #15108. There the cursor was jumping since the tracked selection was in the middle of the range edit
         * and was lost.
         */
        EditOperationsCommand.trimEdit = function (edit, model) {
            this.fixLineTerminators(edit, model);
            return this._trimEdit(model.validateRange(edit.range), edit.text, edit.forceMoveMarkers, model);
        };
        EditOperationsCommand._trimEdit = function (editRange, editText, editForceMoveMarkers, model) {
            var currentText = model.getValueInRange(editRange);
            // Find the equal characters in the front
            var commonPrefixLength = strings.commonPrefixLength(editText, currentText);
            // If the two strings are identical, return no edit (no-op)
            if (commonPrefixLength === currentText.length && commonPrefixLength === editText.length) {
                return null;
            }
            if (commonPrefixLength > 0) {
                // Apply front trimming
                var newStartPosition = model.modifyPosition(editRange.getStartPosition(), commonPrefixLength);
                editRange = new range_1.Range(newStartPosition.lineNumber, newStartPosition.column, editRange.endLineNumber, editRange.endColumn);
                editText = editText.substring(commonPrefixLength);
                currentText = currentText.substr(commonPrefixLength);
            }
            // Find the equal characters in the rear
            var commonSuffixLength = strings.commonSuffixLength(editText, currentText);
            if (commonSuffixLength > 0) {
                // Apply rear trimming
                var newEndPosition = model.modifyPosition(editRange.getEndPosition(), -commonSuffixLength);
                editRange = new range_1.Range(editRange.startLineNumber, editRange.startColumn, newEndPosition.lineNumber, newEndPosition.column);
                editText = editText.substring(0, editText.length - commonSuffixLength);
                currentText = currentText.substring(0, currentText.length - commonSuffixLength);
            }
            return {
                text: editText,
                range: editRange,
                forceMoveMarkers: editForceMoveMarkers
            };
        };
        return EditOperationsCommand;
    }());
    exports.EditOperationsCommand = EditOperationsCommand;
});

define(__m[153/*vs/editor/contrib/hover/browser/hoverOperation*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/]), function (require, exports, async_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ComputeHoverOperationState;
    (function (ComputeHoverOperationState) {
        ComputeHoverOperationState[ComputeHoverOperationState["IDLE"] = 0] = "IDLE";
        ComputeHoverOperationState[ComputeHoverOperationState["FIRST_WAIT"] = 1] = "FIRST_WAIT";
        ComputeHoverOperationState[ComputeHoverOperationState["SECOND_WAIT"] = 2] = "SECOND_WAIT";
        ComputeHoverOperationState[ComputeHoverOperationState["WAITING_FOR_ASYNC_COMPUTATION"] = 3] = "WAITING_FOR_ASYNC_COMPUTATION";
    })(ComputeHoverOperationState || (ComputeHoverOperationState = {}));
    var HoverOperation = (function () {
        function HoverOperation(computer, success, error, progress) {
            var _this = this;
            this._computer = computer;
            this._state = 0 /* IDLE */;
            this._firstWaitScheduler = new async_1.RunOnceScheduler(function () { return _this._triggerAsyncComputation(); }, this._getHoverTimeMillis() / 2);
            this._secondWaitScheduler = new async_1.RunOnceScheduler(function () { return _this._triggerSyncComputation(); }, this._getHoverTimeMillis() / 2);
            this._loadingMessageScheduler = new async_1.RunOnceScheduler(function () { return _this._showLoadingMessage(); }, 3 * this._getHoverTimeMillis());
            this._asyncComputationPromise = null;
            this._asyncComputationPromiseDone = false;
            this._completeCallback = success;
            this._errorCallback = error;
            this._progressCallback = progress;
        }
        HoverOperation.prototype.getComputer = function () {
            return this._computer;
        };
        HoverOperation.prototype._getHoverTimeMillis = function () {
            if (this._computer.getHoverTimeMillis) {
                return this._computer.getHoverTimeMillis();
            }
            return HoverOperation.HOVER_TIME;
        };
        HoverOperation.prototype._triggerAsyncComputation = function () {
            var _this = this;
            this._state = 2 /* SECOND_WAIT */;
            this._secondWaitScheduler.schedule();
            if (this._computer.computeAsync) {
                this._asyncComputationPromiseDone = false;
                this._asyncComputationPromise = this._computer.computeAsync().then(function (asyncResult) {
                    _this._asyncComputationPromiseDone = true;
                    _this._withAsyncResult(asyncResult);
                }, function () { return _this._onError; });
            }
            else {
                this._asyncComputationPromiseDone = true;
            }
        };
        HoverOperation.prototype._triggerSyncComputation = function () {
            if (this._computer.computeSync) {
                this._computer.onResult(this._computer.computeSync(), true);
            }
            if (this._asyncComputationPromiseDone) {
                this._state = 0 /* IDLE */;
                this._onComplete(this._computer.getResult());
            }
            else {
                this._state = 3 /* WAITING_FOR_ASYNC_COMPUTATION */;
                this._onProgress(this._computer.getResult());
            }
        };
        HoverOperation.prototype._showLoadingMessage = function () {
            if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
                this._onProgress(this._computer.getResultWithLoadingMessage());
            }
        };
        HoverOperation.prototype._withAsyncResult = function (asyncResult) {
            if (asyncResult) {
                this._computer.onResult(asyncResult, false);
            }
            if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
                this._state = 0 /* IDLE */;
                this._onComplete(this._computer.getResult());
            }
        };
        HoverOperation.prototype._onComplete = function (value) {
            if (this._completeCallback) {
                this._completeCallback(value);
            }
        };
        HoverOperation.prototype._onError = function (error) {
            if (this._errorCallback) {
                this._errorCallback(error);
            }
            else {
                errors_1.onUnexpectedError(error);
            }
        };
        HoverOperation.prototype._onProgress = function (value) {
            if (this._progressCallback) {
                this._progressCallback(value);
            }
        };
        HoverOperation.prototype.start = function () {
            if (this._state === 0 /* IDLE */) {
                this._state = 1 /* FIRST_WAIT */;
                this._firstWaitScheduler.schedule();
                this._loadingMessageScheduler.schedule();
            }
        };
        HoverOperation.prototype.cancel = function () {
            this._loadingMessageScheduler.cancel();
            if (this._state === 1 /* FIRST_WAIT */) {
                this._firstWaitScheduler.cancel();
            }
            if (this._state === 2 /* SECOND_WAIT */) {
                this._secondWaitScheduler.cancel();
                if (this._asyncComputationPromise) {
                    this._asyncComputationPromise.cancel();
                    this._asyncComputationPromise = null;
                }
            }
            if (this._state === 3 /* WAITING_FOR_ASYNC_COMPUTATION */) {
                if (this._asyncComputationPromise) {
                    this._asyncComputationPromise.cancel();
                    this._asyncComputationPromise = null;
                }
            }
            this._state = 0 /* IDLE */;
        };
        return HoverOperation;
    }());
    HoverOperation.HOVER_TIME = 300;
    exports.HoverOperation = HoverOperation;
});






define(__m[154/*vs/editor/contrib/hover/browser/hoverWidgets*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,16/*vs/editor/common/core/position*/,21/*vs/editor/browser/editorBrowser*/,40/*vs/base/browser/ui/widget*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,3/*vs/base/common/lifecycle*/]), function (require, exports, dom_1, position_1, editorBrowser, widget_1, scrollableElement_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContentHoverWidget = (function (_super) {
        __extends(ContentHoverWidget, _super);
        function ContentHoverWidget(id, editor) {
            var _this = _super.call(this) || this;
            _this.disposables = [];
            // Editor.IContentWidget.allowEditorOverflow
            _this.allowEditorOverflow = true;
            _this._id = id;
            _this._editor = editor;
            _this._isVisible = false;
            _this._containerDomNode = document.createElement('div');
            _this._containerDomNode.className = 'monaco-editor-hover hidden';
            _this._containerDomNode.tabIndex = 0;
            _this._domNode = document.createElement('div');
            _this._domNode.className = 'monaco-editor-hover-content';
            _this.scrollbar = new scrollableElement_1.DomScrollableElement(_this._domNode, { canUseTranslate3d: false });
            _this.disposables.push(_this.scrollbar);
            _this._containerDomNode.appendChild(_this.scrollbar.getDomNode());
            _this.onkeydown(_this._containerDomNode, function (e) {
                if (e.equals(9 /* Escape */)) {
                    _this.hide();
                }
            });
            _this._register(_this._editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this.updateFont();
                }
            }));
            _this._editor.onDidLayoutChange(function (e) { return _this.updateMaxHeight(); });
            _this.updateMaxHeight();
            _this._editor.addContentWidget(_this);
            _this._showAtPosition = null;
            return _this;
        }
        Object.defineProperty(ContentHoverWidget.prototype, "isVisible", {
            get: function () {
                return this._isVisible;
            },
            set: function (value) {
                this._isVisible = value;
                dom_1.toggleClass(this._containerDomNode, 'hidden', !this._isVisible);
            },
            enumerable: true,
            configurable: true
        });
        ContentHoverWidget.prototype.getId = function () {
            return this._id;
        };
        ContentHoverWidget.prototype.getDomNode = function () {
            return this._containerDomNode;
        };
        ContentHoverWidget.prototype.showAt = function (position, focus) {
            // Position has changed
            this._showAtPosition = new position_1.Position(position.lineNumber, position.column);
            this.isVisible = true;
            this._editor.layoutContentWidget(this);
            // Simply force a synchronous render on the editor
            // such that the widget does not really render with left = '0px'
            this._editor.render();
            this._stoleFocus = focus;
            if (focus) {
                this._containerDomNode.focus();
            }
        };
        ContentHoverWidget.prototype.hide = function () {
            if (!this.isVisible) {
                return;
            }
            this.isVisible = false;
            this._editor.layoutContentWidget(this);
            if (this._stoleFocus) {
                this._editor.focus();
            }
        };
        ContentHoverWidget.prototype.getPosition = function () {
            if (this.isVisible) {
                return {
                    position: this._showAtPosition,
                    preference: [
                        editorBrowser.ContentWidgetPositionPreference.ABOVE,
                        editorBrowser.ContentWidgetPositionPreference.BELOW
                    ]
                };
            }
            return null;
        };
        ContentHoverWidget.prototype.dispose = function () {
            this._editor.removeContentWidget(this);
            this.disposables = lifecycle_1.dispose(this.disposables);
            _super.prototype.dispose.call(this);
        };
        ContentHoverWidget.prototype.updateFont = function () {
            var _this = this;
            var codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName('code'));
            var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
            codeTags.concat(codeClasses).forEach(function (node) { return _this._editor.applyFontInfo(node); });
        };
        ContentHoverWidget.prototype.updateContents = function (node) {
            this._domNode.textContent = '';
            this._domNode.appendChild(node);
            this.updateFont();
            this._editor.layoutContentWidget(this);
            this.scrollbar.scanDomNode();
        };
        ContentHoverWidget.prototype.updateMaxHeight = function () {
            var height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
            var _a = this._editor.getConfiguration().fontInfo, fontSize = _a.fontSize, lineHeight = _a.lineHeight;
            this._domNode.style.fontSize = fontSize + "px";
            this._domNode.style.lineHeight = lineHeight + "px";
            this._domNode.style.maxHeight = height + "px";
        };
        return ContentHoverWidget;
    }(widget_1.Widget));
    exports.ContentHoverWidget = ContentHoverWidget;
    var GlyphHoverWidget = (function (_super) {
        __extends(GlyphHoverWidget, _super);
        function GlyphHoverWidget(id, editor) {
            var _this = _super.call(this) || this;
            _this._id = id;
            _this._editor = editor;
            _this._isVisible = false;
            _this._domNode = document.createElement('div');
            _this._domNode.className = 'monaco-editor-hover hidden';
            _this._domNode.setAttribute('aria-hidden', 'true');
            _this._domNode.setAttribute('role', 'presentation');
            _this._showAtLineNumber = -1;
            _this._register(_this._editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this.updateFont();
                }
            }));
            _this._editor.addOverlayWidget(_this);
            return _this;
        }
        Object.defineProperty(GlyphHoverWidget.prototype, "isVisible", {
            get: function () {
                return this._isVisible;
            },
            set: function (value) {
                this._isVisible = value;
                dom_1.toggleClass(this._domNode, 'hidden', !this._isVisible);
            },
            enumerable: true,
            configurable: true
        });
        GlyphHoverWidget.prototype.getId = function () {
            return this._id;
        };
        GlyphHoverWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        GlyphHoverWidget.prototype.showAt = function (lineNumber) {
            this._showAtLineNumber = lineNumber;
            if (!this.isVisible) {
                this.isVisible = true;
            }
            var editorLayout = this._editor.getLayoutInfo();
            var topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);
            var editorScrollTop = this._editor.getScrollTop();
            var lineHeight = this._editor.getConfiguration().lineHeight;
            var nodeHeight = this._domNode.clientHeight;
            var top = topForLineNumber - editorScrollTop - ((nodeHeight - lineHeight) / 2);
            this._domNode.style.left = editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth + "px";
            this._domNode.style.top = Math.max(Math.round(top), 0) + "px";
        };
        GlyphHoverWidget.prototype.hide = function () {
            if (!this.isVisible) {
                return;
            }
            this.isVisible = false;
        };
        GlyphHoverWidget.prototype.getPosition = function () {
            return null;
        };
        GlyphHoverWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            _super.prototype.dispose.call(this);
        };
        GlyphHoverWidget.prototype.updateFont = function () {
            var _this = this;
            var codeTags = Array.prototype.slice.call(this._domNode.getElementsByTagName('code'));
            var codeClasses = Array.prototype.slice.call(this._domNode.getElementsByClassName('code'));
            codeTags.concat(codeClasses).forEach(function (node) { return _this._editor.applyFontInfo(node); });
        };
        GlyphHoverWidget.prototype.updateContents = function (node) {
            this._domNode.textContent = '';
            this._domNode.appendChild(node);
            this.updateFont();
        };
        return GlyphHoverWidget;
    }(widget_1.Widget));
    exports.GlyphHoverWidget = GlyphHoverWidget;
});

define(__m[227/*vs/editor/contrib/inPlaceReplace/common/inPlaceReplaceCommand*/], __M([1/*require*/,0/*exports*/,20/*vs/editor/common/core/selection*/]), function (require, exports, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InPlaceReplaceCommand = (function () {
        function InPlaceReplaceCommand(editRange, originalSelection, text) {
            this._editRange = editRange;
            this._originalSelection = originalSelection;
            this._text = text;
        }
        InPlaceReplaceCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(this._editRange, this._text);
        };
        InPlaceReplaceCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            if (!this._originalSelection.isEmpty()) {
                // Preserve selection and extends to typed text
                return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
            }
            return new selection_1.Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
        };
        return InPlaceReplaceCommand;
    }());
    exports.InPlaceReplaceCommand = InPlaceReplaceCommand;
});

define(__m[228/*vs/editor/contrib/linesOperations/common/copyLinesCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CopyLinesCommand = (function () {
        function CopyLinesCommand(selection, isCopyingDown) {
            this._selection = selection;
            this._isCopyingDown = isCopyingDown;
        }
        CopyLinesCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._startLineNumberDelta = 0;
            this._endLineNumberDelta = 0;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._endLineNumberDelta = 1;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            var sourceLines = [];
            for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {
                sourceLines.push(model.getLineContent(i));
            }
            var sourceText = sourceLines.join('\n');
            if (sourceText === '') {
                // Duplicating empty line
                if (this._isCopyingDown) {
                    this._startLineNumberDelta++;
                    this._endLineNumberDelta++;
                }
            }
            if (!this._isCopyingDown) {
                builder.addEditOperation(new range_1.Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + sourceText);
            }
            else {
                builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + '\n');
            }
            this._selectionId = builder.trackSelection(s);
            this._selectionDirection = this._selection.getDirection();
        };
        CopyLinesCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
                var startLineNumber = result.startLineNumber, startColumn = result.startColumn, endLineNumber = result.endLineNumber, endColumn = result.endColumn;
                if (this._startLineNumberDelta !== 0) {
                    startLineNumber = startLineNumber + this._startLineNumberDelta;
                    startColumn = 1;
                }
                if (this._endLineNumberDelta !== 0) {
                    endLineNumber = endLineNumber + this._endLineNumberDelta;
                    endColumn = 1;
                }
                result = selection_1.Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
            }
            return result;
        };
        return CopyLinesCommand;
    }());
    exports.CopyLinesCommand = CopyLinesCommand;
});

define(__m[229/*vs/editor/contrib/linesOperations/common/deleteLinesCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DeleteLinesCommand = (function () {
        function DeleteLinesCommand(startLineNumber, endLineNumber, restoreCursorToColumn) {
            this.startLineNumber = startLineNumber;
            this.endLineNumber = endLineNumber;
            this.restoreCursorToColumn = restoreCursorToColumn;
        }
        DeleteLinesCommand.createFromSelection = function (selection) {
            var endLineNumber = selection.endLineNumber;
            if (selection.startLineNumber < selection.endLineNumber && selection.endColumn === 1) {
                endLineNumber -= 1;
            }
            return new DeleteLinesCommand(selection.startLineNumber, endLineNumber, selection.positionColumn);
        };
        DeleteLinesCommand.prototype.getEditOperations = function (model, builder) {
            if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
                // Model is empty
                return;
            }
            var startLineNumber = this.startLineNumber;
            var endLineNumber = this.endLineNumber;
            var startColumn = 1;
            var endColumn = model.getLineMaxColumn(endLineNumber);
            if (endLineNumber < model.getLineCount()) {
                endLineNumber += 1;
                endColumn = 1;
            }
            else if (startLineNumber > 1) {
                startLineNumber -= 1;
                startColumn = model.getLineMaxColumn(startLineNumber);
            }
            builder.addEditOperation(new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn), null);
        };
        DeleteLinesCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber, this.restoreCursorToColumn, srcRange.endLineNumber, this.restoreCursorToColumn);
        };
        return DeleteLinesCommand;
    }());
    exports.DeleteLinesCommand = DeleteLinesCommand;
});

define(__m[230/*vs/editor/contrib/linesOperations/common/moveLinesCommand*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveLinesCommand = (function () {
        function MoveLinesCommand(selection, isMovingDown) {
            this._selection = selection;
            this._isMovingDown = isMovingDown;
        }
        MoveLinesCommand.prototype.getEditOperations = function (model, builder) {
            var modelLineCount = model.getLineCount();
            if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
                return;
            }
            if (!this._isMovingDown && this._selection.startLineNumber === 1) {
                return;
            }
            this._moveEndPositionDown = false;
            var s = this._selection;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._moveEndPositionDown = true;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
                // Current line is empty
                var lineNumber = s.startLineNumber;
                var otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);
                if (model.getLineMaxColumn(otherLineNumber) === 1) {
                    // Other line number is empty too, so no editing is needed
                    // Add a no-op to force running by the model
                    builder.addEditOperation(new range_1.Range(1, 1, 1, 1), null);
                }
                else {
                    // Type content from other line number on line number
                    builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
                    // Remove content from other line number
                    builder.addEditOperation(new range_1.Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
                }
                // Track selection at the other line number
                s = new selection_1.Selection(otherLineNumber, 1, otherLineNumber, 1);
            }
            else {
                var movingLineNumber, movingLineText;
                if (this._isMovingDown) {
                    movingLineNumber = s.endLineNumber + 1;
                    movingLineText = model.getLineContent(movingLineNumber);
                    // Delete line that needs to be moved
                    builder.addEditOperation(new range_1.Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
                    // Insert line that needs to be moved before
                    builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), movingLineText + '\n');
                }
                else {
                    movingLineNumber = s.startLineNumber - 1;
                    movingLineText = model.getLineContent(movingLineNumber);
                    // Delete line that needs to be moved
                    builder.addEditOperation(new range_1.Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
                    // Insert line that needs to be moved after
                    builder.addEditOperation(new range_1.Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + movingLineText);
                }
            }
            this._selectionId = builder.trackSelection(s);
        };
        MoveLinesCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moveEndPositionDown) {
                result = result.setEndPosition(result.endLineNumber + 1, 1);
            }
            return result;
        };
        return MoveLinesCommand;
    }());
    exports.MoveLinesCommand = MoveLinesCommand;
});

define(__m[231/*vs/editor/contrib/linesOperations/common/sortLinesCommand*/], __M([1/*require*/,0/*exports*/,46/*vs/editor/common/core/editOperation*/,4/*vs/editor/common/core/range*/]), function (require, exports, editOperation_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SortLinesCommand = (function () {
        function SortLinesCommand(selection, descending) {
            this.selection = selection;
            this.descending = descending;
        }
        SortLinesCommand.prototype.getEditOperations = function (model, builder) {
            var op = sortLines(model, this.selection, this.descending);
            if (op) {
                builder.addEditOperation(op.range, op.text);
            }
            this.selectionId = builder.trackSelection(this.selection);
        };
        SortLinesCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        SortLinesCommand.canRun = function (model, selection, descending) {
            var data = getSortData(model, selection, descending);
            if (!data) {
                return false;
            }
            for (var i = 0, len = data.before.length; i < len; i++) {
                if (data.before[i] !== data.after[i]) {
                    return true;
                }
            }
            return false;
        };
        return SortLinesCommand;
    }());
    exports.SortLinesCommand = SortLinesCommand;
    function getSortData(model, selection, descending) {
        var startLineNumber = selection.startLineNumber;
        var endLineNumber = selection.endLineNumber;
        if (selection.endColumn === 1) {
            endLineNumber--;
        }
        // Nothing to sort if user didn't select anything.
        if (startLineNumber >= endLineNumber) {
            return null;
        }
        var linesToSort = [];
        // Get the contents of the selection to be sorted.
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            linesToSort.push(model.getLineContent(lineNumber));
        }
        var sorted = linesToSort.slice(0);
        sorted.sort(function (a, b) {
            return a.toLowerCase().localeCompare(b.toLowerCase());
        });
        // If descending, reverse the order.
        if (descending === true) {
            sorted = sorted.reverse();
        }
        return {
            startLineNumber: startLineNumber,
            endLineNumber: endLineNumber,
            before: linesToSort,
            after: sorted
        };
    }
    /**
     * Generate commands for sorting lines on a model.
     */
    function sortLines(model, selection, descending) {
        var data = getSortData(model, selection, descending);
        if (!data) {
            return null;
        }
        return editOperation_1.EditOperation.replace(new range_1.Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join('\n'));
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[232/*vs/editor/contrib/quickFix/browser/quickFixWidget*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,16/*vs/editor/common/core/position*/,50/*vs/base/common/actions*/]), function (require, exports, dom_1, position_1, actions_1) {
    'use strict';
    var QuickFixContextMenu = (function () {
        function QuickFixContextMenu(editor, contextMenuService, commandService) {
            this._editor = editor;
            this._contextMenuService = contextMenuService;
            this._commandService = commandService;
        }
        QuickFixContextMenu.prototype.show = function (fixes, at) {
            var _this = this;
            var actions = fixes.then(function (value) {
                return value.map(function (_a) {
                    var command = _a.command;
                    return new actions_1.Action(command.id, command.title, undefined, true, function () {
                        return (_a = _this._commandService).executeCommand.apply(_a, [command.id].concat(command.arguments));
                        var _a;
                    });
                });
            });
            this._contextMenuService.showContextMenu({
                getAnchor: function () {
                    if (position_1.Position.isIPosition(at)) {
                        at = _this._toCoords(at);
                    }
                    return at;
                },
                getActions: function () { return actions; },
                onHide: function () { _this._visible = false; }
            });
        };
        Object.defineProperty(QuickFixContextMenu.prototype, "isVisible", {
            get: function () {
                return this._visible;
            },
            enumerable: true,
            configurable: true
        });
        QuickFixContextMenu.prototype._toCoords = function (position) {
            this._editor.revealPosition(position);
            this._editor.render();
            // Translate to absolute editor position
            var cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
            var editorCoords = dom_1.getDomNodePagePosition(this._editor.getDomNode());
            var x = editorCoords.left + cursorCoords.left;
            var y = editorCoords.top + cursorCoords.top + cursorCoords.height;
            return { x: x, y: y };
        };
        return QuickFixContextMenu;
    }());
    exports.QuickFixContextMenu = QuickFixContextMenu;
});

define(__m[92/*vs/editor/contrib/referenceSearch/browser/referencesModel*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,12/*vs/base/common/event*/,39/*vs/base/common/paths*/,3/*vs/base/common/lifecycle*/,9/*vs/base/common/strings*/,113/*vs/base/common/idGenerator*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/]), function (require, exports, eventEmitter_1, event_1, paths_1, lifecycle_1, strings, idGenerator_1, winjs_base_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OneReference = (function () {
        function OneReference(_parent, _range, _eventBus) {
            this._parent = _parent;
            this._range = _range;
            this._eventBus = _eventBus;
            this._id = idGenerator_1.defaultGenerator.nextId();
        }
        Object.defineProperty(OneReference.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "model", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "uri", {
            get: function () {
                return this._parent.uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "name", {
            get: function () {
                return this._parent.name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "directory", {
            get: function () {
                return this._parent.directory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                this._range = value;
                this._eventBus.emit('ref/changed', this);
            },
            enumerable: true,
            configurable: true
        });
        return OneReference;
    }());
    exports.OneReference = OneReference;
    var FilePreview = (function () {
        function FilePreview(_modelReference) {
            this._modelReference = _modelReference;
        }
        Object.defineProperty(FilePreview.prototype, "_model", {
            get: function () { return this._modelReference.object.textEditorModel; },
            enumerable: true,
            configurable: true
        });
        FilePreview.prototype.preview = function (range, n) {
            if (n === void 0) { n = 8; }
            var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endColumn = range.endColumn;
            var word = this._model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
            var beforeRange = new range_1.Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
            var afterRange = new range_1.Range(startLineNumber, endColumn, startLineNumber, Number.MAX_VALUE);
            var ret = {
                before: this._model.getValueInRange(beforeRange).replace(/^\s+/, strings.empty),
                inside: this._model.getValueInRange(range),
                after: this._model.getValueInRange(afterRange).replace(/\s+$/, strings.empty)
            };
            return ret;
        };
        FilePreview.prototype.dispose = function () {
            if (this._modelReference) {
                this._modelReference.dispose();
                this._modelReference = null;
            }
        };
        return FilePreview;
    }());
    exports.FilePreview = FilePreview;
    var FileReferences = (function () {
        function FileReferences(_parent, _uri) {
            this._parent = _parent;
            this._uri = _uri;
            this._children = [];
        }
        Object.defineProperty(FileReferences.prototype, "id", {
            get: function () {
                return this._uri.toString();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "children", {
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "name", {
            get: function () {
                return paths_1.basename(this.uri.fsPath);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "directory", {
            get: function () {
                return paths_1.dirname(this.uri.fsPath);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "preview", {
            get: function () {
                return this._preview;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "failure", {
            get: function () {
                return this._loadFailure;
            },
            enumerable: true,
            configurable: true
        });
        FileReferences.prototype.resolve = function (textModelResolverService) {
            var _this = this;
            if (this._resolved) {
                return winjs_base_1.TPromise.as(this);
            }
            return textModelResolverService.createModelReference(this._uri).then(function (modelReference) {
                var model = modelReference.object;
                if (!model) {
                    modelReference.dispose();
                    throw new Error();
                }
                _this._preview = new FilePreview(modelReference);
                _this._resolved = true;
                return _this;
            }, function (err) {
                // something wrong here
                _this._children = [];
                _this._resolved = true;
                _this._loadFailure = err;
                return _this;
            });
        };
        FileReferences.prototype.dispose = function () {
            if (this._preview) {
                this._preview.dispose();
                this._preview = null;
            }
        };
        return FileReferences;
    }());
    exports.FileReferences = FileReferences;
    var ReferencesModel = (function () {
        function ReferencesModel(references) {
            this._groups = [];
            this._references = [];
            this._eventBus = new eventEmitter_1.EventEmitter();
            this.onDidChangeReferenceRange = event_1.fromEventEmitter(this._eventBus, 'ref/changed');
            // grouping and sorting
            references.sort(ReferencesModel._compareReferences);
            var current;
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var ref = references_1[_i];
                if (!current || current.uri.toString() !== ref.uri.toString()) {
                    // new group
                    current = new FileReferences(this, ref.uri);
                    this.groups.push(current);
                }
                // append, check for equality first!
                if (current.children.length === 0
                    || !range_1.Range.equalsRange(ref.range, current.children[current.children.length - 1].range)) {
                    var oneRef = new OneReference(current, ref.range, this._eventBus);
                    this._references.push(oneRef);
                    current.children.push(oneRef);
                }
            }
        }
        Object.defineProperty(ReferencesModel.prototype, "empty", {
            get: function () {
                return this._groups.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReferencesModel.prototype, "references", {
            get: function () {
                return this._references;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReferencesModel.prototype, "groups", {
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        ReferencesModel.prototype.nextReference = function (reference) {
            var idx = reference.parent.children.indexOf(reference), len = reference.parent.children.length, totalLength = reference.parent.parent.groups.length;
            if (idx + 1 < len || totalLength === 1) {
                return reference.parent.children[(idx + 1) % len];
            }
            idx = reference.parent.parent.groups.indexOf(reference.parent);
            idx = (idx + 1) % totalLength;
            return reference.parent.parent.groups[idx].children[0];
        };
        ReferencesModel.prototype.nearestReference = function (resource, position) {
            var nearest = this._references.map(function (ref, idx) {
                return {
                    idx: idx,
                    prefixLen: strings.commonPrefixLength(ref.uri.toString(), resource.toString()),
                    offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
                };
            }).sort(function (a, b) {
                if (a.prefixLen > b.prefixLen) {
                    return -1;
                }
                else if (a.prefixLen < b.prefixLen) {
                    return 1;
                }
                else if (a.offsetDist < b.offsetDist) {
                    return -1;
                }
                else if (a.offsetDist > b.offsetDist) {
                    return 1;
                }
                else {
                    return 0;
                }
            })[0];
            if (nearest) {
                return this._references[nearest.idx];
            }
        };
        ReferencesModel.prototype.dispose = function () {
            this._groups = lifecycle_1.dispose(this._groups);
        };
        ReferencesModel._compareReferences = function (a, b) {
            if (a.uri.toString() < b.uri.toString()) {
                return -1;
            }
            else if (a.uri.toString() > b.uri.toString()) {
                return 1;
            }
            else {
                return range_1.Range.compareRangesUsingStarts(a.range, b.range);
            }
        };
        return ReferencesModel;
    }());
    exports.ReferencesModel = ReferencesModel;
});






define(__m[234/*vs/editor/contrib/smartSelect/common/tokenTree*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,81/*vs/editor/common/modes/supports*/,73/*vs/editor/common/modes/supports/richEditBrackets*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/]), function (require, exports, range_1, supports_1, richEditBrackets_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenTreeBracket;
    (function (TokenTreeBracket) {
        TokenTreeBracket[TokenTreeBracket["None"] = 0] = "None";
        TokenTreeBracket[TokenTreeBracket["Open"] = 1] = "Open";
        TokenTreeBracket[TokenTreeBracket["Close"] = -1] = "Close";
    })(TokenTreeBracket = exports.TokenTreeBracket || (exports.TokenTreeBracket = {}));
    var Node = (function () {
        function Node() {
        }
        Object.defineProperty(Node.prototype, "range", {
            get: function () {
                return new range_1.Range(this.start.lineNumber, this.start.column, this.end.lineNumber, this.end.column);
            },
            enumerable: true,
            configurable: true
        });
        return Node;
    }());
    exports.Node = Node;
    var NodeList = (function (_super) {
        __extends(NodeList, _super);
        function NodeList() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Object.defineProperty(NodeList.prototype, "start", {
            get: function () {
                return this.hasChildren
                    ? this.children[0].start
                    : this.parent.start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeList.prototype, "end", {
            get: function () {
                return this.hasChildren
                    ? this.children[this.children.length - 1].end
                    : this.parent.end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeList.prototype, "hasChildren", {
            get: function () {
                return this.children && this.children.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeList.prototype, "isEmpty", {
            get: function () {
                return !this.hasChildren && !this.parent;
            },
            enumerable: true,
            configurable: true
        });
        NodeList.prototype.append = function (node) {
            if (!node) {
                return false;
            }
            node.parent = this;
            if (!this.children) {
                this.children = [];
            }
            if (node instanceof NodeList) {
                if (node.children) {
                    this.children.push.apply(this.children, node.children);
                }
            }
            else {
                this.children.push(node);
            }
            return true;
        };
        return NodeList;
    }(Node));
    exports.NodeList = NodeList;
    var Block = (function (_super) {
        __extends(Block, _super);
        function Block() {
            var _this = _super.call(this) || this;
            _this.elements = new NodeList();
            _this.elements.parent = _this;
            return _this;
        }
        Object.defineProperty(Block.prototype, "start", {
            get: function () {
                return this.open.start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Block.prototype, "end", {
            get: function () {
                return this.close.end;
            },
            enumerable: true,
            configurable: true
        });
        return Block;
    }(Node));
    exports.Block = Block;
    var Token = (function () {
        function Token(range, bracket, bracketType) {
            this.range = range;
            this.bracket = bracket;
            this.bracketType = bracketType;
        }
        return Token;
    }());
    function newNode(token) {
        var node = new Node();
        node.start = token.range.getStartPosition();
        node.end = token.range.getEndPosition();
        return node;
    }
    var RawToken = (function () {
        function RawToken(source, lineNumber, lineText) {
            this.lineNumber = lineNumber;
            this.lineText = lineText;
            this.startOffset = source.startOffset;
            this.endOffset = source.endOffset;
            this.type = source.tokenType;
            this.languageId = source.languageId;
        }
        return RawToken;
    }());
    var ModelRawTokenScanner = (function () {
        function ModelRawTokenScanner(model) {
            this._model = model;
            this._lineCount = this._model.getLineCount();
            this._versionId = this._model.getVersionId();
            this._lineNumber = 0;
            this._lineText = null;
            this._advance();
        }
        ModelRawTokenScanner.prototype._advance = function () {
            this._next = (this._next ? this._next.next() : null);
            while (!this._next && this._lineNumber < this._lineCount) {
                this._lineNumber++;
                this._lineText = this._model.getLineContent(this._lineNumber);
                var currentLineTokens = this._model.getLineTokens(this._lineNumber);
                this._next = currentLineTokens.firstToken();
            }
        };
        ModelRawTokenScanner.prototype.next = function () {
            if (!this._next) {
                return null;
            }
            if (this._model.getVersionId() !== this._versionId) {
                return null;
            }
            var result = new RawToken(this._next, this._lineNumber, this._lineText);
            this._advance();
            return result;
        };
        return ModelRawTokenScanner;
    }());
    var TokenScanner = (function () {
        function TokenScanner(model) {
            this._rawTokenScanner = new ModelRawTokenScanner(model);
            this._nextBuff = [];
            this._cachedLanguageBrackets = null;
            this._cachedLanguageId = -1;
        }
        TokenScanner.prototype.next = function () {
            if (this._nextBuff.length > 0) {
                return this._nextBuff.shift();
            }
            var token = this._rawTokenScanner.next();
            if (!token) {
                return null;
            }
            var lineNumber = token.lineNumber;
            var lineText = token.lineText;
            var tokenType = token.type;
            var startOffset = token.startOffset;
            var endOffset = token.endOffset;
            if (this._cachedLanguageId !== token.languageId) {
                this._cachedLanguageId = token.languageId;
                this._cachedLanguageBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(this._cachedLanguageId);
            }
            var modeBrackets = this._cachedLanguageBrackets;
            if (!modeBrackets || supports_1.ignoreBracketsInToken(tokenType)) {
                return new Token(new range_1.Range(lineNumber, startOffset + 1, lineNumber, endOffset + 1), 0 /* None */, null);
            }
            var foundBracket;
            do {
                foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, startOffset, endOffset);
                if (foundBracket) {
                    var foundBracketStartOffset = foundBracket.startColumn - 1;
                    var foundBracketEndOffset = foundBracket.endColumn - 1;
                    if (startOffset < foundBracketStartOffset) {
                        // there is some text before this bracket in this token
                        this._nextBuff.push(new Token(new range_1.Range(lineNumber, startOffset + 1, lineNumber, foundBracketStartOffset + 1), 0 /* None */, null));
                    }
                    var bracketText = lineText.substring(foundBracketStartOffset, foundBracketEndOffset);
                    bracketText = bracketText.toLowerCase();
                    var bracketData = modeBrackets.textIsBracket[bracketText];
                    var bracketIsOpen = modeBrackets.textIsOpenBracket[bracketText];
                    this._nextBuff.push(new Token(new range_1.Range(lineNumber, foundBracketStartOffset + 1, lineNumber, foundBracketEndOffset + 1), bracketIsOpen ? 1 /* Open */ : -1 /* Close */, bracketData.languageIdentifier.language + ";" + bracketData.open + ";" + bracketData.close));
                    startOffset = foundBracketEndOffset;
                }
            } while (foundBracket);
            if (startOffset < endOffset) {
                // there is some remaining none-bracket text in this token
                this._nextBuff.push(new Token(new range_1.Range(lineNumber, startOffset + 1, lineNumber, endOffset + 1), 0 /* None */, null));
            }
            return this._nextBuff.shift();
        };
        return TokenScanner;
    }());
    var TokenTreeBuilder = (function () {
        function TokenTreeBuilder(model) {
            this._stack = [];
            this._scanner = new TokenScanner(model);
        }
        TokenTreeBuilder.prototype.build = function () {
            var node = new NodeList();
            while (node.append(this._line() || this._any())) {
            }
            return node;
        };
        TokenTreeBuilder.prototype._accept = function (condt) {
            var token = this._stack.pop() || this._scanner.next();
            if (!token) {
                return false;
            }
            var accepted = condt(token);
            if (!accepted) {
                this._stack.push(token);
                this._currentToken = null;
            }
            else {
                this._currentToken = token;
            }
            return accepted;
        };
        TokenTreeBuilder.prototype._peek = function (condt) {
            var ret = false;
            this._accept(function (info) {
                ret = condt(info);
                return false;
            });
            return ret;
        };
        TokenTreeBuilder.prototype._line = function () {
            var node = new NodeList(), lineNumber;
            // capture current linenumber
            this._peek(function (info) {
                lineNumber = info.range.startLineNumber;
                return false;
            });
            while (this._peek(function (info) { return info.range.startLineNumber === lineNumber; })
                && node.append(this._token() || this._block())) {
            }
            if (!node.children || node.children.length === 0) {
                return null;
            }
            else if (node.children.length === 1) {
                return node.children[0];
            }
            else {
                return node;
            }
        };
        TokenTreeBuilder.prototype._token = function () {
            if (!this._accept(function (token) { return token.bracket === 0 /* None */; })) {
                return null;
            }
            return newNode(this._currentToken);
        };
        TokenTreeBuilder.prototype._block = function () {
            var bracketType, accepted;
            accepted = this._accept(function (token) {
                bracketType = token.bracketType;
                return token.bracket === 1 /* Open */;
            });
            if (!accepted) {
                return null;
            }
            var bracket = new Block();
            bracket.open = newNode(this._currentToken);
            while (bracket.elements.append(this._line())) {
            }
            if (!this._accept(function (token) { return token.bracket === -1 /* Close */ && token.bracketType === bracketType; })) {
                // missing closing bracket -> return just a node list
                var nodelist = new NodeList();
                nodelist.append(bracket.open);
                nodelist.append(bracket.elements);
                return nodelist;
            }
            bracket.close = newNode(this._currentToken);
            return bracket;
        };
        TokenTreeBuilder.prototype._any = function () {
            if (!this._accept(function (_) { return true; })) {
                return null;
            }
            return newNode(this._currentToken);
        };
        return TokenTreeBuilder;
    }());
    /**
     * Parses this grammar:
     *	grammer = { line }
     *	line = { block | "token" }
     *	block = "open_bracket" { line } "close_bracket"
     */
    function build(model) {
        var node = new TokenTreeBuilder(model).build();
        return node;
    }
    exports.build = build;
    function find(node, position) {
        if (node instanceof NodeList && node.isEmpty) {
            return null;
        }
        if (!range_1.Range.containsPosition(node.range, position)) {
            return null;
        }
        var result;
        if (node instanceof NodeList) {
            if (node.hasChildren) {
                for (var i = 0, len = node.children.length; i < len && !result; i++) {
                    result = find(node.children[i], position);
                }
            }
        }
        else if (node instanceof Block) {
            result = find(node.open, position) || find(node.elements, position) || find(node.close, position);
        }
        return result || node;
    }
    exports.find = find;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[235/*vs/editor/contrib/snippet/browser/snippet*/], __M([1/*require*/,0/*exports*/,412/*vs/css!vs/editor/contrib/snippet/browser/snippet*/]), function (require, exports) {
    'use strict';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[236/*vs/editor/contrib/snippet/common/snippetParser*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    'use strict';
    var TokenType;
    (function (TokenType) {
        TokenType[TokenType["Dollar"] = 0] = "Dollar";
        TokenType[TokenType["Colon"] = 1] = "Colon";
        TokenType[TokenType["CurlyOpen"] = 2] = "CurlyOpen";
        TokenType[TokenType["CurlyClose"] = 3] = "CurlyClose";
        TokenType[TokenType["Backslash"] = 4] = "Backslash";
        TokenType[TokenType["Int"] = 5] = "Int";
        TokenType[TokenType["VariableName"] = 6] = "VariableName";
        TokenType[TokenType["Format"] = 7] = "Format";
        TokenType[TokenType["EOF"] = 8] = "EOF";
    })(TokenType = exports.TokenType || (exports.TokenType = {}));
    var Scanner = (function () {
        function Scanner() {
            this.text('');
        }
        Scanner.isDigitCharacter = function (ch) {
            return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
        };
        Scanner.isVariableCharacter = function (ch) {
            return ch === 95 /* Underline */
                || (ch >= 97 /* a */ && ch <= 122 /* z */)
                || (ch >= 65 /* A */ && ch <= 90 /* Z */);
        };
        Scanner.prototype.text = function (value) {
            this.value = value;
            this.pos = 0;
        };
        Scanner.prototype.tokenText = function (token) {
            return this.value.substr(token.pos, token.len);
        };
        Scanner.prototype.next = function () {
            if (this.pos >= this.value.length) {
                return { type: TokenType.EOF, pos: this.pos, len: 0 };
            }
            var pos = this.pos;
            var len = 0;
            var ch = this.value.charCodeAt(pos);
            var type;
            // static types
            type = Scanner._table[ch];
            if (typeof type === 'number') {
                this.pos += 1;
                return { type: type, pos: pos, len: 1 };
            }
            // number
            if (Scanner.isDigitCharacter(ch)) {
                type = TokenType.Int;
                do {
                    len += 1;
                    ch = this.value.charCodeAt(pos + len);
                } while (Scanner.isDigitCharacter(ch));
                this.pos += len;
                return { type: type, pos: pos, len: len };
            }
            // variable name
            if (Scanner.isVariableCharacter(ch)) {
                type = TokenType.VariableName;
                do {
                    ch = this.value.charCodeAt(pos + (++len));
                } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
                this.pos += len;
                return { type: type, pos: pos, len: len };
            }
            // format
            type = TokenType.Format;
            do {
                len += 1;
                ch = this.value.charCodeAt(pos + len);
            } while (!isNaN(ch)
                && typeof Scanner._table[ch] === 'undefined' // not static token
                && !Scanner.isDigitCharacter(ch) // not number
                && !Scanner.isVariableCharacter(ch) // not variable
            );
            this.pos += len;
            return { type: type, pos: pos, len: len };
        };
        return Scanner;
    }());
    Scanner._table = (_a = {},
        _a[36 /* DollarSign */] = TokenType.Dollar,
        _a[58 /* Colon */] = TokenType.Colon,
        _a[123 /* OpenCurlyBrace */] = TokenType.CurlyOpen,
        _a[125 /* CloseCurlyBrace */] = TokenType.CurlyClose,
        _a[92 /* Backslash */] = TokenType.Backslash,
        _a);
    exports.Scanner = Scanner;
    var Marker = (function () {
        function Marker() {
        }
        Marker.toString = function (marker) {
            var result = '';
            for (var _i = 0, marker_1 = marker; _i < marker_1.length; _i++) {
                var m = marker_1[_i];
                result += m.toString();
            }
            return result;
        };
        Marker.prototype.toString = function () {
            return '';
        };
        return Marker;
    }());
    exports.Marker = Marker;
    var Text = (function (_super) {
        __extends(Text, _super);
        function Text(string) {
            var _this = _super.call(this) || this;
            _this.string = string;
            return _this;
        }
        Text.prototype.toString = function () {
            return this.string;
        };
        return Text;
    }(Marker));
    exports.Text = Text;
    var Placeholder = (function (_super) {
        __extends(Placeholder, _super);
        function Placeholder(name, defaultValue) {
            if (name === void 0) { name = ''; }
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.defaultValue = defaultValue;
            return _this;
        }
        Placeholder.prototype.toString = function () {
            return Marker.toString(this.defaultValue);
        };
        return Placeholder;
    }(Marker));
    exports.Placeholder = Placeholder;
    var Variable = (function (_super) {
        __extends(Variable, _super);
        function Variable(name, defaultValue) {
            if (name === void 0) { name = ''; }
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.defaultValue = defaultValue;
            return _this;
        }
        Object.defineProperty(Variable.prototype, "isDefined", {
            get: function () {
                return this.resolvedValue !== undefined;
            },
            enumerable: true,
            configurable: true
        });
        Variable.prototype.toString = function () {
            return this.isDefined ? this.resolvedValue : Marker.toString(this.defaultValue);
        };
        return Variable;
    }(Marker));
    exports.Variable = Variable;
    var SnippetParser = (function () {
        function SnippetParser(enableTextMate, enableInternal) {
            if (enableTextMate === void 0) { enableTextMate = true; }
            if (enableInternal === void 0) { enableInternal = true; }
            this._scanner = new Scanner();
            this._enableTextMate = enableTextMate;
            this._enableInternal = enableInternal;
        }
        SnippetParser.prototype.escape = function (value) {
            return Marker.toString(this.parse(value));
        };
        SnippetParser.prototype.parse = function (value) {
            var marker = [];
            this._scanner.text(value);
            this._token = this._scanner.next();
            while (this._parseAny(marker) || this._parseText(marker)) {
            }
            // * fill in default for empty placeHolders
            // * compact sibling Text markers
            function compact(marker, placeholders) {
                for (var i = 0; i < marker.length; i++) {
                    var thisMarker = marker[i];
                    if (thisMarker instanceof Placeholder) {
                        if (placeholders[thisMarker.name] === undefined) {
                            placeholders[thisMarker.name] = thisMarker.defaultValue;
                        }
                        else if (thisMarker.defaultValue.length === 0) {
                            thisMarker.defaultValue = placeholders[thisMarker.name].slice(0);
                        }
                        if (thisMarker.defaultValue.length > 0) {
                            compact(thisMarker.defaultValue, placeholders);
                        }
                    }
                    else if (thisMarker instanceof Variable) {
                        compact(thisMarker.defaultValue, placeholders);
                    }
                    else if (i > 0 && thisMarker instanceof Text && marker[i - 1] instanceof Text) {
                        marker[i - 1].string += marker[i].string;
                        marker.splice(i, 1);
                        i--;
                    }
                }
            }
            compact(marker, Object.create(null));
            return marker;
        };
        SnippetParser.prototype._accept = function (type) {
            if (type === undefined || this._token.type === type) {
                this._prevToken = this._token;
                this._token = this._scanner.next();
                return true;
            }
        };
        SnippetParser.prototype._return = function (token) {
            this._prevToken = undefined;
            this._token = token;
            this._scanner.pos = token.pos + token.len;
        };
        SnippetParser.prototype._parseAny = function (marker) {
            if (this._parseEscaped(marker)) {
                return true;
            }
            else if (this._enableInternal && this._parseInternal(marker)) {
                return true;
            }
            else if (this._enableTextMate && this._parseTM(marker)) {
                return true;
            }
        };
        SnippetParser.prototype._parseText = function (marker) {
            if (this._token.type !== TokenType.EOF) {
                marker.push(new Text(this._scanner.tokenText(this._token)));
                this._accept(undefined);
                return true;
            }
        };
        SnippetParser.prototype._parseTM = function (marker) {
            if (this._accept(TokenType.Dollar)) {
                if (this._accept(TokenType.VariableName) || this._accept(TokenType.Int)) {
                    // $FOO, $123
                    var idOrName = this._scanner.tokenText(this._prevToken);
                    marker.push(/^\d+$/.test(idOrName) ? new Placeholder(idOrName, []) : new Variable(idOrName, []));
                    return true;
                }
                else if (this._accept(TokenType.CurlyOpen)) {
                    // ${name:children}
                    var name_1 = [];
                    var children = [];
                    var target = name_1;
                    while (true) {
                        if (target !== children && this._accept(TokenType.Colon)) {
                            target = children;
                            continue;
                        }
                        if (this._accept(TokenType.CurlyClose)) {
                            var idOrName = Marker.toString(name_1);
                            marker.push(/^\d+$/.test(idOrName) ? new Placeholder(idOrName, children) : new Variable(idOrName, children));
                            return true;
                        }
                        if (this._parseAny(target) || this._parseText(target)) {
                            continue;
                        }
                        // fallback
                        if (children.length > 0) {
                            marker.push(new Text('${' + Marker.toString(name_1) + ':'));
                            marker.push.apply(marker, children);
                        }
                        else {
                            marker.push(new Text('${'));
                            marker.push.apply(marker, name_1);
                        }
                        return true;
                    }
                }
                marker.push(new Text('$'));
                return true;
            }
        };
        SnippetParser.prototype._parseInternal = function (marker) {
            if (this._accept(TokenType.CurlyOpen)) {
                if (!this._accept(TokenType.CurlyOpen)) {
                    this._return(this._prevToken);
                    return false;
                }
                // {{name:children}}, {{name}}, {{name:}}
                var name_2 = [];
                var children = [];
                var target = name_2;
                while (true) {
                    if (this._accept(TokenType.Colon)) {
                        target = children;
                        continue;
                    }
                    if (this._accept(TokenType.CurlyClose)) {
                        if (!this._accept(TokenType.CurlyClose)) {
                            this._return(this._prevToken);
                            continue;
                        }
                        if (children !== target) {
                            // we have not seen the colon which
                            // means use the ident also as
                            // default value
                            children = name_2;
                        }
                        marker.push(new Placeholder(Marker.toString(name_2), children));
                        return true;
                    }
                    if (this._parseAny(target) || this._parseText(target)) {
                        continue;
                    }
                    // fallback
                    if (children.length > 0) {
                        marker.push(new Text('{{' + Marker.toString(name_2) + ':'));
                        marker.push.apply(marker, children);
                    }
                    else {
                        marker.push(new Text('{{'));
                        marker.push.apply(marker, name_2);
                    }
                    return true;
                }
            }
        };
        SnippetParser.prototype._parseEscaped = function (marker) {
            if (this._accept(TokenType.Backslash)) {
                if ((this._enableInternal && (this._accept(TokenType.CurlyOpen) || this._accept(TokenType.CurlyClose) || this._accept(TokenType.Backslash)))
                    || (this._enableTextMate && (this._accept(TokenType.Dollar) || this._accept(TokenType.CurlyClose) || this._accept(TokenType.Backslash)))) {
                }
                marker.push(new Text(this._scanner.tokenText(this._prevToken)));
                return true;
            }
        };
        return SnippetParser;
    }());
    exports.SnippetParser = SnippetParser;
    var _a;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[93/*vs/editor/contrib/snippet/common/snippet*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/,236/*vs/editor/contrib/snippet/common/snippetParser*/]), function (require, exports, strings, range_1, snippetParser_1) {
    'use strict';
    var CodeSnippet = (function () {
        function CodeSnippet() {
            this.lines = [];
            this.placeHolders = [];
            this.finishPlaceHolderIndex = -1;
        }
        CodeSnippet.fromTextmate = function (template, variableResolver) {
            var marker = new snippetParser_1.SnippetParser(true, false).parse(template);
            var snippet = new CodeSnippet();
            _resolveSnippetVariables(marker, variableResolver);
            _fillCodeSnippetFromMarker(snippet, marker);
            return snippet;
        };
        CodeSnippet.fromInternal = function (template) {
            var marker = new snippetParser_1.SnippetParser(false, true).parse(template);
            var snippet = new CodeSnippet();
            _fillCodeSnippetFromMarker(snippet, marker);
            return snippet;
        };
        CodeSnippet.none = function (template) {
            var snippet = new CodeSnippet();
            snippet.lines = template.split(/\r\n|\n|\r/);
            return snippet;
        };
        CodeSnippet.fromEmmet = function (template) {
            return EmmetSnippetParser.parse(template);
        };
        Object.defineProperty(CodeSnippet.prototype, "isInsertOnly", {
            get: function () {
                return this.placeHolders.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CodeSnippet.prototype, "isSingleTabstopOnly", {
            get: function () {
                if (this.placeHolders.length !== 1) {
                    return false;
                }
                var placeHolder = this.placeHolders[0];
                if (placeHolder.value !== '' || placeHolder.occurences.length !== 1) {
                    return false;
                }
                var placeHolderRange = placeHolder.occurences[0];
                if (!range_1.Range.isEmpty(placeHolderRange)) {
                    return false;
                }
                return true;
            },
            enumerable: true,
            configurable: true
        });
        CodeSnippet.prototype.extractLineIndentation = function (str, maxColumn) {
            if (maxColumn === void 0) { maxColumn = Number.MAX_VALUE; }
            var fullIndentation = strings.getLeadingWhitespace(str);
            if (fullIndentation.length > maxColumn - 1) {
                return fullIndentation.substring(0, maxColumn - 1);
            }
            return fullIndentation;
        };
        CodeSnippet.prototype.bind = function (referenceLine, deltaLine, firstLineDeltaColumn, config) {
            var resultLines = [];
            var resultPlaceHolders = [];
            var referenceIndentation = this.extractLineIndentation(referenceLine, firstLineDeltaColumn + 1);
            // Compute resultLines & keep deltaColumns as a reference for adjusting placeholders
            var deltaColumns = [];
            for (var i = 0, len = this.lines.length; i < len; i++) {
                var originalLine = this.lines[i];
                if (i === 0) {
                    deltaColumns[i + 1] = firstLineDeltaColumn;
                    resultLines[i] = originalLine;
                }
                else {
                    var originalLineIndentation = this.extractLineIndentation(originalLine);
                    var remainingLine = originalLine.substr(originalLineIndentation.length);
                    var indentation = config.normalizeIndentation(referenceIndentation + originalLineIndentation);
                    deltaColumns[i + 1] = indentation.length - originalLineIndentation.length;
                    resultLines[i] = indentation + remainingLine;
                }
            }
            // Compute resultPlaceHolders
            for (var _i = 0, _a = this.placeHolders; _i < _a.length; _i++) {
                var originalPlaceHolder = _a[_i];
                var resultOccurences = [];
                for (var _b = 0, _c = originalPlaceHolder.occurences; _b < _c.length; _b++) {
                    var _d = _c[_b], startLineNumber = _d.startLineNumber, startColumn = _d.startColumn, endLineNumber = _d.endLineNumber, endColumn = _d.endColumn;
                    if (startColumn > 1 || startLineNumber === 1) {
                        // placeholders that aren't at the beginning of new snippet lines
                        // will be moved by how many characters the indentation has been
                        // adjusted
                        startColumn = startColumn + deltaColumns[startLineNumber];
                        endColumn = endColumn + deltaColumns[endLineNumber];
                    }
                    else {
                        // placeholders at the beginning of new snippet lines
                        // will be indented by the reference indentation
                        startColumn += referenceIndentation.length;
                        endColumn += referenceIndentation.length;
                    }
                    resultOccurences.push({
                        startLineNumber: startLineNumber + deltaLine,
                        startColumn: startColumn,
                        endLineNumber: endLineNumber + deltaLine,
                        endColumn: endColumn,
                    });
                }
                resultPlaceHolders.push({
                    id: originalPlaceHolder.id,
                    value: originalPlaceHolder.value,
                    occurences: resultOccurences
                });
            }
            return {
                lines: resultLines,
                placeHolders: resultPlaceHolders,
                finishPlaceHolderIndex: this.finishPlaceHolderIndex
            };
        };
        return CodeSnippet;
    }());
    exports.CodeSnippet = CodeSnippet;
    var InternalFormatSnippetParser = new (function () {
        function class_1() {
        }
        class_1.prototype.parse = function (template) {
            this._lastGeneratedId = 0;
            this._snippet = new CodeSnippet();
            this.parseTemplate(template);
            return this._snippet;
        };
        class_1.prototype.parseTemplate = function (template) {
            var placeHoldersMap = Object.create(null);
            var i, len, j, lenJ, templateLines = template.split('\n');
            for (i = 0, len = templateLines.length; i < len; i++) {
                var parsedLine = this.parseLine(templateLines[i], function (id) {
                    if (placeHoldersMap[id]) {
                        return placeHoldersMap[id].value;
                    }
                    return '';
                });
                for (j = 0, lenJ = parsedLine.placeHolders.length; j < lenJ; j++) {
                    var linePlaceHolder = parsedLine.placeHolders[j];
                    var occurence = new range_1.Range(i + 1, linePlaceHolder.startColumn, i + 1, linePlaceHolder.endColumn);
                    var placeHolder;
                    if (placeHoldersMap[linePlaceHolder.id]) {
                        placeHolder = placeHoldersMap[linePlaceHolder.id];
                    }
                    else {
                        placeHolder = {
                            id: linePlaceHolder.id,
                            value: linePlaceHolder.value,
                            occurences: []
                        };
                        this._snippet.placeHolders.push(placeHolder);
                        placeHoldersMap[linePlaceHolder.id] = placeHolder;
                    }
                    placeHolder.occurences.push(occurence);
                }
                this._snippet.lines.push(parsedLine.line);
            }
            // Named variables (e.g. {greeting} and {greeting:Hello}) are sorted first, followed by
            // tab-stops and numeric variables (e.g. $1, $2, ${3:foo}) which are sorted in ascending order
            this._snippet.placeHolders.sort(function (a, b) {
                var nonIntegerId = function (v) { return !(/^\d+$/).test(v.id); };
                var isFinishPlaceHolder = function (v) { return v.id === '' && v.value === ''; };
                // Sort finish placeholder last
                if (isFinishPlaceHolder(a)) {
                    return 1;
                }
                else if (isFinishPlaceHolder(b)) {
                    return -1;
                }
                // Sort named placeholders first
                if (nonIntegerId(a) && nonIntegerId(b)) {
                    return 0;
                }
                else if (nonIntegerId(a)) {
                    return -1;
                }
                else if (nonIntegerId(b)) {
                    return 1;
                }
                if (a.id === b.id) {
                    return 0;
                }
                return Number(a.id) < Number(b.id) ? -1 : 1;
            });
            if (this._snippet.placeHolders.length > 0 && this._snippet.placeHolders[this._snippet.placeHolders.length - 1].value === '') {
                this._snippet.finishPlaceHolderIndex = this._snippet.placeHolders.length - 1;
            }
        };
        class_1.prototype.parseLine = function (line, findDefaultValueForIdFromPrevLines) {
            // Placeholder 0 is the entire line
            var placeHolderStack = [{ placeHolderId: '', placeHolderText: '' }];
            var placeHolders = [];
            var findDefaultValueForId = function (id) {
                var result = findDefaultValueForIdFromPrevLines(id);
                if (result) {
                    return result;
                }
                for (var _i = 0, placeHolders_1 = placeHolders; _i < placeHolders_1.length; _i++) {
                    var placeHolder = placeHolders_1[_i];
                    if (placeHolder.id === id && placeHolder.value) {
                        return placeHolder.value;
                    }
                }
                return '';
            };
            var i = 0;
            var len = line.length;
            var resultIndex = 0;
            while (i < len) {
                var restOfLine = line.substr(i);
                // Look for the start of a placeholder {{
                if (/^{{/.test(restOfLine)) {
                    i += 2;
                    placeHolderStack.push({ placeHolderId: '', placeHolderText: '' });
                    // Look for id
                    var matches = restOfLine.match(/^{{(\w+):/);
                    if (Array.isArray(matches) && matches.length === 2) {
                        placeHolderStack[placeHolderStack.length - 1].placeHolderId = matches[1];
                        i += matches[1].length + 1; // +1 to account for the : at the end of the id
                    }
                    continue;
                }
                // Look for the end of a placeholder. placeHolderStack[0] is the top-level line.
                if (placeHolderStack.length > 1 && /^}}/.test(restOfLine)) {
                    i += 2;
                    if (placeHolderStack[placeHolderStack.length - 1].placeHolderId.length === 0) {
                        // This placeholder did not have an explicit id
                        placeHolderStack[placeHolderStack.length - 1].placeHolderId = placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                        if (placeHolderStack[placeHolderStack.length - 1].placeHolderId === '_') {
                            // This is just an empty tab stop
                            placeHolderStack[placeHolderStack.length - 1].placeHolderId = 'TAB_STOP_' + String(++this._lastGeneratedId);
                            placeHolderStack[placeHolderStack.length - 1].placeHolderText = '';
                            --resultIndex; // Roll back one iteration of the result index as we made the text empty
                        }
                    }
                    if (placeHolderStack[placeHolderStack.length - 1].placeHolderText.length === 0) {
                        // This placeholder is empty or was a mirror
                        var defaultValue = findDefaultValueForId(placeHolderStack[placeHolderStack.length - 1].placeHolderId);
                        placeHolderStack[placeHolderStack.length - 1].placeHolderText = defaultValue;
                        resultIndex += defaultValue.length;
                    }
                    placeHolders.push({
                        id: placeHolderStack[placeHolderStack.length - 1].placeHolderId,
                        value: placeHolderStack[placeHolderStack.length - 1].placeHolderText,
                        startColumn: resultIndex + 1 - placeHolderStack[placeHolderStack.length - 1].placeHolderText.length,
                        endColumn: resultIndex + 1
                    });
                    // Insert our text into the previous placeholder
                    placeHolderStack[placeHolderStack.length - 2].placeHolderText += placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                    placeHolderStack.pop();
                    continue;
                }
                // Look for escapes
                if (/^\\./.test(restOfLine)) {
                    if (restOfLine.charAt(1) === '{' || restOfLine.charAt(1) === '}' || restOfLine.charAt(1) === '\\') {
                        ++i; // Skip the escape slash and take the character literally
                    }
                    else {
                        // invalid escapes
                        placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
                        ++resultIndex;
                        ++i;
                    }
                }
                //This is an escape sequence or not a special character, just insert it
                placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
                ++resultIndex;
                ++i;
            }
            // Sort the placeholder in order of apperance:
            placeHolders.sort(function (a, b) {
                if (a.startColumn < b.startColumn) {
                    return -1;
                }
                if (a.startColumn > b.startColumn) {
                    return 1;
                }
                if (a.endColumn < b.endColumn) {
                    return -1;
                }
                if (a.endColumn > b.endColumn) {
                    return 1;
                }
                return 0;
            });
            return {
                line: placeHolderStack[0].placeHolderText,
                placeHolders: placeHolders
            };
        };
        return class_1;
    }());
    var EmmetSnippetParser = new (function () {
        function class_2() {
        }
        class_2.prototype.parse = function (template) {
            template = _convertExternalSnippet(template, ExternalSnippetType.EmmetSnippet);
            return InternalFormatSnippetParser.parse(template);
        };
        return class_2;
    }());
    var ExternalSnippetType;
    (function (ExternalSnippetType) {
        ExternalSnippetType[ExternalSnippetType["TextMateSnippet"] = 0] = "TextMateSnippet";
        ExternalSnippetType[ExternalSnippetType["EmmetSnippet"] = 1] = "EmmetSnippet";
    })(ExternalSnippetType = exports.ExternalSnippetType || (exports.ExternalSnippetType = {}));
    // This is used for both TextMate and Emmet
    function _convertExternalSnippet(snippet, snippetType) {
        var openBraces = 0;
        var convertedSnippet = '';
        var i = 0;
        var len = snippet.length;
        while (i < len) {
            var restOfLine = snippet.substr(i);
            // Cursor tab stop
            if (/^\$0/.test(restOfLine)) {
                i += 2;
                convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
                continue;
            }
            if (/^\$\{0\}/.test(restOfLine)) {
                i += 4;
                convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
                continue;
            }
            // Tab stops
            var matches = restOfLine.match(/^\$(\d+)/);
            if (Array.isArray(matches) && matches.length === 2) {
                i += 1 + matches[1].length;
                convertedSnippet += '{{' + matches[1] + ':}}';
                continue;
            }
            matches = restOfLine.match(/^\$\{(\d+)\}/);
            if (Array.isArray(matches) && matches.length === 2) {
                i += 3 + matches[1].length;
                convertedSnippet += '{{' + matches[1] + ':}}';
                continue;
            }
            // Open brace patterns placeholder
            if (/^\${/.test(restOfLine)) {
                i += 2;
                ++openBraces;
                convertedSnippet += '{{';
                continue;
            }
            // Close brace patterns placeholder
            if (openBraces > 0 && /^}/.test(restOfLine)) {
                i += 1;
                --openBraces;
                convertedSnippet += '}}';
                continue;
            }
            // Escapes
            if (/^\\./.test(restOfLine)) {
                i += 2;
                if (/^\\\$/.test(restOfLine)) {
                    convertedSnippet += '$';
                }
                else {
                    convertedSnippet += restOfLine.substr(0, 2);
                }
                continue;
            }
            // Escape braces that don't belong to a placeholder
            matches = restOfLine.match(/^({|})/);
            if (Array.isArray(matches) && matches.length === 2) {
                i += 1;
                convertedSnippet += '\\' + matches[1];
                continue;
            }
            i += 1;
            convertedSnippet += restOfLine.charAt(0);
        }
        return convertedSnippet;
    }
    ;
    function _resolveSnippetVariables(marker, resolver) {
        if (resolver) {
            var stack = marker.slice();
            while (stack.length > 0) {
                var marker_1 = stack.shift();
                if (marker_1 instanceof snippetParser_1.Variable) {
                    try {
                        marker_1.resolvedValue = resolver.resolve(marker_1.name);
                    }
                    catch (e) {
                    }
                    if (marker_1.isDefined) {
                        continue;
                    }
                }
                if (marker_1 instanceof snippetParser_1.Variable || marker_1 instanceof snippetParser_1.Placeholder) {
                    // 'recurse'
                    stack.unshift.apply(stack, marker_1.defaultValue);
                }
            }
        }
    }
    function _isFinishPlaceHolder(v) {
        return (v.id === '' && v.value === '') || v.id === '0';
    }
    function _fillCodeSnippetFromMarker(snippet, marker) {
        var placeHolders = Object.create(null);
        var hasFinishPlaceHolder = false;
        var stack = marker.slice();
        snippet.lines = [''];
        while (stack.length > 0) {
            var marker_2 = stack.shift();
            if (marker_2 instanceof snippetParser_1.Text) {
                // simple text
                var lines = marker_2.string.split(/\r\n|\n|\r/);
                snippet.lines[snippet.lines.length - 1] += lines.shift();
                (_a = snippet.lines).push.apply(_a, lines);
            }
            else if (marker_2 instanceof snippetParser_1.Placeholder) {
                var placeHolder = placeHolders[marker_2.name];
                if (!placeHolder) {
                    placeHolders[marker_2.name] = placeHolder = {
                        id: marker_2.name,
                        value: snippetParser_1.Marker.toString(marker_2.defaultValue),
                        occurences: []
                    };
                    snippet.placeHolders.push(placeHolder);
                }
                hasFinishPlaceHolder = hasFinishPlaceHolder || _isFinishPlaceHolder(placeHolder);
                var line = snippet.lines.length;
                var column = snippet.lines[line - 1].length + 1;
                placeHolder.occurences.push({
                    startLineNumber: line,
                    startColumn: column,
                    endLineNumber: line,
                    endColumn: column + snippetParser_1.Marker.toString(marker_2.defaultValue).length // TODO multiline placeholders!
                });
                stack.unshift.apply(stack, marker_2.defaultValue);
            }
            else if (marker_2 instanceof snippetParser_1.Variable) {
                if (!marker_2.isDefined) {
                    // contine as placeholder
                    // THIS is because of us having falsy
                    // advertised ${foo} as placeholder syntax
                    stack.unshift(new snippetParser_1.Placeholder(marker_2.name, marker_2.defaultValue.length === 0
                        ? [new snippetParser_1.Text(marker_2.name)]
                        : marker_2.defaultValue));
                }
                else if (marker_2.resolvedValue) {
                    // contine with the value
                    stack.unshift(new snippetParser_1.Text(marker_2.resolvedValue));
                }
                else {
                    // continue with default values
                    stack.unshift.apply(stack, marker_2.defaultValue);
                }
            }
            if (stack.length === 0 && !hasFinishPlaceHolder) {
                stack.push(new snippetParser_1.Placeholder('0', []));
            }
        }
        // Named variables (e.g. {greeting} and {greeting:Hello}) are sorted first, followed by
        // tab-stops and numeric variables (e.g. $1, $2, ${3:foo}) which are sorted in ascending order
        snippet.placeHolders.sort(function (a, b) {
            var nonIntegerId = function (v) { return !(/^\d+$/).test(v.id); };
            // Sort finish placeholder last
            if (_isFinishPlaceHolder(a)) {
                return 1;
            }
            else if (_isFinishPlaceHolder(b)) {
                return -1;
            }
            // Sort named placeholders first
            if (nonIntegerId(a) && nonIntegerId(b)) {
                return 0;
            }
            else if (nonIntegerId(a)) {
                return -1;
            }
            else if (nonIntegerId(b)) {
                return 1;
            }
            if (a.id === b.id) {
                return 0;
            }
            return Number(a.id) < Number(b.id) ? -1 : 1;
        });
        if (snippet.placeHolders.length > 0) {
            snippet.finishPlaceHolderIndex = snippet.placeHolders.length - 1;
            snippet.placeHolders[snippet.finishPlaceHolderIndex].id = '';
        }
        var _a;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[238/*vs/editor/contrib/snippet/common/snippetVariables*/], __M([1/*require*/,0/*exports*/,39/*vs/base/common/paths*/]), function (require, exports, paths_1) {
    'use strict';
    var SnippetVariablesResolver = (function () {
        function SnippetVariablesResolver(editor) {
            this._editor = editor;
        }
        SnippetVariablesResolver.prototype.resolve = function (name) {
            var model = this._editor.getModel();
            if (!model) {
                throw new Error();
            }
            switch (name) {
                case 'SELECTION':
                case 'TM_SELECTED_TEXT': return this._tmSelectedText();
                case 'TM_CURRENT_LINE': return this._tmCurrentLine();
                case 'TM_CURRENT_WORD': return this._tmCurrentWord();
                case 'TM_LINE_INDEX': return this._tmLineIndex();
                case 'TM_LINE_NUMBER': return this._tmLineNumber();
                case 'TM_FILENAME': return this._tmFilename();
                case 'TM_DIRECTORY': return this._tmDirectory();
                case 'TM_FILEPATH': return this._tmFilepath();
            }
            return;
        };
        SnippetVariablesResolver.prototype._tmCurrentLine = function () {
            var positionLineNumber = this._editor.getSelection().positionLineNumber;
            return this._editor.getModel().getValueInRange({ startLineNumber: positionLineNumber, startColumn: 1, endLineNumber: positionLineNumber, endColumn: Number.MAX_VALUE });
        };
        SnippetVariablesResolver.prototype._tmCurrentWord = function () {
            var word = this._editor.getModel().getWordAtPosition(this._editor.getPosition());
            return word ? word.word : '';
        };
        SnippetVariablesResolver.prototype._tmFilename = function () {
            return paths_1.basename(this._editor.getModel().uri.fsPath);
        };
        SnippetVariablesResolver.prototype._tmDirectory = function () {
            var dir = paths_1.dirname(paths_1.normalize(this._editor.getModel().uri.fsPath));
            return dir !== '.' ? dir : '';
        };
        SnippetVariablesResolver.prototype._tmFilepath = function () {
            return this._editor.getModel().uri.fsPath;
        };
        SnippetVariablesResolver.prototype._tmLineIndex = function () {
            return String(this._editor.getSelection().positionLineNumber - 1);
        };
        SnippetVariablesResolver.prototype._tmLineNumber = function () {
            return String(this._editor.getSelection().positionLineNumber);
        };
        SnippetVariablesResolver.prototype._tmSelectedText = function () {
            return this._editor.getModel().getValueInRange(this._editor.getSelection());
        };
        return SnippetVariablesResolver;
    }());
    exports.SnippetVariablesResolver = SnippetVariablesResolver;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[239/*vs/editor/contrib/suggest/common/completionModel*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,9/*vs/base/common/strings*/,86/*vs/base/common/filters*/]), function (require, exports, arrays_1, strings_1, filters_1) {
    'use strict';
    var LineContext = (function () {
        function LineContext() {
        }
        return LineContext;
    }());
    exports.LineContext = LineContext;
    var CompletionModel = (function () {
        function CompletionModel(items, column, lineContext) {
            this._items = items;
            this._column = column;
            this._lineContext = lineContext;
        }
        Object.defineProperty(CompletionModel.prototype, "lineContext", {
            get: function () {
                return this._lineContext;
            },
            set: function (value) {
                if (this._lineContext.leadingLineContent !== value.leadingLineContent
                    || this._lineContext.characterCountDelta !== value.characterCountDelta) {
                    this._lineContext = value;
                    this._filteredItems = undefined;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompletionModel.prototype, "items", {
            get: function () {
                this._ensureCachedState();
                return this._filteredItems;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompletionModel.prototype, "topScoreIdx", {
            get: function () {
                this._ensureCachedState();
                return this._topScoreIdx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompletionModel.prototype, "incomplete", {
            get: function () {
                this._ensureCachedState();
                return this._isIncomplete;
            },
            enumerable: true,
            configurable: true
        });
        CompletionModel.prototype.resolveIncompleteInfo = function () {
            var incomplete = [];
            var complete = [];
            for (var _i = 0, _a = this._items; _i < _a.length; _i++) {
                var item = _a[_i];
                if (!item.container.incomplete) {
                    complete.push(item);
                }
                else if (incomplete.indexOf(item.support) < 0) {
                    incomplete.push(item.support);
                }
            }
            return { incomplete: incomplete, complete: complete };
        };
        Object.defineProperty(CompletionModel.prototype, "stats", {
            get: function () {
                this._ensureCachedState();
                return this._stats;
            },
            enumerable: true,
            configurable: true
        });
        CompletionModel.prototype._ensureCachedState = function () {
            if (!this._filteredItems) {
                this._createCachedState();
            }
        };
        CompletionModel.prototype._createCachedState = function () {
            this._filteredItems = [];
            this._topScoreIdx = -1;
            this._isIncomplete = false;
            this._stats = { suggestionCount: 0, snippetCount: 0, textCount: 0 };
            var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;
            var word = '';
            var topScore = -1;
            for (var _i = 0, _b = this._items; _i < _b.length; _i++) {
                var item = _b[_i];
                var suggestion = item.suggestion, support = item.support, container = item.container;
                var filter = support && support.filter || filters_1.fuzzyContiguousFilter;
                // collect those supports that signaled having
                // an incomplete result
                this._isIncomplete = this._isIncomplete || container.incomplete;
                // 'word' is that remainder of the current line that we
                // filter and score against. In theory each suggestion uses a
                // differnet word, but in practice not - that's why we cache
                var wordLen = suggestion.overwriteBefore + characterCountDelta - (item.position.column - this._column);
                if (word.length !== wordLen) {
                    word = wordLen === 0 ? '' : leadingLineContent.slice(-wordLen);
                }
                var match = false;
                // compute highlights based on 'label'
                item.highlights = filter(word, suggestion.label);
                match = item.highlights !== null;
                // no match on label nor codeSnippet -> check on filterText
                if (!match && typeof suggestion.filterText === 'string') {
                    if (!arrays_1.isFalsyOrEmpty(filter(word, suggestion.filterText))) {
                        match = true;
                        // try to compute highlights by stripping none-word
                        // characters from the end of the string
                        item.highlights = filter(word.replace(/^\W+|\W+$/, ''), suggestion.label);
                    }
                }
                if (!match) {
                    continue;
                }
                this._filteredItems.push(item);
                // compute score against word
                var score = CompletionModel._scoreByHighlight(item, word);
                if (score > topScore) {
                    topScore = score;
                    this._topScoreIdx = this._filteredItems.length - 1;
                }
                // update stats
                this._stats.suggestionCount++;
                switch (suggestion.type) {
                    case 'snippet':
                        this._stats.snippetCount++;
                        break;
                    case 'text':
                        this._stats.textCount++;
                        break;
                }
            }
        };
        CompletionModel._scoreByHighlight = function (item, currentWord) {
            var highlights = item.highlights, suggestion = item.suggestion;
            if (arrays_1.isFalsyOrEmpty(highlights)) {
                return 0;
            }
            var caseSensitiveMatches = 0;
            var caseInsensitiveMatches = 0;
            var firstMatchStart = 0;
            var len = Math.min(CompletionModel._base, suggestion.label.length);
            var currentWordOffset = 0;
            for (var pos = 0, idx = 0; pos < len; pos++) {
                var highlight = highlights[idx];
                if (pos === highlight.start) {
                    // reached a highlight: find highlighted part
                    // and count case-sensitive /case-insensitive matches
                    var part = suggestion.label.substring(highlight.start, highlight.end);
                    currentWordOffset = strings_1.indexOfIgnoreCase(currentWord, part, currentWordOffset);
                    if (currentWordOffset >= 0) {
                        do {
                            if (suggestion.label[pos] === currentWord[currentWordOffset]) {
                                caseSensitiveMatches += 1;
                            }
                            else {
                                caseInsensitiveMatches += 1;
                            }
                            pos += 1;
                            currentWordOffset += 1;
                        } while (pos < highlight.end);
                    }
                    // proceed with next highlight, store first start,
                    // exit loop when no highlight is available
                    if (idx === 0) {
                        firstMatchStart = highlight.start;
                    }
                    idx += 1;
                    if (idx >= highlights.length) {
                        break;
                    }
                }
            }
            // combine the 4 scoring values into one
            // value using base_100. Values further left
            // are more important
            return (Math.pow(CompletionModel._base, 3)) * caseSensitiveMatches
                + (Math.pow(CompletionModel._base, 2)) * caseInsensitiveMatches
                + (Math.pow(CompletionModel._base, 1)) * (CompletionModel._base - firstMatchStart)
                + (Math.pow(CompletionModel._base, 0)) * (CompletionModel._base - highlights.length);
        };
        return CompletionModel;
    }());
    CompletionModel._base = 100;
    exports.CompletionModel = CompletionModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[160/*vs/editor/contrib/zoneWidget/browser/zoneWidget*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,40/*vs/base/browser/ui/widget*/,36/*vs/base/common/objects*/,11/*vs/base/browser/dom*/,98/*vs/base/browser/ui/sash/sash*/,4/*vs/editor/common/core/range*/,418/*vs/css!vs/editor/contrib/zoneWidget/browser/zoneWidget*/]), function (require, exports, lifecycle_1, widget_1, objects, dom, sash_1, range_1) {
    'use strict';
    var defaultOptions = {
        showArrow: true,
        showFrame: true,
        frameColor: '',
        className: ''
    };
    var WIDGET_ID = 'vs.editor.contrib.zoneWidget';
    var ViewZoneDelegate = (function () {
        function ViewZoneDelegate(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
            this.domNode = domNode;
            this.afterLineNumber = afterLineNumber;
            this.afterColumn = afterColumn;
            this.heightInLines = heightInLines;
            this._onDomNodeTop = onDomNodeTop;
            this._onComputedHeight = onComputedHeight;
        }
        ViewZoneDelegate.prototype.onDomNodeTop = function (top) {
            this._onDomNodeTop(top);
        };
        ViewZoneDelegate.prototype.onComputedHeight = function (height) {
            this._onComputedHeight(height);
        };
        return ViewZoneDelegate;
    }());
    exports.ViewZoneDelegate = ViewZoneDelegate;
    var OverlayWidgetDelegate = (function () {
        function OverlayWidgetDelegate(id, domNode) {
            this._id = id;
            this._domNode = domNode;
        }
        OverlayWidgetDelegate.prototype.getId = function () {
            return this._id;
        };
        OverlayWidgetDelegate.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverlayWidgetDelegate.prototype.getPosition = function () {
            return null;
        };
        return OverlayWidgetDelegate;
    }());
    exports.OverlayWidgetDelegate = OverlayWidgetDelegate;
    var ZoneWidget = (function (_super) {
        __extends(ZoneWidget, _super);
        function ZoneWidget(editor, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this._overlayWidget = null;
            _this._positionMarkerId = [];
            _this._viewZone = null;
            _this._disposables = new lifecycle_1.Disposables();
            _this.container = null;
            _this.editor = editor;
            _this.options = objects.mixin(objects.clone(defaultOptions), options);
            _this.domNode = document.createElement('div');
            if (!_this.options.isAccessible) {
                _this.domNode.setAttribute('aria-hidden', 'true');
                _this.domNode.setAttribute('role', 'presentation');
            }
            _this._disposables.add(_this.editor.onDidLayoutChange(function (info) {
                var width = _this._getWidth(info);
                _this.domNode.style.width = width + 'px';
                _this._onWidth(width);
            }));
            return _this;
        }
        ZoneWidget.prototype.dispose = function () {
            var _this = this;
            this._disposables.dispose();
            if (this._overlayWidget) {
                this.editor.removeOverlayWidget(this._overlayWidget);
                this._overlayWidget = null;
            }
            if (this._viewZone) {
                this.editor.changeViewZones(function (accessor) {
                    accessor.removeZone(_this._viewZone.id);
                    _this._viewZone = null;
                });
            }
            this.editor.deltaDecorations(this._positionMarkerId, []);
        };
        ZoneWidget.prototype.create = function () {
            dom.addClass(this.domNode, 'zone-widget');
            dom.addClass(this.domNode, this.options.className);
            this.container = document.createElement('div');
            dom.addClass(this.container, 'zone-widget-container');
            this.domNode.appendChild(this.container);
            this._fillContainer(this.container);
            this._initSash();
        };
        ZoneWidget.prototype._getWidth = function (info) {
            if (info === void 0) { info = this.editor.getLayoutInfo(); }
            return info.width - info.verticalScrollbarWidth;
        };
        ZoneWidget.prototype._onViewZoneTop = function (top) {
            this.domNode.style.top = top + 'px';
        };
        ZoneWidget.prototype._onViewZoneHeight = function (height) {
            this.domNode.style.height = height + "px";
            var containerHeight = height - this._decoratingElementsHeight();
            this.container.style.height = containerHeight + "px";
            this._doLayout(containerHeight, this._getWidth());
            this._resizeSash.layout();
        };
        Object.defineProperty(ZoneWidget.prototype, "position", {
            get: function () {
                var id = this._positionMarkerId[0];
                if (id) {
                    return this.editor.getModel().getDecorationRange(id).getStartPosition();
                }
            },
            enumerable: true,
            configurable: true
        });
        ZoneWidget.prototype.show = function (rangeOrPos, heightInLines) {
            var range = range_1.Range.isIRange(rangeOrPos)
                ? rangeOrPos
                : new range_1.Range(rangeOrPos.lineNumber, rangeOrPos.column, rangeOrPos.lineNumber, rangeOrPos.column);
            this._showImpl(range, heightInLines);
            this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range: range, options: {} }]);
        };
        ZoneWidget.prototype.hide = function () {
            var _this = this;
            if (this._viewZone) {
                this.editor.changeViewZones(function (accessor) {
                    accessor.removeZone(_this._viewZone.id);
                });
                this._viewZone = null;
            }
            if (this._overlayWidget) {
                this.editor.removeOverlayWidget(this._overlayWidget);
                this._overlayWidget = null;
            }
        };
        ZoneWidget.prototype._decoratingElementsHeight = function () {
            var lineHeight = this.editor.getConfiguration().lineHeight;
            var result = 0;
            if (this.options.showArrow) {
                var arrowHeight = Math.round(lineHeight / 3);
                result += 2 * arrowHeight;
            }
            if (this.options.showFrame) {
                var frameThickness = Math.round(lineHeight / 9);
                result += 2 * frameThickness;
            }
            return result;
        };
        ZoneWidget.prototype._showImpl = function (where, heightInLines) {
            var _this = this;
            var position = {
                lineNumber: where.startLineNumber,
                column: where.startColumn
            };
            var width = this._getWidth();
            this.domNode.style.width = width + "px";
            // Reveal position, to get the line rendered, such that the arrow can be positioned properly
            this.editor.revealPosition(position);
            // Render the widget as zone (rendering) and widget (lifecycle)
            var viewZoneDomNode = document.createElement('div'), arrow = document.createElement('div'), lineHeight = this.editor.getConfiguration().lineHeight, arrowHeight = 0, frameThickness = 0;
            // Render the arrow one 1/3 of an editor line height
            if (this.options.showArrow) {
                arrowHeight = Math.round(lineHeight / 3);
                arrow = document.createElement('div');
                arrow.className = 'zone-widget-arrow below';
                arrow.style.top = -arrowHeight + 'px';
                arrow.style.borderWidth = arrowHeight + 'px';
                arrow.style.left = this.editor.getOffsetForColumn(position.lineNumber, position.column) + 'px';
                arrow.style.borderBottomColor = this.options.frameColor;
                viewZoneDomNode.appendChild(arrow);
            }
            // Render the frame as 1/9 of an editor line height
            if (this.options.showFrame) {
                frameThickness = Math.round(lineHeight / 9);
            }
            // insert zone widget
            this.editor.changeViewZones(function (accessor) {
                if (_this._viewZone) {
                    accessor.removeZone(_this._viewZone.id);
                }
                if (_this._overlayWidget) {
                    _this.editor.removeOverlayWidget(_this._overlayWidget);
                    _this._overlayWidget = null;
                }
                _this.domNode.style.top = '-1000px';
                _this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, function (top) { return _this._onViewZoneTop(top); }, function (height) { return _this._onViewZoneHeight(height); });
                _this._viewZone.id = accessor.addZone(_this._viewZone);
                _this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + _this._viewZone.id, _this.domNode);
                _this.editor.addOverlayWidget(_this._overlayWidget);
            });
            if (this.options.showFrame) {
                var width_1 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
                this.container.style.borderTopColor = this.options.frameColor;
                this.container.style.borderBottomColor = this.options.frameColor;
                this.container.style.borderTopWidth = width_1 + 'px';
                this.container.style.borderBottomWidth = width_1 + 'px';
            }
            var containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
            this.container.style.top = arrowHeight + 'px';
            this.container.style.height = containerHeight + 'px';
            this.container.style.overflow = 'hidden';
            this._doLayout(containerHeight, width);
            this.editor.setSelection(where);
            // Reveal the line above or below the zone widget, to get the zone widget in the viewport
            var revealLineNumber = Math.min(this.editor.getModel().getLineCount(), Math.max(1, where.endLineNumber + 1));
            this.editor.revealLine(revealLineNumber);
        };
        ZoneWidget.prototype._onWidth = function (widthInPixel) {
            // implement in subclass
        };
        ZoneWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
            // implement in subclass
        };
        ZoneWidget.prototype._relayout = function (newHeightInLines) {
            var _this = this;
            if (this._viewZone.heightInLines !== newHeightInLines) {
                this.editor.changeViewZones(function (accessor) {
                    _this._viewZone.heightInLines = newHeightInLines;
                    accessor.layoutZone(_this._viewZone.id);
                });
            }
        };
        // --- sash
        ZoneWidget.prototype._initSash = function () {
            var _this = this;
            this._resizeSash = new sash_1.Sash(this.domNode, this, { orientation: sash_1.Orientation.HORIZONTAL });
            if (!this.options.isResizeable) {
                this._resizeSash.hide();
                this._resizeSash.disable();
            }
            var data;
            this._disposables.add(this._resizeSash.addListener2('start', function (e) {
                if (_this._viewZone) {
                    data = {
                        startY: e.startY,
                        heightInLines: _this._viewZone.heightInLines,
                    };
                }
            }));
            this._disposables.add(this._resizeSash.addListener2('end', function () {
                data = undefined;
            }));
            this._disposables.add(this._resizeSash.addListener2('change', function (evt) {
                if (data) {
                    var lineDelta = (evt.currentY - data.startY) / _this.editor.getConfiguration().lineHeight;
                    var roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
                    var newHeightInLines = data.heightInLines + roundedLineDelta;
                    if (newHeightInLines > 5 && newHeightInLines < 35) {
                        _this._relayout(newHeightInLines);
                    }
                }
            }));
        };
        ZoneWidget.prototype.getHorizontalSashLeft = function () {
            return 0;
        };
        ZoneWidget.prototype.getHorizontalSashTop = function () {
            return parseInt(this.domNode.style.height) - (this._decoratingElementsHeight() / 2);
        };
        ZoneWidget.prototype.getHorizontalSashWidth = function () {
            return this.editor.getLayoutInfo().width;
        };
        return ZoneWidget;
    }(widget_1.Widget));
    exports.ZoneWidget = ZoneWidget;
});

define(__m[241/*vs/nls!vs/base/browser/ui/actionbar/actionbar*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/browser/ui/actionbar/actionbar", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[69/*vs/base/browser/ui/actionbar/actionbar*/], __M([1/*require*/,0/*exports*/,241/*vs/nls!vs/base/browser/ui/actionbar/actionbar*/,3/*vs/base/common/lifecycle*/,33/*vs/base/browser/builder*/,270/*vs/base/browser/ui/selectBox/selectBox*/,19/*vs/base/common/platform*/,50/*vs/base/common/actions*/,11/*vs/base/browser/dom*/,67/*vs/base/common/events*/,24/*vs/base/common/types*/,25/*vs/base/common/eventEmitter*/,61/*vs/base/browser/touch*/,51/*vs/base/browser/keyboardEvent*/,197/*vs/css!vs/base/browser/ui/actionbar/actionbar*/]), function (require, exports, nls, lifecycle, builder_1, selectBox_1, platform, actions_1, DOM, events_1, types, eventEmitter_1, touch_1, keyboardEvent_1) {
    'use strict';
    var BaseActionItem = (function (_super) {
        __extends(BaseActionItem, _super);
        function BaseActionItem(context, action, options) {
            var _this = _super.call(this) || this;
            _this.options = options;
            _this._callOnDispose = [];
            _this._context = context || _this;
            _this._action = action;
            if (action instanceof actions_1.Action) {
                _this._callOnDispose.push(action.onDidChange(function (event) {
                    if (!_this.builder) {
                        // we have not been rendered yet, so there
                        // is no point in updating the UI
                        return;
                    }
                    _this._handleActionChangeEvent(event);
                }));
            }
            return _this;
        }
        BaseActionItem.prototype._handleActionChangeEvent = function (event) {
            if (event.enabled !== void 0) {
                this._updateEnabled();
            }
            if (event.checked !== void 0) {
                this._updateChecked();
            }
            if (event.class !== void 0) {
                this._updateClass();
            }
            if (event.label !== void 0) {
                this._updateLabel();
                this._updateTooltip();
            }
            if (event.tooltip !== void 0) {
                this._updateTooltip();
            }
        };
        Object.defineProperty(BaseActionItem.prototype, "callOnDispose", {
            get: function () {
                return this._callOnDispose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseActionItem.prototype, "actionRunner", {
            get: function () {
                return this._actionRunner;
            },
            set: function (actionRunner) {
                this._actionRunner = actionRunner;
            },
            enumerable: true,
            configurable: true
        });
        BaseActionItem.prototype.getAction = function () {
            return this._action;
        };
        BaseActionItem.prototype.isEnabled = function () {
            return this._action.enabled;
        };
        BaseActionItem.prototype.setActionContext = function (newContext) {
            this._context = newContext;
        };
        BaseActionItem.prototype.render = function (container) {
            var _this = this;
            this.builder = builder_1.$(container);
            this.gesture = new touch_1.Gesture(container);
            var enableDragging = this.options && this.options.draggable;
            if (enableDragging) {
                container.draggable = true;
            }
            this.builder.on(touch_1.EventType.Tap, function (e) { return _this.onClick(e); });
            if (platform.isMacintosh) {
                this.builder.on(DOM.EventType.CONTEXT_MENU, function (event) { return _this.onClick(event); }); // https://github.com/Microsoft/vscode/issues/1011
            }
            this.builder.on(DOM.EventType.MOUSE_DOWN, function (e) {
                if (!enableDragging) {
                    DOM.EventHelper.stop(e); // do not run when dragging is on because that would disable it
                }
                if (_this._action.enabled) {
                    _this.builder.addClass('active');
                }
            });
            this.builder.on(DOM.EventType.CLICK, function (e) {
                DOM.EventHelper.stop(e, true);
                setTimeout(function () { return _this.onClick(e); }, 50);
            });
            this.builder.on([DOM.EventType.MOUSE_UP, DOM.EventType.MOUSE_OUT], function (e) {
                DOM.EventHelper.stop(e);
                _this.builder.removeClass('active');
            });
        };
        BaseActionItem.prototype.onClick = function (event) {
            DOM.EventHelper.stop(event, true);
            var context;
            if (types.isUndefinedOrNull(this._context)) {
                context = event;
            }
            else {
                context = this._context;
                context.event = event;
            }
            this._actionRunner.run(this._action, context);
        };
        BaseActionItem.prototype.focus = function () {
            if (this.builder) {
                this.builder.domFocus();
            }
        };
        BaseActionItem.prototype.blur = function () {
            if (this.builder) {
                this.builder.domBlur();
            }
        };
        BaseActionItem.prototype._updateEnabled = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateLabel = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateTooltip = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateClass = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateChecked = function () {
            // implement in subclass
        };
        BaseActionItem.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.builder) {
                this.builder.destroy();
                this.builder = null;
            }
            if (this.gesture) {
                this.gesture.dispose();
                this.gesture = null;
            }
            this._callOnDispose = lifecycle.dispose(this._callOnDispose);
        };
        return BaseActionItem;
    }(eventEmitter_1.EventEmitter));
    exports.BaseActionItem = BaseActionItem;
    var Separator = (function (_super) {
        __extends(Separator, _super);
        function Separator(label, order) {
            var _this = _super.call(this, Separator.ID, label, label ? 'separator text' : 'separator') || this;
            _this.checked = false;
            _this.radio = false;
            _this.enabled = false;
            _this.order = order;
            return _this;
        }
        return Separator;
    }(actions_1.Action));
    Separator.ID = 'vs.actions.separator';
    exports.Separator = Separator;
    var ActionItem = (function (_super) {
        __extends(ActionItem, _super);
        function ActionItem(context, action, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, context, action, options) || this;
            _this.options = options;
            _this.options.icon = options.icon !== undefined ? options.icon : false;
            _this.options.label = options.label !== undefined ? options.label : true;
            _this.cssClass = '';
            return _this;
        }
        ActionItem.prototype.render = function (container) {
            _super.prototype.render.call(this, container);
            this.$e = builder_1.$('a.action-label').appendTo(this.builder);
            this.$e.attr({ role: 'button' });
            if (this.options.label && this.options.keybinding) {
                builder_1.$('span.keybinding').text(this.options.keybinding).appendTo(this.builder);
            }
            this._updateClass();
            this._updateLabel();
            this._updateTooltip();
            this._updateEnabled();
            this._updateChecked();
        };
        ActionItem.prototype.focus = function () {
            _super.prototype.focus.call(this);
            this.$e.domFocus();
        };
        ActionItem.prototype._updateLabel = function () {
            if (this.options.label) {
                this.$e.text(this.getAction().label);
            }
        };
        ActionItem.prototype._updateTooltip = function () {
            var title = null;
            if (this.getAction().tooltip) {
                title = this.getAction().tooltip;
            }
            else if (!this.options.label && this.getAction().label && this.options.icon) {
                title = this.getAction().label;
                if (this.options.keybinding) {
                    title = nls.localize(0, null, title, this.options.keybinding);
                }
            }
            if (title) {
                this.$e.attr({ title: title });
            }
        };
        ActionItem.prototype._updateClass = function () {
            if (this.cssClass) {
                this.$e.removeClass(this.cssClass);
            }
            if (this.options.icon) {
                this.cssClass = this.getAction().class;
                this.$e.addClass('icon');
                if (this.cssClass) {
                    this.$e.addClass(this.cssClass);
                }
                this._updateEnabled();
            }
            else {
                this.$e.removeClass('icon');
            }
        };
        ActionItem.prototype._updateEnabled = function () {
            if (this.getAction().enabled) {
                this.builder.removeClass('disabled');
                this.$e.removeClass('disabled');
                this.$e.attr({ tabindex: 0 });
            }
            else {
                this.builder.addClass('disabled');
                this.$e.addClass('disabled');
                DOM.removeTabIndexAndUpdateFocus(this.$e.getHTMLElement());
            }
        };
        ActionItem.prototype._updateChecked = function () {
            if (this.getAction().checked) {
                this.$e.addClass('checked');
            }
            else {
                this.$e.removeClass('checked');
            }
        };
        ActionItem.prototype._updateRadio = function () {
            if (this.getAction().radio) {
                this.$e.addClass('radio');
            }
            else {
                this.$e.removeClass('radio');
            }
        };
        return ActionItem;
    }(BaseActionItem));
    exports.ActionItem = ActionItem;
    var ActionsOrientation;
    (function (ActionsOrientation) {
        ActionsOrientation[ActionsOrientation["HORIZONTAL"] = 1] = "HORIZONTAL";
        ActionsOrientation[ActionsOrientation["VERTICAL"] = 2] = "VERTICAL";
    })(ActionsOrientation = exports.ActionsOrientation || (exports.ActionsOrientation = {}));
    var defaultOptions = {
        orientation: ActionsOrientation.HORIZONTAL,
        context: null
    };
    var ActionBar = (function (_super) {
        __extends(ActionBar, _super);
        function ActionBar(container, options) {
            if (options === void 0) { options = defaultOptions; }
            var _this = _super.call(this) || this;
            _this.options = options;
            _this._context = options.context;
            _this.toDispose = [];
            _this._actionRunner = _this.options.actionRunner;
            if (!_this._actionRunner) {
                _this._actionRunner = new actions_1.ActionRunner();
                _this.toDispose.push(_this._actionRunner);
            }
            _this.toDispose.push(_this.addEmitter2(_this._actionRunner));
            _this.items = [];
            _this.focusedItem = undefined;
            _this.domNode = document.createElement('div');
            _this.domNode.className = 'monaco-action-bar';
            if (options.animated !== false) {
                DOM.addClass(_this.domNode, 'animated');
            }
            var isVertical = _this.options.orientation === ActionsOrientation.VERTICAL;
            if (isVertical) {
                _this.domNode.className += ' vertical';
            }
            builder_1.$(_this.domNode).on(DOM.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                var eventHandled = true;
                if (event.equals(isVertical ? 16 /* UpArrow */ : 15 /* LeftArrow */)) {
                    _this.focusPrevious();
                }
                else if (event.equals(isVertical ? 18 /* DownArrow */ : 17 /* RightArrow */)) {
                    _this.focusNext();
                }
                else if (event.equals(9 /* Escape */)) {
                    _this.cancel();
                }
                else if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                }
                else {
                    eventHandled = false;
                }
                if (eventHandled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
            // Prevent native context menu on actions
            builder_1.$(_this.domNode).on(DOM.EventType.CONTEXT_MENU, function (e) {
                e.preventDefault();
                e.stopPropagation();
            });
            builder_1.$(_this.domNode).on(DOM.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                // Run action on Enter/Space
                if (event.equals(3 /* Enter */) || event.equals(10 /* Space */)) {
                    _this.doTrigger(event);
                    event.preventDefault();
                    event.stopPropagation();
                }
                else if (event.equals(2 /* Tab */) || event.equals(1024 /* Shift */ | 2 /* Tab */)) {
                    _this.updateFocusedItem();
                }
            });
            _this.focusTracker = DOM.trackFocus(_this.domNode);
            _this.focusTracker.addBlurListener(function () {
                if (document.activeElement === _this.domNode || !DOM.isAncestor(document.activeElement, _this.domNode)) {
                    _this.emit(DOM.EventType.BLUR, {});
                    _this.focusedItem = undefined;
                }
            });
            _this.focusTracker.addFocusListener(function () { return _this.updateFocusedItem(); });
            _this.actionsList = document.createElement('ul');
            _this.actionsList.className = 'actions-container';
            _this.actionsList.setAttribute('role', 'toolbar');
            if (_this.options.ariaLabel) {
                _this.actionsList.setAttribute('aria-label', _this.options.ariaLabel);
            }
            _this.domNode.appendChild(_this.actionsList);
            ((container instanceof builder_1.Builder) ? container.getHTMLElement() : container).appendChild(_this.domNode);
            return _this;
        }
        ActionBar.prototype.setAriaLabel = function (label) {
            if (label) {
                this.actionsList.setAttribute('aria-label', label);
            }
            else {
                this.actionsList.removeAttribute('aria-label');
            }
        };
        ActionBar.prototype.updateFocusedItem = function () {
            for (var i = 0; i < this.actionsList.children.length; i++) {
                var elem = this.actionsList.children[i];
                if (DOM.isAncestor(document.activeElement, elem)) {
                    this.focusedItem = i;
                    break;
                }
            }
        };
        Object.defineProperty(ActionBar.prototype, "context", {
            get: function () {
                return this._context;
            },
            set: function (context) {
                this._context = context;
                this.items.forEach(function (i) { return i.setActionContext(context); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActionBar.prototype, "actionRunner", {
            get: function () {
                return this._actionRunner;
            },
            set: function (actionRunner) {
                if (actionRunner) {
                    this._actionRunner = actionRunner;
                    this.items.forEach(function (item) { return item.actionRunner = actionRunner; });
                }
            },
            enumerable: true,
            configurable: true
        });
        ActionBar.prototype.getContainer = function () {
            return builder_1.$(this.domNode);
        };
        ActionBar.prototype.push = function (arg, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var actions = !Array.isArray(arg) ? [arg] : arg;
            var index = types.isNumber(options.index) ? options.index : null;
            actions.forEach(function (action) {
                var actionItemElement = document.createElement('li');
                actionItemElement.className = 'action-item';
                actionItemElement.setAttribute('role', 'presentation');
                var item = null;
                if (_this.options.actionItemProvider) {
                    item = _this.options.actionItemProvider(action);
                }
                if (!item) {
                    item = new ActionItem(_this.context, action, options);
                }
                item.actionRunner = _this._actionRunner;
                item.setActionContext(_this.context);
                _this.addEmitter2(item);
                item.render(actionItemElement);
                if (index === null || index < 0 || index >= _this.actionsList.children.length) {
                    _this.actionsList.appendChild(actionItemElement);
                }
                else {
                    _this.actionsList.insertBefore(actionItemElement, _this.actionsList.children[index++]);
                }
                _this.items.push(item);
            });
        };
        ActionBar.prototype.pull = function (index) {
            if (index >= 0 && index < this.items.length) {
                this.items.splice(index, 1);
                this.actionsList.removeChild(this.actionsList.childNodes[index]);
            }
        };
        ActionBar.prototype.clear = function () {
            // Do not dispose action items if they were provided from outside
            this.items = this.options.actionItemProvider ? [] : lifecycle.dispose(this.items);
            builder_1.$(this.actionsList).empty();
        };
        ActionBar.prototype.length = function () {
            return this.items.length;
        };
        ActionBar.prototype.isEmpty = function () {
            return this.items.length === 0;
        };
        ActionBar.prototype.focus = function (selectFirst) {
            if (selectFirst && typeof this.focusedItem === 'undefined') {
                this.focusedItem = 0;
            }
            this.updateFocus();
        };
        ActionBar.prototype.focusNext = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.focusedItem = this.items.length - 1;
            }
            var startIndex = this.focusedItem;
            var item;
            do {
                this.focusedItem = (this.focusedItem + 1) % this.items.length;
                item = this.items[this.focusedItem];
            } while (this.focusedItem !== startIndex && !item.isEnabled());
            if (this.focusedItem === startIndex && !item.isEnabled()) {
                this.focusedItem = undefined;
            }
            this.updateFocus();
        };
        ActionBar.prototype.focusPrevious = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.focusedItem = 0;
            }
            var startIndex = this.focusedItem;
            var item;
            do {
                this.focusedItem = this.focusedItem - 1;
                if (this.focusedItem < 0) {
                    this.focusedItem = this.items.length - 1;
                }
                item = this.items[this.focusedItem];
            } while (this.focusedItem !== startIndex && !item.isEnabled());
            if (this.focusedItem === startIndex && !item.isEnabled()) {
                this.focusedItem = undefined;
            }
            this.updateFocus();
        };
        ActionBar.prototype.updateFocus = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.domNode.focus();
                return;
            }
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];
                var actionItem = item;
                if (i === this.focusedItem) {
                    if (types.isFunction(actionItem.focus)) {
                        actionItem.focus();
                    }
                }
                else {
                    if (types.isFunction(actionItem.blur)) {
                        actionItem.blur();
                    }
                }
            }
        };
        ActionBar.prototype.doTrigger = function (event) {
            if (typeof this.focusedItem === 'undefined') {
                return; //nothing to focus
            }
            // trigger action
            var actionItem = this.items[this.focusedItem];
            if (actionItem instanceof BaseActionItem) {
                var context = (actionItem._context === null || actionItem._context === undefined) ? event : actionItem._context;
                this.run(actionItem._action, context).done();
            }
        };
        ActionBar.prototype.cancel = function () {
            if (document.activeElement instanceof HTMLElement) {
                document.activeElement.blur(); // remove focus from focussed action
            }
            this.emit(events_1.EventType.CANCEL);
        };
        ActionBar.prototype.run = function (action, context) {
            return this._actionRunner.run(action, context);
        };
        ActionBar.prototype.dispose = function () {
            if (this.items !== null) {
                lifecycle.dispose(this.items);
            }
            this.items = null;
            if (this.focusTracker) {
                this.focusTracker.dispose();
                this.focusTracker = null;
            }
            this.toDispose = lifecycle.dispose(this.toDispose);
            this.getContainer().destroy();
            _super.prototype.dispose.call(this);
        };
        return ActionBar;
    }(eventEmitter_1.EventEmitter));
    exports.ActionBar = ActionBar;
    var SelectActionItem = (function (_super) {
        __extends(SelectActionItem, _super);
        function SelectActionItem(ctx, action, options, selected) {
            var _this = _super.call(this, ctx, action) || this;
            _this.selectBox = new selectBox_1.SelectBox(options, selected);
            _this.toDispose = [];
            _this.toDispose.push(_this.selectBox);
            _this.registerListeners();
            return _this;
        }
        SelectActionItem.prototype.setOptions = function (options, selected) {
            this.selectBox.setOptions(options, selected);
        };
        SelectActionItem.prototype.select = function (index) {
            this.selectBox.select(index);
        };
        SelectActionItem.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(this.selectBox.onDidSelect(function (selected) {
                _this.actionRunner.run(_this._action, _this.getActionContext(selected)).done();
            }));
        };
        SelectActionItem.prototype.getActionContext = function (option) {
            return option;
        };
        SelectActionItem.prototype.focus = function () {
            if (this.selectBox) {
                this.selectBox.focus();
            }
        };
        SelectActionItem.prototype.blur = function () {
            if (this.selectBox) {
                this.selectBox.blur();
            }
        };
        SelectActionItem.prototype.render = function (container) {
            this.selectBox.render(container);
        };
        SelectActionItem.prototype.dispose = function () {
            this.toDispose = lifecycle.dispose(this.toDispose);
            _super.prototype.dispose.call(this);
        };
        return SelectActionItem;
    }(BaseActionItem));
    exports.SelectActionItem = SelectActionItem;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[245/*vs/base/browser/ui/menu/menu*/], __M([1/*require*/,0/*exports*/,33/*vs/base/browser/builder*/,69/*vs/base/browser/ui/actionbar/actionbar*/,25/*vs/base/common/eventEmitter*/,243/*vs/css!vs/base/browser/ui/menu/menu*/]), function (require, exports, builder_1, actionbar_1, eventEmitter_1) {
    'use strict';
    var Menu = (function (_super) {
        __extends(Menu, _super);
        function Menu(container, actions, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            builder_1.$(container).addClass('monaco-menu-container');
            var $menu = builder_1.$('.monaco-menu').appendTo(container);
            _this.actionBar = new actionbar_1.ActionBar($menu, {
                orientation: actionbar_1.ActionsOrientation.VERTICAL,
                actionItemProvider: options.actionItemProvider,
                context: options.context,
                actionRunner: options.actionRunner
            });
            _this.listener = _this.addEmitter2(_this.actionBar);
            _this.actionBar.push(actions, { icon: true, label: true });
            return _this;
        }
        Menu.prototype.focus = function () {
            this.actionBar.focus(true);
        };
        Menu.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.actionBar) {
                this.actionBar.dispose();
                this.actionBar = null;
            }
            if (this.listener) {
                this.listener.dispose();
                this.listener = null;
            }
        };
        return Menu;
    }(eventEmitter_1.EventEmitter));
    exports.Menu = Menu;
});

define(__m[246/*vs/nls!vs/base/browser/ui/aria/aria*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/browser/ui/aria/aria", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[99/*vs/base/browser/ui/aria/aria*/], __M([1/*require*/,0/*exports*/,246/*vs/nls!vs/base/browser/ui/aria/aria*/,19/*vs/base/common/platform*/,33/*vs/base/browser/builder*/,200/*vs/css!vs/base/browser/ui/aria/aria*/]), function (require, exports, nls, platform_1, builder_1) {
    'use strict';
    var ariaContainer;
    var alertContainer;
    var statusContainer;
    function setARIAContainer(parent) {
        ariaContainer = builder_1.$('.aria-container').appendTo(parent);
        alertContainer = builder_1.$('.alert').appendTo(ariaContainer).attr({ 'role': 'alert', 'aria-atomic': 'true' });
        statusContainer = builder_1.$('.status').appendTo(ariaContainer).attr({ 'role': 'status', 'aria-atomic': 'true' });
    }
    exports.setARIAContainer = setARIAContainer;
    /**
     * Given the provided message, will make sure that it is read as alert to screen readers.
     */
    function alert(msg) {
        insertMessage(alertContainer, msg);
    }
    exports.alert = alert;
    /**
     * Given the provided message, will make sure that it is read as status to screen readers.
     */
    function status(msg) {
        if (platform_1.isMacintosh) {
            alert(msg); // VoiceOver does not seem to support status role
        }
        else {
            insertMessage(statusContainer, msg);
        }
    }
    exports.status = status;
    function insertMessage(target, msg) {
        if (!ariaContainer) {
            // console.warn('ARIA support needs a container. Call setARIAContainer() first.');
            return;
        }
        if (target.getHTMLElement().textContent === msg) {
            msg = nls.localize(0, null, msg);
        }
        builder_1.$(target).empty();
        builder_1.$(target).text(msg);
    }
});

define(__m[248/*vs/nls!vs/base/browser/ui/findinput/findInput*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/browser/ui/findinput/findInput", data); });
define(__m[249/*vs/nls!vs/base/browser/ui/inputbox/inputBox*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/browser/ui/inputbox/inputBox", data); });





define(__m[100/*vs/base/browser/ui/inputbox/inputBox*/], __M([1/*require*/,0/*exports*/,249/*vs/nls!vs/base/browser/ui/inputbox/inputBox*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,103/*vs/base/browser/htmlContentRenderer*/,99/*vs/base/browser/ui/aria/aria*/,69/*vs/base/browser/ui/actionbar/actionbar*/,171/*vs/base/browser/ui/contextview/contextview*/,12/*vs/base/common/event*/,40/*vs/base/browser/ui/widget*/,233/*vs/css!vs/base/browser/ui/inputbox/inputBox*/]), function (require, exports, nls, Bal, dom, htmlContentRenderer_1, aria, actionbar_1, contextview_1, event_1, widget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var $ = dom.$;
    var MessageType;
    (function (MessageType) {
        MessageType[MessageType["INFO"] = 1] = "INFO";
        MessageType[MessageType["WARNING"] = 2] = "WARNING";
        MessageType[MessageType["ERROR"] = 3] = "ERROR";
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var InputBox = (function (_super) {
        __extends(InputBox, _super);
        function InputBox(container, contextViewProvider, options) {
            var _this = _super.call(this) || this;
            _this.state = 'idle';
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            _this._onDidHeightChange = _this._register(new event_1.Emitter());
            _this.onDidHeightChange = _this._onDidHeightChange.event;
            _this.contextViewProvider = contextViewProvider;
            _this.options = options || Object.create(null);
            _this.message = null;
            _this.cachedHeight = null;
            _this.placeholder = _this.options.placeholder || '';
            _this.ariaLabel = _this.options.ariaLabel || '';
            if (_this.options.validationOptions) {
                _this.validation = _this.options.validationOptions.validation;
                _this.showValidationMessage = _this.options.validationOptions.showMessage || false;
            }
            _this.element = dom.append(container, $('.monaco-inputbox.idle'));
            var tagName = _this.options.flexibleHeight ? 'textarea' : 'input';
            var wrapper = dom.append(_this.element, $('.wrapper'));
            _this.input = dom.append(wrapper, $(tagName + '.input'));
            _this.input.setAttribute('autocorrect', 'off');
            _this.input.setAttribute('autocapitalize', 'off');
            _this.input.setAttribute('spellcheck', 'false');
            _this.onfocus(_this.input, function () { return dom.addClass(_this.element, 'synthetic-focus'); });
            _this.onblur(_this.input, function () { return dom.removeClass(_this.element, 'synthetic-focus'); });
            if (_this.options.flexibleHeight) {
                _this.mirror = dom.append(wrapper, $('div.mirror'));
            }
            else {
                _this.input.type = _this.options.type || 'text';
                _this.input.setAttribute('wrap', 'off');
            }
            if (_this.ariaLabel) {
                _this.input.setAttribute('aria-label', _this.ariaLabel);
            }
            if (_this.placeholder) {
                _this.input.setAttribute('placeholder', _this.placeholder);
                _this.input.title = _this.placeholder;
            }
            _this.oninput(_this.input, function () { return _this.onValueChange(); });
            _this.onblur(_this.input, function () { return _this.onBlur(); });
            _this.onfocus(_this.input, function () { return _this.onFocus(); });
            // Add placeholder shim for IE because IE decides to hide the placeholder on focus (we dont want that!)
            if (_this.placeholder && Bal.isIE) {
                _this.onclick(_this.input, function (e) {
                    dom.EventHelper.stop(e, true);
                    _this.input.focus();
                });
            }
            setTimeout(function () { return _this.updateMirror(); }, 0);
            // Support actions
            if (_this.options.actions) {
                _this.actionbar = _this._register(new actionbar_1.ActionBar(_this.element));
                _this.actionbar.push(_this.options.actions, { icon: true, label: false });
            }
            return _this;
        }
        InputBox.prototype.onBlur = function () {
            this._hideMessage();
        };
        InputBox.prototype.onFocus = function () {
            this._showMessage();
        };
        InputBox.prototype.setPlaceHolder = function (placeHolder) {
            if (this.input) {
                this.input.setAttribute('placeholder', placeHolder);
            }
        };
        InputBox.prototype.setAriaLabel = function (label) {
            this.ariaLabel = label;
            if (this.input) {
                if (label) {
                    this.input.setAttribute('aria-label', this.ariaLabel);
                }
                else {
                    this.input.removeAttribute('aria-label');
                }
            }
        };
        InputBox.prototype.setContextViewProvider = function (contextViewProvider) {
            this.contextViewProvider = contextViewProvider;
        };
        Object.defineProperty(InputBox.prototype, "inputElement", {
            get: function () {
                return this.input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "value", {
            get: function () {
                return this.input.value;
            },
            set: function (newValue) {
                if (this.input.value !== newValue) {
                    this.input.value = newValue;
                    this.onValueChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "height", {
            get: function () {
                return this.cachedHeight === null ? dom.getTotalHeight(this.element) : this.cachedHeight;
            },
            enumerable: true,
            configurable: true
        });
        InputBox.prototype.focus = function () {
            this.input.focus();
        };
        InputBox.prototype.blur = function () {
            this.input.blur();
        };
        InputBox.prototype.hasFocus = function () {
            return document.activeElement === this.input;
        };
        InputBox.prototype.select = function (range) {
            if (range === void 0) { range = null; }
            this.input.select();
            if (range) {
                this.input.setSelectionRange(range.start, range.end);
            }
        };
        InputBox.prototype.enable = function () {
            this.input.removeAttribute('disabled');
        };
        InputBox.prototype.disable = function () {
            this.input.disabled = true;
            this._hideMessage();
        };
        InputBox.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        Object.defineProperty(InputBox.prototype, "width", {
            get: function () {
                return dom.getTotalWidth(this.input);
            },
            set: function (width) {
                this.input.style.width = width + 'px';
            },
            enumerable: true,
            configurable: true
        });
        InputBox.prototype.showMessage = function (message, force) {
            this.message = message;
            dom.removeClass(this.element, 'idle');
            dom.removeClass(this.element, 'info');
            dom.removeClass(this.element, 'warning');
            dom.removeClass(this.element, 'error');
            dom.addClass(this.element, this.classForType(message.type));
            // ARIA Support
            var alertText;
            if (message.type === MessageType.ERROR) {
                alertText = nls.localize(0, null, message.content);
            }
            else if (message.type === MessageType.WARNING) {
                alertText = nls.localize(1, null, message.content);
            }
            else {
                alertText = nls.localize(2, null, message.content);
            }
            aria.alert(alertText);
            if (this.hasFocus() || force) {
                this._showMessage();
            }
        };
        InputBox.prototype.hideMessage = function () {
            this.message = null;
            dom.removeClass(this.element, 'info');
            dom.removeClass(this.element, 'warning');
            dom.removeClass(this.element, 'error');
            dom.addClass(this.element, 'idle');
            this._hideMessage();
        };
        InputBox.prototype.isInputValid = function () {
            return !!this.validation && !this.validation(this.value);
        };
        InputBox.prototype.validate = function () {
            var result = null;
            if (this.validation) {
                result = this.validation(this.value);
                if (!result) {
                    this.inputElement.removeAttribute('aria-invalid');
                    this.hideMessage();
                }
                else {
                    this.inputElement.setAttribute('aria-invalid', 'true');
                    this.showMessage(result);
                }
            }
            return !result;
        };
        InputBox.prototype.classForType = function (type) {
            switch (type) {
                case MessageType.INFO: return 'info';
                case MessageType.WARNING: return 'warning';
                default: return 'error';
            }
        };
        InputBox.prototype._showMessage = function () {
            var _this = this;
            if (!this.contextViewProvider || !this.message) {
                return;
            }
            var div;
            var layout = function () { return div.style.width = dom.getTotalWidth(_this.element) + 'px'; };
            this.state = 'open';
            this.contextViewProvider.showContextView({
                getAnchor: function () { return _this.element; },
                anchorAlignment: contextview_1.AnchorAlignment.RIGHT,
                render: function (container) {
                    div = dom.append(container, $('.monaco-inputbox-container'));
                    layout();
                    var renderOptions = {
                        tagName: 'span',
                        className: 'monaco-inputbox-message',
                    };
                    if (_this.message.formatContent) {
                        renderOptions.formattedText = _this.message.content;
                    }
                    else {
                        renderOptions.text = _this.message.content;
                    }
                    var spanElement = htmlContentRenderer_1.renderHtml(renderOptions);
                    dom.addClass(spanElement, _this.classForType(_this.message.type));
                    dom.append(div, spanElement);
                    return null;
                },
                layout: layout
            });
        };
        InputBox.prototype._hideMessage = function () {
            if (!this.contextViewProvider || this.state !== 'open') {
                return;
            }
            this.state = 'idle';
            this.contextViewProvider.hideContextView();
        };
        InputBox.prototype.onValueChange = function () {
            this._onDidChange.fire(this.value);
            this.validate();
            this.updateMirror();
            if (this.state === 'open') {
                this.contextViewProvider.layout();
            }
        };
        InputBox.prototype.updateMirror = function () {
            if (!this.mirror) {
                return;
            }
            var value = this.value || this.placeholder;
            var lastCharCode = value.charCodeAt(value.length - 1);
            var suffix = lastCharCode === 10 ? ' ' : '';
            this.mirror.textContent = value + suffix;
            this.layout();
        };
        InputBox.prototype.layout = function () {
            if (!this.mirror) {
                return;
            }
            var previousHeight = this.cachedHeight;
            this.cachedHeight = dom.getTotalHeight(this.mirror);
            if (previousHeight !== this.cachedHeight) {
                this.input.style.height = this.cachedHeight + 'px';
                this._onDidHeightChange.fire(this.cachedHeight);
            }
        };
        InputBox.prototype.dispose = function () {
            this._hideMessage();
            this.element = null;
            this.input = null;
            this.contextViewProvider = null;
            this.message = null;
            this.placeholder = null;
            this.ariaLabel = null;
            this.validation = null;
            this.showValidationMessage = null;
            this.state = null;
            this.actionbar = null;
            _super.prototype.dispose.call(this);
        };
        return InputBox;
    }(widget_1.Widget));
    exports.InputBox = InputBox;
});






define(__m[251/*vs/base/browser/ui/findinput/findInput*/], __M([1/*require*/,0/*exports*/,248/*vs/nls!vs/base/browser/ui/findinput/findInput*/,11/*vs/base/browser/dom*/,100/*vs/base/browser/ui/inputbox/inputBox*/,204/*vs/base/browser/ui/checkbox/checkbox*/,40/*vs/base/browser/ui/widget*/,12/*vs/base/common/event*/,218/*vs/css!vs/base/browser/ui/findinput/findInput*/]), function (require, exports, nls, dom, inputBox_1, checkbox_1, widget_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NLS_REGEX_CHECKBOX_LABEL = nls.localize(0, null);
    var NLS_WHOLE_WORD_CHECKBOX_LABEL = nls.localize(1, null);
    var NLS_CASE_SENSITIVE_CHECKBOX_LABEL = nls.localize(2, null);
    var NLS_DEFAULT_LABEL = nls.localize(3, null);
    var FindInput = (function (_super) {
        __extends(FindInput, _super);
        function FindInput(parent, contextViewProvider, options) {
            var _this = _super.call(this) || this;
            _this._onDidOptionChange = _this._register(new event_1.Emitter());
            _this.onDidOptionChange = _this._onDidOptionChange.event;
            _this._onKeyDown = _this._register(new event_1.Emitter());
            _this.onKeyDown = _this._onKeyDown.event;
            _this._onInput = _this._register(new event_1.Emitter());
            _this.onInput = _this._onInput.event;
            _this._onKeyUp = _this._register(new event_1.Emitter());
            _this.onKeyUp = _this._onKeyUp.event;
            _this._onCaseSensitiveKeyDown = _this._register(new event_1.Emitter());
            _this.onCaseSensitiveKeyDown = _this._onCaseSensitiveKeyDown.event;
            _this.contextViewProvider = contextViewProvider;
            _this.width = options.width || 100;
            _this.placeholder = options.placeholder || '';
            _this.validation = options.validation;
            _this.label = options.label || NLS_DEFAULT_LABEL;
            _this.regex = null;
            _this.wholeWords = null;
            _this.caseSensitive = null;
            _this.domNode = null;
            _this.inputBox = null;
            _this.buildDomNode(options.appendCaseSensitiveLabel || '', options.appendWholeWordsLabel || '', options.appendRegexLabel || '');
            if (Boolean(parent)) {
                parent.appendChild(_this.domNode);
            }
            _this.onkeydown(_this.inputBox.inputElement, function (e) { return _this._onKeyDown.fire(e); });
            _this.onkeyup(_this.inputBox.inputElement, function (e) { return _this._onKeyUp.fire(e); });
            _this.oninput(_this.inputBox.inputElement, function (e) { return _this._onInput.fire(); });
            return _this;
        }
        FindInput.prototype.enable = function () {
            dom.removeClass(this.domNode, 'disabled');
            this.inputBox.enable();
            this.regex.enable();
            this.wholeWords.enable();
            this.caseSensitive.enable();
        };
        FindInput.prototype.disable = function () {
            dom.addClass(this.domNode, 'disabled');
            this.inputBox.disable();
            this.regex.disable();
            this.wholeWords.disable();
            this.caseSensitive.disable();
        };
        FindInput.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        FindInput.prototype.clear = function () {
            this.clearValidation();
            this.setValue('');
            this.focus();
        };
        FindInput.prototype.setWidth = function (newWidth) {
            this.width = newWidth;
            this.domNode.style.width = this.width + 'px';
            this.contextViewProvider.layout();
            this.setInputWidth();
        };
        FindInput.prototype.getValue = function () {
            return this.inputBox.value;
        };
        FindInput.prototype.setValue = function (value) {
            if (this.inputBox.value !== value) {
                this.inputBox.value = value;
            }
        };
        FindInput.prototype.select = function () {
            this.inputBox.select();
        };
        FindInput.prototype.focus = function () {
            this.inputBox.focus();
        };
        FindInput.prototype.getCaseSensitive = function () {
            return this.caseSensitive.checked;
        };
        FindInput.prototype.setCaseSensitive = function (value) {
            this.caseSensitive.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.getWholeWords = function () {
            return this.wholeWords.checked;
        };
        FindInput.prototype.setWholeWords = function (value) {
            this.wholeWords.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.getRegex = function () {
            return this.regex.checked;
        };
        FindInput.prototype.setRegex = function (value) {
            this.regex.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.focusOnCaseSensitive = function () {
            this.caseSensitive.focus();
        };
        FindInput.prototype.setInputWidth = function () {
            var w = this.width - this.caseSensitive.width() - this.wholeWords.width() - this.regex.width();
            this.inputBox.width = w;
        };
        FindInput.prototype.buildDomNode = function (appendCaseSensitiveLabel, appendWholeWordsLabel, appendRegexLabel) {
            var _this = this;
            this.domNode = document.createElement('div');
            this.domNode.style.width = this.width + 'px';
            dom.addClass(this.domNode, 'monaco-findInput');
            this.inputBox = this._register(new inputBox_1.InputBox(this.domNode, this.contextViewProvider, {
                placeholder: this.placeholder || '',
                ariaLabel: this.label || '',
                validationOptions: {
                    validation: this.validation || null,
                    showMessage: true
                }
            }));
            this.regex = this._register(new checkbox_1.Checkbox({
                actionClassName: 'regex',
                title: NLS_REGEX_CHECKBOX_LABEL + appendRegexLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                }
            }));
            this.wholeWords = this._register(new checkbox_1.Checkbox({
                actionClassName: 'whole-word',
                title: NLS_WHOLE_WORD_CHECKBOX_LABEL + appendWholeWordsLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                }
            }));
            this.caseSensitive = this._register(new checkbox_1.Checkbox({
                actionClassName: 'case-sensitive',
                title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + appendCaseSensitiveLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                },
                onKeyDown: function (e) {
                    _this._onCaseSensitiveKeyDown.fire(e);
                }
            }));
            // Arrow-Key support to navigate between options
            var indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
            this.onkeydown(this.domNode, function (event) {
                if (event.equals(15 /* LeftArrow */) || event.equals(17 /* RightArrow */) || event.equals(9 /* Escape */)) {
                    var index = indexes.indexOf(document.activeElement);
                    if (index >= 0) {
                        var newIndex = void 0;
                        if (event.equals(17 /* RightArrow */)) {
                            newIndex = (index + 1) % indexes.length;
                        }
                        else if (event.equals(15 /* LeftArrow */)) {
                            if (index === 0) {
                                newIndex = indexes.length - 1;
                            }
                            else {
                                newIndex = index - 1;
                            }
                        }
                        if (event.equals(9 /* Escape */)) {
                            indexes[index].blur();
                        }
                        else if (newIndex >= 0) {
                            indexes[newIndex].focus();
                        }
                        dom.EventHelper.stop(event, true);
                    }
                }
            });
            this.setInputWidth();
            var controls = document.createElement('div');
            controls.className = 'controls';
            controls.appendChild(this.caseSensitive.domNode);
            controls.appendChild(this.wholeWords.domNode);
            controls.appendChild(this.regex.domNode);
            this.domNode.appendChild(controls);
        };
        FindInput.prototype.validate = function () {
            this.inputBox.validate();
        };
        FindInput.prototype.showMessage = function (message) {
            this.inputBox.showMessage(message);
        };
        FindInput.prototype.clearMessage = function () {
            this.inputBox.hideMessage();
        };
        FindInput.prototype.clearValidation = function () {
            this.inputBox.hideMessage();
        };
        FindInput.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return FindInput;
    }(widget_1.Widget));
    FindInput.OPTION_CHANGE = 'optionChange';
    exports.FindInput = FindInput;
});

define(__m[252/*vs/nls!vs/base/common/json*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/common/json", data); });
define(__m[253/*vs/base/common/json*/], __M([1/*require*/,0/*exports*/,252/*vs/nls!vs/base/common/json*/]), function (require, exports, nls_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ScanError;
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    })(ScanError = exports.ScanError || (exports.ScanError = {}));
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
    })(SyntaxKind = exports.SyntaxKind || (exports.SyntaxKind = {}));
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                    value = value * 16 + ch - 48 /* _0 */;
                }
                else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                    value = value * 16 + ch - 65 /* A */ + 10;
                }
                else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                    value = value * 16 + ch - 97 /* a */ + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = SyntaxKind.Unknown;
            scanError = ScanError.None;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === 48 /* _0 */) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                    return text.substring(start, pos);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === 34 /* doubleQuote */) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* backslash */) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case 34 /* doubleQuote */:
                            result += '\"';
                            break;
                        case 92 /* backslash */:
                            result += '\\';
                            break;
                        case 47 /* slash */:
                            result += '/';
                            break;
                        case 98 /* b */:
                            result += '\b';
                            break;
                        case 102 /* f */:
                            result += '\f';
                            break;
                        case 110 /* n */:
                            result += '\n';
                            break;
                        case 114 /* r */:
                            result += '\r';
                            break;
                        case 116 /* t */:
                            result += '\t';
                            break;
                        case 117 /* u */:
                            var ch_1 = scanHexDigits(4, true);
                            if (ch_1 >= 0) {
                                result += String.fromCharCode(ch_1);
                            }
                            else {
                                scanError = ScanError.InvalidUnicode;
                            }
                            break;
                        default:
                            scanError = ScanError.InvalidEscapeCharacter;
                    }
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = ScanError.None;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = SyntaxKind.EOF;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = SyntaxKind.Trivia;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                    pos++;
                    value += '\n';
                }
                return token = SyntaxKind.LineBreakTrivia;
            }
            switch (code) {
                // tokens: []{}:,
                case 123 /* openBrace */:
                    pos++;
                    return token = SyntaxKind.OpenBraceToken;
                case 125 /* closeBrace */:
                    pos++;
                    return token = SyntaxKind.CloseBraceToken;
                case 91 /* openBracket */:
                    pos++;
                    return token = SyntaxKind.OpenBracketToken;
                case 93 /* closeBracket */:
                    pos++;
                    return token = SyntaxKind.CloseBracketToken;
                case 58 /* colon */:
                    pos++;
                    return token = SyntaxKind.ColonToken;
                case 44 /* comma */:
                    pos++;
                    return token = SyntaxKind.CommaToken;
                // strings
                case 34 /* doubleQuote */:
                    pos++;
                    value = scanString();
                    return token = SyntaxKind.StringLiteral;
                // comments
                case 47 /* slash */:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.LineCommentTrivia;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = ScanError.UnexpectedEndOfComment;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.BlockCommentTrivia;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
                // numbers
                case 45 /* minus */:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = SyntaxKind.Unknown;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case 48 /* _0 */:
                case 49 /* _1 */:
                case 50 /* _2 */:
                case 51 /* _3 */:
                case 52 /* _4 */:
                case 53 /* _5 */:
                case 54 /* _6 */:
                case 55 /* _7 */:
                case 56 /* _8 */:
                case 57 /* _9 */:
                    value += scanNumber();
                    return token = SyntaxKind.NumericLiteral;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = SyntaxKind.TrueKeyword;
                            case 'false': return token = SyntaxKind.FalseKeyword;
                            case 'null': return token = SyntaxKind.NullKeyword;
                        }
                        return token = SyntaxKind.Unknown;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case 125 /* closeBrace */:
                case 93 /* closeBracket */:
                case 123 /* openBrace */:
                case 91 /* openBracket */:
                case 34 /* doubleQuote */:
                case 58 /* colon */:
                case 44 /* comma */:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
            ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
            ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
    }
    function isLineBreak(ch) {
        return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
    }
    function isDigit(ch) {
        return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * Takes JSON with JavaScript-style comments and remove
     * them. Optionally replaces every none-newline character
     * of comments with a replaceCharacter
     */
    function stripComments(text, replaceCh) {
        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
        do {
            pos = _scanner.getPosition();
            kind = _scanner.scan();
            switch (kind) {
                case SyntaxKind.LineCommentTrivia:
                case SyntaxKind.BlockCommentTrivia:
                case SyntaxKind.EOF:
                    if (offset !== pos) {
                        parts.push(text.substring(offset, pos));
                    }
                    if (replaceCh !== void 0) {
                        parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                    }
                    offset = _scanner.getPosition();
                    break;
            }
        } while (kind !== SyntaxKind.EOF);
        return parts.join('');
    }
    exports.stripComments = stripComments;
    var ParseErrorCode;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 0] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 1] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 2] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 3] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 4] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 5] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 6] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 7] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 8] = "EndOfFileExpected";
    })(ParseErrorCode = exports.ParseErrorCode || (exports.ParseErrorCode = {}));
    function getParseErrorMessage(errorCode) {
        switch (errorCode) {
            case ParseErrorCode.InvalidSymbol: return nls_1.localize(0, null);
            case ParseErrorCode.InvalidNumberFormat: return nls_1.localize(1, null);
            case ParseErrorCode.PropertyNameExpected: return nls_1.localize(2, null);
            case ParseErrorCode.ValueExpected: return nls_1.localize(3, null);
            case ParseErrorCode.ColonExpected: return nls_1.localize(4, null);
            case ParseErrorCode.CommaExpected: return nls_1.localize(5, null);
            case ParseErrorCode.CloseBraceExpected: return nls_1.localize(6, null);
            case ParseErrorCode.CloseBracketExpected: return nls_1.localize(7, null);
            case ParseErrorCode.EndOfFileExpected: return nls_1.localize(8, null);
            default:
                return '';
        }
    }
    exports.getParseErrorMessage = getParseErrorMessage;
    function getLiteralNodeType(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            default: return 'null';
        }
    }
    /**
     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
     */
    function getLocation(text, position) {
        var segments = []; // strings or numbers
        var earlyReturnException = new Object();
        var previousNode = void 0;
        var previousNodeInst = {
            value: void 0,
            offset: void 0,
            length: void 0,
            type: void 0
        };
        var isAtPropertyKey = false;
        function setPreviousNode(value, offset, length, type) {
            previousNodeInst.value = value;
            previousNodeInst.offset = offset;
            previousNodeInst.length = length;
            previousNodeInst.type = type;
            previousNodeInst.columnOffset = void 0;
            previousNode = previousNodeInst;
        }
        try {
            visit(text, {
                onObjectBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    isAtPropertyKey = position > offset;
                    segments.push(''); // push a placeholder (will be replaced or removed)
                },
                onObjectProperty: function (name, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(name, offset, length, 'property');
                    segments[segments.length - 1] = name;
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onObjectEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onArrayBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.push(0);
                },
                onArrayEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onLiteralValue: function (value, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(value, offset, length, getLiteralNodeType(value));
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onSeparator: function (sep, offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    if (sep === ':' && previousNode.type === 'property') {
                        previousNode.columnOffset = offset;
                        isAtPropertyKey = false;
                        previousNode = void 0;
                    }
                    else if (sep === ',') {
                        var last = segments[segments.length - 1];
                        if (typeof last === 'number') {
                            segments[segments.length - 1] = last + 1;
                        }
                        else {
                            isAtPropertyKey = true;
                            segments[segments.length - 1] = '';
                        }
                        previousNode = void 0;
                    }
                }
            });
        }
        catch (e) {
            if (e !== earlyReturnException) {
                throw e;
            }
        }
        if (segments[segments.length - 1] === '') {
            segments.pop();
        }
        return {
            path: segments,
            previousNode: previousNode,
            isAtPropertyKey: isAtPropertyKey,
            matches: function (pattern) {
                var k = 0;
                for (var i = 0; k < pattern.length && i < segments.length; i++) {
                    if (pattern[k] === segments[i] || pattern[k] === '*') {
                        k++;
                    }
                    else if (pattern[k] !== '**') {
                        return false;
                    }
                }
                return k === pattern.length;
            }
        };
    }
    exports.getLocation = getLocation;
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function parse(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        return currentParent[0];
    }
    exports.parse = parse;
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function parseTree(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            ensurePropertyComplete(valueNode.offset + valueNode.length);
            return valueNode;
        }
        var visitor = {
            onObjectBegin: function (offset) {
                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: function (name, offset, length) {
                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
            },
            onObjectEnd: function (offset, length) {
                ensurePropertyComplete(offset);
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
            },
            onArrayBegin: function (offset, length) {
                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
            },
            onLiteralValue: function (value, offset, length) {
                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            },
            onSeparator: function (sep, offset, length) {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.columnOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        var result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    exports.parseTree = parseTree;
    function findNodeAtLocation(root, path) {
        if (!root) {
            return void 0;
        }
        var node = root;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var segment = path_1[_i];
            if (typeof segment === 'string') {
                if (node.type !== 'object') {
                    return void 0;
                }
                var found = false;
                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                    var propertyNode = _b[_a];
                    if (propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return void 0;
                }
            }
            else {
                var index = segment;
                if (node.type !== 'array' || index < 0 || index >= node.children.length) {
                    return void 0;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    exports.findNodeAtLocation = findNodeAtLocation;
    function getNodeValue(node) {
        if (node.type === 'array') {
            return node.children.map(getNodeValue);
        }
        else if (node.type === 'object') {
            var obj = {};
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                obj[prop.children[0].value] = getNodeValue(prop.children[1]);
            }
            return obj;
        }
        return node.value;
    }
    exports.getNodeValue = getNodeValue;
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function visit(text, visitor, options) {
        var _scanner = createScanner(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);
        var disallowComments = options && options.disallowComments;
        function scanNext() {
            while (true) {
                var token = _scanner.scan();
                switch (token) {
                    case SyntaxKind.LineCommentTrivia:
                    case SyntaxKind.BlockCommentTrivia:
                        if (disallowComments) {
                            handleError(ParseErrorCode.InvalidSymbol);
                        }
                        break;
                    case SyntaxKind.Unknown:
                        handleError(ParseErrorCode.InvalidSymbol);
                        break;
                    case SyntaxKind.Trivia:
                    case SyntaxKind.LineBreakTrivia:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== SyntaxKind.EOF) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            var value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case SyntaxKind.NumericLiteral:
                    var value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(ParseErrorCode.InvalidNumberFormat);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(ParseErrorCode.InvalidNumberFormat);
                    }
                    onLiteralValue(value);
                    break;
                case SyntaxKind.NullKeyword:
                    onLiteralValue(null);
                    break;
                case SyntaxKind.TrueKeyword:
                    onLiteralValue(true);
                    break;
                case SyntaxKind.FalseKeyword:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                return false;
            }
            parseString(false);
            if (_scanner.getToken() === SyntaxKind.ColonToken) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
            }
            else {
                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            return true;
        }
        function parseObject() {
            onObjectBegin();
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseProperty()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            onArrayBegin();
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            switch (_scanner.getToken()) {
                case SyntaxKind.OpenBracketToken:
                    return parseArray();
                case SyntaxKind.OpenBraceToken:
                    return parseObject();
                case SyntaxKind.StringLiteral:
                    return parseString(true);
                default:
                    return parseLiteral();
            }
        }
        scanNext();
        if (_scanner.getToken() === SyntaxKind.EOF) {
            return true;
        }
        if (!parseValue()) {
            handleError(ParseErrorCode.ValueExpected, [], []);
            return false;
        }
        if (_scanner.getToken() !== SyntaxKind.EOF) {
            handleError(ParseErrorCode.EndOfFileExpected, [], []);
        }
        return true;
    }
    exports.visit = visit;
});

define(__m[176/*vs/nls!vs/base/common/keybinding*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/common/keybinding", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[132/*vs/base/common/keybinding*/], __M([1/*require*/,0/*exports*/,176/*vs/nls!vs/base/common/keybinding*/,19/*vs/base/common/platform*/,32/*vs/base/common/keyCodes*/]), function (require, exports, nls, defaultPlatform, keyCodes_1) {
    'use strict';
    var KeybindingLabels = (function () {
        function KeybindingLabels() {
        }
        /**
         * @internal
         */
        KeybindingLabels.getUserSettingsKeybindingRegex = function () {
            if (!this._cachedKeybindingRegex) {
                var numpadKey = 'numpad(0|1|2|3|4|5|6|7|8|9|_multiply|_add|_subtract|_decimal|_divide|_separator)';
                var oemKey = '`|\\-|=|\\[|\\]|\\\\\\\\|;|\'|,|\\.|\\/|oem_8|oem_102';
                var specialKey = 'left|up|right|down|pageup|pagedown|end|home|tab|enter|escape|space|backspace|delete|pausebreak|capslock|insert|contextmenu|numlock|scrolllock';
                var casualKey = '[a-z]|[0-9]|f(1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19)';
                var key = '((' + [numpadKey, oemKey, specialKey, casualKey].join(')|(') + '))';
                var mod = '((ctrl|shift|alt|cmd|win|meta)\\+)*';
                var keybinding = '(' + mod + key + ')';
                this._cachedKeybindingRegex = '"\\s*(' + keybinding + '(\\s+' + keybinding + ')?' + ')\\s*"';
            }
            return this._cachedKeybindingRegex;
        };
        /**
         * Format the binding to a format appropiate for the user settings file.
         * @internal
         */
        KeybindingLabels.toUserSettingsLabel = function (value, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            var result = _asString(value, UserSettingsKeyLabelProvider.INSTANCE, Platform);
            result = result.toLowerCase();
            if (Platform.isMacintosh) {
                result = result.replace(/meta/g, 'cmd');
            }
            else if (Platform.isWindows) {
                result = result.replace(/meta/g, 'win');
            }
            return result;
        };
        /**
         * @internal
         */
        KeybindingLabels.fromUserSettingsLabel = function (input, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            if (!input) {
                return null;
            }
            input = input.toLowerCase().trim();
            var ctrlCmd = false, shift = false, alt = false, winCtrl = false, key = '';
            while (/^(ctrl|shift|alt|meta|win|cmd)(\+|\-)/.test(input)) {
                if (/^ctrl(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        winCtrl = true;
                    }
                    else {
                        ctrlCmd = true;
                    }
                    input = input.substr('ctrl-'.length);
                }
                if (/^shift(\+|\-)/.test(input)) {
                    shift = true;
                    input = input.substr('shift-'.length);
                }
                if (/^alt(\+|\-)/.test(input)) {
                    alt = true;
                    input = input.substr('alt-'.length);
                }
                if (/^meta(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('meta-'.length);
                }
                if (/^win(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('win-'.length);
                }
                if (/^cmd(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('cmd-'.length);
                }
            }
            var chord = 0;
            var firstSpaceIdx = input.indexOf(' ');
            if (firstSpaceIdx > 0) {
                key = input.substring(0, firstSpaceIdx);
                chord = KeybindingLabels.fromUserSettingsLabel(input.substring(firstSpaceIdx), Platform);
            }
            else {
                key = input;
            }
            var keyCode = keyCodes_1.USER_SETTINGS.toKeyCode(key);
            var result = 0;
            if (ctrlCmd) {
                result |= 2048 /* CtrlCmd */;
            }
            if (shift) {
                result |= 1024 /* Shift */;
            }
            if (alt) {
                result |= 512 /* Alt */;
            }
            if (winCtrl) {
                result |= 256 /* WinCtrl */;
            }
            result |= keyCode;
            return keyCodes_1.KeyChord(result, chord);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         * @internal
         */
        KeybindingLabels._toUSLabel = function (keybinding, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return _asString(keybinding.value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for placing in an aria-label.
         * @internal
         */
        KeybindingLabels._toUSAriaLabel = function (keybinding, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return _asString(keybinding.value, AriaKeyLabelProvider.INSTANCE, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         * @internal
         */
        KeybindingLabels._toUSHTMLLabel = function (keybinding, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return _asHTML(keybinding.value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         * @internal
         */
        KeybindingLabels.toCustomLabel = function (keybinding, labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return _asString(keybinding.value, labelProvider, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         * @internal
         */
        KeybindingLabels.toCustomHTMLLabel = function (keybinding, labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return _asHTML(keybinding.value, labelProvider, Platform);
        };
        /**
         * This prints the binding in a format suitable for electron's accelerators.
         * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
         * @internal
         */
        KeybindingLabels._toElectronAccelerator = function (keybinding, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            if (keyCodes_1.BinaryKeybindings.hasChord(keybinding.value)) {
                // Electron cannot handle chords
                return null;
            }
            var keyCode = keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding.value);
            if (keyCode >= 93 /* NUMPAD_0 */ && keyCode <= 108 /* NUMPAD_DIVIDE */) {
                // Electron cannot handle numpad keys
                return null;
            }
            return _asString(keybinding.value, ElectronAcceleratorLabelProvider.INSTANCE, Platform);
        };
        return KeybindingLabels;
    }());
    KeybindingLabels._cachedKeybindingRegex = null;
    exports.KeybindingLabels = KeybindingLabels;
    /**
     * Print for Electron
     */
    var ElectronAcceleratorLabelProvider = (function () {
        function ElectronAcceleratorLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Cmd';
            this.windowsKeyLabel = 'Super';
            this.modifierSeparator = '+';
        }
        ElectronAcceleratorLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case 16 /* UpArrow */:
                    return 'Up';
                case 18 /* DownArrow */:
                    return 'Down';
                case 15 /* LeftArrow */:
                    return 'Left';
                case 17 /* RightArrow */:
                    return 'Right';
            }
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        return ElectronAcceleratorLabelProvider;
    }());
    ElectronAcceleratorLabelProvider.INSTANCE = new ElectronAcceleratorLabelProvider();
    exports.ElectronAcceleratorLabelProvider = ElectronAcceleratorLabelProvider;
    /**
     * Print for Mac UI
     */
    var MacUIKeyLabelProvider = (function () {
        function MacUIKeyLabelProvider() {
            this.ctrlKeyLabel = '\u2303';
            this.shiftKeyLabel = '\u21E7';
            this.altKeyLabel = '\u2325';
            this.cmdKeyLabel = '\u2318';
            this.windowsKeyLabel = nls.localize(0, null);
            this.modifierSeparator = '';
        }
        MacUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case 15 /* LeftArrow */:
                    return MacUIKeyLabelProvider.leftArrowUnicodeLabel;
                case 16 /* UpArrow */:
                    return MacUIKeyLabelProvider.upArrowUnicodeLabel;
                case 17 /* RightArrow */:
                    return MacUIKeyLabelProvider.rightArrowUnicodeLabel;
                case 18 /* DownArrow */:
                    return MacUIKeyLabelProvider.downArrowUnicodeLabel;
            }
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        return MacUIKeyLabelProvider;
    }());
    MacUIKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
    MacUIKeyLabelProvider.leftArrowUnicodeLabel = String.fromCharCode(8592);
    MacUIKeyLabelProvider.upArrowUnicodeLabel = String.fromCharCode(8593);
    MacUIKeyLabelProvider.rightArrowUnicodeLabel = String.fromCharCode(8594);
    MacUIKeyLabelProvider.downArrowUnicodeLabel = String.fromCharCode(8595);
    exports.MacUIKeyLabelProvider = MacUIKeyLabelProvider;
    /**
     * Aria label provider for Mac.
     */
    var AriaKeyLabelProvider = (function () {
        function AriaKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(1, null);
            this.shiftKeyLabel = nls.localize(2, null);
            this.altKeyLabel = nls.localize(3, null);
            this.cmdKeyLabel = nls.localize(4, null);
            this.windowsKeyLabel = nls.localize(5, null);
            this.modifierSeparator = '+';
        }
        AriaKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        return AriaKeyLabelProvider;
    }());
    AriaKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
    exports.AriaKeyLabelProvider = AriaKeyLabelProvider;
    /**
     * Print for Windows, Linux UI
     */
    var ClassicUIKeyLabelProvider = (function () {
        function ClassicUIKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(6, null);
            this.shiftKeyLabel = nls.localize(7, null);
            this.altKeyLabel = nls.localize(8, null);
            this.cmdKeyLabel = nls.localize(9, null);
            this.windowsKeyLabel = nls.localize(10, null);
            this.modifierSeparator = '+';
        }
        ClassicUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return keyCodes_1.KeyCodeUtils.toString(keyCode);
        };
        return ClassicUIKeyLabelProvider;
    }());
    ClassicUIKeyLabelProvider.INSTANCE = new ClassicUIKeyLabelProvider();
    exports.ClassicUIKeyLabelProvider = ClassicUIKeyLabelProvider;
    /**
     * Print for the user settings file.
     */
    var UserSettingsKeyLabelProvider = (function () {
        function UserSettingsKeyLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Meta';
            this.windowsKeyLabel = 'Meta';
            this.modifierSeparator = '+';
        }
        UserSettingsKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return keyCodes_1.USER_SETTINGS.fromKeyCode(keyCode);
        };
        return UserSettingsKeyLabelProvider;
    }());
    UserSettingsKeyLabelProvider.INSTANCE = new UserSettingsKeyLabelProvider();
    function _asString(keybinding, labelProvider, Platform) {
        var result = [], ctrlCmd = keyCodes_1.BinaryKeybindings.hasCtrlCmd(keybinding), shift = keyCodes_1.BinaryKeybindings.hasShift(keybinding), alt = keyCodes_1.BinaryKeybindings.hasAlt(keybinding), winCtrl = keyCodes_1.BinaryKeybindings.hasWinCtrl(keybinding), keyCode = keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return '';
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            result.push(labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            result.push(labelProvider.shiftKeyLabel);
        }
        if (alt) {
            result.push(labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            result.push(labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            result.push(labelProvider.windowsKeyLabel);
        }
        // the actual key
        result.push(keyLabel);
        var actualResult = result.join(labelProvider.modifierSeparator);
        if (keyCodes_1.BinaryKeybindings.hasChord(keybinding)) {
            return actualResult + ' ' + _asString(keyCodes_1.BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform);
        }
        return actualResult;
    }
    function _pushKey(result, str) {
        if (result.length > 0) {
            result.push({
                tagName: 'span',
                text: '+'
            });
        }
        result.push({
            tagName: 'span',
            className: 'monaco-kbkey',
            text: str
        });
    }
    function _asHTML(keybinding, labelProvider, Platform, isChord) {
        if (isChord === void 0) { isChord = false; }
        var result = [], ctrlCmd = keyCodes_1.BinaryKeybindings.hasCtrlCmd(keybinding), shift = keyCodes_1.BinaryKeybindings.hasShift(keybinding), alt = keyCodes_1.BinaryKeybindings.hasAlt(keybinding), winCtrl = keyCodes_1.BinaryKeybindings.hasWinCtrl(keybinding), keyCode = keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return [];
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            _pushKey(result, labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            _pushKey(result, labelProvider.shiftKeyLabel);
        }
        if (alt) {
            _pushKey(result, labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            _pushKey(result, labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            _pushKey(result, labelProvider.windowsKeyLabel);
        }
        // the actual key
        _pushKey(result, keyLabel);
        var chordTo = null;
        if (keyCodes_1.BinaryKeybindings.hasChord(keybinding)) {
            chordTo = _asHTML(keyCodes_1.BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform, true);
            result.push({
                tagName: 'span',
                text: ' '
            });
            result = result.concat(chordTo);
        }
        if (isChord) {
            return result;
        }
        return [{
                tagName: 'span',
                className: 'monaco-kb',
                children: result
            }];
    }
});

define(__m[256/*vs/nls!vs/base/common/severity*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
define(__m[30/*vs/base/common/severity*/], __M([1/*require*/,0/*exports*/,256/*vs/nls!vs/base/common/severity*/,9/*vs/base/common/strings*/]), function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    (function (Severity) {
        var _error = 'error', _warning = 'warning', _warn = 'warn', _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
        function toString(value) {
            return _displayStrings[value] || strings.empty;
        }
        Severity.toString = toString;
        function compare(a, b) {
            return b - a;
        }
        Severity.compare = compare;
    })(Severity || (Severity = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Severity;
});

define(__m[258/*vs/editor/contrib/quickFix/browser/lightBulbWidget*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,12/*vs/base/common/event*/,30/*vs/base/common/severity*/,11/*vs/base/browser/dom*/,401/*vs/css!vs/editor/contrib/quickFix/browser/lightBulbWidget*/]), function (require, exports, lifecycle_1, event_1, severity_1, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LightBulbWidget = (function () {
        function LightBulbWidget(editor) {
            var _this = this;
            this._onClick = new event_1.Emitter();
            this._toDispose = [];
            this._editor = editor;
            this._editor.addOverlayWidget(this);
            this._toDispose.push(this._editor.onDidScrollChange(function () {
                if (_this._visible) {
                    _this._layout();
                }
            }));
            this._toDispose.push(event_1.any(this._editor.onDidChangeConfiguration, this._editor.onDidChangeModelDecorations)(function () {
                // hide when something has been added to glyph margin
                if (_this._visible && !_this._hasSpaceInGlyphMargin(_this._line)) {
                    _this.hide();
                }
            }));
        }
        LightBulbWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        Object.defineProperty(LightBulbWidget.prototype, "onClick", {
            get: function () {
                return this._onClick.event;
            },
            enumerable: true,
            configurable: true
        });
        LightBulbWidget.prototype.getId = function () {
            return '__lightBulbWidget';
        };
        LightBulbWidget.prototype.getDomNode = function () {
            var _this = this;
            if (!this._domNode) {
                this._domNode = document.createElement('div');
                this._domNode.style.width = '21px';
                this._domNode.style.height = '20px';
                this._domNode.className = 'lightbulb-glyph hidden';
                this._toDispose.push(dom.addDisposableListener(this._domNode, 'mousedown', function (e) {
                    e.preventDefault();
                    // a bit of extra work to make sure the menu
                    // doesn't cover the line-text
                    var _a = dom.getDomNodePagePosition(_this._domNode), top = _a.top, height = _a.height;
                    var lineHeight = _this._editor.getConfiguration().lineHeight;
                    _this._onClick.fire({
                        x: e.clientX,
                        y: top + height + Math.floor(lineHeight / 3)
                    });
                }));
            }
            return this._domNode;
        };
        LightBulbWidget.prototype.getPosition = function () {
            return null;
        };
        Object.defineProperty(LightBulbWidget.prototype, "model", {
            get: function () {
                return this._model;
            },
            set: function (e) {
                var _this = this;
                this._model = e;
                this.hide();
                var modelNow = this._model;
                e.fixes.done(function (fixes) {
                    if (modelNow === _this._model && fixes && fixes.length > 0) {
                        _this.show(e);
                    }
                    else {
                        _this.hide();
                    }
                }, function (err) {
                    _this.hide();
                });
            },
            enumerable: true,
            configurable: true
        });
        LightBulbWidget.prototype.show = function (e) {
            var line = e.range.startLineNumber;
            if (!this._hasSpaceInGlyphMargin(line)) {
                return;
            }
            if (!this._visible || this._line !== line) {
                this._line = line;
                this._visible = true;
                this._layout();
                this._domNode.dataset['severity'] = e.severity >= severity_1.default.Warning ? 'high' : '';
            }
        };
        LightBulbWidget.prototype._hasSpaceInGlyphMargin = function (line) {
            if (!this._editor.getRawConfiguration().glyphMargin) {
                return false;
            }
            var decorations = this._editor.getLineDecorations(line);
            if (decorations) {
                for (var _i = 0, decorations_1 = decorations; _i < decorations_1.length; _i++) {
                    var options = decorations_1[_i].options;
                    if (options.glyphMarginClassName) {
                        return false;
                    }
                }
            }
            return true;
        };
        LightBulbWidget.prototype._layout = function () {
            var topForLineNumber = this._editor.getTopForLineNumber(this._line);
            var editorScrollTop = this._editor.getScrollTop();
            var top = topForLineNumber - editorScrollTop;
            this._domNode.style.top = top + "px";
            this._domNode.style.left = 0 + "px";
            this._domNode.classList.remove('hidden');
        };
        LightBulbWidget.prototype.hide = function () {
            if (this._visible) {
                this._visible = false;
                this._domNode.classList.add('hidden');
            }
        };
        return LightBulbWidget;
    }());
    exports.LightBulbWidget = LightBulbWidget;
});

define(__m[259/*vs/nls!vs/base/parts/quickopen/browser/quickOpenModel*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/parts/quickopen/browser/quickOpenModel", data); });
define(__m[260/*vs/nls!vs/base/parts/quickopen/browser/quickOpenWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/parts/quickopen/browser/quickOpenWidget", data); });
define(__m[261/*vs/nls!vs/base/parts/tree/browser/treeDefaults*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/base/parts/tree/browser/treeDefaults", data); });





define(__m[87/*vs/base/parts/tree/browser/treeDefaults*/], __M([1/*require*/,0/*exports*/,261/*vs/nls!vs/base/parts/tree/browser/treeDefaults*/,6/*vs/base/common/winjs.base*/,50/*vs/base/common/actions*/,19/*vs/base/common/platform*/,10/*vs/base/common/errors*/,11/*vs/base/browser/dom*/]), function (require, exports, nls, winjs_base_1, actions_1, platform, errors, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LegacyRenderer = (function () {
        function LegacyRenderer() {
        }
        LegacyRenderer.prototype.getHeight = function (tree, element) {
            return 20;
        };
        LegacyRenderer.prototype.getTemplateId = function (tree, element) {
            return 'legacy';
        };
        LegacyRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            return {
                root: container,
                element: null,
                previousCleanupFn: null
            };
        };
        LegacyRenderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            if (templateData.previousCleanupFn) {
                templateData.previousCleanupFn(tree, templateData.element);
            }
            while (templateData.root && templateData.root.firstChild) {
                templateData.root.removeChild(templateData.root.firstChild);
            }
            templateData.element = element;
            templateData.previousCleanupFn = this.render(tree, element, templateData.root);
        };
        LegacyRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            if (templateData.previousCleanupFn) {
                templateData.previousCleanupFn(tree, templateData.element);
            }
            templateData.root = null;
            templateData.element = null;
            templateData.previousCleanupFn = null;
        };
        LegacyRenderer.prototype.render = function (tree, element, container, previousCleanupFn) {
            container.textContent = '' + element;
            return null;
        };
        return LegacyRenderer;
    }());
    exports.LegacyRenderer = LegacyRenderer;
    var ClickBehavior;
    (function (ClickBehavior) {
        /**
         * Handle the click when the mouse button is pressed but not released yet.
         */
        ClickBehavior[ClickBehavior["ON_MOUSE_DOWN"] = 0] = "ON_MOUSE_DOWN";
        /**
         * Handle the click when the mouse button is released.
         */
        ClickBehavior[ClickBehavior["ON_MOUSE_UP"] = 1] = "ON_MOUSE_UP";
    })(ClickBehavior = exports.ClickBehavior || (exports.ClickBehavior = {}));
    var KeybindingDispatcher = (function () {
        function KeybindingDispatcher() {
            this._arr = [];
        }
        KeybindingDispatcher.prototype.set = function (keybinding, callback) {
            this._arr.push({
                keybinding: keybinding,
                callback: callback
            });
        };
        KeybindingDispatcher.prototype.dispatch = function (keybinding) {
            // Loop from the last to the first to handle overwrites
            for (var i = this._arr.length - 1; i >= 0; i--) {
                var item = this._arr[i];
                if (keybinding.value === item.keybinding) {
                    return item.callback;
                }
            }
            return null;
        };
        return KeybindingDispatcher;
    }());
    exports.KeybindingDispatcher = KeybindingDispatcher;
    var DefaultController = (function () {
        function DefaultController(options) {
            if (options === void 0) { options = { clickBehavior: ClickBehavior.ON_MOUSE_UP }; }
            var _this = this;
            this.options = options;
            this.downKeyBindingDispatcher = new KeybindingDispatcher();
            this.downKeyBindingDispatcher.set(10 /* Space */, function (t, e) { return _this.onSpace(t, e); });
            this.downKeyBindingDispatcher.set(16 /* UpArrow */, function (t, e) { return _this.onUp(t, e); });
            this.downKeyBindingDispatcher.set(11 /* PageUp */, function (t, e) { return _this.onPageUp(t, e); });
            this.downKeyBindingDispatcher.set(18 /* DownArrow */, function (t, e) { return _this.onDown(t, e); });
            this.downKeyBindingDispatcher.set(12 /* PageDown */, function (t, e) { return _this.onPageDown(t, e); });
            this.downKeyBindingDispatcher.set(15 /* LeftArrow */, function (t, e) { return _this.onLeft(t, e); });
            this.downKeyBindingDispatcher.set(17 /* RightArrow */, function (t, e) { return _this.onRight(t, e); });
            this.downKeyBindingDispatcher.set(9 /* Escape */, function (t, e) { return _this.onEscape(t, e); });
            this.upKeyBindingDispatcher = new KeybindingDispatcher();
            this.upKeyBindingDispatcher.set(3 /* Enter */, this.onEnter.bind(this));
            this.upKeyBindingDispatcher.set(2048 /* CtrlCmd */ | 3 /* Enter */, this.onEnter.bind(this));
        }
        DefaultController.prototype.onMouseDown = function (tree, element, event, origin) {
            if (origin === void 0) { origin = 'mouse'; }
            if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && (event.leftButton || event.middleButton)) {
                if (event.target) {
                    if (event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                        return false; // Ignore event if target is a form input field (avoids browser specific issues)
                    }
                    if (dom.findParentWithClass(event.target, 'monaco-action-bar', 'row')) {
                        return false; // Ignore event if target is over an action bar of the row
                    }
                }
                // Propagate to onLeftClick now
                return this.onLeftClick(tree, element, event, origin);
            }
            return false;
        };
        DefaultController.prototype.onClick = function (tree, element, event) {
            var isMac = platform.isMacintosh;
            // A Ctrl click on the Mac is a context menu event
            if (isMac && event.ctrlKey) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return false; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && (event.leftButton || event.middleButton)) {
                return false; // Already handled by onMouseDown
            }
            return this.onLeftClick(tree, element, event);
        };
        DefaultController.prototype.onLeftClick = function (tree, element, eventish, origin) {
            if (origin === void 0) { origin = 'mouse'; }
            var payload = { origin: origin, originalEvent: eventish };
            if (tree.getInput() === element) {
                tree.clearFocus(payload);
                tree.clearSelection(payload);
            }
            else {
                var isMouseDown = eventish && eventish.browserEvent && eventish.browserEvent.type === 'mousedown';
                if (!isMouseDown) {
                    eventish.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
                }
                eventish.stopPropagation();
                tree.DOMFocus();
                tree.setSelection([element], payload);
                tree.setFocus(element, payload);
                if (tree.isExpanded(element)) {
                    tree.collapse(element).done(null, errors.onUnexpectedError);
                }
                else {
                    tree.expand(element).done(null, errors.onUnexpectedError);
                }
            }
            return true;
        };
        DefaultController.prototype.onContextMenu = function (tree, element, event) {
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return false; // allow context menu on input fields
            }
            // Prevent native context menu from showing up
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            return false;
        };
        DefaultController.prototype.onTap = function (tree, element, event) {
            var target = event.initialTarget;
            if (target && target.tagName && target.tagName.toLowerCase() === 'input') {
                return false; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            return this.onLeftClick(tree, element, event, 'touch');
        };
        DefaultController.prototype.onKeyDown = function (tree, event) {
            return this.onKey(this.downKeyBindingDispatcher, tree, event);
        };
        DefaultController.prototype.onKeyUp = function (tree, event) {
            return this.onKey(this.upKeyBindingDispatcher, tree, event);
        };
        DefaultController.prototype.onKey = function (bindings, tree, event) {
            var handler = bindings.dispatch(event.toKeybinding());
            if (handler) {
                if (handler(tree, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    return true;
                }
            }
            return false;
        };
        DefaultController.prototype.onUp = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusPrevious(1, payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onPageUp = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusPreviousPage(payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onDown = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusNext(1, payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onPageDown = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusNextPage(payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onLeft = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                var focus = tree.getFocus();
                tree.collapse(focus).then(function (didCollapse) {
                    if (focus && !didCollapse) {
                        tree.focusParent(payload);
                        return tree.reveal(tree.getFocus());
                    }
                }).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onRight = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                var focus = tree.getFocus();
                tree.expand(focus).then(function (didExpand) {
                    if (focus && !didExpand) {
                        tree.focusFirstChild(payload);
                        return tree.reveal(tree.getFocus());
                    }
                }).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onEnter = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                return false;
            }
            var focus = tree.getFocus();
            if (focus) {
                tree.setSelection([focus], payload);
            }
            return true;
        };
        DefaultController.prototype.onSpace = function (tree, event) {
            if (tree.getHighlight()) {
                return false;
            }
            var focus = tree.getFocus();
            if (focus) {
                tree.toggleExpansion(focus);
            }
            return true;
        };
        DefaultController.prototype.onEscape = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
                return true;
            }
            if (tree.getSelection().length) {
                tree.clearSelection(payload);
                return true;
            }
            if (tree.getFocus()) {
                tree.clearFocus(payload);
                return true;
            }
            return false;
        };
        return DefaultController;
    }());
    exports.DefaultController = DefaultController;
    var DefaultDragAndDrop = (function () {
        function DefaultDragAndDrop() {
        }
        DefaultDragAndDrop.prototype.getDragURI = function (tree, element) {
            return null;
        };
        DefaultDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
            return;
        };
        DefaultDragAndDrop.prototype.onDragOver = function (tree, data, targetElement, originalEvent) {
            return null;
        };
        DefaultDragAndDrop.prototype.drop = function (tree, data, targetElement, originalEvent) {
            return;
        };
        return DefaultDragAndDrop;
    }());
    exports.DefaultDragAndDrop = DefaultDragAndDrop;
    var DefaultFilter = (function () {
        function DefaultFilter() {
        }
        DefaultFilter.prototype.isVisible = function (tree, element) {
            return true;
        };
        return DefaultFilter;
    }());
    exports.DefaultFilter = DefaultFilter;
    var DefaultSorter = (function () {
        function DefaultSorter() {
        }
        DefaultSorter.prototype.compare = function (tree, element, otherElement) {
            return 0;
        };
        return DefaultSorter;
    }());
    exports.DefaultSorter = DefaultSorter;
    var DefaultAccessibilityProvider = (function () {
        function DefaultAccessibilityProvider() {
        }
        DefaultAccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            return null;
        };
        return DefaultAccessibilityProvider;
    }());
    exports.DefaultAccessibilityProvider = DefaultAccessibilityProvider;
    var CollapseAllAction = (function (_super) {
        __extends(CollapseAllAction, _super);
        function CollapseAllAction(viewer, enabled) {
            var _this = _super.call(this, 'vs.tree.collapse', nls.localize(0, null), 'monaco-tree-action collapse-all', enabled) || this;
            _this.viewer = viewer;
            return _this;
        }
        CollapseAllAction.prototype.run = function (context) {
            if (this.viewer.getHighlight()) {
                return winjs_base_1.TPromise.as(null); // Global action disabled if user is in edit mode from another action
            }
            this.viewer.collapseAll();
            this.viewer.clearSelection();
            this.viewer.clearFocus();
            this.viewer.DOMFocus();
            this.viewer.focusFirst();
            return winjs_base_1.TPromise.as(null);
        };
        return CollapseAllAction;
    }(actions_1.Action));
    exports.CollapseAllAction = CollapseAllAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[105/*vs/base/parts/quickopen/browser/quickOpenModel*/], __M([1/*require*/,0/*exports*/,259/*vs/nls!vs/base/parts/quickopen/browser/quickOpenModel*/,6/*vs/base/common/winjs.base*/,24/*vs/base/common/types*/,86/*vs/base/common/filters*/,9/*vs/base/common/strings*/,39/*vs/base/common/paths*/,172/*vs/base/browser/ui/iconLabel/iconLabel*/,504/*vs/base/common/comparers*/,69/*vs/base/browser/ui/actionbar/actionbar*/,87/*vs/base/parts/tree/browser/treeDefaults*/,110/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,11/*vs/base/browser/dom*/]), function (require, exports, nls, winjs_base_1, types, filters, strings, paths, iconLabel_1, comparers_1, actionbar_1, treeDefaults_1, highlightedLabel_1, DOM) {
    'use strict';
    var IDS = 0;
    var EntryAccessor = (function () {
        function EntryAccessor() {
        }
        EntryAccessor.getLabel = function (entry) {
            return entry.getLabel();
        };
        EntryAccessor.getResourcePath = function (entry) {
            var resource = entry.getResource();
            return resource && resource.fsPath;
        };
        return EntryAccessor;
    }());
    var QuickOpenEntry = (function () {
        function QuickOpenEntry(highlights) {
            if (highlights === void 0) { highlights = []; }
            this.id = (IDS++).toString();
            this.labelHighlights = highlights;
            this.descriptionHighlights = [];
        }
        /**
         * A unique identifier for the entry
         */
        QuickOpenEntry.prototype.getId = function () {
            return this.id;
        };
        /**
         * The label of the entry to identify it from others in the list
         */
        QuickOpenEntry.prototype.getLabel = function () {
            return null;
        };
        /**
         * The options for the label to use for this entry
         */
        QuickOpenEntry.prototype.getLabelOptions = function () {
            return null;
        };
        /**
         * The label of the entry to use when a screen reader wants to read about the entry
         */
        QuickOpenEntry.prototype.getAriaLabel = function () {
            return this.getLabel();
        };
        /**
         * Detail information about the entry that is optional and can be shown below the label
         */
        QuickOpenEntry.prototype.getDetail = function () {
            return null;
        };
        /**
         * The icon of the entry to identify it from others in the list
         */
        QuickOpenEntry.prototype.getIcon = function () {
            return null;
        };
        /**
         * A secondary description that is optional and can be shown right to the label
         */
        QuickOpenEntry.prototype.getDescription = function () {
            return null;
        };
        /**
         * A resource for this entry. Resource URIs can be used to compare different kinds of entries and group
         * them together.
         */
        QuickOpenEntry.prototype.getResource = function () {
            return null;
        };
        /**
         * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
         */
        QuickOpenEntry.prototype.isHidden = function () {
            return this.hidden;
        };
        /**
         * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
         */
        QuickOpenEntry.prototype.setHidden = function (hidden) {
            this.hidden = hidden;
        };
        /**
         * Allows to set highlight ranges that should show up for the entry label and optionally description if set.
         */
        QuickOpenEntry.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
            this.labelHighlights = labelHighlights;
            this.descriptionHighlights = descriptionHighlights;
            this.detailHighlights = detailHighlights;
        };
        /**
         * Allows to return highlight ranges that should show up for the entry label and description.
         */
        QuickOpenEntry.prototype.getHighlights = function () {
            return [this.labelHighlights, this.descriptionHighlights, this.detailHighlights];
        };
        /**
         * Called when the entry is selected for opening. Returns a boolean value indicating if an action was performed or not.
         * The mode parameter gives an indication if the element is previewed (using arrow keys) or opened.
         *
         * The context parameter provides additional context information how the run was triggered.
         */
        QuickOpenEntry.prototype.run = function (mode, context) {
            return false;
        };
        /**
         * A good default sort implementation for quick open entries respecting highlight information
         * as well as associated resources.
         */
        QuickOpenEntry.compare = function (elementA, elementB, lookFor) {
            // Normalize
            if (lookFor) {
                lookFor = strings.stripWildcards(lookFor).toLowerCase();
            }
            // Give matches with label highlights higher priority over
            // those with only description highlights
            var labelHighlightsA = elementA.getHighlights()[0] || [];
            var labelHighlightsB = elementB.getHighlights()[0] || [];
            if (labelHighlightsA.length && !labelHighlightsB.length) {
                return -1;
            }
            else if (!labelHighlightsA.length && labelHighlightsB.length) {
                return 1;
            }
            // Fallback to the full path if labels are identical and we have associated resources
            var nameA = elementA.getLabel();
            var nameB = elementB.getLabel();
            if (nameA === nameB) {
                var resourceA = elementA.getResource();
                var resourceB = elementB.getResource();
                if (resourceA && resourceB) {
                    nameA = resourceA.fsPath;
                    nameB = resourceB.fsPath;
                }
            }
            return comparers_1.compareAnything(nameA, nameB, lookFor);
        };
        QuickOpenEntry.compareByScore = function (elementA, elementB, lookFor, lookForNormalizedLower, scorerCache) {
            return comparers_1.compareByScore(elementA, elementB, EntryAccessor, lookFor, lookForNormalizedLower, scorerCache);
        };
        /**
         * A good default highlight implementation for an entry with label and description.
         */
        QuickOpenEntry.highlight = function (entry, lookFor, fuzzyHighlight) {
            if (fuzzyHighlight === void 0) { fuzzyHighlight = false; }
            var labelHighlights = [];
            var descriptionHighlights = [];
            var normalizedLookFor = strings.stripWildcards(lookFor);
            var label = entry.getLabel();
            var description = entry.getDescription();
            // Highlight file aware
            if (entry.getResource()) {
                // Highlight entire label and description if searching for full absolute path
                if (lookFor.toLowerCase() === entry.getResource().fsPath.toLowerCase()) {
                    labelHighlights.push({ start: 0, end: label.length });
                    descriptionHighlights.push({ start: 0, end: description.length });
                }
                else if (fuzzyHighlight || lookFor.indexOf(paths.nativeSep) >= 0) {
                    var candidateLabelHighlights = filters.matchesFuzzy(lookFor, label, fuzzyHighlight);
                    if (!candidateLabelHighlights) {
                        var pathPrefix = description ? (description + paths.nativeSep) : '';
                        var pathPrefixLength_1 = pathPrefix.length;
                        // If there are no highlights in the label, build a path out of description and highlight and match on both,
                        // then extract the individual label and description highlights back to the original positions
                        var pathHighlights = filters.matchesFuzzy(lookFor, pathPrefix + label, fuzzyHighlight);
                        if (!pathHighlights && lookFor !== normalizedLookFor) {
                            pathHighlights = filters.matchesFuzzy(normalizedLookFor, pathPrefix + label, fuzzyHighlight);
                        }
                        if (pathHighlights) {
                            pathHighlights.forEach(function (h) {
                                // Match overlaps label and description part, we need to split it up
                                if (h.start < pathPrefixLength_1 && h.end > pathPrefixLength_1) {
                                    labelHighlights.push({ start: 0, end: h.end - pathPrefixLength_1 });
                                    descriptionHighlights.push({ start: h.start, end: pathPrefixLength_1 });
                                }
                                else if (h.start >= pathPrefixLength_1) {
                                    labelHighlights.push({ start: h.start - pathPrefixLength_1, end: h.end - pathPrefixLength_1 });
                                }
                                else {
                                    descriptionHighlights.push(h);
                                }
                            });
                        }
                    }
                    else {
                        labelHighlights = candidateLabelHighlights;
                    }
                }
                else {
                    labelHighlights = filters.matchesFuzzy(lookFor, label);
                }
            }
            else {
                labelHighlights = filters.matchesFuzzy(lookFor, label);
            }
            return { labelHighlights: labelHighlights, descriptionHighlights: descriptionHighlights };
        };
        QuickOpenEntry.prototype.isFile = function () {
            return false; // TODO@Ben debt with editor history merging
        };
        return QuickOpenEntry;
    }());
    exports.QuickOpenEntry = QuickOpenEntry;
    var QuickOpenEntryItem = (function (_super) {
        __extends(QuickOpenEntryItem, _super);
        function QuickOpenEntryItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Must return the height as being used by the render function.
         */
        QuickOpenEntryItem.prototype.getHeight = function () {
            return 0;
        };
        /**
         * Allows to present the quick open entry in a custom way inside the tree.
         */
        QuickOpenEntryItem.prototype.render = function (tree, container, previousCleanupFn) {
            return null;
        };
        return QuickOpenEntryItem;
    }(QuickOpenEntry));
    exports.QuickOpenEntryItem = QuickOpenEntryItem;
    var QuickOpenEntryGroup = (function (_super) {
        __extends(QuickOpenEntryGroup, _super);
        function QuickOpenEntryGroup(entry, groupLabel, withBorder) {
            var _this = _super.call(this) || this;
            _this.entry = entry;
            _this.groupLabel = groupLabel;
            _this.withBorder = withBorder;
            return _this;
        }
        /**
         * The label of the group or null if none.
         */
        QuickOpenEntryGroup.prototype.getGroupLabel = function () {
            return this.groupLabel;
        };
        QuickOpenEntryGroup.prototype.setGroupLabel = function (groupLabel) {
            this.groupLabel = groupLabel;
        };
        /**
         * Whether to show a border on top of the group entry or not.
         */
        QuickOpenEntryGroup.prototype.showBorder = function () {
            return this.withBorder;
        };
        QuickOpenEntryGroup.prototype.setShowBorder = function (showBorder) {
            this.withBorder = showBorder;
        };
        QuickOpenEntryGroup.prototype.getLabel = function () {
            return this.entry ? this.entry.getLabel() : _super.prototype.getLabel.call(this);
        };
        QuickOpenEntryGroup.prototype.getLabelOptions = function () {
            return this.entry ? this.entry.getLabelOptions() : _super.prototype.getLabelOptions.call(this);
        };
        QuickOpenEntryGroup.prototype.getAriaLabel = function () {
            return this.entry ? this.entry.getAriaLabel() : _super.prototype.getAriaLabel.call(this);
        };
        QuickOpenEntryGroup.prototype.getDetail = function () {
            return this.entry ? this.entry.getDetail() : _super.prototype.getDetail.call(this);
        };
        QuickOpenEntryGroup.prototype.getResource = function () {
            return this.entry ? this.entry.getResource() : _super.prototype.getResource.call(this);
        };
        QuickOpenEntryGroup.prototype.getIcon = function () {
            return this.entry ? this.entry.getIcon() : _super.prototype.getIcon.call(this);
        };
        QuickOpenEntryGroup.prototype.getDescription = function () {
            return this.entry ? this.entry.getDescription() : _super.prototype.getDescription.call(this);
        };
        QuickOpenEntryGroup.prototype.getEntry = function () {
            return this.entry;
        };
        QuickOpenEntryGroup.prototype.getHighlights = function () {
            return this.entry ? this.entry.getHighlights() : _super.prototype.getHighlights.call(this);
        };
        QuickOpenEntryGroup.prototype.isHidden = function () {
            return this.entry ? this.entry.isHidden() : _super.prototype.isHidden.call(this);
        };
        QuickOpenEntryGroup.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
            this.entry ? this.entry.setHighlights(labelHighlights, descriptionHighlights, detailHighlights) : _super.prototype.setHighlights.call(this, labelHighlights, descriptionHighlights, detailHighlights);
        };
        QuickOpenEntryGroup.prototype.setHidden = function (hidden) {
            this.entry ? this.entry.setHidden(hidden) : _super.prototype.setHidden.call(this, hidden);
        };
        QuickOpenEntryGroup.prototype.run = function (mode, context) {
            return this.entry ? this.entry.run(mode, context) : _super.prototype.run.call(this, mode, context);
        };
        return QuickOpenEntryGroup;
    }(QuickOpenEntry));
    exports.QuickOpenEntryGroup = QuickOpenEntryGroup;
    var templateEntry = 'quickOpenEntry';
    var templateEntryGroup = 'quickOpenEntryGroup';
    var templateEntryItem = 'quickOpenEntryItem';
    var EntryItemRenderer = (function (_super) {
        __extends(EntryItemRenderer, _super);
        function EntryItemRenderer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EntryItemRenderer.prototype.getTemplateId = function (tree, element) {
            return templateEntryItem;
        };
        EntryItemRenderer.prototype.render = function (tree, element, container, previousCleanupFn) {
            if (element instanceof QuickOpenEntryItem) {
                return element.render(tree, container, previousCleanupFn);
            }
            return _super.prototype.render.call(this, tree, element, container, previousCleanupFn);
        };
        return EntryItemRenderer;
    }(treeDefaults_1.LegacyRenderer));
    var NoActionProvider = (function () {
        function NoActionProvider() {
        }
        NoActionProvider.prototype.hasActions = function (tree, element) {
            return false;
        };
        NoActionProvider.prototype.getActions = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        NoActionProvider.prototype.hasSecondaryActions = function (tree, element) {
            return false;
        };
        NoActionProvider.prototype.getSecondaryActions = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        NoActionProvider.prototype.getActionItem = function (tree, element, action) {
            return null;
        };
        return NoActionProvider;
    }());
    var Renderer = (function () {
        function Renderer(actionProvider, actionRunner) {
            if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
            if (actionRunner === void 0) { actionRunner = null; }
            this.actionProvider = actionProvider;
            this.actionRunner = actionRunner;
            this.entryItemRenderer = new EntryItemRenderer();
        }
        Renderer.prototype.getHeight = function (entry) {
            if (entry instanceof QuickOpenEntryItem) {
                return entry.getHeight();
            }
            if (entry.getDetail()) {
                return 44;
            }
            return 22;
        };
        Renderer.prototype.getTemplateId = function (entry) {
            if (entry instanceof QuickOpenEntryItem) {
                return templateEntryItem;
            }
            if (entry instanceof QuickOpenEntryGroup) {
                return templateEntryGroup;
            }
            return templateEntry;
        };
        Renderer.prototype.renderTemplate = function (templateId, container) {
            // Entry Item
            if (templateId === templateEntryItem) {
                return this.entryItemRenderer.renderTemplate(null, templateId, container);
            }
            // Entry Group
            var group;
            if (templateId === templateEntryGroup) {
                group = document.createElement('div');
                DOM.addClass(group, 'results-group');
                container.appendChild(group);
            }
            // Action Bar
            DOM.addClass(container, 'actions');
            var entryContainer = document.createElement('div');
            DOM.addClass(entryContainer, 'sub-content');
            container.appendChild(entryContainer);
            var actionBarContainer = document.createElement('div');
            DOM.addClass(actionBarContainer, 'primary-action-bar');
            container.appendChild(actionBarContainer);
            var actionBar = new actionbar_1.ActionBar(actionBarContainer, {
                actionRunner: this.actionRunner
            });
            // Entry
            var entry = document.createElement('div');
            DOM.addClass(entry, 'quick-open-entry');
            entryContainer.appendChild(entry);
            // Icon
            var icon = document.createElement('span');
            entry.appendChild(icon);
            // Label
            var label = new iconLabel_1.IconLabel(entry, { supportHighlights: true });
            // Description
            var descriptionContainer = document.createElement('span');
            entry.appendChild(descriptionContainer);
            DOM.addClass(descriptionContainer, 'quick-open-entry-description');
            var description = new highlightedLabel_1.HighlightedLabel(descriptionContainer);
            // Detail
            var detailContainer = document.createElement('div');
            entry.appendChild(detailContainer);
            DOM.addClass(detailContainer, 'quick-open-entry-meta');
            var detail = new highlightedLabel_1.HighlightedLabel(detailContainer);
            return {
                container: container,
                entry: entry,
                icon: icon,
                label: label,
                detail: detail,
                description: description,
                group: group,
                actionBar: actionBar
            };
        };
        Renderer.prototype.renderElement = function (entry, templateId, templateData) {
            // Entry Item
            if (templateId === templateEntryItem) {
                this.entryItemRenderer.renderElement(null, entry, templateId, templateData);
                return;
            }
            var data = templateData;
            // Action Bar
            if (this.actionProvider.hasActions(null, entry)) {
                DOM.addClass(data.container, 'has-actions');
            }
            else {
                DOM.removeClass(data.container, 'has-actions');
            }
            data.actionBar.context = entry; // make sure the context is the current element
            this.actionProvider.getActions(null, entry).then(function (actions) {
                // TODO@Ben this will not work anymore as soon as quick open has more actions
                // but as long as there is only one are ok
                if (data.actionBar.isEmpty() && actions && actions.length > 0) {
                    data.actionBar.push(actions, { icon: true, label: false });
                }
                else if (!data.actionBar.isEmpty() && (!actions || actions.length === 0)) {
                    data.actionBar.clear();
                }
            });
            // Entry group
            if (entry instanceof QuickOpenEntryGroup) {
                var group = entry;
                // Border
                if (group.showBorder()) {
                    DOM.addClass(data.container, 'results-group-separator');
                }
                else {
                    DOM.removeClass(data.container, 'results-group-separator');
                }
                // Group Label
                var groupLabel = group.getGroupLabel() || '';
                templateData.group.textContent = groupLabel;
            }
            // Normal Entry
            if (entry instanceof QuickOpenEntry) {
                var _a = entry.getHighlights(), labelHighlights = _a[0], descriptionHighlights = _a[1], detailHighlights = _a[2];
                // Icon
                var iconClass = entry.getIcon() ? ('quick-open-entry-icon ' + entry.getIcon()) : '';
                data.icon.className = iconClass;
                // Label
                var options = entry.getLabelOptions() || Object.create(null);
                options.matches = labelHighlights || [];
                data.label.setValue(entry.getLabel(), null, options);
                // Meta
                data.detail.set(entry.getDetail(), detailHighlights);
                // Description
                data.description.set(entry.getDescription(), descriptionHighlights || []);
                data.description.element.title = entry.getDescription();
            }
        };
        Renderer.prototype.disposeTemplate = function (templateId, templateData) {
            if (templateId === templateEntryItem) {
                this.entryItemRenderer.disposeTemplate(null, templateId, templateData);
            }
            else {
                var data = templateData;
                data.actionBar.dispose();
                data.actionBar = null;
                data.container = null;
                data.entry = null;
                data.description.dispose();
                data.description = null;
                data.detail.dispose();
                data.detail = null;
                data.group = null;
                data.icon = null;
                data.label.dispose();
                data.label = null;
            }
        };
        return Renderer;
    }());
    var QuickOpenModel = (function () {
        function QuickOpenModel(entries, actionProvider) {
            if (entries === void 0) { entries = []; }
            if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
            this._entries = entries;
            this._dataSource = this;
            this._renderer = new Renderer(actionProvider);
            this._filter = this;
            this._runner = this;
            this._accessibilityProvider = this;
        }
        Object.defineProperty(QuickOpenModel.prototype, "entries", {
            get: function () { return this._entries; },
            set: function (entries) {
                this._entries = entries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "dataSource", {
            get: function () { return this._dataSource; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "renderer", {
            get: function () { return this._renderer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "filter", {
            get: function () { return this._filter; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "runner", {
            get: function () { return this._runner; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "accessibilityProvider", {
            get: function () { return this._accessibilityProvider; },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds entries that should show up in the quick open viewer.
         */
        QuickOpenModel.prototype.addEntries = function (entries) {
            if (types.isArray(entries)) {
                this._entries = this._entries.concat(entries);
            }
        };
        /**
         * Set the entries that should show up in the quick open viewer.
         */
        QuickOpenModel.prototype.setEntries = function (entries) {
            if (types.isArray(entries)) {
                this._entries = entries;
            }
        };
        /**
         * Get the entries that should show up in the quick open viewer.
         *
         * @visibleOnly optional parameter to only return visible entries
         */
        QuickOpenModel.prototype.getEntries = function (visibleOnly) {
            if (visibleOnly) {
                return this._entries.filter(function (e) { return !e.isHidden(); });
            }
            return this._entries;
        };
        QuickOpenModel.prototype.getId = function (entry) {
            return entry.getId();
        };
        QuickOpenModel.prototype.getLabel = function (entry) {
            return entry.getLabel();
        };
        QuickOpenModel.prototype.getAriaLabel = function (entry) {
            var ariaLabel = entry.getAriaLabel();
            if (ariaLabel) {
                return nls.localize(0, null, entry.getAriaLabel());
            }
            return nls.localize(1, null);
        };
        QuickOpenModel.prototype.isVisible = function (entry) {
            return !entry.isHidden();
        };
        QuickOpenModel.prototype.run = function (entry, mode, context) {
            return entry.run(mode, context);
        };
        return QuickOpenModel;
    }());
    exports.QuickOpenModel = QuickOpenModel;
});






define(__m[139/*vs/base/parts/tree/browser/treeImpl*/], __M([1/*require*/,0/*exports*/,87/*vs/base/parts/tree/browser/treeDefaults*/,25/*vs/base/common/eventEmitter*/,183/*vs/base/parts/tree/browser/treeModel*/,264/*vs/base/parts/tree/browser/treeView*/,88/*vs/base/common/iterator*/,322/*vs/css!vs/base/parts/tree/browser/tree*/]), function (require, exports, TreeDefaults, Events, Model, View, iterator_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TreeContext = (function () {
        function TreeContext(tree, configuration, options) {
            if (options === void 0) { options = {}; }
            this.tree = tree;
            this.configuration = configuration;
            this.options = options;
            if (!configuration.dataSource) {
                throw new Error('You must provide a Data Source to the tree.');
            }
            this.dataSource = configuration.dataSource;
            this.renderer = configuration.renderer || new TreeDefaults.LegacyRenderer();
            this.controller = configuration.controller || new TreeDefaults.DefaultController();
            this.dnd = configuration.dnd || new TreeDefaults.DefaultDragAndDrop();
            this.filter = configuration.filter || new TreeDefaults.DefaultFilter();
            this.sorter = configuration.sorter || null;
            this.accessibilityProvider = configuration.accessibilityProvider || new TreeDefaults.DefaultAccessibilityProvider();
        }
        return TreeContext;
    }());
    exports.TreeContext = TreeContext;
    var Tree = (function (_super) {
        __extends(Tree, _super);
        function Tree(container, configuration, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.container = container;
            _this.configuration = configuration;
            _this.options = options;
            _this.options.twistiePixels = typeof _this.options.twistiePixels === 'number' ? _this.options.twistiePixels : 32;
            _this.options.showTwistie = _this.options.showTwistie === false ? false : true;
            _this.options.indentPixels = typeof _this.options.indentPixels === 'number' ? _this.options.indentPixels : 12;
            _this.options.alwaysFocused = _this.options.alwaysFocused === true ? true : false;
            _this.options.useShadows = _this.options.useShadows === false ? false : true;
            _this.options.paddingOnRow = _this.options.paddingOnRow === false ? false : true;
            _this.context = new TreeContext(_this, configuration, options);
            _this.model = new Model.TreeModel(_this.context);
            _this.view = new View.TreeView(_this.context, _this.container);
            _this.view.setModel(_this.model);
            _this.addEmitter2(_this.model);
            _this.addEmitter2(_this.view);
            return _this;
        }
        Tree.prototype.getHTMLElement = function () {
            return this.view.getHTMLElement();
        };
        Tree.prototype.layout = function (height) {
            this.view.layout(height);
        };
        Tree.prototype.DOMFocus = function () {
            this.view.focus();
        };
        Tree.prototype.isDOMFocused = function () {
            return this.view.isFocused();
        };
        Tree.prototype.DOMBlur = function () {
            this.view.blur();
        };
        Tree.prototype.onVisible = function () {
            this.view.onVisible();
        };
        Tree.prototype.onHidden = function () {
            this.view.onHidden();
        };
        Tree.prototype.setInput = function (element) {
            return this.model.setInput(element);
        };
        Tree.prototype.getInput = function () {
            return this.model.getInput();
        };
        Tree.prototype.refresh = function (element, recursive) {
            if (element === void 0) { element = null; }
            if (recursive === void 0) { recursive = true; }
            return this.model.refresh(element, recursive);
        };
        Tree.prototype.refreshAll = function (elements, recursive) {
            if (recursive === void 0) { recursive = true; }
            return this.model.refreshAll(elements, recursive);
        };
        Tree.prototype.expand = function (element) {
            return this.model.expand(element);
        };
        Tree.prototype.expandAll = function (elements) {
            return this.model.expandAll(elements);
        };
        Tree.prototype.collapse = function (element, recursive) {
            if (recursive === void 0) { recursive = false; }
            return this.model.collapse(element, recursive);
        };
        Tree.prototype.collapseAll = function (elements, recursive) {
            if (elements === void 0) { elements = null; }
            if (recursive === void 0) { recursive = false; }
            return this.model.collapseAll(elements, recursive);
        };
        Tree.prototype.toggleExpansion = function (element) {
            return this.model.toggleExpansion(element);
        };
        Tree.prototype.toggleExpansionAll = function (elements) {
            return this.model.toggleExpansionAll(elements);
        };
        Tree.prototype.isExpanded = function (element) {
            return this.model.isExpanded(element);
        };
        Tree.prototype.getExpandedElements = function () {
            return this.model.getExpandedElements();
        };
        Tree.prototype.reveal = function (element, relativeTop) {
            if (relativeTop === void 0) { relativeTop = null; }
            return this.model.reveal(element, relativeTop);
        };
        Tree.prototype.getRelativeTop = function (element) {
            var item = this.model.getItem(element);
            return this.view.getRelativeTop(item);
        };
        Tree.prototype.getScrollPosition = function () {
            return this.view.getScrollPosition();
        };
        Tree.prototype.setScrollPosition = function (pos) {
            this.view.setScrollPosition(pos);
        };
        Tree.prototype.getContentHeight = function () {
            return this.view.getTotalHeight();
        };
        Tree.prototype.setHighlight = function (element, eventPayload) {
            this.model.setHighlight(element, eventPayload);
        };
        Tree.prototype.getHighlight = function () {
            return this.model.getHighlight();
        };
        Tree.prototype.isHighlighted = function (element) {
            return this.model.isFocused(element);
        };
        Tree.prototype.clearHighlight = function (eventPayload) {
            this.model.setHighlight(null, eventPayload);
        };
        Tree.prototype.select = function (element, eventPayload) {
            this.model.select(element, eventPayload);
        };
        Tree.prototype.selectRange = function (fromElement, toElement, eventPayload) {
            this.model.selectRange(fromElement, toElement, eventPayload);
        };
        Tree.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
            this.model.deselectRange(fromElement, toElement, eventPayload);
        };
        Tree.prototype.selectAll = function (elements, eventPayload) {
            this.model.selectAll(elements, eventPayload);
        };
        Tree.prototype.deselect = function (element, eventPayload) {
            this.model.deselect(element, eventPayload);
        };
        Tree.prototype.deselectAll = function (elements, eventPayload) {
            this.model.deselectAll(elements, eventPayload);
        };
        Tree.prototype.setSelection = function (elements, eventPayload) {
            this.model.setSelection(elements, eventPayload);
        };
        Tree.prototype.toggleSelection = function (element, eventPayload) {
            this.model.toggleSelection(element, eventPayload);
        };
        Tree.prototype.isSelected = function (element) {
            return this.model.isSelected(element);
        };
        Tree.prototype.getSelection = function () {
            return this.model.getSelection();
        };
        Tree.prototype.clearSelection = function (eventPayload) {
            this.model.setSelection([], eventPayload);
        };
        Tree.prototype.selectNext = function (count, clearSelection, eventPayload) {
            this.model.selectNext(count, clearSelection, eventPayload);
        };
        Tree.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
            this.model.selectPrevious(count, clearSelection, eventPayload);
        };
        Tree.prototype.selectParent = function (clearSelection, eventPayload) {
            this.model.selectParent(clearSelection, eventPayload);
        };
        Tree.prototype.setFocus = function (element, eventPayload) {
            this.model.setFocus(element, eventPayload);
        };
        Tree.prototype.isFocused = function (element) {
            return this.model.isFocused(element);
        };
        Tree.prototype.getFocus = function () {
            return this.model.getFocus();
        };
        Tree.prototype.focusNext = function (count, eventPayload) {
            this.model.focusNext(count, eventPayload);
        };
        Tree.prototype.focusPrevious = function (count, eventPayload) {
            this.model.focusPrevious(count, eventPayload);
        };
        Tree.prototype.focusParent = function (eventPayload) {
            this.model.focusParent(eventPayload);
        };
        Tree.prototype.focusFirstChild = function (eventPayload) {
            this.model.focusFirstChild(eventPayload);
        };
        Tree.prototype.focusFirst = function (eventPayload) {
            this.model.focusFirst(eventPayload);
        };
        Tree.prototype.focusNth = function (index, eventPayload) {
            this.model.focusNth(index, eventPayload);
        };
        Tree.prototype.focusLast = function (eventPayload) {
            this.model.focusLast(eventPayload);
        };
        Tree.prototype.focusNextPage = function (eventPayload) {
            this.view.focusNextPage(eventPayload);
        };
        Tree.prototype.focusPreviousPage = function (eventPayload) {
            this.view.focusPreviousPage(eventPayload);
        };
        Tree.prototype.clearFocus = function (eventPayload) {
            this.model.setFocus(null, eventPayload);
        };
        Tree.prototype.addTraits = function (trait, elements) {
            this.model.addTraits(trait, elements);
        };
        Tree.prototype.removeTraits = function (trait, elements) {
            this.model.removeTraits(trait, elements);
        };
        Tree.prototype.toggleTrait = function (trait, element) {
            this.model.hasTrait(trait, element) ? this.model.removeTraits(trait, [element])
                : this.model.addTraits(trait, [element]);
        };
        Tree.prototype.hasTrait = function (trait, element) {
            return this.model.hasTrait(trait, element);
        };
        Tree.prototype.getNavigator = function (fromElement, subTreeOnly) {
            return new iterator_1.MappedNavigator(this.model.getNavigator(fromElement, subTreeOnly), function (i) { return i && i.getElement(); });
        };
        Tree.prototype.dispose = function () {
            if (this.model !== null) {
                this.model.dispose();
                this.model = null;
            }
            if (this.view !== null) {
                this.view.dispose();
                this.view = null;
            }
            _super.prototype.dispose.call(this);
        };
        return Tree;
    }(Events.EventEmitter));
    exports.Tree = Tree;
});






define(__m[265/*vs/base/parts/quickopen/browser/quickOpenWidget*/], __M([1/*require*/,0/*exports*/,260/*vs/nls!vs/base/parts/quickopen/browser/quickOpenWidget*/,6/*vs/base/common/winjs.base*/,19/*vs/base/common/platform*/,67/*vs/base/common/events*/,24/*vs/base/common/types*/,10/*vs/base/common/errors*/,84/*vs/base/parts/quickopen/common/quickOpen*/,175/*vs/base/parts/quickopen/browser/quickOpenViewer*/,33/*vs/base/browser/builder*/,100/*vs/base/browser/ui/inputbox/inputBox*/,30/*vs/base/common/severity*/,139/*vs/base/parts/tree/browser/treeImpl*/,247/*vs/base/browser/ui/progressbar/progressbar*/,51/*vs/base/browser/keyboardEvent*/,87/*vs/base/parts/tree/browser/treeDefaults*/,11/*vs/base/browser/dom*/,3/*vs/base/common/lifecycle*/,38/*vs/base/common/scrollable*/,321/*vs/css!vs/base/parts/quickopen/browser/quickopen*/]), function (require, exports, nls, winjs_base_1, platform, events_1, types, errors, quickOpen_1, quickOpenViewer_1, builder_1, inputBox_1, severity_1, treeImpl_1, progressbar_1, keyboardEvent_1, treeDefaults_1, DOM, lifecycle_1, scrollable_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenController = (function (_super) {
        __extends(QuickOpenController, _super);
        function QuickOpenController() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        QuickOpenController.prototype.onContextMenu = function (tree, element, event) {
            if (platform.isMacintosh) {
                return this.onLeftClick(tree, element, event); // https://github.com/Microsoft/vscode/issues/1011
            }
            return _super.prototype.onContextMenu.call(this, tree, element, event);
        };
        return QuickOpenController;
    }(treeDefaults_1.DefaultController));
    exports.QuickOpenController = QuickOpenController;
    var HideReason;
    (function (HideReason) {
        HideReason[HideReason["ELEMENT_SELECTED"] = 0] = "ELEMENT_SELECTED";
        HideReason[HideReason["FOCUS_LOST"] = 1] = "FOCUS_LOST";
        HideReason[HideReason["CANCELED"] = 2] = "CANCELED";
    })(HideReason = exports.HideReason || (exports.HideReason = {}));
    var DEFAULT_INPUT_ARIA_LABEL = nls.localize(0, null);
    var QuickOpenWidget = (function () {
        function QuickOpenWidget(container, callbacks, options, usageLogger) {
            this.toUnbind = [];
            this.container = container;
            this.callbacks = callbacks;
            this.options = options;
            this.usageLogger = usageLogger;
            this.model = null;
        }
        QuickOpenWidget.prototype.getElement = function () {
            return builder_1.$(this.builder);
        };
        QuickOpenWidget.prototype.getModel = function () {
            return this.model;
        };
        QuickOpenWidget.prototype.setCallbacks = function (callbacks) {
            this.callbacks = callbacks;
        };
        QuickOpenWidget.prototype.create = function () {
            var _this = this;
            this.builder = builder_1.$().div(function (div) {
                // Eventing
                div.on(DOM.EventType.KEY_DOWN, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    if (keyboardEvent.keyCode === 9 /* Escape */) {
                        DOM.EventHelper.stop(e, true);
                        _this.hide(HideReason.CANCELED);
                    }
                })
                    .on(DOM.EventType.CONTEXT_MENU, function (e) { return DOM.EventHelper.stop(e, true); }) // Do this to fix an issue on Mac where the menu goes into the way
                    .on(DOM.EventType.FOCUS, function (e) { return _this.gainingFocus(); }, null, true)
                    .on(DOM.EventType.BLUR, function (e) { return _this.loosingFocus(e); }, null, true);
                // Progress Bar
                _this.progressBar = new progressbar_1.ProgressBar(div.clone());
                _this.progressBar.getContainer().hide();
                // Input Field
                div.div({ 'class': 'quick-open-input' }, function (inputContainer) {
                    _this.inputContainer = inputContainer;
                    _this.inputBox = new inputBox_1.InputBox(inputContainer.getHTMLElement(), null, {
                        placeholder: _this.options.inputPlaceHolder || '',
                        ariaLabel: DEFAULT_INPUT_ARIA_LABEL
                    });
                    // ARIA
                    _this.inputElement = _this.inputBox.inputElement;
                    _this.inputElement.setAttribute('role', 'combobox');
                    _this.inputElement.setAttribute('aria-haspopup', 'false');
                    _this.inputElement.setAttribute('aria-autocomplete', 'list');
                    DOM.addDisposableListener(_this.inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {
                        var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                        var shouldOpenInBackground = _this.shouldOpenInBackground(keyboardEvent);
                        // Do not handle Tab: It is used to navigate between elements without mouse
                        if (keyboardEvent.keyCode === 2 /* Tab */) {
                            return;
                        }
                        else if (keyboardEvent.keyCode === 18 /* DownArrow */ || keyboardEvent.keyCode === 16 /* UpArrow */ || keyboardEvent.keyCode === 12 /* PageDown */ || keyboardEvent.keyCode === 11 /* PageUp */) {
                            DOM.EventHelper.stop(e, true);
                            _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey);
                            // Position cursor at the end of input to allow right arrow (open in background) to function immediately
                            _this.inputBox.inputElement.selectionStart = _this.inputBox.value.length;
                        }
                        else if (keyboardEvent.keyCode === 3 /* Enter */ || shouldOpenInBackground) {
                            DOM.EventHelper.stop(e, true);
                            var focus_1 = _this.tree.getFocus();
                            if (focus_1) {
                                _this.elementSelected(focus_1, e, shouldOpenInBackground ? quickOpen_1.Mode.OPEN_IN_BACKGROUND : quickOpen_1.Mode.OPEN);
                            }
                        }
                    });
                    DOM.addDisposableListener(_this.inputBox.inputElement, DOM.EventType.INPUT, function (e) {
                        _this.onType();
                    });
                });
                // Tree
                _this.treeContainer = div.div({
                    'class': 'quick-open-tree'
                }, function (div) {
                    _this.tree = new treeImpl_1.Tree(div.getHTMLElement(), {
                        dataSource: new quickOpenViewer_1.DataSource(_this),
                        controller: new QuickOpenController({ clickBehavior: treeDefaults_1.ClickBehavior.ON_MOUSE_UP }),
                        renderer: new quickOpenViewer_1.Renderer(_this),
                        filter: new quickOpenViewer_1.Filter(_this),
                        accessibilityProvider: new quickOpenViewer_1.AccessibilityProvider(_this)
                    }, {
                        twistiePixels: 11,
                        indentPixels: 0,
                        alwaysFocused: true,
                        verticalScrollMode: scrollable_1.ScrollbarVisibility.Visible,
                        ariaLabel: nls.localize(1, null)
                    });
                    _this.treeElement = _this.tree.getHTMLElement();
                    // Handle Focus and Selection event
                    _this.toUnbind.push(_this.tree.addListener2(events_1.EventType.FOCUS, function (event) {
                        _this.elementFocused(event.focus, event);
                    }));
                    _this.toUnbind.push(_this.tree.addListener2(events_1.EventType.SELECTION, function (event) {
                        if (event.selection && event.selection.length > 0) {
                            _this.elementSelected(event.selection[0], event);
                        }
                    }));
                }).
                    on(DOM.EventType.KEY_DOWN, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    // Only handle when in quick navigation mode
                    if (!_this.quickNavigateConfiguration) {
                        return;
                    }
                    // Support keyboard navigation in quick navigation mode
                    if (keyboardEvent.keyCode === 18 /* DownArrow */ || keyboardEvent.keyCode === 16 /* UpArrow */ || keyboardEvent.keyCode === 12 /* PageDown */ || keyboardEvent.keyCode === 11 /* PageUp */) {
                        DOM.EventHelper.stop(e, true);
                        _this.navigateInTree(keyboardEvent.keyCode);
                    }
                }).
                    on(DOM.EventType.KEY_UP, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    var keyCode = keyboardEvent.keyCode;
                    // Only handle when in quick navigation mode
                    if (!_this.quickNavigateConfiguration) {
                        return;
                    }
                    // Select element when keys are pressed that signal it
                    var quickNavKeys = _this.quickNavigateConfiguration.keybindings;
                    var wasTriggerKeyPressed = keyCode === 3 /* Enter */ || quickNavKeys.some(function (k) {
                        if (k.hasShift() && keyCode === 4 /* Shift */) {
                            if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
                                return false; // this is an optimistic check for the shift key being used to navigate back in quick open
                            }
                            return true;
                        }
                        if (k.hasAlt() && keyCode === 6 /* Alt */) {
                            return true;
                        }
                        // Mac is a bit special
                        if (platform.isMacintosh) {
                            if (k.hasCtrlCmd() && keyCode === 57 /* Meta */) {
                                return true;
                            }
                            if (k.hasWinCtrl() && keyCode === 5 /* Ctrl */) {
                                return true;
                            }
                        }
                        else {
                            if (k.hasCtrlCmd() && keyCode === 5 /* Ctrl */) {
                                return true;
                            }
                            if (k.hasWinCtrl() && keyCode === 57 /* Meta */) {
                                return true;
                            }
                        }
                        return false;
                    });
                    if (wasTriggerKeyPressed) {
                        var focus_2 = _this.tree.getFocus();
                        if (focus_2) {
                            _this.elementSelected(focus_2, e);
                        }
                    }
                }).
                    clone();
            })
                .addClass('quick-open-widget')
                .build(this.container);
            // Support layout
            if (this.layoutDimensions) {
                this.layout(this.layoutDimensions);
            }
            return this.builder.getHTMLElement();
        };
        QuickOpenWidget.prototype.shouldOpenInBackground = function (e) {
            if (e.keyCode !== 17 /* RightArrow */) {
                return false; // only for right arrow
            }
            if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey) {
                return false; // no modifiers allowed
            }
            return this.inputBox.inputElement.selectionStart === this.inputBox.value.length; // only when cursor is at the end of the input field value
        };
        QuickOpenWidget.prototype.onType = function () {
            var value = this.inputBox.value;
            // Adjust help text as needed if present
            if (this.helpText) {
                if (value) {
                    this.helpText.hide();
                }
                else {
                    this.helpText.show();
                }
            }
            // Send to callbacks
            this.callbacks.onType(value);
        };
        QuickOpenWidget.prototype.quickNavigate = function (configuration, next) {
            if (this.isVisible) {
                // Transition into quick navigate mode if not yet done
                if (!this.quickNavigateConfiguration) {
                    this.quickNavigateConfiguration = configuration;
                    this.tree.DOMFocus();
                }
                // Navigate
                this.navigateInTree(next ? 18 /* DownArrow */ : 16 /* UpArrow */);
            }
        };
        QuickOpenWidget.prototype.navigateInTree = function (keyCode, isShift) {
            var model = this.tree.getInput();
            var entries = model ? model.entries : [];
            var oldFocus = this.tree.getFocus();
            // Normal Navigation
            switch (keyCode) {
                case 18 /* DownArrow */:
                    this.tree.focusNext();
                    break;
                case 16 /* UpArrow */:
                    this.tree.focusPrevious();
                    break;
                case 12 /* PageDown */:
                    this.tree.focusNextPage();
                    break;
                case 11 /* PageUp */:
                    this.tree.focusPreviousPage();
                    break;
                case 2 /* Tab */:
                    if (isShift) {
                        this.tree.focusPrevious();
                    }
                    else {
                        this.tree.focusNext();
                    }
                    break;
            }
            var newFocus = this.tree.getFocus();
            // Support cycle-through navigation if focus did not change
            if (entries.length > 1 && oldFocus === newFocus) {
                // Up from no entry or first entry goes down to last
                if (keyCode === 16 /* UpArrow */ || (keyCode === 2 /* Tab */ && isShift)) {
                    this.tree.focusLast();
                }
                else if (keyCode === 18 /* DownArrow */ || keyCode === 2 /* Tab */ && !isShift) {
                    this.tree.focusFirst();
                }
            }
            // Reveal
            newFocus = this.tree.getFocus();
            if (newFocus) {
                this.tree.reveal(newFocus).done(null, errors.onUnexpectedError);
            }
        };
        QuickOpenWidget.prototype.elementFocused = function (value, event) {
            if (!value || !this.isVisible()) {
                return;
            }
            // ARIA
            this.inputElement.setAttribute('aria-activedescendant', this.treeElement.getAttribute('aria-activedescendant'));
            var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
            this.model.runner.run(value, quickOpen_1.Mode.PREVIEW, context);
        };
        QuickOpenWidget.prototype.elementSelected = function (value, event, preferredMode) {
            var hide = true;
            // Trigger open of element on selection
            if (this.isVisible()) {
                var mode = preferredMode || quickOpen_1.Mode.OPEN;
                var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
                hide = this.model.runner.run(value, mode, context);
            }
            // add telemetry when an item is accepted, logging the index of the item in the list and the length of the list
            // to measure the rate of the success and the relevance of the order
            if (this.usageLogger) {
                var indexOfAcceptedElement = this.model.entries.indexOf(value);
                var entriesCount = this.model.entries.length;
                this.usageLogger.publicLog('quickOpenWidgetItemAccepted', { index: indexOfAcceptedElement, count: entriesCount, isQuickNavigate: this.quickNavigateConfiguration ? true : false });
            }
            // Hide if command was run successfully
            if (hide) {
                this.hide(HideReason.ELEMENT_SELECTED);
            }
        };
        QuickOpenWidget.prototype.extractKeyMods = function (event) {
            var isCtrlCmd = event && (event.ctrlKey || event.metaKey || (event.payload && event.payload.originalEvent && (event.payload.originalEvent.ctrlKey || event.payload.originalEvent.metaKey)));
            return isCtrlCmd ? [2048 /* CtrlCmd */] : [];
        };
        QuickOpenWidget.prototype.show = function (param, options) {
            this.visible = true;
            this.isLoosingFocus = false;
            this.quickNavigateConfiguration = options ? options.quickNavigateConfiguration : void 0;
            // Adjust UI for quick navigate mode
            if (this.quickNavigateConfiguration) {
                this.inputContainer.hide();
                this.builder.show();
                this.tree.DOMFocus();
            }
            else {
                this.inputContainer.show();
                this.builder.show();
                this.inputBox.focus();
            }
            // Adjust Help text for IE
            if (this.helpText) {
                if (this.quickNavigateConfiguration || types.isString(param)) {
                    this.helpText.hide();
                }
                else {
                    this.helpText.show();
                }
            }
            // Show based on param
            if (types.isString(param)) {
                this.doShowWithPrefix(param);
            }
            else {
                this.doShowWithInput(param, options && options.autoFocus ? options.autoFocus : {});
            }
            if (this.callbacks.onShow) {
                this.callbacks.onShow();
            }
        };
        QuickOpenWidget.prototype.doShowWithPrefix = function (prefix) {
            this.inputBox.value = prefix;
            this.callbacks.onType(prefix);
        };
        QuickOpenWidget.prototype.doShowWithInput = function (input, autoFocus) {
            this.setInput(input, autoFocus);
        };
        QuickOpenWidget.prototype.setInputAndLayout = function (input, autoFocus) {
            var _this = this;
            this.treeContainer.style({ height: this.getHeight(input) + "px" });
            this.tree.setInput(null).then(function () {
                _this.model = input;
                // ARIA
                _this.inputElement.setAttribute('aria-haspopup', String(input && input.entries && input.entries.length > 0));
                return _this.tree.setInput(input);
            }).done(function () {
                // Indicate entries to tree
                _this.tree.layout();
                // Handle auto focus
                if (input && input.entries.some(function (e) { return _this.isElementVisible(input, e); })) {
                    _this.autoFocus(input, autoFocus);
                }
            }, errors.onUnexpectedError);
        };
        QuickOpenWidget.prototype.isElementVisible = function (input, e) {
            if (!input.filter) {
                return true;
            }
            return input.filter.isVisible(e);
        };
        QuickOpenWidget.prototype.autoFocus = function (input, autoFocus) {
            var _this = this;
            if (autoFocus === void 0) { autoFocus = {}; }
            var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
            // First check for auto focus of prefix matches
            if (autoFocus.autoFocusPrefixMatch) {
                var caseSensitiveMatch = void 0;
                var caseInsensitiveMatch = void 0;
                var prefix = autoFocus.autoFocusPrefixMatch;
                var lowerCasePrefix = prefix.toLowerCase();
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    var label = input.dataSource.getLabel(entry);
                    if (!caseSensitiveMatch && label.indexOf(prefix) === 0) {
                        caseSensitiveMatch = entry;
                    }
                    else if (!caseInsensitiveMatch && label.toLowerCase().indexOf(lowerCasePrefix) === 0) {
                        caseInsensitiveMatch = entry;
                    }
                    if (caseSensitiveMatch && caseInsensitiveMatch) {
                        break;
                    }
                }
                var entryToFocus = caseSensitiveMatch || caseInsensitiveMatch;
                if (entryToFocus) {
                    this.tree.setFocus(entryToFocus);
                    this.tree.reveal(entryToFocus, 0.5).done(null, errors.onUnexpectedError);
                    return;
                }
            }
            // Second check for auto focus of first entry
            if (autoFocus.autoFocusFirstEntry) {
                this.tree.focusFirst();
                this.tree.reveal(this.tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            else if (typeof autoFocus.autoFocusIndex === 'number') {
                if (entries.length > autoFocus.autoFocusIndex) {
                    this.tree.focusNth(autoFocus.autoFocusIndex);
                    this.tree.reveal(this.tree.getFocus()).done(null, errors.onUnexpectedError);
                }
            }
            else if (autoFocus.autoFocusSecondEntry) {
                if (entries.length > 1) {
                    this.tree.focusNth(1);
                }
            }
            else if (autoFocus.autoFocusLastEntry) {
                if (entries.length > 1) {
                    this.tree.focusLast();
                }
            }
        };
        QuickOpenWidget.prototype.refresh = function (input, autoFocus) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            // Apply height & Refresh
            this.treeContainer.style({ height: this.getHeight(input) + "px" });
            this.tree.refresh().done(function () {
                // Indicate entries to tree
                _this.tree.layout();
                var doAutoFocus = autoFocus && input && input.entries.some(function (e) { return _this.isElementVisible(input, e); });
                if (doAutoFocus && !autoFocus.autoFocusPrefixMatch) {
                    doAutoFocus = !_this.tree.getFocus(); // if auto focus is not for prefix matches, we do not want to change what the user has focussed already
                }
                // Handle auto focus
                if (doAutoFocus) {
                    _this.autoFocus(input, autoFocus);
                }
            }, errors.onUnexpectedError);
        };
        QuickOpenWidget.prototype.getHeight = function (input) {
            var _this = this;
            var renderer = input.renderer;
            if (!input) {
                var itemHeight = renderer.getHeight(null);
                return this.options.minItemsToShow ? this.options.minItemsToShow * itemHeight : 0;
            }
            var height = 0;
            var preferredItemsHeight;
            if (this.layoutDimensions && this.layoutDimensions.height) {
                preferredItemsHeight = (this.layoutDimensions.height - 50 /* subtract height of input field (30px) and some spacing (drop shadow) to fit */) * 0.40 /* max 40% of screen */;
            }
            if (!preferredItemsHeight || preferredItemsHeight > QuickOpenWidget.MAX_ITEMS_HEIGHT) {
                preferredItemsHeight = QuickOpenWidget.MAX_ITEMS_HEIGHT;
            }
            var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
            var maxEntries = this.options.maxItemsToShow || entries.length;
            for (var i = 0; i < maxEntries && i < entries.length; i++) {
                var entryHeight = renderer.getHeight(entries[i]);
                if (height + entryHeight <= preferredItemsHeight) {
                    height += entryHeight;
                }
                else {
                    break;
                }
            }
            return height;
        };
        QuickOpenWidget.prototype.hide = function (reason) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            this.visible = false;
            this.builder.hide();
            this.builder.domBlur();
            // report failure cases
            if (reason === HideReason.CANCELED) {
                if (this.model) {
                    var entriesCount = this.model.entries.filter(function (e) { return _this.isElementVisible(_this.model, e); }).length;
                    if (this.usageLogger) {
                        this.usageLogger.publicLog('quickOpenWidgetCancelled', { count: entriesCount, isQuickNavigate: this.quickNavigateConfiguration ? true : false });
                    }
                }
            }
            // Clear input field and clear tree
            this.inputBox.value = '';
            this.tree.setInput(null);
            // ARIA
            this.inputElement.setAttribute('aria-haspopup', 'false');
            // Reset Tree Height
            this.treeContainer.style({ height: (this.options.minItemsToShow ? this.options.minItemsToShow * 22 : 0) + 'px' });
            // Clear any running Progress
            this.progressBar.stop().getContainer().hide();
            // Clear Focus
            if (this.tree.isDOMFocused()) {
                this.tree.DOMBlur();
            }
            else if (this.inputBox.hasFocus()) {
                this.inputBox.blur();
            }
            // Callbacks
            if (reason === HideReason.ELEMENT_SELECTED) {
                this.callbacks.onOk();
            }
            else {
                this.callbacks.onCancel();
            }
            if (this.callbacks.onHide) {
                this.callbacks.onHide(reason);
            }
        };
        QuickOpenWidget.prototype.getQuickNavigateConfiguration = function () {
            return this.quickNavigateConfiguration;
        };
        QuickOpenWidget.prototype.setPlaceHolder = function (placeHolder) {
            if (this.inputBox) {
                this.inputBox.setPlaceHolder(placeHolder);
            }
        };
        QuickOpenWidget.prototype.setValue = function (value, select) {
            if (this.inputBox) {
                this.inputBox.value = value;
                if (select) {
                    this.inputBox.select();
                }
            }
        };
        QuickOpenWidget.prototype.setPassword = function (isPassword) {
            if (this.inputBox) {
                this.inputBox.inputElement.type = isPassword ? 'password' : 'text';
            }
        };
        QuickOpenWidget.prototype.setInput = function (input, autoFocus, ariaLabel) {
            if (!this.isVisible()) {
                return;
            }
            // If the input changes, indicate this to the tree
            if (!!this.getInput()) {
                this.onInputChanging();
            }
            // Adapt tree height to entries and apply input
            this.setInputAndLayout(input, autoFocus);
            // Apply ARIA
            if (this.inputBox) {
                this.inputBox.setAriaLabel(ariaLabel || DEFAULT_INPUT_ARIA_LABEL);
            }
        };
        QuickOpenWidget.prototype.onInputChanging = function () {
            var _this = this;
            if (this.inputChangingTimeoutHandle) {
                clearTimeout(this.inputChangingTimeoutHandle);
                this.inputChangingTimeoutHandle = null;
            }
            // when the input is changing in quick open, we indicate this as CSS class to the widget
            // for a certain timeout. this helps reducing some hectic UI updates when input changes quickly
            this.builder.addClass('content-changing');
            this.inputChangingTimeoutHandle = setTimeout(function () {
                _this.builder.removeClass('content-changing');
            }, 500);
        };
        QuickOpenWidget.prototype.getInput = function () {
            return this.tree.getInput();
        };
        QuickOpenWidget.prototype.showInputDecoration = function (decoration) {
            if (this.inputBox) {
                this.inputBox.showMessage({ type: decoration === severity_1.default.Info ? inputBox_1.MessageType.INFO : decoration === severity_1.default.Warning ? inputBox_1.MessageType.WARNING : inputBox_1.MessageType.ERROR, content: '' });
            }
        };
        QuickOpenWidget.prototype.clearInputDecoration = function () {
            if (this.inputBox) {
                this.inputBox.hideMessage();
            }
        };
        QuickOpenWidget.prototype.focus = function () {
            if (this.isVisible() && this.inputBox) {
                this.inputBox.focus();
            }
        };
        QuickOpenWidget.prototype.accept = function () {
            if (this.isVisible()) {
                var focus_3 = this.tree.getFocus();
                if (focus_3) {
                    this.elementSelected(focus_3);
                }
            }
        };
        QuickOpenWidget.prototype.getProgressBar = function () {
            return this.progressBar;
        };
        QuickOpenWidget.prototype.getInputBox = function () {
            return this.inputBox;
        };
        QuickOpenWidget.prototype.setExtraClass = function (clazz) {
            var previousClass = this.builder.getProperty('extra-class');
            if (previousClass) {
                this.builder.removeClass(previousClass);
            }
            if (clazz) {
                this.builder.addClass(clazz);
                this.builder.setProperty('extra-class', clazz);
            }
            else if (previousClass) {
                this.builder.removeProperty('extra-class');
            }
        };
        QuickOpenWidget.prototype.isVisible = function () {
            return this.visible;
        };
        QuickOpenWidget.prototype.layout = function (dimension) {
            this.layoutDimensions = dimension;
            // Apply to quick open width (height is dynamic by number of items to show)
            var quickOpenWidth = Math.min(this.layoutDimensions.width * 0.62 /* golden cut */, QuickOpenWidget.MAX_WIDTH);
            if (this.builder) {
                // quick open
                this.builder.style({
                    width: quickOpenWidth + 'px',
                    marginLeft: '-' + (quickOpenWidth / 2) + 'px'
                });
                // input field
                this.inputContainer.style({
                    width: (quickOpenWidth - 12) + 'px'
                });
            }
        };
        QuickOpenWidget.prototype.gainingFocus = function () {
            this.isLoosingFocus = false;
        };
        QuickOpenWidget.prototype.loosingFocus = function (e) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            var relatedTarget = e.relatedTarget;
            if (!this.quickNavigateConfiguration && DOM.isAncestor(relatedTarget, this.builder.getHTMLElement())) {
                return; // user clicked somewhere into quick open widget, do not close thereby
            }
            this.isLoosingFocus = true;
            winjs_base_1.TPromise.timeout(0).then(function () {
                if (!_this.isLoosingFocus) {
                    return;
                }
                var veto = _this.callbacks.onFocusLost && _this.callbacks.onFocusLost();
                if (!veto) {
                    _this.hide(HideReason.FOCUS_LOST);
                }
            });
        };
        QuickOpenWidget.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
            this.progressBar.dispose();
            this.inputBox.dispose();
            this.tree.dispose();
        };
        return QuickOpenWidget;
    }());
    QuickOpenWidget.MAX_WIDTH = 600; // Max total width of quick open widget
    QuickOpenWidget.MAX_ITEMS_HEIGHT = 20 * 22; // Max height of item list below input field
    exports.QuickOpenWidget = QuickOpenWidget;
});

define(__m[266/*vs/editor/contrib/quickOpen/browser/quickOpenEditorWidget*/], __M([1/*require*/,0/*exports*/,33/*vs/base/browser/builder*/,265/*vs/base/parts/quickopen/browser/quickOpenWidget*/,21/*vs/editor/browser/editorBrowser*/]), function (require, exports, builder_1, quickOpenWidget_1, editorBrowser_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenEditorWidget = (function () {
        function QuickOpenEditorWidget(codeEditor, onOk, onCancel, onType, configuration) {
            this.codeEditor = codeEditor;
            this.create(onOk, onCancel, onType, configuration);
        }
        QuickOpenEditorWidget.prototype.create = function (onOk, onCancel, onType, configuration) {
            this.domNode = builder_1.$().div().getHTMLElement();
            this.quickOpenWidget = new quickOpenWidget_1.QuickOpenWidget(this.domNode, {
                onOk: onOk,
                onCancel: onCancel,
                onType: onType
            }, {
                inputPlaceHolder: null,
                inputAriaLabel: configuration.inputAriaLabel
            }, null);
            this.quickOpenWidget.create();
            this.codeEditor.addOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.setInput = function (model, focus) {
            this.quickOpenWidget.setInput(model, focus);
        };
        QuickOpenEditorWidget.prototype.getId = function () {
            return QuickOpenEditorWidget.ID;
        };
        QuickOpenEditorWidget.prototype.getDomNode = function () {
            return this.domNode;
        };
        QuickOpenEditorWidget.prototype.destroy = function () {
            this.codeEditor.removeOverlayWidget(this);
            this.quickOpenWidget.dispose();
        };
        QuickOpenEditorWidget.prototype.isVisible = function () {
            return this.visible;
        };
        QuickOpenEditorWidget.prototype.show = function (value) {
            this.visible = true;
            var editorLayout = this.codeEditor.getLayoutInfo();
            if (editorLayout) {
                this.quickOpenWidget.layout(new builder_1.Dimension(editorLayout.width, editorLayout.height));
            }
            this.quickOpenWidget.show(value);
            this.codeEditor.layoutOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.hide = function () {
            this.visible = false;
            this.quickOpenWidget.hide();
            this.codeEditor.layoutOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.getPosition = function () {
            if (this.visible) {
                return {
                    preference: editorBrowser_1.OverlayWidgetPositionPreference.TOP_CENTER
                };
            }
            return null;
        };
        return QuickOpenEditorWidget;
    }());
    QuickOpenEditorWidget.ID = 'editor.contrib.quickOpenEditorWidget';
    exports.QuickOpenEditorWidget = QuickOpenEditorWidget;
});

define(__m[267/*vs/nls!vs/editor/common/config/commonEditorConfig*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/config/commonEditorConfig", data); });
define(__m[268/*vs/nls!vs/editor/common/config/defaultConfig*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/config/defaultConfig", data); });
define(__m[44/*vs/editor/common/config/defaultConfig*/], __M([1/*require*/,0/*exports*/,268/*vs/nls!vs/editor/common/config/defaultConfig*/,19/*vs/base/common/platform*/,74/*vs/editor/common/model/wordHelper*/]), function (require, exports, nls, platform, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.DEFAULT_INDENTATION = {
        tabSize: 4,
        insertSpaces: true,
        detectIndentation: true
    };
    exports.DEFAULT_TRIM_AUTO_WHITESPACE = true;
    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'Courier New\', monospace, \'Droid Sans Fallback\'';
    /**
     * Determined from empirical observations.
     */
    exports.GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;
    var ConfigClass = (function () {
        function ConfigClass() {
            this.editor = {
                experimentalScreenReader: true,
                rulers: [],
                wordSeparators: wordHelper_1.USUAL_WORD_SEPARATORS,
                selectionClipboard: true,
                ariaLabel: nls.localize(0, null),
                lineNumbers: 'on',
                selectOnLineNumbers: true,
                lineNumbersMinChars: 5,
                glyphMargin: true,
                lineDecorationsWidth: 10,
                revealHorizontalRightPadding: 30,
                roundedSelection: true,
                theme: 'vs',
                readOnly: false,
                scrollbar: {
                    verticalScrollbarSize: 14,
                    horizontal: 'auto',
                    useShadows: true,
                    verticalHasArrows: false,
                    horizontalHasArrows: false
                },
                fixedOverflowWidgets: false,
                overviewRulerLanes: 2,
                cursorBlinking: 'blink',
                mouseWheelZoom: false,
                cursorStyle: 'line',
                fontLigatures: false,
                disableTranslate3d: false,
                hideCursorInOverviewRuler: false,
                scrollBeyondLastLine: true,
                automaticLayout: false,
                wrappingColumn: 300,
                wordWrap: false,
                wrappingIndent: 'same',
                wordWrapBreakBeforeCharacters: '([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋',
                wordWrapBreakAfterCharacters: ' \t})]?|&,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ’”〉》」』】〕）］｝｣',
                wordWrapBreakObtrusiveCharacters: '.',
                // Features
                hover: true,
                contextmenu: true,
                mouseWheelScrollSensitivity: 1,
                quickSuggestions: true,
                quickSuggestionsDelay: 10,
                parameterHints: true,
                iconsInSuggestions: true,
                autoClosingBrackets: true,
                formatOnType: false,
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnEnter: true,
                acceptSuggestionOnCommitCharacter: true,
                snippetSuggestions: 'bottom',
                emptySelectionClipboard: true,
                tabCompletion: false,
                wordBasedSuggestions: true,
                suggestFontSize: 0,
                suggestLineHeight: 0,
                selectionHighlight: true,
                codeLens: true,
                referenceInfos: true,
                folding: true,
                renderWhitespace: 'none',
                renderControlCharacters: false,
                renderIndentGuides: false,
                renderLineHighlight: 'line',
                useTabStops: true,
                fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
                fontWeight: 'normal',
                fontSize: (platform.isMacintosh ? 12 : 14),
                lineHeight: 0
            };
        }
        return ConfigClass;
    }());
    exports.DefaultConfig = new ConfigClass();
});






define(__m[107/*vs/editor/common/config/fontInfo*/], __M([1/*require*/,0/*exports*/,44/*vs/editor/common/config/defaultConfig*/,106/*vs/editor/common/config/editorZoom*/]), function (require, exports, defaultConfig_1, editorZoom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function safeParseFloat(n, defaultValue) {
        if (typeof n === 'number') {
            return n;
        }
        var r = parseFloat(n);
        if (isNaN(r)) {
            return defaultValue;
        }
        return r;
    }
    function safeParseInt(n, defaultValue) {
        if (typeof n === 'number') {
            return Math.round(n);
        }
        var r = parseInt(n);
        if (isNaN(r)) {
            return defaultValue;
        }
        return r;
    }
    function clamp(n, min, max) {
        if (n < min) {
            return min;
        }
        if (n > max) {
            return max;
        }
        return n;
    }
    var BareFontInfo = (function () {
        /**
         * @internal
         */
        function BareFontInfo(opts) {
            this.fontFamily = String(opts.fontFamily);
            this.fontWeight = String(opts.fontWeight);
            this.fontSize = opts.fontSize;
            this.lineHeight = opts.lineHeight | 0;
        }
        /**
         * @internal
         */
        BareFontInfo.createFromRawSettings = function (opts) {
            var fontFamily = String(opts.fontFamily) || defaultConfig_1.DefaultConfig.editor.fontFamily;
            var fontWeight = String(opts.fontWeight) || defaultConfig_1.DefaultConfig.editor.fontWeight;
            var fontSize = safeParseFloat(opts.fontSize, defaultConfig_1.DefaultConfig.editor.fontSize);
            fontSize = clamp(fontSize, 0, 100);
            if (fontSize === 0) {
                fontSize = defaultConfig_1.DefaultConfig.editor.fontSize;
            }
            var lineHeight = safeParseInt(opts.lineHeight, 0);
            lineHeight = clamp(lineHeight, 0, 150);
            if (lineHeight === 0) {
                lineHeight = Math.round(defaultConfig_1.GOLDEN_LINE_HEIGHT_RATIO * fontSize);
            }
            var editorZoomLevelMultiplier = 1 + (editorZoom_1.EditorZoom.getZoomLevel() * 0.1);
            fontSize *= editorZoomLevelMultiplier;
            lineHeight *= editorZoomLevelMultiplier;
            return new BareFontInfo({
                fontFamily: fontFamily,
                fontWeight: fontWeight,
                fontSize: fontSize,
                lineHeight: lineHeight
            });
        };
        /**
         * @internal
         */
        BareFontInfo.prototype.getId = function () {
            return this.fontFamily + '-' + this.fontWeight + '-' + this.fontSize + '-' + this.lineHeight + '-';
        };
        return BareFontInfo;
    }());
    exports.BareFontInfo = BareFontInfo;
    var FontInfo = (function (_super) {
        __extends(FontInfo, _super);
        /**
         * @internal
         */
        function FontInfo(opts) {
            var _this = _super.call(this, opts) || this;
            _this.isMonospace = opts.isMonospace;
            _this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
            _this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
            _this.spaceWidth = opts.spaceWidth;
            _this.maxDigitWidth = opts.maxDigitWidth;
            return _this;
        }
        /**
         * @internal
         */
        FontInfo.prototype.equals = function (other) {
            return (this.fontFamily === other.fontFamily
                && this.fontWeight === other.fontWeight
                && this.fontSize === other.fontSize
                && this.lineHeight === other.lineHeight
                && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth
                && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth
                && this.spaceWidth === other.spaceWidth
                && this.maxDigitWidth === other.maxDigitWidth);
        };
        /**
         * @internal
         */
        FontInfo.prototype.clone = function () {
            return new FontInfo(this);
        };
        return FontInfo;
    }(BareFontInfo));
    exports.FontInfo = FontInfo;
});

define(__m[271/*vs/nls!vs/editor/common/controller/cursor*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/controller/cursor", data); });
define(__m[272/*vs/nls!vs/editor/common/model/textModelWithTokens*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/model/textModelWithTokens", data); });
define(__m[273/*vs/nls!vs/editor/common/modes/modesRegistry*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/modes/modesRegistry", data); });
define(__m[274/*vs/nls!vs/editor/common/modes/snippetsRegistry*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/modes/snippetsRegistry", data); });
define(__m[275/*vs/nls!vs/editor/common/services/bulkEdit*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/services/bulkEdit", data); });





define(__m[276/*vs/editor/common/services/bulkEdit*/], __M([1/*require*/,0/*exports*/,275/*vs/nls!vs/editor/common/services/bulkEdit*/,28/*vs/base/common/arrays*/,91/*vs/base/common/collections*/,3/*vs/base/common/lifecycle*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,46/*vs/editor/common/core/editOperation*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/]), function (require, exports, nls, arrays_1, collections_1, lifecycle_1, uri_1, winjs_base_1, editOperation_1, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ChangeRecorder = (function () {
        function ChangeRecorder(fileService) {
            this._fileService = fileService;
        }
        ChangeRecorder.prototype.start = function () {
            var changes = Object.create(null);
            var stop;
            if (this._fileService) {
                stop = this._fileService.onFileChanges(function (event) {
                    event.changes.forEach(function (change) {
                        var key = String(change.resource);
                        var array = changes[key];
                        if (!array) {
                            changes[key] = array = [];
                        }
                        array.push(change);
                    });
                });
            }
            return {
                stop: function () { return stop && stop.dispose(); },
                hasChanged: function (resource) { return !!changes[resource.toString()]; },
                allChanges: function () { return arrays_1.flatten(collections_1.values(changes)); }
            };
        };
        return ChangeRecorder;
    }());
    var EditTask = (function () {
        function EditTask(modelReference) {
            this._endCursorSelection = null;
            this._modelReference = modelReference;
            this._edits = [];
        }
        Object.defineProperty(EditTask.prototype, "_model", {
            get: function () { return this._modelReference.object.textEditorModel; },
            enumerable: true,
            configurable: true
        });
        EditTask.prototype.addEdit = function (edit) {
            var range;
            if (!edit.range) {
                range = this._model.getFullModelRange();
            }
            else {
                range = edit.range;
            }
            this._edits.push(editOperation_1.EditOperation.replace(range_1.Range.lift(range), edit.newText));
        };
        EditTask.prototype.apply = function () {
            var _this = this;
            if (this._edits.length === 0) {
                return;
            }
            this._edits.sort(EditTask._editCompare);
            this._initialSelections = this._getInitialSelections();
            this._model.pushEditOperations(this._initialSelections, this._edits, function (edits) { return _this._getEndCursorSelections(edits); });
        };
        EditTask.prototype._getInitialSelections = function () {
            var firstRange = this._edits[0].range;
            var initialSelection = new selection_1.Selection(firstRange.startLineNumber, firstRange.startColumn, firstRange.endLineNumber, firstRange.endColumn);
            return [initialSelection];
        };
        EditTask.prototype._getEndCursorSelections = function (inverseEditOperations) {
            var relevantEditIndex = 0;
            for (var i = 0; i < inverseEditOperations.length; i++) {
                var editRange = inverseEditOperations[i].range;
                for (var j = 0; j < this._initialSelections.length; j++) {
                    var selectionRange = this._initialSelections[j];
                    if (range_1.Range.areIntersectingOrTouching(editRange, selectionRange)) {
                        relevantEditIndex = i;
                        break;
                    }
                }
            }
            var srcRange = inverseEditOperations[relevantEditIndex].range;
            this._endCursorSelection = new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
            return [this._endCursorSelection];
        };
        EditTask.prototype.getEndCursorSelection = function () {
            return this._endCursorSelection;
        };
        EditTask._editCompare = function (a, b) {
            return range_1.Range.compareRangesUsingStarts(a.range, b.range);
        };
        EditTask.prototype.dispose = function () {
            if (this._model) {
                this._modelReference.dispose();
                this._modelReference = null;
            }
        };
        return EditTask;
    }());
    var SourceModelEditTask = (function (_super) {
        __extends(SourceModelEditTask, _super);
        function SourceModelEditTask(modelReference, initialSelections) {
            var _this = _super.call(this, modelReference) || this;
            _this._knownInitialSelections = initialSelections;
            return _this;
        }
        SourceModelEditTask.prototype._getInitialSelections = function () {
            return this._knownInitialSelections;
        };
        return SourceModelEditTask;
    }(EditTask));
    var BulkEditModel = (function () {
        function BulkEditModel(textModelResolverService, sourceModel, sourceSelections, edits, progress) {
            if (progress === void 0) { progress = null; }
            this.progress = progress;
            this._numberOfResourcesToModify = 0;
            this._numberOfChanges = 0;
            this._edits = Object.create(null);
            this._textModelResolverService = textModelResolverService;
            this._sourceModel = sourceModel;
            this._sourceSelections = sourceSelections;
            this._sourceModelTask = null;
            for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                var edit = edits_1[_i];
                this._addEdit(edit);
            }
        }
        BulkEditModel.prototype.resourcesCount = function () {
            return this._numberOfResourcesToModify;
        };
        BulkEditModel.prototype.changeCount = function () {
            return this._numberOfChanges;
        };
        BulkEditModel.prototype._addEdit = function (edit) {
            var array = this._edits[edit.resource.toString()];
            if (!array) {
                this._edits[edit.resource.toString()] = array = [];
                this._numberOfResourcesToModify += 1;
            }
            this._numberOfChanges += 1;
            array.push(edit);
        };
        BulkEditModel.prototype.prepare = function () {
            var _this = this;
            if (this._tasks) {
                throw new Error('illegal state - already prepared');
            }
            this._tasks = [];
            var promises = [];
            if (this.progress) {
                this.progress.total(this._numberOfResourcesToModify * 2);
            }
            collections_1.forEach(this._edits, function (entry) {
                var promise = _this._textModelResolverService.createModelReference(uri_1.default.parse(entry.key)).then(function (ref) {
                    var model = ref.object;
                    if (!model || !model.textEditorModel) {
                        throw new Error("Cannot load file " + entry.key);
                    }
                    var textEditorModel = model.textEditorModel;
                    var task;
                    if (_this._sourceModel && textEditorModel.uri.toString() === _this._sourceModel.toString()) {
                        _this._sourceModelTask = new SourceModelEditTask(ref, _this._sourceSelections);
                        task = _this._sourceModelTask;
                    }
                    else {
                        task = new EditTask(ref);
                    }
                    entry.value.forEach(function (edit) { return task.addEdit(edit); });
                    _this._tasks.push(task);
                    if (_this.progress) {
                        _this.progress.worked(1);
                    }
                });
                promises.push(promise);
            });
            return winjs_base_1.TPromise.join(promises).then(function (_) { return _this; });
        };
        BulkEditModel.prototype.apply = function () {
            var _this = this;
            this._tasks.forEach(function (task) { return _this.applyTask(task); });
            var r = null;
            if (this._sourceModelTask) {
                r = this._sourceModelTask.getEndCursorSelection();
            }
            return r;
        };
        BulkEditModel.prototype.applyTask = function (task) {
            task.apply();
            if (this.progress) {
                this.progress.worked(1);
            }
        };
        BulkEditModel.prototype.dispose = function () {
            this._tasks = lifecycle_1.dispose(this._tasks);
        };
        return BulkEditModel;
    }());
    function bulkEdit(textModelResolverService, editor, edits, fileService, progress) {
        if (progress === void 0) { progress = null; }
        var bulk = createBulkEdit(textModelResolverService, editor, fileService);
        bulk.add(edits);
        bulk.progress(progress);
        return bulk.finish();
    }
    exports.bulkEdit = bulkEdit;
    function createBulkEdit(textModelResolverService, editor, fileService) {
        var all = [];
        var recording = new ChangeRecorder(fileService).start();
        var progressRunner;
        function progress(progress) {
            progressRunner = progress;
        }
        function add(edits) {
            all.push.apply(all, edits);
        }
        function getConcurrentEdits() {
            var names;
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
                var edit = all_1[_i];
                if (recording.hasChanged(edit.resource)) {
                    if (!names) {
                        names = [];
                    }
                    names.push(edit.resource.fsPath);
                }
            }
            if (names) {
                return nls.localize(0, null, names.join(', '));
            }
        }
        function finish() {
            if (all.length === 0) {
                return winjs_base_1.TPromise.as(undefined);
            }
            var concurrentEdits = getConcurrentEdits();
            if (concurrentEdits) {
                return winjs_base_1.TPromise.wrapError(concurrentEdits);
            }
            var uri;
            var selections;
            if (editor && editor.getModel()) {
                uri = editor.getModel().uri;
                selections = editor.getSelections();
            }
            var model = new BulkEditModel(textModelResolverService, uri, selections, all, progressRunner);
            return model.prepare().then(function (_) {
                var concurrentEdits = getConcurrentEdits();
                if (concurrentEdits) {
                    throw new Error(concurrentEdits);
                }
                recording.stop();
                var result = model.apply();
                model.dispose();
                return result;
            });
        }
        return {
            progress: progress,
            add: add,
            finish: finish
        };
    }
    exports.createBulkEdit = createBulkEdit;
});

define(__m[277/*vs/nls!vs/editor/common/services/modeServiceImpl*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/services/modeServiceImpl", data); });
define(__m[278/*vs/nls!vs/editor/common/services/modelServiceImpl*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/common/services/modelServiceImpl", data); });
define(__m[279/*vs/nls!vs/editor/contrib/bracketMatching/common/bracketMatching*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/bracketMatching/common/bracketMatching", data); });
define(__m[280/*vs/nls!vs/editor/contrib/caretOperations/common/caretOperations*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/caretOperations/common/caretOperations", data); });
define(__m[281/*vs/nls!vs/editor/contrib/clipboard/browser/clipboard*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/clipboard/browser/clipboard", data); });
define(__m[282/*vs/nls!vs/editor/contrib/comment/common/comment*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/comment/common/comment", data); });
define(__m[283/*vs/nls!vs/editor/contrib/contextmenu/browser/contextmenu*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/contextmenu/browser/contextmenu", data); });
define(__m[284/*vs/nls!vs/editor/contrib/find/browser/findWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/find/browser/findWidget", data); });
define(__m[285/*vs/nls!vs/editor/contrib/find/common/findController*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/find/common/findController", data); });
define(__m[286/*vs/nls!vs/editor/contrib/folding/browser/folding*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/folding/browser/folding", data); });
define(__m[287/*vs/nls!vs/editor/contrib/format/common/formatActions*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/format/common/formatActions", data); });
define(__m[288/*vs/nls!vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/goToDeclaration/browser/goToDeclaration", data); });
define(__m[289/*vs/nls!vs/editor/contrib/gotoError/browser/gotoError*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/gotoError/browser/gotoError", data); });
define(__m[290/*vs/nls!vs/editor/contrib/hover/browser/hover*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/hover/browser/hover", data); });
define(__m[291/*vs/nls!vs/editor/contrib/hover/browser/modesContentHover*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/hover/browser/modesContentHover", data); });
define(__m[292/*vs/nls!vs/editor/contrib/inPlaceReplace/common/inPlaceReplace*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/inPlaceReplace/common/inPlaceReplace", data); });
define(__m[293/*vs/nls!vs/editor/contrib/inspectTokens/browser/inspectTokens*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/inspectTokens/browser/inspectTokens", data); });
define(__m[294/*vs/nls!vs/editor/contrib/linesOperations/common/linesOperations*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/linesOperations/common/linesOperations", data); });
define(__m[295/*vs/nls!vs/editor/contrib/links/browser/links*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/links/browser/links", data); });
define(__m[296/*vs/nls!vs/editor/contrib/multicursor/common/multicursor*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/multicursor/common/multicursor", data); });
define(__m[297/*vs/nls!vs/editor/contrib/parameterHints/browser/parameterHints*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/parameterHints/browser/parameterHints", data); });
define(__m[298/*vs/nls!vs/editor/contrib/parameterHints/browser/parameterHintsWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/parameterHints/browser/parameterHintsWidget", data); });
define(__m[299/*vs/nls!vs/editor/contrib/quickFix/browser/quickFix*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/quickFix/browser/quickFix", data); });
define(__m[300/*vs/nls!vs/editor/contrib/quickOpen/browser/gotoLine*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/gotoLine", data); });
define(__m[301/*vs/nls!vs/editor/contrib/quickOpen/browser/quickCommand*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickCommand", data); });
define(__m[302/*vs/nls!vs/editor/contrib/quickOpen/browser/quickOutline*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickOutline", data); });
define(__m[303/*vs/nls!vs/editor/contrib/referenceSearch/browser/referenceSearch*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referenceSearch", data); });
define(__m[304/*vs/nls!vs/editor/contrib/referenceSearch/browser/referencesController*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referencesController", data); });
define(__m[305/*vs/nls!vs/editor/contrib/referenceSearch/browser/referencesWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referencesWidget", data); });
define(__m[306/*vs/nls!vs/editor/contrib/rename/browser/rename*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/rename/browser/rename", data); });
define(__m[307/*vs/nls!vs/editor/contrib/rename/browser/renameInputField*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/rename/browser/renameInputField", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[308/*vs/editor/contrib/rename/browser/renameInputField*/], __M([1/*require*/,0/*exports*/,307/*vs/nls!vs/editor/contrib/rename/browser/renameInputField*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,21/*vs/editor/browser/editorBrowser*/,411/*vs/css!vs/editor/contrib/rename/browser/renameInputField*/]), function (require, exports, nls_1, errors_1, lifecycle_1, winjs_base_1, range_1, editorBrowser_1) {
    'use strict';
    var RenameInputField = (function () {
        function RenameInputField(editor) {
            var _this = this;
            this._disposables = [];
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this._currentAcceptInput = null;
            this._currentCancelInput = null;
            this._editor = editor;
            this._editor.addContentWidget(this);
            this._disposables.push(editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this.updateFont();
                }
            }));
        }
        RenameInputField.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._editor.removeContentWidget(this);
        };
        RenameInputField.prototype.getId = function () {
            return '__renameInputWidget';
        };
        RenameInputField.prototype.getDomNode = function () {
            if (!this._domNode) {
                this._inputField = document.createElement('input');
                this._inputField.className = 'rename-input';
                this._inputField.type = 'text';
                this._inputField.setAttribute('aria-label', nls_1.localize(0, null));
                this._domNode = document.createElement('div');
                this._domNode.style.height = this._editor.getConfiguration().lineHeight + "px";
                this._domNode.className = 'monaco-editor rename-box';
                this._domNode.appendChild(this._inputField);
                this.updateFont();
            }
            return this._domNode;
        };
        RenameInputField.prototype.updateFont = function () {
            if (!this._inputField) {
                return;
            }
            var fontInfo = this._editor.getConfiguration().fontInfo;
            this._inputField.style.fontFamily = fontInfo.fontFamily;
            this._inputField.style.fontWeight = fontInfo.fontWeight;
            this._inputField.style.fontSize = fontInfo.fontSize + "px";
        };
        RenameInputField.prototype.getPosition = function () {
            return this._visible
                ? { position: this._position, preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE] }
                : null;
        };
        RenameInputField.prototype.acceptInput = function () {
            if (this._currentAcceptInput) {
                this._currentAcceptInput();
            }
        };
        RenameInputField.prototype.cancelInput = function () {
            if (this._currentCancelInput) {
                this._currentCancelInput();
            }
        };
        RenameInputField.prototype.getInput = function (where, value, selectionStart, selectionEnd) {
            var _this = this;
            this._position = { lineNumber: where.startLineNumber, column: where.startColumn };
            this._inputField.value = value;
            this._inputField.setAttribute('selectionStart', selectionStart.toString());
            this._inputField.setAttribute('selectionEnd', selectionEnd.toString());
            this._inputField.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
            var disposeOnDone = [], always;
            always = function () {
                lifecycle_1.dispose(disposeOnDone);
                _this._hide();
            };
            return new winjs_base_1.TPromise(function (c, e) {
                _this._currentCancelInput = function () {
                    _this._currentAcceptInput = null;
                    _this._currentCancelInput = null;
                    e(errors_1.canceled());
                    return true;
                };
                _this._currentAcceptInput = function () {
                    if (_this._inputField.value.trim().length === 0 || _this._inputField.value === value) {
                        // empty or whitespace only or not changed
                        _this._currentCancelInput();
                        return;
                    }
                    _this._currentAcceptInput = null;
                    _this._currentCancelInput = null;
                    c(_this._inputField.value);
                };
                var onCursorChanged = function () {
                    if (!range_1.Range.containsPosition(where, _this._editor.getPosition())) {
                        _this._currentCancelInput();
                    }
                };
                disposeOnDone.push(_this._editor.onDidChangeCursorSelection(onCursorChanged));
                disposeOnDone.push(_this._editor.onDidBlurEditor(_this._currentCancelInput));
                _this._show();
            }, this._currentCancelInput).then(function (newValue) {
                always();
                return newValue;
            }, function (err) {
                always();
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        RenameInputField.prototype._show = function () {
            var _this = this;
            this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber);
            this._visible = true;
            this._editor.layoutContentWidget(this);
            setTimeout(function () {
                _this._inputField.focus();
                _this._inputField.setSelectionRange(parseInt(_this._inputField.getAttribute('selectionStart')), parseInt(_this._inputField.getAttribute('selectionEnd')));
            }, 25);
        };
        RenameInputField.prototype._hide = function () {
            this._visible = false;
            this._editor.layoutContentWidget(this);
        };
        return RenameInputField;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = RenameInputField;
});

define(__m[309/*vs/nls!vs/editor/contrib/rename/common/rename*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/rename/common/rename", data); });
define(__m[310/*vs/nls!vs/editor/contrib/smartSelect/common/smartSelect*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/smartSelect/common/smartSelect", data); });
define(__m[311/*vs/nls!vs/editor/contrib/suggest/browser/suggestController*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/suggest/browser/suggestController", data); });
define(__m[312/*vs/nls!vs/editor/contrib/suggest/browser/suggestWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/suggest/browser/suggestWidget", data); });
define(__m[313/*vs/nls!vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode", data); });
define(__m[314/*vs/nls!vs/editor/contrib/zoneWidget/browser/peekViewWidget*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/editor/contrib/zoneWidget/browser/peekViewWidget", data); });
define(__m[315/*vs/nls!vs/platform/configuration/common/configurationRegistry*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/platform/configuration/common/configurationRegistry", data); });
define(__m[316/*vs/nls!vs/platform/extensions/common/extensionsRegistry*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/platform/extensions/common/extensionsRegistry", data); });
define(__m[317/*vs/nls!vs/platform/keybinding/common/abstractKeybindingService*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/platform/keybinding/common/abstractKeybindingService", data); });
define(__m[318/*vs/nls!vs/platform/message/common/message*/], __M([7/*vs/nls*/,8/*vs/nls!vs/editor/editor.main*/]), function(nls, data) { return nls.create("vs/platform/message/common/message", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[319/*vs/platform/contextview/browser/contextMenuHandler*/], __M([1/*require*/,0/*exports*/,33/*vs/base/browser/builder*/,3/*vs/base/common/lifecycle*/,34/*vs/base/browser/mouseEvent*/,50/*vs/base/common/actions*/,245/*vs/base/browser/ui/menu/menu*/,67/*vs/base/common/events*/,30/*vs/base/common/severity*/,419/*vs/css!vs/platform/contextview/browser/contextMenuHandler*/]), function (require, exports, builder_1, lifecycle_1, mouseEvent_1, actions_1, menu_1, events_1, severity_1) {
    'use strict';
    var ContextMenuHandler = (function () {
        function ContextMenuHandler(element, contextViewService, telemetryService, messageService) {
            var _this = this;
            this.setContainer(element);
            this.contextViewService = contextViewService;
            this.telemetryService = telemetryService;
            this.messageService = messageService;
            this.actionRunner = new actions_1.ActionRunner();
            this.menuContainerElement = null;
            this.toDispose = [];
            var hideViewOnRun = false;
            this.toDispose.push(this.actionRunner.addListener2(events_1.EventType.BEFORE_RUN, function (e) {
                if (_this.telemetryService) {
                    _this.telemetryService.publicLog('workbenchActionExecuted', { id: e.action.id, from: 'contextMenu' });
                }
                hideViewOnRun = !!e.retainActionItem;
                if (!hideViewOnRun) {
                    _this.contextViewService.hideContextView(false);
                }
            }));
            this.toDispose.push(this.actionRunner.addListener2(events_1.EventType.RUN, function (e) {
                if (hideViewOnRun) {
                    _this.contextViewService.hideContextView(false);
                }
                hideViewOnRun = false;
                if (e.error && _this.messageService) {
                    _this.messageService.show(severity_1.default.Error, e.error);
                }
            }));
        }
        ContextMenuHandler.prototype.setContainer = function (container) {
            var _this = this;
            if (this.$el) {
                this.$el.off(['click', 'mousedown']);
                this.$el = null;
            }
            if (container) {
                this.$el = builder_1.$(container);
                this.$el.on('mousedown', function (e) { return _this.onMouseDown(e); });
            }
        };
        ContextMenuHandler.prototype.showContextMenu = function (delegate) {
            var _this = this;
            delegate.getActions().done(function (actions) {
                _this.contextViewService.showContextView({
                    getAnchor: function () { return delegate.getAnchor(); },
                    canRelayout: false,
                    render: function (container) {
                        _this.menuContainerElement = container;
                        var className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';
                        if (className) {
                            container.className += ' ' + className;
                        }
                        var menu = new menu_1.Menu(container, actions, {
                            actionItemProvider: delegate.getActionItem,
                            context: delegate.getActionsContext ? delegate.getActionsContext() : null,
                            actionRunner: _this.actionRunner
                        });
                        var listener1 = menu.addListener2(events_1.EventType.CANCEL, function (e) {
                            _this.contextViewService.hideContextView(true);
                        });
                        var listener2 = menu.addListener2(events_1.EventType.BLUR, function (e) {
                            _this.contextViewService.hideContextView(true);
                        });
                        menu.focus();
                        return lifecycle_1.combinedDisposable([listener1, listener2, menu]);
                    },
                    onHide: function (didCancel) {
                        if (delegate.onHide) {
                            delegate.onHide(didCancel);
                        }
                        _this.menuContainerElement = null;
                    }
                });
            });
        };
        ContextMenuHandler.prototype.onMouseDown = function (e) {
            if (!this.menuContainerElement) {
                return;
            }
            var event = new mouseEvent_1.StandardMouseEvent(e);
            var element = event.target;
            while (element) {
                if (element === this.menuContainerElement) {
                    return;
                }
                element = element.parentElement;
            }
            this.contextViewService.hideContextView();
        };
        ContextMenuHandler.prototype.dispose = function () {
            this.setContainer(null);
        };
        return ContextMenuHandler;
    }());
    exports.ContextMenuHandler = ContextMenuHandler;
});

define(__m[320/*vs/platform/contextview/browser/contextMenuService*/], __M([1/*require*/,0/*exports*/,319/*vs/platform/contextview/browser/contextMenuHandler*/]), function (require, exports, contextMenuHandler_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuService = (function () {
        function ContextMenuService(container, telemetryService, messageService, contextViewService) {
            this.contextMenuHandler = new contextMenuHandler_1.ContextMenuHandler(container, contextViewService, telemetryService, messageService);
        }
        ContextMenuService.prototype.dispose = function () {
            this.contextMenuHandler.dispose();
        };
        ContextMenuService.prototype.setContainer = function (container) {
            this.contextMenuHandler.setContainer(container);
        };
        // ContextMenu
        ContextMenuService.prototype.showContextMenu = function (delegate) {
            this.contextMenuHandler.showContextMenu(delegate);
        };
        return ContextMenuService;
    }());
    exports.ContextMenuService = ContextMenuService;
});






define(__m[143/*vs/platform/instantiation/common/descriptors*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractDescriptor = (function () {
        function AbstractDescriptor(_staticArguments) {
            this._staticArguments = _staticArguments;
            // empty
        }
        AbstractDescriptor.prototype.appendStaticArguments = function (more) {
            this._staticArguments.push.apply(this._staticArguments, more);
        };
        AbstractDescriptor.prototype.staticArguments = function (nth) {
            if (isNaN(nth)) {
                return this._staticArguments.slice(0);
            }
            else {
                return this._staticArguments[nth];
            }
        };
        AbstractDescriptor.prototype._validate = function (type) {
            if (!type) {
                throw errors_1.illegalArgument('can not be falsy');
            }
        };
        return AbstractDescriptor;
    }());
    exports.AbstractDescriptor = AbstractDescriptor;
    var SyncDescriptor = (function (_super) {
        __extends(SyncDescriptor, _super);
        function SyncDescriptor(_ctor) {
            var staticArguments = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                staticArguments[_i - 1] = arguments[_i];
            }
            var _this = _super.call(this, staticArguments) || this;
            _this._ctor = _ctor;
            return _this;
        }
        Object.defineProperty(SyncDescriptor.prototype, "ctor", {
            get: function () {
                return this._ctor;
            },
            enumerable: true,
            configurable: true
        });
        SyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0, this._ctor].concat(allArgs)))();
        };
        return SyncDescriptor;
    }(AbstractDescriptor));
    exports.SyncDescriptor = SyncDescriptor;
    exports.createSyncDescriptor = function (ctor) {
        var staticArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            staticArguments[_i - 1] = arguments[_i];
        }
        return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0, ctor].concat(staticArguments)))();
    };
    var AsyncDescriptor = (function (_super) {
        __extends(AsyncDescriptor, _super);
        function AsyncDescriptor(_moduleName, _ctorName) {
            var staticArguments = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                staticArguments[_i - 2] = arguments[_i];
            }
            var _this = _super.call(this, staticArguments) || this;
            _this._moduleName = _moduleName;
            _this._ctorName = _ctorName;
            if (typeof _moduleName !== 'string') {
                throw new Error('Invalid AsyncDescriptor arguments, expected `moduleName` to be a string!');
            }
            return _this;
        }
        AsyncDescriptor.create = function (moduleName, ctorName) {
            return new AsyncDescriptor(moduleName, ctorName);
        };
        Object.defineProperty(AsyncDescriptor.prototype, "moduleName", {
            get: function () {
                return this._moduleName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AsyncDescriptor.prototype, "ctorName", {
            get: function () {
                return this._ctorName;
            },
            enumerable: true,
            configurable: true
        });
        AsyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (AsyncDescriptor.bind.apply(AsyncDescriptor, [void 0, this.moduleName, this.ctorName].concat(allArgs)))();
        };
        return AsyncDescriptor;
    }(AbstractDescriptor));
    exports.AsyncDescriptor = AsyncDescriptor;
});

define(__m[14/*vs/platform/instantiation/common/instantiation*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // ------ internal util
    var _util;
    (function (_util) {
        _util.serviceIds = new Map();
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        if (_util.serviceIds.has(serviceId)) {
            return _util.serviceIds.get(serviceId);
        }
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        _util.serviceIds.set(serviceId, id);
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

define(__m[52/*vs/editor/common/services/editorWorkerService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID_EDITOR_WORKER_SERVICE = 'editorWorkerService';
    exports.IEditorWorkerService = instantiation_1.createDecorator(exports.ID_EDITOR_WORKER_SERVICE);
});

define(__m[89/*vs/editor/common/services/modeService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModeService = instantiation_1.createDecorator('modeService');
});

define(__m[43/*vs/editor/common/services/modelService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModelService = instantiation_1.createDecorator('modelService');
});

define(__m[66/*vs/editor/common/services/resolverService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ITextModelResolverService = instantiation_1.createDecorator('textModelResolverService');
});

define(__m[78/*vs/editor/common/services/standaloneColorService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IStandaloneColorService = instantiation_1.createDecorator('standaloneColorService');
});







var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[328/*vs/editor/contrib/smartSelect/common/tokenSelectionSupport*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,43/*vs/editor/common/services/modelService*/,234/*vs/editor/contrib/smartSelect/common/tokenTree*/]), function (require, exports, winjs_base_1, range_1, modelService_1, tokenTree_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenSelectionSupport = (function () {
        function TokenSelectionSupport(modelService) {
            this._modelService = modelService;
        }
        TokenSelectionSupport.prototype.getRangesToPosition = function (resource, position) {
            return winjs_base_1.TPromise.as(this.getRangesToPositionSync(resource, position));
        };
        TokenSelectionSupport.prototype.getRangesToPositionSync = function (resource, position) {
            var model = this._modelService.getModel(resource), entries = [];
            if (model) {
                this._doGetRangesToPosition(model, position).forEach(function (range) {
                    entries.push({
                        type: void 0,
                        range: range
                    });
                });
            }
            return entries;
        };
        TokenSelectionSupport.prototype._doGetRangesToPosition = function (model, position) {
            var tree = tokenTree_1.build(model), node, lastRange;
            node = tokenTree_1.find(tree, position);
            var ranges = [];
            while (node) {
                if (!lastRange || !range_1.Range.equalsRange(lastRange, node.range)) {
                    ranges.push(node.range);
                }
                lastRange = node.range;
                node = node.parent;
            }
            ranges = ranges.reverse();
            return ranges;
        };
        return TokenSelectionSupport;
    }());
    TokenSelectionSupport = __decorate([
        __param(0, modelService_1.IModelService)
    ], TokenSelectionSupport);
    exports.TokenSelectionSupport = TokenSelectionSupport;
});

define(__m[22/*vs/platform/commands/common/commands*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,24/*vs/base/common/types*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, winjs_base_1, types_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ICommandService = instantiation_1.createDecorator('commandService');
    function isCommand(thing) {
        return typeof thing === 'object'
            && typeof thing.handler === 'function'
            && (!thing.description || typeof thing.description === 'object');
    }
    exports.CommandsRegistry = new (function () {
        function class_1() {
            this._commands = new Map();
        }
        class_1.prototype.registerCommand = function (id, commandOrDesc) {
            var _this = this;
            if (!commandOrDesc) {
                throw new Error("invalid command");
            }
            var command;
            if (!isCommand(commandOrDesc)) {
                // simple handler
                command = { handler: commandOrDesc };
            }
            else {
                var handler_1 = commandOrDesc.handler, description = commandOrDesc.description;
                if (description) {
                    // add argument validation if rich command metadata is provided
                    var constraints_1 = [];
                    for (var _i = 0, _a = description.args; _i < _a.length; _i++) {
                        var arg = _a[_i];
                        constraints_1.push(arg.constraint);
                    }
                    command = {
                        description: description,
                        handler: function (accessor) {
                            var args = [];
                            for (var _i = 1; _i < arguments.length; _i++) {
                                args[_i - 1] = arguments[_i];
                            }
                            types_1.validateConstraints(args, constraints_1);
                            return handler_1.apply(void 0, [accessor].concat(args));
                        }
                    };
                }
                else {
                    // add as simple handler
                    command = { handler: handler_1 };
                }
            }
            // find a place to store the command
            var commandOrArray = this._commands.get(id);
            if (commandOrArray === void 0) {
                this._commands.set(id, command);
            }
            else if (Array.isArray(commandOrArray)) {
                commandOrArray.unshift(command);
            }
            else {
                this._commands.set(id, [command, commandOrArray]);
            }
            return {
                dispose: function () {
                    var commandOrArray = _this._commands.get(id);
                    if (Array.isArray(commandOrArray)) {
                        // remove from array, remove array
                        // if last element removed
                        var idx = commandOrArray.indexOf(command);
                        if (idx >= 0) {
                            commandOrArray.splice(idx, 1);
                            if (commandOrArray.length === 0) {
                                _this._commands.delete(id);
                            }
                        }
                    }
                    else if (isCommand(commandOrArray)) {
                        // remove from map
                        _this._commands.delete(id);
                    }
                }
            };
        };
        class_1.prototype.getCommand = function (id) {
            var commandOrArray = this._commands.get(id);
            if (Array.isArray(commandOrArray)) {
                return commandOrArray[0];
            }
            else {
                return commandOrArray;
            }
        };
        class_1.prototype.getCommands = function () {
            var _this = this;
            var result = Object.create(null);
            this._commands.forEach(function (value, key) {
                result[key] = _this.getCommand(key);
            });
            return result;
        };
        return class_1;
    }());
    exports.NullCommandService = {
        _serviceBrand: undefined,
        executeCommand: function () {
            return winjs_base_1.TPromise.as(undefined);
        }
    };
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[330/*vs/editor/contrib/links/common/links*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/,22/*vs/platform/commands/common/commands*/,43/*vs/editor/common/services/modelService*/]), function (require, exports, errors_1, uri_1, winjs_base_1, range_1, modes_1, async_1, commands_1, modelService_1) {
    'use strict';
    var Link = (function () {
        function Link(link, provider) {
            this._link = link;
            this._provider = provider;
        }
        Object.defineProperty(Link.prototype, "range", {
            get: function () {
                return this._link.range;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Link.prototype, "url", {
            get: function () {
                return this._link.url;
            },
            enumerable: true,
            configurable: true
        });
        Link.prototype.resolve = function () {
            var _this = this;
            if (this._link.url) {
                try {
                    return winjs_base_1.TPromise.as(uri_1.default.parse(this._link.url));
                }
                catch (e) {
                    return winjs_base_1.TPromise.wrapError('invalid');
                }
            }
            if (typeof this._provider.resolveLink === 'function') {
                return async_1.asWinJsPromise(function (token) { return _this._provider.resolveLink(_this._link, token); }).then(function (value) {
                    _this._link = value || _this._link;
                    if (_this._link.url) {
                        // recurse
                        return _this.resolve();
                    }
                    return winjs_base_1.TPromise.wrapError('missing');
                });
            }
            return winjs_base_1.TPromise.wrapError('missing');
        };
        return Link;
    }());
    exports.Link = Link;
    function getLinks(model) {
        var links = [];
        // ask all providers for links in parallel
        var promises = modes_1.LinkProviderRegistry.ordered(model).reverse().map(function (provider) {
            return async_1.asWinJsPromise(function (token) { return provider.provideLinks(model, token); }).then(function (result) {
                if (Array.isArray(result)) {
                    var newLinks = result.map(function (link) { return new Link(link, provider); });
                    links = union(links, newLinks);
                }
            }, errors_1.onUnexpectedExternalError);
        });
        return winjs_base_1.TPromise.join(promises).then(function () {
            return links;
        });
    }
    exports.getLinks = getLinks;
    function union(oldLinks, newLinks) {
        // reunite oldLinks with newLinks and remove duplicates
        var result = [], oldIndex, oldLen, newIndex, newLen, oldLink, newLink, comparisonResult;
        for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {
            oldLink = oldLinks[oldIndex];
            newLink = newLinks[newIndex];
            if (range_1.Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
                // Remove the oldLink
                oldIndex++;
                continue;
            }
            comparisonResult = range_1.Range.compareRangesUsingStarts(oldLink.range, newLink.range);
            if (comparisonResult < 0) {
                // oldLink is before
                result.push(oldLink);
                oldIndex++;
            }
            else {
                // newLink is before
                result.push(newLink);
                newIndex++;
            }
        }
        for (; oldIndex < oldLen; oldIndex++) {
            result.push(oldLinks[oldIndex]);
        }
        for (; newIndex < newLen; newIndex++) {
            result.push(newLinks[newIndex]);
        }
        return result;
    }
    commands_1.CommandsRegistry.registerCommand('_executeLinkProvider', function (accessor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var uri = args[0];
        if (!(uri instanceof uri_1.default)) {
            return;
        }
        var model = accessor.get(modelService_1.IModelService).getModel(uri);
        if (!model) {
            return;
        }
        return getLinks(model);
    });
});















define(__m[59/*vs/platform/actions/common/actions*/], __M([1/*require*/,0/*exports*/,50/*vs/base/common/actions*/,6/*vs/base/common/winjs.base*/,143/*vs/platform/instantiation/common/descriptors*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/]), function (require, exports, actions_1, winjs_base_1, descriptors_1, instantiation_1, commands_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MenuId = (function () {
        function MenuId(_id) {
            this._id = _id;
        }
        Object.defineProperty(MenuId.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        return MenuId;
    }());
    MenuId.EditorTitle = new MenuId('1');
    MenuId.EditorTitleContext = new MenuId('2');
    MenuId.EditorContext = new MenuId('3');
    MenuId.ExplorerContext = new MenuId('4');
    MenuId.ProblemsPanelContext = new MenuId('5');
    MenuId.DebugVariablesContext = new MenuId('6');
    MenuId.DebugWatchContext = new MenuId('7');
    MenuId.DebugCallStackContext = new MenuId('8');
    MenuId.DebugBreakpointsContext = new MenuId('9');
    MenuId.DebugConsoleContext = new MenuId('10');
    MenuId.SCMTitle = new MenuId('11');
    MenuId.SCMResourceGroupContext = new MenuId('12');
    MenuId.SCMResourceContext = new MenuId('13');
    exports.MenuId = MenuId;
    exports.IMenuService = instantiation_1.createDecorator('menuService');
    exports.MenuRegistry = new (function () {
        function class_1() {
            this.commands = Object.create(null);
            this.menuItems = Object.create(null);
        }
        class_1.prototype.addCommand = function (command) {
            var old = this.commands[command.id];
            this.commands[command.id] = command;
            return old !== void 0;
        };
        class_1.prototype.getCommand = function (id) {
            return this.commands[id];
        };
        class_1.prototype.appendMenuItem = function (_a, item) {
            var id = _a.id;
            var array = this.menuItems[id];
            if (!array) {
                this.menuItems[id] = array = [item];
            }
            else {
                array.push(item);
            }
            return {
                dispose: function () {
                    var idx = array.indexOf(item);
                    if (idx >= 0) {
                        array.splice(idx, 1);
                    }
                }
            };
        };
        class_1.prototype.getMenuItems = function (_a) {
            var id = _a.id;
            return this.menuItems[id] || [];
        };
        return class_1;
    }());
    var ExecuteCommandAction = (function (_super) {
        __extends(ExecuteCommandAction, _super);
        function ExecuteCommandAction(id, label, _commandService) {
            var _this = _super.call(this, id, label) || this;
            _this._commandService = _commandService;
            return _this;
        }
        ExecuteCommandAction.prototype.run = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return (_a = this._commandService).executeCommand.apply(_a, [this.id].concat(args));
            var _a;
        };
        return ExecuteCommandAction;
    }(actions_1.Action));
    ExecuteCommandAction = __decorate([
        __param(2, commands_1.ICommandService)
    ], ExecuteCommandAction);
    exports.ExecuteCommandAction = ExecuteCommandAction;
    var MenuItemAction = (function (_super) {
        __extends(MenuItemAction, _super);
        function MenuItemAction(item, alt, arg, commandService) {
            var _this = _super.call(this, item.id, item.title, commandService) || this;
            _this._cssClass = item.iconClass;
            _this._enabled = true;
            _this._arg = arg;
            _this.item = item;
            _this.alt = alt ? new MenuItemAction(alt, undefined, arg, commandService) : undefined;
            return _this;
        }
        MenuItemAction.prototype.run = function () {
            return _super.prototype.run.call(this, this._arg);
        };
        return MenuItemAction;
    }(ExecuteCommandAction));
    MenuItemAction = __decorate([
        __param(3, commands_1.ICommandService)
    ], MenuItemAction);
    exports.MenuItemAction = MenuItemAction;
    var SyncActionDescriptor = (function () {
        function SyncActionDescriptor(ctor, id, label, keybindings, keybindingContext, keybindingWeight) {
            this._id = id;
            this._label = label;
            this._keybindings = keybindings;
            this._keybindingContext = keybindingContext;
            this._keybindingWeight = keybindingWeight;
            this._descriptor = descriptors_1.createSyncDescriptor(ctor, this._id, this._label);
        }
        Object.defineProperty(SyncActionDescriptor.prototype, "syncDescriptor", {
            get: function () {
                return this._descriptor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindings", {
            get: function () {
                return this._keybindings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindingContext", {
            get: function () {
                return this._keybindingContext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindingWeight", {
            get: function () {
                return this._keybindingWeight;
            },
            enumerable: true,
            configurable: true
        });
        return SyncActionDescriptor;
    }());
    exports.SyncActionDescriptor = SyncActionDescriptor;
    /**
     * A proxy for an action that needs to load code in order to confunction. Can be used from contributions to defer
     * module loading up to the point until the run method is being executed.
     */
    var DeferredAction = (function (_super) {
        __extends(DeferredAction, _super);
        function DeferredAction(_instantiationService, _descriptor, id, label, cssClass, enabled) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            var _this = _super.call(this, id, label, cssClass, enabled) || this;
            _this._instantiationService = _instantiationService;
            _this._descriptor = _descriptor;
            return _this;
        }
        Object.defineProperty(DeferredAction.prototype, "cachedAction", {
            get: function () {
                return this._cachedAction;
            },
            set: function (action) {
                this._cachedAction = action;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "id", {
            get: function () {
                if (this._cachedAction instanceof actions_1.Action) {
                    return this._cachedAction.id;
                }
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "label", {
            get: function () {
                if (this._cachedAction instanceof actions_1.Action) {
                    return this._cachedAction.label;
                }
                return this._label;
            },
            set: function (value) {
                if (this._cachedAction instanceof actions_1.Action) {
                    this._cachedAction.label = value;
                }
                else {
                    this._setLabel(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "class", {
            get: function () {
                if (this._cachedAction instanceof actions_1.Action) {
                    return this._cachedAction.class;
                }
                return this._cssClass;
            },
            set: function (value) {
                if (this._cachedAction instanceof actions_1.Action) {
                    this._cachedAction.class = value;
                }
                else {
                    this._setClass(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "enabled", {
            get: function () {
                if (this._cachedAction instanceof actions_1.Action) {
                    return this._cachedAction.enabled;
                }
                return this._enabled;
            },
            set: function (value) {
                if (this._cachedAction instanceof actions_1.Action) {
                    this._cachedAction.enabled = value;
                }
                else {
                    this._setEnabled(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "order", {
            get: function () {
                if (this._cachedAction instanceof actions_1.Action) {
                    return this._cachedAction.order;
                }
                return this._order;
            },
            set: function (order) {
                if (this._cachedAction instanceof actions_1.Action) {
                    this._cachedAction.order = order;
                }
                else {
                    this._order = order;
                }
            },
            enumerable: true,
            configurable: true
        });
        DeferredAction.prototype.run = function (event) {
            if (this._cachedAction) {
                return this._cachedAction.run(event);
            }
            return this._createAction().then(function (action) {
                return action.run(event);
            });
        };
        DeferredAction.prototype._createAction = function () {
            var _this = this;
            var promise = winjs_base_1.TPromise.as(undefined);
            return promise.then(function () {
                return _this._instantiationService.createInstance(_this._descriptor);
            }).then(function (action) {
                if (action instanceof actions_1.Action) {
                    _this._cachedAction = action;
                    // Pipe events from the instantated action through this deferred action
                    _this._emitterUnbind = action.onDidChange(function (e) { return _this._onDidChange.fire(e); });
                }
                else {
                    throw new Error('Action must be an instanceof Base Action');
                }
                return action;
            });
        };
        DeferredAction.prototype.dispose = function () {
            if (this._emitterUnbind) {
                this._emitterUnbind.dispose();
            }
            if (this._cachedAction) {
                this._cachedAction.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        return DeferredAction;
    }(actions_1.Action));
    exports.DeferredAction = DeferredAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[56/*vs/platform/configuration/common/configuration*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    "use strict";
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    var ConfigurationSource;
    (function (ConfigurationSource) {
        ConfigurationSource[ConfigurationSource["Default"] = 1] = "Default";
        ConfigurationSource[ConfigurationSource["User"] = 2] = "User";
        ConfigurationSource[ConfigurationSource["Workspace"] = 3] = "Workspace";
    })(ConfigurationSource = exports.ConfigurationSource || (exports.ConfigurationSource = {}));
    /**
     * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)
     */
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                current = current[path[i]];
                if (typeof current === 'undefined' || current === null) {
                    return undefined;
                }
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
});






define(__m[18/*vs/platform/contextkey/common/contextkey*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextKeyExprType;
    (function (ContextKeyExprType) {
        ContextKeyExprType[ContextKeyExprType["Defined"] = 1] = "Defined";
        ContextKeyExprType[ContextKeyExprType["Not"] = 2] = "Not";
        ContextKeyExprType[ContextKeyExprType["Equals"] = 3] = "Equals";
        ContextKeyExprType[ContextKeyExprType["NotEquals"] = 4] = "NotEquals";
        ContextKeyExprType[ContextKeyExprType["And"] = 5] = "And";
    })(ContextKeyExprType = exports.ContextKeyExprType || (exports.ContextKeyExprType = {}));
    var ContextKeyExpr = (function () {
        function ContextKeyExpr() {
        }
        ContextKeyExpr.has = function (key) {
            return new ContextKeyDefinedExpr(key);
        };
        ContextKeyExpr.equals = function (key, value) {
            return new ContextKeyEqualsExpr(key, value);
        };
        ContextKeyExpr.notEquals = function (key, value) {
            return new ContextKeyNotEqualsExpr(key, value);
        };
        ContextKeyExpr.not = function (key) {
            return new ContextKeyNotExpr(key);
        };
        ContextKeyExpr.and = function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i] = arguments[_i];
            }
            return new ContextKeyAndExpr(expr);
        };
        ContextKeyExpr.deserialize = function (serialized) {
            var _this = this;
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new ContextKeyAndExpr(pieces.map(function (p) { return _this._deserializeOne(p); }));
            return result.normalize();
        };
        ContextKeyExpr._deserializeOne = function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new ContextKeyNotEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new ContextKeyEqualsExpr(pieces[0].trim(), this._deserializeValue(pieces[1]));
            }
            if (/^\!\s*/.test(serializedOne)) {
                return new ContextKeyNotExpr(serializedOne.substr(1).trim());
            }
            return new ContextKeyDefinedExpr(serializedOne);
        };
        ContextKeyExpr._deserializeValue = function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        };
        return ContextKeyExpr;
    }());
    exports.ContextKeyExpr = ContextKeyExpr;
    function cmp(a, b) {
        var aType = a.getType();
        var bType = b.getType();
        if (aType !== bType) {
            return aType - bType;
        }
        switch (aType) {
            case ContextKeyExprType.Defined:
                return a.cmp(b);
            case ContextKeyExprType.Not:
                return a.cmp(b);
            case ContextKeyExprType.Equals:
                return a.cmp(b);
            case ContextKeyExprType.NotEquals:
                return a.cmp(b);
            default:
                throw new Error('Unknown ContextKeyExpr!');
        }
    }
    var ContextKeyDefinedExpr = (function () {
        function ContextKeyDefinedExpr(key) {
            this.key = key;
        }
        ContextKeyDefinedExpr.prototype.getType = function () {
            return ContextKeyExprType.Defined;
        };
        ContextKeyDefinedExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyDefinedExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyDefinedExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyDefinedExpr.prototype.evaluate = function (context) {
            return (!!context[this.key]);
        };
        ContextKeyDefinedExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyDefinedExpr.prototype.serialize = function () {
            return this.key;
        };
        ContextKeyDefinedExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyDefinedExpr;
    }());
    exports.ContextKeyDefinedExpr = ContextKeyDefinedExpr;
    var ContextKeyEqualsExpr = (function () {
        function ContextKeyEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.Equals;
        };
        ContextKeyEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context[this.key] == this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyDefinedExpr(this.key);
                }
                return new ContextKeyNotExpr(this.key);
            }
            return this;
        };
        ContextKeyEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        ContextKeyEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyEqualsExpr;
    }());
    exports.ContextKeyEqualsExpr = ContextKeyEqualsExpr;
    var ContextKeyNotEqualsExpr = (function () {
        function ContextKeyNotEqualsExpr(key, value) {
            this.key = key;
            this.value = value;
        }
        ContextKeyNotEqualsExpr.prototype.getType = function () {
            return ContextKeyExprType.NotEquals;
        };
        ContextKeyNotEqualsExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotEqualsExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotEqualsExpr) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        ContextKeyNotEqualsExpr.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context[this.key] != this.value);
            /* tslint:enable:triple-equals */
        };
        ContextKeyNotEqualsExpr.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new ContextKeyNotExpr(this.key);
                }
                return new ContextKeyDefinedExpr(this.key);
            }
            return this;
        };
        ContextKeyNotEqualsExpr.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        ContextKeyNotEqualsExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotEqualsExpr;
    }());
    exports.ContextKeyNotEqualsExpr = ContextKeyNotEqualsExpr;
    var ContextKeyNotExpr = (function () {
        function ContextKeyNotExpr(key) {
            this.key = key;
        }
        ContextKeyNotExpr.prototype.getType = function () {
            return ContextKeyExprType.Not;
        };
        ContextKeyNotExpr.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        ContextKeyNotExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyNotExpr) {
                return (this.key === other.key);
            }
            return false;
        };
        ContextKeyNotExpr.prototype.evaluate = function (context) {
            return (!context[this.key]);
        };
        ContextKeyNotExpr.prototype.normalize = function () {
            return this;
        };
        ContextKeyNotExpr.prototype.serialize = function () {
            return '!' + this.key;
        };
        ContextKeyNotExpr.prototype.keys = function () {
            return [this.key];
        };
        return ContextKeyNotExpr;
    }());
    exports.ContextKeyNotExpr = ContextKeyNotExpr;
    var ContextKeyAndExpr = (function () {
        function ContextKeyAndExpr(expr) {
            this.expr = ContextKeyAndExpr._normalizeArr(expr);
        }
        ContextKeyAndExpr.prototype.getType = function () {
            return ContextKeyExprType.And;
        };
        ContextKeyAndExpr.prototype.equals = function (other) {
            if (other instanceof ContextKeyAndExpr) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (var i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
        };
        ContextKeyAndExpr.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        ContextKeyAndExpr._normalizeArr = function (arr) {
            var expr = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var e = arr[i];
                    if (!e) {
                        continue;
                    }
                    e = e.normalize();
                    if (!e) {
                        continue;
                    }
                    if (e instanceof ContextKeyAndExpr) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                expr.sort(cmp);
            }
            return expr;
        };
        ContextKeyAndExpr.prototype.normalize = function () {
            if (this.expr.length === 0) {
                return null;
            }
            if (this.expr.length === 1) {
                return this.expr[0];
            }
            return this;
        };
        ContextKeyAndExpr.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                return this.normalize().serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        ContextKeyAndExpr.prototype.keys = function () {
            var result = [];
            for (var _i = 0, _a = this.expr; _i < _a.length; _i++) {
                var expr = _a[_i];
                result.push.apply(result, expr.keys());
            }
            return result;
        };
        return ContextKeyAndExpr;
    }());
    exports.ContextKeyAndExpr = ContextKeyAndExpr;
    var RawContextKey = (function (_super) {
        __extends(RawContextKey, _super);
        function RawContextKey(key, defaultValue) {
            var _this = _super.call(this, key) || this;
            _this._defaultValue = defaultValue;
            return _this;
        }
        RawContextKey.prototype.bindTo = function (target) {
            return target.createKey(this.key, this._defaultValue);
        };
        RawContextKey.prototype.getValue = function (target) {
            return target.getContextKeyValue(this.key);
        };
        RawContextKey.prototype.toNegated = function () {
            return ContextKeyExpr.not(this.key);
        };
        RawContextKey.prototype.isEqualTo = function (value) {
            return ContextKeyExpr.equals(this.key, value);
        };
        return RawContextKey;
    }(ContextKeyDefinedExpr));
    exports.RawContextKey = RawContextKey;
    exports.IContextKeyService = instantiation_1.createDecorator('contextKeyService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});















define(__m[161/*vs/editor/common/editorAction*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,14/*vs/platform/instantiation/common/instantiation*/,18/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, winjs_base_1, instantiation_1, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractInternalEditorAction = (function () {
        function AbstractInternalEditorAction(id, label, alias, editor) {
            this.id = id;
            this.label = label;
            this.alias = alias;
            this._editor = editor;
        }
        return AbstractInternalEditorAction;
    }());
    exports.AbstractInternalEditorAction = AbstractInternalEditorAction;
    var InternalEditorAction = (function (_super) {
        __extends(InternalEditorAction, _super);
        function InternalEditorAction(actual, editor, instantiationService, contextKeyService) {
            var _this = _super.call(this, actual.id, actual.label, actual.alias, editor) || this;
            _this._actual = actual;
            _this._instantiationService = instantiationService;
            _this._contextKeyService = contextKeyService;
            return _this;
        }
        InternalEditorAction.prototype.isSupported = function () {
            return this._contextKeyService.contextMatchesRules(this._actual.precondition);
        };
        InternalEditorAction.prototype.run = function () {
            var _this = this;
            if (!this.isSupported()) {
                return winjs_base_1.TPromise.as(void 0);
            }
            return this._instantiationService.invokeFunction(function (accessor) {
                return winjs_base_1.TPromise.as(_this._actual.runEditorCommand(accessor, _this._editor, null));
            });
        };
        return InternalEditorAction;
    }(AbstractInternalEditorAction));
    InternalEditorAction = __decorate([
        __param(2, instantiation_1.IInstantiationService),
        __param(3, contextkey_1.IContextKeyService)
    ], InternalEditorAction);
    exports.InternalEditorAction = InternalEditorAction;
    var DynamicEditorAction = (function (_super) {
        __extends(DynamicEditorAction, _super);
        function DynamicEditorAction(descriptor, editor) {
            var _this = _super.call(this, descriptor.id, descriptor.label, descriptor.label, editor) || this;
            _this._run = descriptor.run;
            return _this;
        }
        DynamicEditorAction.prototype.isSupported = function () {
            return true;
        };
        DynamicEditorAction.prototype.run = function () {
            return winjs_base_1.TPromise.as(this._run(this._editor));
        };
        return DynamicEditorAction;
    }(AbstractInternalEditorAction));
    exports.DynamicEditorAction = DynamicEditorAction;
});

define(__m[2/*vs/editor/common/editorCommon*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/types*/,18/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, types, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Describes how to indent wrapped lines.
     */
    var WrappingIndent;
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    })(WrappingIndent = exports.WrappingIndent || (exports.WrappingIndent = {}));
    var InternalEditorScrollbarOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorScrollbarOptions(source) {
            this.arrowSize = source.arrowSize | 0;
            this.vertical = source.vertical | 0;
            this.horizontal = source.horizontal | 0;
            this.useShadows = Boolean(source.useShadows);
            this.verticalHasArrows = Boolean(source.verticalHasArrows);
            this.horizontalHasArrows = Boolean(source.horizontalHasArrows);
            this.handleMouseWheel = Boolean(source.handleMouseWheel);
            this.horizontalScrollbarSize = source.horizontalScrollbarSize | 0;
            this.horizontalSliderSize = source.horizontalSliderSize | 0;
            this.verticalScrollbarSize = source.verticalScrollbarSize | 0;
            this.verticalSliderSize = source.verticalSliderSize | 0;
            this.mouseWheelScrollSensitivity = Number(source.mouseWheelScrollSensitivity);
        }
        /**
         * @internal
         */
        InternalEditorScrollbarOptions.prototype.equals = function (other) {
            return (this.arrowSize === other.arrowSize
                && this.vertical === other.vertical
                && this.horizontal === other.horizontal
                && this.useShadows === other.useShadows
                && this.verticalHasArrows === other.verticalHasArrows
                && this.horizontalHasArrows === other.horizontalHasArrows
                && this.handleMouseWheel === other.handleMouseWheel
                && this.horizontalScrollbarSize === other.horizontalScrollbarSize
                && this.horizontalSliderSize === other.horizontalSliderSize
                && this.verticalScrollbarSize === other.verticalScrollbarSize
                && this.verticalSliderSize === other.verticalSliderSize
                && this.mouseWheelScrollSensitivity === other.mouseWheelScrollSensitivity);
        };
        /**
         * @internal
         */
        InternalEditorScrollbarOptions.prototype.clone = function () {
            return new InternalEditorScrollbarOptions(this);
        };
        return InternalEditorScrollbarOptions;
    }());
    exports.InternalEditorScrollbarOptions = InternalEditorScrollbarOptions;
    var EditorWrappingInfo = (function () {
        /**
         * @internal
         */
        function EditorWrappingInfo(source) {
            this.isViewportWrapping = Boolean(source.isViewportWrapping);
            this.wrappingColumn = source.wrappingColumn | 0;
            this.wrappingIndent = source.wrappingIndent | 0;
            this.wordWrapBreakBeforeCharacters = String(source.wordWrapBreakBeforeCharacters);
            this.wordWrapBreakAfterCharacters = String(source.wordWrapBreakAfterCharacters);
            this.wordWrapBreakObtrusiveCharacters = String(source.wordWrapBreakObtrusiveCharacters);
        }
        /**
         * @internal
         */
        EditorWrappingInfo.prototype.equals = function (other) {
            return (this.isViewportWrapping === other.isViewportWrapping
                && this.wrappingColumn === other.wrappingColumn
                && this.wrappingIndent === other.wrappingIndent
                && this.wordWrapBreakBeforeCharacters === other.wordWrapBreakBeforeCharacters
                && this.wordWrapBreakAfterCharacters === other.wordWrapBreakAfterCharacters
                && this.wordWrapBreakObtrusiveCharacters === other.wordWrapBreakObtrusiveCharacters);
        };
        /**
         * @internal
         */
        EditorWrappingInfo.prototype.clone = function () {
            return new EditorWrappingInfo(this);
        };
        return EditorWrappingInfo;
    }());
    exports.EditorWrappingInfo = EditorWrappingInfo;
    var InternalEditorViewOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorViewOptions(source) {
            this.theme = String(source.theme);
            this.canUseTranslate3d = Boolean(source.canUseTranslate3d);
            this.experimentalScreenReader = Boolean(source.experimentalScreenReader);
            this.rulers = InternalEditorViewOptions._toSortedIntegerArray(source.rulers);
            this.ariaLabel = String(source.ariaLabel);
            this.renderLineNumbers = Boolean(source.renderLineNumbers);
            this.renderCustomLineNumbers = source.renderCustomLineNumbers;
            this.renderRelativeLineNumbers = Boolean(source.renderRelativeLineNumbers);
            this.selectOnLineNumbers = Boolean(source.selectOnLineNumbers);
            this.glyphMargin = Boolean(source.glyphMargin);
            this.revealHorizontalRightPadding = source.revealHorizontalRightPadding | 0;
            this.roundedSelection = Boolean(source.roundedSelection);
            this.overviewRulerLanes = source.overviewRulerLanes | 0;
            this.cursorBlinking = source.cursorBlinking | 0;
            this.mouseWheelZoom = Boolean(source.mouseWheelZoom);
            this.cursorStyle = source.cursorStyle | 0;
            this.hideCursorInOverviewRuler = Boolean(source.hideCursorInOverviewRuler);
            this.scrollBeyondLastLine = Boolean(source.scrollBeyondLastLine);
            this.editorClassName = String(source.editorClassName);
            this.stopRenderingLineAfter = source.stopRenderingLineAfter | 0;
            this.renderWhitespace = source.renderWhitespace;
            this.renderControlCharacters = Boolean(source.renderControlCharacters);
            this.renderIndentGuides = Boolean(source.renderIndentGuides);
            this.renderLineHighlight = source.renderLineHighlight;
            this.scrollbar = source.scrollbar.clone();
            this.fixedOverflowWidgets = Boolean(source.fixedOverflowWidgets);
        }
        InternalEditorViewOptions._toSortedIntegerArray = function (source) {
            if (!Array.isArray(source)) {
                return [];
            }
            var arrSource = source;
            var result = arrSource.map(function (el) {
                var r = parseInt(el, 10);
                if (isNaN(r)) {
                    return 0;
                }
                return r;
            });
            result.sort();
            return result;
        };
        InternalEditorViewOptions._numberArraysEqual = function (a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.equals = function (other) {
            return (this.theme === other.theme
                && this.canUseTranslate3d === other.canUseTranslate3d
                && this.experimentalScreenReader === other.experimentalScreenReader
                && InternalEditorViewOptions._numberArraysEqual(this.rulers, other.rulers)
                && this.ariaLabel === other.ariaLabel
                && this.renderLineNumbers === other.renderLineNumbers
                && this.renderCustomLineNumbers === other.renderCustomLineNumbers
                && this.renderRelativeLineNumbers === other.renderRelativeLineNumbers
                && this.selectOnLineNumbers === other.selectOnLineNumbers
                && this.glyphMargin === other.glyphMargin
                && this.revealHorizontalRightPadding === other.revealHorizontalRightPadding
                && this.roundedSelection === other.roundedSelection
                && this.overviewRulerLanes === other.overviewRulerLanes
                && this.cursorBlinking === other.cursorBlinking
                && this.mouseWheelZoom === other.mouseWheelZoom
                && this.cursorStyle === other.cursorStyle
                && this.hideCursorInOverviewRuler === other.hideCursorInOverviewRuler
                && this.scrollBeyondLastLine === other.scrollBeyondLastLine
                && this.editorClassName === other.editorClassName
                && this.stopRenderingLineAfter === other.stopRenderingLineAfter
                && this.renderWhitespace === other.renderWhitespace
                && this.renderControlCharacters === other.renderControlCharacters
                && this.renderIndentGuides === other.renderIndentGuides
                && this.renderLineHighlight === other.renderLineHighlight
                && this.scrollbar.equals(other.scrollbar)
                && this.fixedOverflowWidgets === other.fixedOverflowWidgets);
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                theme: this.theme !== newOpts.theme,
                canUseTranslate3d: this.canUseTranslate3d !== newOpts.canUseTranslate3d,
                experimentalScreenReader: this.experimentalScreenReader !== newOpts.experimentalScreenReader,
                rulers: (!InternalEditorViewOptions._numberArraysEqual(this.rulers, newOpts.rulers)),
                ariaLabel: this.ariaLabel !== newOpts.ariaLabel,
                renderLineNumbers: this.renderLineNumbers !== newOpts.renderLineNumbers,
                renderCustomLineNumbers: this.renderCustomLineNumbers !== newOpts.renderCustomLineNumbers,
                renderRelativeLineNumbers: this.renderRelativeLineNumbers !== newOpts.renderRelativeLineNumbers,
                selectOnLineNumbers: this.selectOnLineNumbers !== newOpts.selectOnLineNumbers,
                glyphMargin: this.glyphMargin !== newOpts.glyphMargin,
                revealHorizontalRightPadding: this.revealHorizontalRightPadding !== newOpts.revealHorizontalRightPadding,
                roundedSelection: this.roundedSelection !== newOpts.roundedSelection,
                overviewRulerLanes: this.overviewRulerLanes !== newOpts.overviewRulerLanes,
                cursorBlinking: this.cursorBlinking !== newOpts.cursorBlinking,
                mouseWheelZoom: this.mouseWheelZoom !== newOpts.mouseWheelZoom,
                cursorStyle: this.cursorStyle !== newOpts.cursorStyle,
                hideCursorInOverviewRuler: this.hideCursorInOverviewRuler !== newOpts.hideCursorInOverviewRuler,
                scrollBeyondLastLine: this.scrollBeyondLastLine !== newOpts.scrollBeyondLastLine,
                editorClassName: this.editorClassName !== newOpts.editorClassName,
                stopRenderingLineAfter: this.stopRenderingLineAfter !== newOpts.stopRenderingLineAfter,
                renderWhitespace: this.renderWhitespace !== newOpts.renderWhitespace,
                renderControlCharacters: this.renderControlCharacters !== newOpts.renderControlCharacters,
                renderIndentGuides: this.renderIndentGuides !== newOpts.renderIndentGuides,
                renderLineHighlight: this.renderLineHighlight !== newOpts.renderLineHighlight,
                scrollbar: (!this.scrollbar.equals(newOpts.scrollbar)),
                fixedOverflowWidgets: this.fixedOverflowWidgets !== newOpts.fixedOverflowWidgets
            };
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.clone = function () {
            return new InternalEditorViewOptions(this);
        };
        return InternalEditorViewOptions;
    }());
    exports.InternalEditorViewOptions = InternalEditorViewOptions;
    var EditorContribOptions = (function () {
        /**
         * @internal
         */
        function EditorContribOptions(source) {
            this.selectionClipboard = Boolean(source.selectionClipboard);
            this.hover = Boolean(source.hover);
            this.contextmenu = Boolean(source.contextmenu);
            this.quickSuggestions = Boolean(source.quickSuggestions);
            this.quickSuggestionsDelay = source.quickSuggestionsDelay || 0;
            this.parameterHints = Boolean(source.parameterHints);
            this.iconsInSuggestions = Boolean(source.iconsInSuggestions);
            this.formatOnType = Boolean(source.formatOnType);
            this.suggestOnTriggerCharacters = Boolean(source.suggestOnTriggerCharacters);
            this.acceptSuggestionOnEnter = Boolean(source.acceptSuggestionOnEnter);
            this.acceptSuggestionOnCommitCharacter = Boolean(source.acceptSuggestionOnCommitCharacter);
            this.snippetSuggestions = source.snippetSuggestions;
            this.emptySelectionClipboard = source.emptySelectionClipboard;
            this.tabCompletion = source.tabCompletion;
            this.wordBasedSuggestions = source.wordBasedSuggestions;
            this.suggestFontSize = source.suggestFontSize;
            this.suggestLineHeight = source.suggestLineHeight;
            this.selectionHighlight = Boolean(source.selectionHighlight);
            this.codeLens = Boolean(source.codeLens);
            this.folding = Boolean(source.folding);
        }
        /**
         * @internal
         */
        EditorContribOptions.prototype.equals = function (other) {
            return (this.selectionClipboard === other.selectionClipboard
                && this.hover === other.hover
                && this.contextmenu === other.contextmenu
                && this.quickSuggestions === other.quickSuggestions
                && this.quickSuggestionsDelay === other.quickSuggestionsDelay
                && this.parameterHints === other.parameterHints
                && this.iconsInSuggestions === other.iconsInSuggestions
                && this.formatOnType === other.formatOnType
                && this.suggestOnTriggerCharacters === other.suggestOnTriggerCharacters
                && this.acceptSuggestionOnEnter === other.acceptSuggestionOnEnter
                && this.acceptSuggestionOnCommitCharacter === other.acceptSuggestionOnCommitCharacter
                && this.snippetSuggestions === other.snippetSuggestions
                && this.emptySelectionClipboard === other.emptySelectionClipboard
                && this.tabCompletion === other.tabCompletion
                && this.wordBasedSuggestions === other.wordBasedSuggestions
                && this.suggestFontSize === other.suggestFontSize
                && this.suggestLineHeight === other.suggestLineHeight
                && this.selectionHighlight === other.selectionHighlight
                && this.codeLens === other.codeLens
                && this.folding === other.folding);
        };
        /**
         * @internal
         */
        EditorContribOptions.prototype.clone = function () {
            return new EditorContribOptions(this);
        };
        return EditorContribOptions;
    }());
    exports.EditorContribOptions = EditorContribOptions;
    /**
     * Internal configuration options (transformed or computed) for the editor.
     */
    var InternalEditorOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorOptions(source) {
            this.lineHeight = source.lineHeight | 0;
            this.readOnly = Boolean(source.readOnly);
            this.wordSeparators = String(source.wordSeparators);
            this.autoClosingBrackets = Boolean(source.autoClosingBrackets);
            this.useTabStops = Boolean(source.useTabStops);
            this.tabFocusMode = Boolean(source.tabFocusMode);
            this.layoutInfo = source.layoutInfo.clone();
            this.fontInfo = source.fontInfo.clone();
            this.viewInfo = source.viewInfo.clone();
            this.wrappingInfo = source.wrappingInfo.clone();
            this.contribInfo = source.contribInfo.clone();
        }
        /**
         * @internal
         */
        InternalEditorOptions.prototype.equals = function (other) {
            return (this.lineHeight === other.lineHeight
                && this.readOnly === other.readOnly
                && this.wordSeparators === other.wordSeparators
                && this.autoClosingBrackets === other.autoClosingBrackets
                && this.useTabStops === other.useTabStops
                && this.tabFocusMode === other.tabFocusMode
                && this.layoutInfo.equals(other.layoutInfo)
                && this.fontInfo.equals(other.fontInfo)
                && this.viewInfo.equals(other.viewInfo)
                && this.wrappingInfo.equals(other.wrappingInfo)
                && this.contribInfo.equals(other.contribInfo));
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                lineHeight: (this.lineHeight !== newOpts.lineHeight),
                readOnly: (this.readOnly !== newOpts.readOnly),
                wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
                autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
                useTabStops: (this.useTabStops !== newOpts.useTabStops),
                tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
                layoutInfo: (!this.layoutInfo.equals(newOpts.layoutInfo)),
                fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
                viewInfo: this.viewInfo.createChangeEvent(newOpts.viewInfo),
                wrappingInfo: (!this.wrappingInfo.equals(newOpts.wrappingInfo)),
                contribInfo: (!this.contribInfo.equals(newOpts.contribInfo)),
            };
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.clone = function () {
            return new InternalEditorOptions(this);
        };
        return InternalEditorOptions;
    }());
    exports.InternalEditorOptions = InternalEditorOptions;
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    var OverviewRulerLane;
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(OverviewRulerLane = exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    /**
     * End of line character preference.
     */
    var EndOfLinePreference;
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(EndOfLinePreference = exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    /**
     * The default end of line to use when instantiating models.
     */
    var DefaultEndOfLine;
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(DefaultEndOfLine = exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    /**
     * End of line character preference.
     */
    var EndOfLineSequence;
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(EndOfLineSequence = exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var TextModelResolvedOptions = (function () {
        /**
         * @internal
         */
        function TextModelResolvedOptions(src) {
            this.tabSize = src.tabSize | 0;
            this.insertSpaces = Boolean(src.insertSpaces);
            this.defaultEOL = src.defaultEOL | 0;
            this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
        }
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.equals = function (other) {
            return (this.tabSize === other.tabSize
                && this.insertSpaces === other.insertSpaces
                && this.defaultEOL === other.defaultEOL
                && this.trimAutoWhitespace === other.trimAutoWhitespace);
        };
        /**
         * @internal
         */
        TextModelResolvedOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                tabSize: this.tabSize !== newOpts.tabSize,
                insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
                trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
            };
        };
        return TextModelResolvedOptions;
    }());
    exports.TextModelResolvedOptions = TextModelResolvedOptions;
    var FindMatch = (function () {
        /**
         * @internal
         */
        function FindMatch(range, matches) {
            this.range = range;
            this.matches = matches;
        }
        return FindMatch;
    }());
    exports.FindMatch = FindMatch;
    /**
     * Describes the behaviour of decorations when typing/editing near their edges.
     */
    var TrackedRangeStickiness;
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(TrackedRangeStickiness = exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    /**
     * Describes the reason the cursor has changed its position.
     */
    var CursorChangeReason;
    (function (CursorChangeReason) {
        /**
         * Unknown or not set.
         */
        CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
        /**
         * A `model.setValue()` was called.
         */
        CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
        /**
         * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
         */
        CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
        /**
         * There was an explicit user gesture.
         */
        CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
        /**
         * There was a Paste.
         */
        CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
        /**
         * There was an Undo.
         */
        CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
        /**
         * There was a Redo.
         */
        CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
    })(CursorChangeReason = exports.CursorChangeReason || (exports.CursorChangeReason = {}));
    /**
     * @internal
     */
    var VerticalRevealType;
    (function (VerticalRevealType) {
        VerticalRevealType[VerticalRevealType["Simple"] = 0] = "Simple";
        VerticalRevealType[VerticalRevealType["Center"] = 1] = "Center";
        VerticalRevealType[VerticalRevealType["CenterIfOutsideViewport"] = 2] = "CenterIfOutsideViewport";
        VerticalRevealType[VerticalRevealType["Top"] = 3] = "Top";
        VerticalRevealType[VerticalRevealType["Bottom"] = 4] = "Bottom";
    })(VerticalRevealType = exports.VerticalRevealType || (exports.VerticalRevealType = {}));
    /**
     * A description for the overview ruler position.
     */
    var OverviewRulerPosition = (function () {
        /**
         * @internal
         */
        function OverviewRulerPosition(source) {
            this.width = source.width | 0;
            this.height = source.height | 0;
            this.top = source.top | 0;
            this.right = source.right | 0;
        }
        /**
         * @internal
         */
        OverviewRulerPosition.prototype.equals = function (other) {
            return (this.width === other.width
                && this.height === other.height
                && this.top === other.top
                && this.right === other.right);
        };
        /**
         * @internal
         */
        OverviewRulerPosition.prototype.clone = function () {
            return new OverviewRulerPosition(this);
        };
        return OverviewRulerPosition;
    }());
    exports.OverviewRulerPosition = OverviewRulerPosition;
    /**
     * The internal layout details of the editor.
     */
    var EditorLayoutInfo = (function () {
        /**
         * @internal
         */
        function EditorLayoutInfo(source) {
            this.width = source.width | 0;
            this.height = source.height | 0;
            this.glyphMarginLeft = source.glyphMarginLeft | 0;
            this.glyphMarginWidth = source.glyphMarginWidth | 0;
            this.glyphMarginHeight = source.glyphMarginHeight | 0;
            this.lineNumbersLeft = source.lineNumbersLeft | 0;
            this.lineNumbersWidth = source.lineNumbersWidth | 0;
            this.lineNumbersHeight = source.lineNumbersHeight | 0;
            this.decorationsLeft = source.decorationsLeft | 0;
            this.decorationsWidth = source.decorationsWidth | 0;
            this.decorationsHeight = source.decorationsHeight | 0;
            this.contentLeft = source.contentLeft | 0;
            this.contentWidth = source.contentWidth | 0;
            this.contentHeight = source.contentHeight | 0;
            this.verticalScrollbarWidth = source.verticalScrollbarWidth | 0;
            this.horizontalScrollbarHeight = source.horizontalScrollbarHeight | 0;
            this.overviewRuler = source.overviewRuler.clone();
        }
        /**
         * @internal
         */
        EditorLayoutInfo.prototype.equals = function (other) {
            return (this.width === other.width
                && this.height === other.height
                && this.glyphMarginLeft === other.glyphMarginLeft
                && this.glyphMarginWidth === other.glyphMarginWidth
                && this.glyphMarginHeight === other.glyphMarginHeight
                && this.lineNumbersLeft === other.lineNumbersLeft
                && this.lineNumbersWidth === other.lineNumbersWidth
                && this.lineNumbersHeight === other.lineNumbersHeight
                && this.decorationsLeft === other.decorationsLeft
                && this.decorationsWidth === other.decorationsWidth
                && this.decorationsHeight === other.decorationsHeight
                && this.contentLeft === other.contentLeft
                && this.contentWidth === other.contentWidth
                && this.contentHeight === other.contentHeight
                && this.verticalScrollbarWidth === other.verticalScrollbarWidth
                && this.horizontalScrollbarHeight === other.horizontalScrollbarHeight
                && this.overviewRuler.equals(other.overviewRuler));
        };
        /**
         * @internal
         */
        EditorLayoutInfo.prototype.clone = function () {
            return new EditorLayoutInfo(this);
        };
        return EditorLayoutInfo;
    }());
    exports.EditorLayoutInfo = EditorLayoutInfo;
    /**
     * Type of hit element with the mouse in the editor.
     */
    var MouseTargetType;
    (function (MouseTargetType) {
        /**
         * Mouse is on top of an unknown element.
         */
        MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
        /**
         * Mouse is on top of the textarea used for input.
         */
        MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
        /**
         * Mouse is on top of the glyph margin
         */
        MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        /**
         * Mouse is on top of the line numbers
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        /**
         * Mouse is on top of the line decorations
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        /**
         * Mouse is on top of the whitespace left in the gutter by a view zone.
         */
        MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        /**
         * Mouse is on top of text in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        /**
         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
         */
        MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        /**
         * Mouse is on top of a view zone in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        /**
         * Mouse is on top of a content widget.
         */
        MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        /**
         * Mouse is on top of the decorations overview ruler.
         */
        MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        /**
         * Mouse is on top of a scrollbar.
         */
        MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
        /**
         * Mouse is on top of an overlay widget.
         */
        MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    })(MouseTargetType = exports.MouseTargetType || (exports.MouseTargetType = {}));
    /**
     * @internal
     */
    var EditorContextKeys;
    (function (EditorContextKeys) {
        /**
         * A context key that is set when the editor's text has focus (cursor is blinking).
         * @internal
         */
        EditorContextKeys.TextFocus = new contextkey_1.RawContextKey('editorTextFocus', false);
        /**
         * A context key that is set when the editor's text or an editor's widget has focus.
         * @internal
         */
        EditorContextKeys.Focus = new contextkey_1.RawContextKey('editorFocus', false);
        /**
         * A context key that is set when the editor's text is readonly.
         * @internal
         */
        EditorContextKeys.ReadOnly = new contextkey_1.RawContextKey('editorReadonly', false);
        /**
         * @internal
         */
        EditorContextKeys.Writable = EditorContextKeys.ReadOnly.toNegated();
        /**
         * A context key that is set when the editor has a non-collapsed selection.
         * @internal
         */
        EditorContextKeys.HasNonEmptySelection = new contextkey_1.RawContextKey('editorHasSelection', false);
        /**
         * @internal
         */
        EditorContextKeys.HasOnlyEmptySelection = EditorContextKeys.HasNonEmptySelection.toNegated();
        /**
         * A context key that is set when the editor has multiple selections (multiple cursors).
         * @internal
         */
        EditorContextKeys.HasMultipleSelections = new contextkey_1.RawContextKey('editorHasMultipleSelections', false);
        /**
         * @internal
         */
        EditorContextKeys.HasSingleSelection = EditorContextKeys.HasMultipleSelections.toNegated();
        /**
         * @internal
         */
        EditorContextKeys.TabMovesFocus = new contextkey_1.RawContextKey('editorTabMovesFocus', false);
        /**
         * @internal
         */
        EditorContextKeys.TabDoesNotMoveFocus = EditorContextKeys.TabMovesFocus.toNegated();
        /**
         * A context key that is set to the language associated with the model associated with the editor.
         * @internal
         */
        EditorContextKeys.LanguageId = new contextkey_1.RawContextKey('editorLangId', undefined);
    })(EditorContextKeys = exports.EditorContextKeys || (exports.EditorContextKeys = {}));
    ;
    /**
     * @internal
     */
    var ModeContextKeys;
    (function (ModeContextKeys) {
        /**
         * @internal
         */
        ModeContextKeys.hasCompletionItemProvider = new contextkey_1.RawContextKey('editorHasCompletionItemProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasCodeActionsProvider = new contextkey_1.RawContextKey('editorHasCodeActionsProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasCodeLensProvider = new contextkey_1.RawContextKey('editorHasCodeLensProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasDefinitionProvider = new contextkey_1.RawContextKey('editorHasDefinitionProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasTypeDefinitionProvider = new contextkey_1.RawContextKey('editorHasTypeDefinitionProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasHoverProvider = new contextkey_1.RawContextKey('editorHasHoverProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasDocumentHighlightProvider = new contextkey_1.RawContextKey('editorHasDocumentHighlightProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasDocumentSymbolProvider = new contextkey_1.RawContextKey('editorHasDocumentSymbolProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasReferenceProvider = new contextkey_1.RawContextKey('editorHasReferenceProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasRenameProvider = new contextkey_1.RawContextKey('editorHasRenameProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasDocumentFormattingProvider = new contextkey_1.RawContextKey('editorHasDocumentFormattingProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasDocumentSelectionFormattingProvider = new contextkey_1.RawContextKey('editorHasDocumentSelectionFormattingProvider', undefined);
        /**
         * @internal
         */
        ModeContextKeys.hasSignatureHelpProvider = new contextkey_1.RawContextKey('editorHasSignatureHelpProvider', undefined);
    })(ModeContextKeys = exports.ModeContextKeys || (exports.ModeContextKeys = {}));
    // --- view
    /**
     * @internal
     */
    exports.ViewEventNames = {
        ModelFlushedEvent: 'modelFlushedEvent',
        LinesDeletedEvent: 'linesDeletedEvent',
        LinesInsertedEvent: 'linesInsertedEvent',
        LineChangedEvent: 'lineChangedEvent',
        TokensChangedEvent: 'tokensChangedEvent',
        DecorationsChangedEvent: 'decorationsChangedEvent',
        CursorPositionChangedEvent: 'cursorPositionChangedEvent',
        CursorSelectionChangedEvent: 'cursorSelectionChangedEvent',
        RevealRangeEvent: 'revealRangeEvent',
        LineMappingChangedEvent: 'lineMappingChangedEvent',
        ScrollRequestEvent: 'scrollRequestEvent'
    };
    /**
     * @internal
     */
    var Viewport = (function () {
        function Viewport(top, left, width, height) {
            this.top = top | 0;
            this.left = left | 0;
            this.width = width | 0;
            this.height = height | 0;
        }
        return Viewport;
    }());
    exports.Viewport = Viewport;
    /**
     * @internal
     */
    var CodeEditorStateFlag;
    (function (CodeEditorStateFlag) {
        CodeEditorStateFlag[CodeEditorStateFlag["Value"] = 0] = "Value";
        CodeEditorStateFlag[CodeEditorStateFlag["Selection"] = 1] = "Selection";
        CodeEditorStateFlag[CodeEditorStateFlag["Position"] = 2] = "Position";
        CodeEditorStateFlag[CodeEditorStateFlag["Scroll"] = 3] = "Scroll";
    })(CodeEditorStateFlag = exports.CodeEditorStateFlag || (exports.CodeEditorStateFlag = {}));
    /**
     * The type of the `IEditor`.
     */
    exports.EditorType = {
        ICodeEditor: 'vs.editor.ICodeEditor',
        IDiffEditor: 'vs.editor.IDiffEditor'
    };
    /**
     *@internal
     */
    function isCommonCodeEditor(thing) {
        if (thing && typeof thing.getEditorType === 'function') {
            return thing.getEditorType() === exports.EditorType.ICodeEditor;
        }
        else {
            return false;
        }
    }
    exports.isCommonCodeEditor = isCommonCodeEditor;
    /**
     *@internal
     */
    function isCommonDiffEditor(thing) {
        if (thing && typeof thing.getEditorType === 'function') {
            return thing.getEditorType() === exports.EditorType.IDiffEditor;
        }
        else {
            return false;
        }
    }
    exports.isCommonDiffEditor = isCommonDiffEditor;
    /**
     * @internal
     */
    exports.ClassName = {
        EditorWarningDecoration: 'greensquiggly',
        EditorErrorDecoration: 'redsquiggly'
    };
    /**
     * @internal
     */
    exports.EventType = {
        Disposed: 'disposed',
        ConfigurationChanged: 'configurationChanged',
        ModelDispose: 'modelDispose',
        ModelChanged: 'modelChanged',
        ModelTokensChanged: 'modelTokensChanged',
        ModelLanguageChanged: 'modelLanguageChanged',
        ModelOptionsChanged: 'modelOptionsChanged',
        ModelRawContentChanged: 'contentChanged',
        ModelContentChanged2: 'contentChanged2',
        ModelRawContentChangedFlush: 'flush',
        ModelRawContentChangedLinesDeleted: 'linesDeleted',
        ModelRawContentChangedLinesInserted: 'linesInserted',
        ModelRawContentChangedLineChanged: 'lineChanged',
        EditorTextBlur: 'blur',
        EditorTextFocus: 'focus',
        EditorFocus: 'widgetFocus',
        EditorBlur: 'widgetBlur',
        ModelDecorationsChanged: 'decorationsChanged',
        CursorPositionChanged: 'positionChanged',
        CursorSelectionChanged: 'selectionChanged',
        CursorRevealRange: 'revealRange',
        CursorScrollRequest: 'scrollRequest',
        ViewFocusGained: 'focusGained',
        ViewFocusLost: 'focusLost',
        ViewFocusChanged: 'focusChanged',
        ViewScrollChanged: 'scrollChanged',
        ViewZonesChanged: 'zonesChanged',
        ViewLayoutChanged: 'viewLayoutChanged',
        ContextMenu: 'contextMenu',
        MouseDown: 'mousedown',
        MouseUp: 'mouseup',
        MouseMove: 'mousemove',
        MouseLeave: 'mouseleave',
        KeyDown: 'keydown',
        KeyUp: 'keyup',
        WillType: 'willType',
        DidType: 'didType',
        EditorLayout: 'editorLayout',
        DiffUpdated: 'diffUpdated'
    };
    /**
     * Positions in the view for cursor move command.
     */
    exports.CursorMovePosition = {
        Left: 'left',
        Right: 'right',
        Up: 'up',
        Down: 'down',
        WrappedLineStart: 'wrappedLineStart',
        WrappedLineFirstNonWhitespaceCharacter: 'wrappedLineFirstNonWhitespaceCharacter',
        WrappedLineColumnCenter: 'wrappedLineColumnCenter',
        WrappedLineEnd: 'wrappedLineEnd',
        WrappedLineLastNonWhitespaceCharacter: 'wrappedLineLastNonWhitespaceCharacter',
        ViewPortTop: 'viewPortTop',
        ViewPortCenter: 'viewPortCenter',
        ViewPortBottom: 'viewPortBottom',
        ViewPortIfOutside: 'viewPortIfOutside'
    };
    /**
     * Units for Cursor move 'by' argument
     */
    exports.CursorMoveByUnit = {
        Line: 'line',
        WrappedLine: 'wrappedLine',
        Character: 'character',
        HalfLine: 'halfLine'
    };
    ;
    /**
     * @internal
     */
    var isCursorMoveArgs = function (arg) {
        if (!types.isObject(arg)) {
            return false;
        }
        var cursorMoveArg = arg;
        if (!types.isString(cursorMoveArg.to)) {
            return false;
        }
        if (!types.isUndefined(cursorMoveArg.select) && !types.isBoolean(cursorMoveArg.select)) {
            return false;
        }
        if (!types.isUndefined(cursorMoveArg.by) && !types.isString(cursorMoveArg.by)) {
            return false;
        }
        if (!types.isUndefined(cursorMoveArg.value) && !types.isNumber(cursorMoveArg.value)) {
            return false;
        }
        return true;
    };
    /**
     * Directions in the view for editor scroll command.
     */
    exports.EditorScrollDirection = {
        Up: 'up',
        Down: 'down',
    };
    /**
     * Units for editor scroll 'by' argument
     */
    exports.EditorScrollByUnit = {
        Line: 'line',
        WrappedLine: 'wrappedLine',
        Page: 'page',
        HalfPage: 'halfPage'
    };
    ;
    /**
     * @internal
     */
    var isEditorScrollArgs = function (arg) {
        if (!types.isObject(arg)) {
            return false;
        }
        var scrollArg = arg;
        if (!types.isString(scrollArg.to)) {
            return false;
        }
        if (!types.isUndefined(scrollArg.by) && !types.isString(scrollArg.by)) {
            return false;
        }
        if (!types.isUndefined(scrollArg.value) && !types.isNumber(scrollArg.value)) {
            return false;
        }
        if (!types.isUndefined(scrollArg.revealCursor) && !types.isBoolean(scrollArg.revealCursor)) {
            return false;
        }
        return true;
    };
    ;
    /**
     * Values for reveal line 'at' argument
     */
    exports.RevealLineAtArgument = {
        Top: 'top',
        Center: 'center',
        Bottom: 'bottom'
    };
    /**
     * @internal
     */
    var isRevealLineArgs = function (arg) {
        if (!types.isObject(arg)) {
            return false;
        }
        var reveaLineArg = arg;
        if (!types.isNumber(reveaLineArg.lineNumber)) {
            return false;
        }
        if (!types.isUndefined(reveaLineArg.at) && !types.isString(reveaLineArg.at)) {
            return false;
        }
        return true;
    };
    /**
     * @internal
     */
    exports.CommandDescription = {
        CursorMove: {
            description: 'Move cursor to a logical position in the view',
            args: [
                {
                    name: 'Cursor move argument object',
                    description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'left', 'right', 'up', 'down'\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter',\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t",
                    constraint: isCursorMoveArgs
                }
            ]
        },
        EditorScroll: {
            description: 'Scroll editor in the given direction',
            args: [
                {
                    name: 'Editor scroll argument object',
                    description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory direction value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'up', 'down'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'page', 'halfPage'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n\t\t\t\t",
                    constraint: isEditorScrollArgs
                }
            ]
        },
        RevealLine: {
            description: 'Reveal the given line at the given logical position',
            args: [
                {
                    name: 'Reveal line argument object',
                    description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'lineNumber': A mandatory line number value.\n\t\t\t\t\t* 'at': Logical position at which line has to be revealed .\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'top', 'center', 'bottom'\n\t\t\t\t\t\t```\n\t\t\t\t",
                    constraint: isRevealLineArgs
                }
            ]
        }
    };
    /**
     * Built-in commands.
     */
    exports.Handler = {
        ExecuteCommand: 'executeCommand',
        ExecuteCommands: 'executeCommands',
        CursorLeft: 'cursorLeft',
        CursorLeftSelect: 'cursorLeftSelect',
        CursorWordLeft: 'cursorWordLeft',
        CursorWordStartLeft: 'cursorWordStartLeft',
        CursorWordEndLeft: 'cursorWordEndLeft',
        CursorWordLeftSelect: 'cursorWordLeftSelect',
        CursorWordStartLeftSelect: 'cursorWordStartLeftSelect',
        CursorWordEndLeftSelect: 'cursorWordEndLeftSelect',
        CursorRight: 'cursorRight',
        CursorRightSelect: 'cursorRightSelect',
        CursorWordRight: 'cursorWordRight',
        CursorWordStartRight: 'cursorWordStartRight',
        CursorWordEndRight: 'cursorWordEndRight',
        CursorWordRightSelect: 'cursorWordRightSelect',
        CursorWordStartRightSelect: 'cursorWordStartRightSelect',
        CursorWordEndRightSelect: 'cursorWordEndRightSelect',
        CursorUp: 'cursorUp',
        CursorUpSelect: 'cursorUpSelect',
        CursorDown: 'cursorDown',
        CursorDownSelect: 'cursorDownSelect',
        CursorPageUp: 'cursorPageUp',
        CursorPageUpSelect: 'cursorPageUpSelect',
        CursorPageDown: 'cursorPageDown',
        CursorPageDownSelect: 'cursorPageDownSelect',
        CursorHome: 'cursorHome',
        CursorHomeSelect: 'cursorHomeSelect',
        CursorEnd: 'cursorEnd',
        CursorEndSelect: 'cursorEndSelect',
        ExpandLineSelection: 'expandLineSelection',
        CursorTop: 'cursorTop',
        CursorTopSelect: 'cursorTopSelect',
        CursorBottom: 'cursorBottom',
        CursorBottomSelect: 'cursorBottomSelect',
        CursorColumnSelectLeft: 'cursorColumnSelectLeft',
        CursorColumnSelectRight: 'cursorColumnSelectRight',
        CursorColumnSelectUp: 'cursorColumnSelectUp',
        CursorColumnSelectPageUp: 'cursorColumnSelectPageUp',
        CursorColumnSelectDown: 'cursorColumnSelectDown',
        CursorColumnSelectPageDown: 'cursorColumnSelectPageDown',
        CursorMove: 'cursorMove',
        AddCursorDown: 'addCursorDown',
        AddCursorUp: 'addCursorUp',
        CursorUndo: 'cursorUndo',
        MoveTo: 'moveTo',
        MoveToSelect: 'moveToSelect',
        ColumnSelect: 'columnSelect',
        CreateCursor: 'createCursor',
        LastCursorMoveToSelect: 'lastCursorMoveToSelect',
        Type: 'type',
        ReplacePreviousChar: 'replacePreviousChar',
        CompositionStart: 'compositionStart',
        CompositionEnd: 'compositionEnd',
        Paste: 'paste',
        Tab: 'tab',
        Indent: 'indent',
        Outdent: 'outdent',
        DeleteLeft: 'deleteLeft',
        DeleteRight: 'deleteRight',
        DeleteWordLeft: 'deleteWordLeft',
        DeleteWordStartLeft: 'deleteWordStartLeft',
        DeleteWordEndLeft: 'deleteWordEndLeft',
        DeleteWordRight: 'deleteWordRight',
        DeleteWordStartRight: 'deleteWordStartRight',
        DeleteWordEndRight: 'deleteWordEndRight',
        RemoveSecondaryCursors: 'removeSecondaryCursors',
        CancelSelection: 'cancelSelection',
        Cut: 'cut',
        Undo: 'undo',
        Redo: 'redo',
        WordSelect: 'wordSelect',
        WordSelectDrag: 'wordSelectDrag',
        LastCursorWordSelect: 'lastCursorWordSelect',
        LineSelect: 'lineSelect',
        LineSelectDrag: 'lineSelectDrag',
        LastCursorLineSelect: 'lastCursorLineSelect',
        LastCursorLineSelectDrag: 'lastCursorLineSelectDrag',
        LineInsertBefore: 'lineInsertBefore',
        LineInsertAfter: 'lineInsertAfter',
        LineBreakInsert: 'lineBreakInsert',
        SelectAll: 'selectAll',
        EditorScroll: 'editorScroll',
        ScrollLineUp: 'scrollLineUp',
        ScrollLineDown: 'scrollLineDown',
        ScrollPageUp: 'scrollPageUp',
        ScrollPageDown: 'scrollPageDown',
        RevealLine: 'revealLine'
    };
    /**
     * The style in which the editor's cursor should be rendered.
     */
    var TextEditorCursorStyle;
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    })(TextEditorCursorStyle = exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    /**
     * The kind of animation in which the editor's cursor should be rendered.
     */
    var TextEditorCursorBlinkingStyle;
    (function (TextEditorCursorBlinkingStyle) {
        /**
         * Hidden
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
        /**
         * Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
        /**
         * Blinking with smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
        /**
         * Blinking with prolonged filled state and smooth fading
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
        /**
         * Expand collapse animation on the y axis
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
        /**
         * No-Blinking
         */
        TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
    })(TextEditorCursorBlinkingStyle = exports.TextEditorCursorBlinkingStyle || (exports.TextEditorCursorBlinkingStyle = {}));
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    /**
     * @internal
     */
    var ColorZone = (function () {
        function ColorZone(from, to, colorId, position) {
            this.from = from | 0;
            this.to = to | 0;
            this.colorId = colorId | 0;
            this.position = position | 0;
        }
        return ColorZone;
    }());
    exports.ColorZone = ColorZone;
    /**
     * A zone in the overview ruler
     * @internal
     */
    var OverviewRulerZone = (function () {
        function OverviewRulerZone(startLineNumber, endLineNumber, position, forceHeight, color, darkColor) {
            this.startLineNumber = startLineNumber;
            this.endLineNumber = endLineNumber;
            this.position = position;
            this.forceHeight = forceHeight;
            this._color = color;
            this._darkColor = darkColor;
            this._colorZones = null;
        }
        OverviewRulerZone.prototype.getColor = function (useDarkColor) {
            if (useDarkColor) {
                return this._darkColor;
            }
            return this._color;
        };
        OverviewRulerZone.prototype.equals = function (other) {
            return (this.startLineNumber === other.startLineNumber
                && this.endLineNumber === other.endLineNumber
                && this.position === other.position
                && this.forceHeight === other.forceHeight
                && this._color === other._color
                && this._darkColor === other._darkColor);
        };
        OverviewRulerZone.prototype.compareTo = function (other) {
            if (this.startLineNumber === other.startLineNumber) {
                if (this.endLineNumber === other.endLineNumber) {
                    if (this.forceHeight === other.forceHeight) {
                        if (this.position === other.position) {
                            if (this._darkColor === other._darkColor) {
                                if (this._color === other._color) {
                                    return 0;
                                }
                                return this._color < other._color ? -1 : 1;
                            }
                            return this._darkColor < other._darkColor ? -1 : 1;
                        }
                        return this.position - other.position;
                    }
                    return this.forceHeight - other.forceHeight;
                }
                return this.endLineNumber - other.endLineNumber;
            }
            return this.startLineNumber - other.startLineNumber;
        };
        OverviewRulerZone.prototype.setColorZones = function (colorZones) {
            this._colorZones = colorZones;
        };
        OverviewRulerZone.prototype.getColorZones = function () {
            return this._colorZones;
        };
        return OverviewRulerZone;
    }());
    exports.OverviewRulerZone = OverviewRulerZone;
});






define(__m[336/*vs/editor/browser/services/codeEditorServiceImpl*/], __M([1/*require*/,0/*exports*/,36/*vs/base/common/objects*/,145/*vs/base/common/marshalling*/,9/*vs/base/common/strings*/,27/*vs/base/common/uri*/,11/*vs/base/browser/dom*/,2/*vs/editor/common/editorCommon*/,196/*vs/editor/common/services/abstractCodeEditorService*/,3/*vs/base/common/lifecycle*/]), function (require, exports, objects, marshalling_1, strings, uri_1, dom, editorCommon_1, abstractCodeEditorService_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CodeEditorServiceImpl = (function (_super) {
        __extends(CodeEditorServiceImpl, _super);
        function CodeEditorServiceImpl(styleSheet) {
            if (styleSheet === void 0) { styleSheet = dom.createStyleSheet(); }
            var _this = _super.call(this) || this;
            _this._styleSheet = styleSheet;
            _this._decorationOptionProviders = Object.create(null);
            return _this;
        }
        CodeEditorServiceImpl.prototype.registerDecorationType = function (key, options, parentTypeKey) {
            var provider = this._decorationOptionProviders[key];
            if (!provider) {
                if (!parentTypeKey) {
                    provider = new DecorationTypeOptionsProvider(this._styleSheet, key, options);
                }
                else {
                    provider = new DecorationSubTypeOptionsProvider(this._styleSheet, key, parentTypeKey, options);
                }
                this._decorationOptionProviders[key] = provider;
            }
            provider.refCount++;
        };
        CodeEditorServiceImpl.prototype.removeDecorationType = function (key) {
            var provider = this._decorationOptionProviders[key];
            if (provider) {
                provider.refCount--;
                if (provider.refCount <= 0) {
                    delete this._decorationOptionProviders[key];
                    provider.dispose();
                    this.listCodeEditors().forEach(function (ed) { return ed.removeDecorations(key); });
                }
            }
        };
        CodeEditorServiceImpl.prototype.resolveDecorationOptions = function (decorationTypeKey, writable) {
            var provider = this._decorationOptionProviders[decorationTypeKey];
            if (!provider) {
                throw new Error('Unknown decoration type key: ' + decorationTypeKey);
            }
            return provider.getOptions(this, writable);
        };
        return CodeEditorServiceImpl;
    }(abstractCodeEditorService_1.AbstractCodeEditorService));
    exports.CodeEditorServiceImpl = CodeEditorServiceImpl;
    var DecorationSubTypeOptionsProvider = (function () {
        function DecorationSubTypeOptionsProvider(styleSheet, key, parentTypeKey, options) {
            this._parentTypeKey = parentTypeKey;
            this.refCount = 0;
            var themedOpts = getThemedRenderOptions(options);
            this._beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, 3 /* BeforeContentClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
            });
            this._afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, 4 /* AfterContentClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
            });
            if (this._beforeContentClassName || this._afterContentClassName) {
                this._disposable = lifecycle_1.toDisposable(function () {
                    dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
                });
            }
        }
        DecorationSubTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
            var options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
            if (this._beforeContentClassName) {
                options.beforeContentClassName = this._beforeContentClassName;
            }
            if (this._afterContentClassName) {
                options.afterContentClassName = this._afterContentClassName;
            }
            return options;
        };
        DecorationSubTypeOptionsProvider.prototype.dispose = function () {
            if (this._disposable) {
                this._disposable.dispose();
                delete this._disposable;
            }
        };
        return DecorationSubTypeOptionsProvider;
    }());
    var DecorationTypeOptionsProvider = (function () {
        function DecorationTypeOptionsProvider(styleSheet, key, options) {
            this.refCount = 0;
            var themedOpts = getThemedRenderOptions(options);
            this.className = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 0 /* ClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.dark)
            });
            this.inlineClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 1 /* InlineClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.dark)
            });
            this.beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 3 /* BeforeContentClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
            });
            this.afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 4 /* AfterContentClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
            });
            this.glyphMarginClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, 2 /* GlyphMarginClassName */, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.dark)
            });
            this.isWholeLine = Boolean(options.isWholeLine);
            if (typeof themedOpts.light.overviewRulerColor !== 'undefined'
                || typeof themedOpts.dark.overviewRulerColor !== 'undefined') {
                this.overviewRuler = {
                    color: themedOpts.light.overviewRulerColor || themedOpts.dark.overviewRulerColor,
                    darkColor: themedOpts.dark.overviewRulerColor || themedOpts.light.overviewRulerColor,
                    position: options.overviewRulerLane || editorCommon_1.OverviewRulerLane.Center
                };
            }
            this._disposable = lifecycle_1.toDisposable(function () {
                dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
            });
        }
        DecorationTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
            if (!writable) {
                return this;
            }
            return {
                inlineClassName: this.inlineClassName,
                beforeContentClassName: this.beforeContentClassName,
                afterContentClassName: this.afterContentClassName,
                className: this.className,
                glyphMarginClassName: this.glyphMarginClassName,
                isWholeLine: this.isWholeLine,
                overviewRuler: this.overviewRuler,
                stickiness: this.stickiness
            };
        };
        DecorationTypeOptionsProvider.prototype.dispose = function () {
            if (this._disposable) {
                this._disposable.dispose();
                delete this._disposable;
            }
        };
        return DecorationTypeOptionsProvider;
    }());
    var DecorationRenderHelper = (function () {
        function DecorationRenderHelper() {
        }
        /**
         * Build the CSS for decorations styled via `className`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationClassName = function (opts) {
            var cssTextArr = [];
            DecorationRenderHelper.collectCSSText(opts, ['backgroundColor', 'outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
            DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled via `inlineClassName`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName = function (opts) {
            var cssTextArr = [];
            DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'cursor', 'color', 'letterSpacing'], cssTextArr);
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled before or after content.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationContentClassName = function (opts) {
            var cssTextArr = [];
            if (typeof opts !== 'undefined') {
                DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
                if (typeof opts.contentIconPath === 'string') {
                    cssTextArr.push(strings.format(this._CSS_MAP.contentIconPath, uri_1.default.file(opts.contentIconPath).toString()));
                }
                else if (opts.contentIconPath instanceof uri_1.default) {
                    cssTextArr.push(strings.format(this._CSS_MAP.contentIconPath, opts.contentIconPath.toString(true).replace(/'/g, '%27')));
                }
                if (typeof opts.contentText !== 'undefined') {
                    var escaped = opts.contentText.replace(/\"/g, '\\\"');
                    cssTextArr.push(strings.format(this._CSS_MAP.contentText, escaped));
                }
                DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'color', 'backgroundColor', 'margin'], cssTextArr);
                if (DecorationRenderHelper.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
                    cssTextArr.push('display:inline-block;');
                }
            }
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled via `glpyhMarginClassName`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName = function (opts) {
            var cssTextArr = [];
            if (typeof opts.gutterIconPath !== 'undefined') {
                if (typeof opts.gutterIconPath === 'string') {
                    cssTextArr.push(strings.format(this._CSS_MAP.gutterIconPath, uri_1.default.file(opts.gutterIconPath).toString()));
                }
                else {
                    cssTextArr.push(strings.format(this._CSS_MAP.gutterIconPath, opts.gutterIconPath.toString(true).replace(/'/g, '%27')));
                }
                if (typeof opts.gutterIconSize !== 'undefined') {
                    cssTextArr.push(strings.format(this._CSS_MAP.gutterIconSize, opts.gutterIconSize));
                }
            }
            return cssTextArr.join('');
        };
        DecorationRenderHelper.collectBorderSettingsCSSText = function (opts, cssTextArr) {
            if (DecorationRenderHelper.collectCSSText(opts, DecorationRenderHelper.border_rules, cssTextArr)) {
                cssTextArr.push(strings.format('box-sizing: border-box;'));
                return true;
            }
            return false;
        };
        DecorationRenderHelper.collectCSSText = function (opts, properties, cssTextArr) {
            var lenBefore = cssTextArr.length;
            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                var property = properties_1[_i];
                if (typeof opts[property] !== 'undefined') {
                    cssTextArr.push(strings.format(this._CSS_MAP[property], opts[property]));
                }
            }
            return cssTextArr.length !== lenBefore;
        };
        /**
         * Create CSS rules for `cssTexts` with the generated class names from `ruleType`
         */
        DecorationRenderHelper.createCSSRules = function (styleSheet, key, parentKey, ruleType, cssTexts) {
            function createCSSSelector(themeType, cssText) {
                var selector = CSSNameHelper.getSelector(themeType, key, parentKey, ruleType);
                dom.createCSSRule(selector, cssText, styleSheet);
            }
            var hasContent = false;
            if (cssTexts.light.length > 0) {
                createCSSSelector(0 /* Light */, cssTexts.light);
                hasContent = true;
            }
            if (cssTexts.dark.length > 0) {
                createCSSSelector(1 /* Dark */, cssTexts.dark);
                createCSSSelector(2 /* HighContrastBlack */, cssTexts.dark);
                hasContent = true;
            }
            if (hasContent) {
                var className = CSSNameHelper.getClassName(key, ruleType);
                if (parentKey) {
                    className = className + ' ' + CSSNameHelper.getClassName(parentKey, ruleType);
                }
                return className;
            }
            return void 0;
        };
        return DecorationRenderHelper;
    }());
    DecorationRenderHelper._CSS_MAP = {
        color: 'color:{0} !important;',
        backgroundColor: 'background-color:{0};',
        outline: 'outline:{0};',
        outlineColor: 'outline-color:{0};',
        outlineStyle: 'outline-style:{0};',
        outlineWidth: 'outline-width:{0};',
        border: 'border:{0};',
        borderColor: 'border-color:{0};',
        borderRadius: 'border-radius:{0};',
        borderSpacing: 'border-spacing:{0};',
        borderStyle: 'border-style:{0};',
        borderWidth: 'border-width:{0};',
        textDecoration: 'text-decoration:{0};',
        cursor: 'cursor:{0};',
        letterSpacing: 'letter-spacing:{0};',
        gutterIconPath: 'background:url(\'{0}\') center center no-repeat;',
        gutterIconSize: 'background-size:{0};',
        contentText: 'content:\'{0}\';',
        contentIconPath: 'content:url(\'{0}\');',
        margin: 'margin:{0};',
        width: 'width:{0};',
        height: 'height:{0};'
    };
    DecorationRenderHelper.border_rules = ['border', 'borderColor', 'borderColor', 'borderSpacing', 'borderStyle', 'borderWidth'];
    var ThemeType;
    (function (ThemeType) {
        ThemeType[ThemeType["Light"] = 0] = "Light";
        ThemeType[ThemeType["Dark"] = 1] = "Dark";
        ThemeType[ThemeType["HighContrastBlack"] = 2] = "HighContrastBlack";
    })(ThemeType || (ThemeType = {}));
    var ModelDecorationCSSRuleType;
    (function (ModelDecorationCSSRuleType) {
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["ClassName"] = 0] = "ClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["InlineClassName"] = 1] = "InlineClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["GlyphMarginClassName"] = 2] = "GlyphMarginClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["BeforeContentClassName"] = 3] = "BeforeContentClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["AfterContentClassName"] = 4] = "AfterContentClassName";
    })(ModelDecorationCSSRuleType || (ModelDecorationCSSRuleType = {}));
    var CSSNameHelper = (function () {
        function CSSNameHelper() {
        }
        CSSNameHelper._getSelectorPrefixOf = function (theme) {
            if (theme === 0 /* Light */) {
                return '.monaco-editor.vs';
            }
            if (theme === 1 /* Dark */) {
                return '.monaco-editor.vs-dark';
            }
            return '.monaco-editor.hc-black';
        };
        CSSNameHelper.getClassName = function (key, type) {
            return 'ced-' + key + '-' + type;
        };
        CSSNameHelper.getSelector = function (themeType, key, parentKey, ruleType) {
            var selector = this._getSelectorPrefixOf(themeType) + ' .' + this.getClassName(key, ruleType);
            if (parentKey) {
                selector = selector + '.' + this.getClassName(parentKey, ruleType);
            }
            if (ruleType === 3 /* BeforeContentClassName */) {
                selector += '::before';
            }
            else if (ruleType === 4 /* AfterContentClassName */) {
                selector += '::after';
            }
            return selector;
        };
        CSSNameHelper.getDeletionSubstring = function (key) {
            return '.ced-' + key + '-';
        };
        return CSSNameHelper;
    }());
    function getThemedRenderOptions(opts) {
        // TODO@alex,joh - not really how/what deep clone is being used
        // for here but it will break the URI TODO@martin
        // let light = <T> objects.deepClone(opts);
        var light = marshalling_1.parse(marshalling_1.stringify(opts));
        objects.mixin(light, opts.light);
        // let dark = <T> objects.deepClone(opts);
        var dark = marshalling_1.parse(marshalling_1.stringify(opts));
        objects.mixin(dark, opts.dark);
        return {
            light: light,
            dark: dark
        };
    }
});

define(__m[337/*vs/editor/browser/view/viewController*/], __M([1/*require*/,0/*exports*/,16/*vs/editor/common/core/position*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, position_1, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewController = (function () {
        function ViewController(viewModel, triggerCursorHandler, outgoingEvents, commandService) {
            this.viewModel = viewModel;
            this.triggerCursorHandler = triggerCursorHandler;
            this.outgoingEvents = outgoingEvents;
            this.commandService = commandService;
        }
        ViewController.prototype.paste = function (source, text, pasteOnNewLine) {
            this.commandService.executeCommand(editorCommon.Handler.Paste, {
                text: text,
                pasteOnNewLine: pasteOnNewLine,
            });
        };
        ViewController.prototype.type = function (source, text) {
            this.commandService.executeCommand(editorCommon.Handler.Type, {
                text: text
            });
        };
        ViewController.prototype.replacePreviousChar = function (source, text, replaceCharCnt) {
            this.commandService.executeCommand(editorCommon.Handler.ReplacePreviousChar, {
                text: text,
                replaceCharCnt: replaceCharCnt
            });
        };
        ViewController.prototype.compositionStart = function (source) {
            this.commandService.executeCommand(editorCommon.Handler.CompositionStart, {});
        };
        ViewController.prototype.compositionEnd = function (source) {
            this.commandService.executeCommand(editorCommon.Handler.CompositionEnd, {});
        };
        ViewController.prototype.cut = function (source) {
            this.commandService.executeCommand(editorCommon.Handler.Cut, {});
        };
        ViewController.prototype._validateViewColumn = function (viewPosition) {
            var minColumn = this.viewModel.getLineMinColumn(viewPosition.lineNumber);
            if (viewPosition.column < minColumn) {
                return new position_1.Position(viewPosition.lineNumber, minColumn);
            }
            return viewPosition;
        };
        ViewController.prototype.dispatchMouse = function (data) {
            if (data.startedOnLineNumbers) {
                // If the dragging started on the gutter, then have operations work on the entire line
                if (data.altKey) {
                    if (data.inSelectionMode) {
                        this.lastCursorLineSelect('mouse', data.position);
                    }
                    else {
                        this.createCursor('mouse', data.position, true);
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.lineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lineSelect('mouse', data.position);
                    }
                }
            }
            else if (data.mouseDownCount >= 4) {
                this.selectAll('mouse');
            }
            else if (data.mouseDownCount === 3) {
                if (data.altKey) {
                    if (data.inSelectionMode) {
                        this.lastCursorLineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lastCursorLineSelect('mouse', data.position);
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.lineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lineSelect('mouse', data.position);
                    }
                }
            }
            else if (data.mouseDownCount === 2) {
                if (data.altKey) {
                    this.lastCursorWordSelect('mouse', data.position);
                }
                else {
                    if (data.inSelectionMode) {
                        this.wordSelectDrag('mouse', data.position);
                    }
                    else {
                        this.wordSelect('mouse', data.position);
                    }
                }
            }
            else {
                if (data.altKey) {
                    if (!data.ctrlKey && !data.metaKey) {
                        if (data.shiftKey) {
                            this.columnSelect('mouse', data.position, data.mouseColumn);
                        }
                        else {
                            // Do multi-cursor operations only when purely alt is pressed
                            if (data.inSelectionMode) {
                                this.lastCursorMoveToSelect('mouse', data.position);
                            }
                            else {
                                this.createCursor('mouse', data.position, false);
                            }
                        }
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.moveToSelect('mouse', data.position);
                    }
                    else {
                        this.moveTo('mouse', data.position);
                    }
                }
            }
        };
        ViewController.prototype.moveTo = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.MoveTo, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.moveToSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.MoveToSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.columnSelect = function (source, viewPosition, mouseColumn) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.ColumnSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition,
                mouseColumn: mouseColumn
            });
        };
        ViewController.prototype.createCursor = function (source, viewPosition, wholeLine) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.CreateCursor, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition,
                wholeLine: wholeLine
            });
        };
        ViewController.prototype.lastCursorMoveToSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorMoveToSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.wordSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.WordSelect, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.wordSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.WordSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.lastCursorWordSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorWordSelect, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.lineSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LineSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lineSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LineSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lastCursorLineSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorLineSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lastCursorLineSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorLineSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.selectAll = function (source) {
            this.triggerCursorHandler(source, editorCommon.Handler.SelectAll, null);
        };
        // ----------------------
        ViewController.prototype.convertViewToModelPosition = function (viewPosition) {
            return this.viewModel.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
        };
        ViewController.prototype.emitKeyDown = function (e) {
            this.outgoingEvents.emitKeyDown(e);
        };
        ViewController.prototype.emitKeyUp = function (e) {
            this.outgoingEvents.emitKeyUp(e);
        };
        ViewController.prototype.emitContextMenu = function (e) {
            this.outgoingEvents.emitContextMenu(e);
        };
        ViewController.prototype.emitMouseMove = function (e) {
            this.outgoingEvents.emitMouseMove(e);
        };
        ViewController.prototype.emitMouseLeave = function (e) {
            this.outgoingEvents.emitMouseLeave(e);
        };
        ViewController.prototype.emitMouseUp = function (e) {
            this.outgoingEvents.emitMouseUp(e);
        };
        ViewController.prototype.emitMouseDown = function (e) {
            this.outgoingEvents.emitMouseDown(e);
        };
        return ViewController;
    }());
    exports.ViewController = ViewController;
});






define(__m[166/*vs/editor/common/controller/textAreaState*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, strings_1, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TextAreaStrategy;
    (function (TextAreaStrategy) {
        TextAreaStrategy[TextAreaStrategy["IENarrator"] = 0] = "IENarrator";
        TextAreaStrategy[TextAreaStrategy["NVDA"] = 1] = "NVDA";
    })(TextAreaStrategy = exports.TextAreaStrategy || (exports.TextAreaStrategy = {}));
    var USE_NVDA_FULL_TEXT = false;
    function createTextAreaState(strategy) {
        if (strategy === TextAreaStrategy.IENarrator) {
            return IENarratorTextAreaState.EMPTY;
        }
        if (USE_NVDA_FULL_TEXT) {
            return NVDAFullTextAreaState.EMPTY;
        }
        return NVDAPagedTextAreaState.EMPTY;
    }
    exports.createTextAreaState = createTextAreaState;
    var TextAreaState = (function () {
        function TextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            this.previousState = previousState ? previousState.shallowClone() : null;
            this.value = value;
            this.selectionStart = selectionStart;
            this.selectionEnd = selectionEnd;
            this.isInOverwriteMode = isInOverwriteMode;
        }
        TextAreaState.prototype.updateComposition = function () {
            if (!this.previousState) {
                // This is the EMPTY state
                return {
                    text: '',
                    replaceCharCnt: 0
                };
            }
            return {
                text: this.value,
                replaceCharCnt: this.previousState.selectionEnd - this.previousState.selectionStart
            };
        };
        TextAreaState.prototype.getSelectionStart = function () {
            return this.selectionStart;
        };
        TextAreaState.prototype.getValue = function () {
            return this.value;
        };
        TextAreaState.prototype.applyToTextArea = function (reason, textArea, select) {
            // console.log(Date.now() + ': applyToTextArea ' + reason + ': ' + this.toString());
            if (textArea.getValue() !== this.value) {
                textArea.setValue(reason, this.value);
            }
            if (select) {
                textArea.setSelectionRange(this.selectionStart, this.selectionEnd);
            }
        };
        TextAreaState.prototype.deduceInput = function () {
            if (!this.previousState) {
                // This is the EMPTY state
                return {
                    text: '',
                    replaceCharCnt: 0
                };
            }
            // console.log('------------------------deduceInput');
            // console.log('CURRENT STATE: ' + this.toString());
            // console.log('PREVIOUS STATE: ' + this.previousState.toString());
            var previousValue = this.previousState.value;
            var previousSelectionStart = this.previousState.selectionStart;
            var previousSelectionEnd = this.previousState.selectionEnd;
            var currentValue = this.value;
            var currentSelectionStart = this.selectionStart;
            var currentSelectionEnd = this.selectionEnd;
            // Strip the previous suffix from the value (without interfering with the current selection)
            var previousSuffix = previousValue.substring(previousSelectionEnd);
            var currentSuffix = currentValue.substring(currentSelectionEnd);
            var suffixLength = strings_1.commonSuffixLength(previousSuffix, currentSuffix);
            currentValue = currentValue.substring(0, currentValue.length - suffixLength);
            previousValue = previousValue.substring(0, previousValue.length - suffixLength);
            var previousPrefix = previousValue.substring(0, previousSelectionStart);
            var currentPrefix = currentValue.substring(0, currentSelectionStart);
            var prefixLength = strings_1.commonPrefixLength(previousPrefix, currentPrefix);
            currentValue = currentValue.substring(prefixLength);
            previousValue = previousValue.substring(prefixLength);
            currentSelectionStart -= prefixLength;
            previousSelectionStart -= prefixLength;
            currentSelectionEnd -= prefixLength;
            previousSelectionEnd -= prefixLength;
            // console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);
            // console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);
            if (currentSelectionStart === currentSelectionEnd) {
                // composition accept case
                // [blahblah] => blahblah|
                if (previousValue === currentValue
                    && previousSelectionStart === 0
                    && previousSelectionEnd === previousValue.length
                    && currentSelectionStart === currentValue.length
                    && currentValue.indexOf('\n') === -1) {
                    return {
                        text: '',
                        replaceCharCnt: 0
                    };
                }
                // no current selection
                var replacePreviousCharacters_1 = (previousPrefix.length - prefixLength);
                // console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');
                return {
                    text: currentValue,
                    replaceCharCnt: replacePreviousCharacters_1
                };
            }
            // there is a current selection => composition case
            var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;
            return {
                text: currentValue,
                replaceCharCnt: replacePreviousCharacters
            };
        };
        return TextAreaState;
    }());
    exports.TextAreaState = TextAreaState;
    var IENarratorTextAreaState = (function (_super) {
        __extends(IENarratorTextAreaState, _super);
        function IENarratorTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode, selectionToken) {
            var _this = _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode) || this;
            _this.selectionToken = selectionToken;
            return _this;
        }
        IENarratorTextAreaState.prototype.shallowClone = function () {
            return new IENarratorTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, this.selectionToken);
        };
        IENarratorTextAreaState.prototype.toEmpty = function () {
            return IENarratorTextAreaState.EMPTY;
        };
        IENarratorTextAreaState.prototype.toString = function () {
            return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ', selectionToken: ' + this.selectionToken + ']';
        };
        IENarratorTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.IENarrator) {
                return this;
            }
            if (USE_NVDA_FULL_TEXT) {
                return new NVDAFullTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
            }
            return new NVDAPagedTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        IENarratorTextAreaState.prototype.equals = function (other) {
            if (other instanceof IENarratorTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode
                    && this.selectionToken === other.selectionToken);
            }
            return false;
        };
        IENarratorTextAreaState.prototype.fromTextArea = function (textArea) {
            return new IENarratorTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode(), this.selectionToken);
        };
        IENarratorTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var LIMIT_CHARS = 100;
            var PADDING_LINES_COUNT = 0;
            var selectionStartLineNumber = selection.startLineNumber, selectionStartColumn = selection.startColumn, selectionEndLineNumber = selection.endLineNumber, selectionEndColumn = selection.endColumn, selectionEndLineNumberMaxColumn = model.getLineMaxColumn(selectionEndLineNumber);
            // If the selection is empty and we have switched line numbers, expand selection to full line (helps Narrator trigger a full line read)
            if (selection.isEmpty() && this.selectionToken !== selectionStartLineNumber) {
                selectionStartColumn = 1;
                selectionEndColumn = selectionEndLineNumberMaxColumn;
            }
            // `pretext` contains the text before the selection
            var pretext = '';
            var startLineNumber = Math.max(1, selectionStartLineNumber - PADDING_LINES_COUNT);
            if (startLineNumber < selectionStartLineNumber) {
                pretext = model.getValueInRange(new range_1.Range(startLineNumber, 1, selectionStartLineNumber, 1), editorCommon_1.EndOfLinePreference.LF);
            }
            pretext += model.getValueInRange(new range_1.Range(selectionStartLineNumber, 1, selectionStartLineNumber, selectionStartColumn), editorCommon_1.EndOfLinePreference.LF);
            if (pretext.length > LIMIT_CHARS) {
                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
            }
            // `posttext` contains the text after the selection
            var posttext = '';
            var endLineNumber = Math.min(selectionEndLineNumber + PADDING_LINES_COUNT, model.getLineCount());
            posttext += model.getValueInRange(new range_1.Range(selectionEndLineNumber, selectionEndColumn, selectionEndLineNumber, selectionEndLineNumberMaxColumn), editorCommon_1.EndOfLinePreference.LF);
            if (endLineNumber > selectionEndLineNumber) {
                posttext = '\n' + model.getValueInRange(new range_1.Range(selectionEndLineNumber + 1, 1, endLineNumber, model.getLineMaxColumn(endLineNumber)), editorCommon_1.EndOfLinePreference.LF);
            }
            if (posttext.length > LIMIT_CHARS) {
                posttext = posttext.substring(0, LIMIT_CHARS);
            }
            // `text` contains the text of the selection
            var text = model.getValueInRange(new range_1.Range(selectionStartLineNumber, selectionStartColumn, selectionEndLineNumber, selectionEndColumn), editorCommon_1.EndOfLinePreference.LF);
            if (text.length > 2 * LIMIT_CHARS) {
                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
            }
            return new IENarratorTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false, selectionStartLineNumber);
        };
        IENarratorTextAreaState.prototype.fromText = function (text) {
            return new IENarratorTextAreaState(this, text, 0, text.length, false, 0);
        };
        IENarratorTextAreaState.prototype.resetSelection = function () {
            return new IENarratorTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode, this.selectionToken);
        };
        return IENarratorTextAreaState;
    }(TextAreaState));
    IENarratorTextAreaState.EMPTY = new IENarratorTextAreaState(null, '', 0, 0, false, 0);
    exports.IENarratorTextAreaState = IENarratorTextAreaState;
    var NVDAPagedTextAreaState = (function (_super) {
        __extends(NVDAPagedTextAreaState, _super);
        function NVDAPagedTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            return _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode) || this;
        }
        NVDAPagedTextAreaState.prototype.shallowClone = function () {
            return new NVDAPagedTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        NVDAPagedTextAreaState.prototype.toEmpty = function () {
            return NVDAPagedTextAreaState.EMPTY;
        };
        NVDAPagedTextAreaState.prototype.toString = function () {
            return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ']';
        };
        NVDAPagedTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.NVDA) {
                return this;
            }
            return new IENarratorTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, 0);
        };
        NVDAPagedTextAreaState.prototype.equals = function (other) {
            if (other instanceof NVDAPagedTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode);
            }
            return false;
        };
        NVDAPagedTextAreaState.prototype.fromTextArea = function (textArea) {
            return new NVDAPagedTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode());
        };
        NVDAPagedTextAreaState._getPageOfLine = function (lineNumber) {
            return Math.floor((lineNumber - 1) / NVDAPagedTextAreaState._LINES_PER_PAGE);
        };
        NVDAPagedTextAreaState._getRangeForPage = function (page) {
            var offset = page * NVDAPagedTextAreaState._LINES_PER_PAGE;
            var startLineNumber = offset + 1;
            var endLineNumber = offset + NVDAPagedTextAreaState._LINES_PER_PAGE;
            return new range_1.Range(startLineNumber, 1, endLineNumber, 1073741824 /* MAX_SAFE_SMALL_INTEGER */);
        };
        NVDAPagedTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var selectionStartPage = NVDAPagedTextAreaState._getPageOfLine(selection.startLineNumber);
            var selectionStartPageRange = NVDAPagedTextAreaState._getRangeForPage(selectionStartPage);
            var selectionEndPage = NVDAPagedTextAreaState._getPageOfLine(selection.endLineNumber);
            var selectionEndPageRange = NVDAPagedTextAreaState._getRangeForPage(selectionEndPage);
            var pretextRange = selectionStartPageRange.intersectRanges(new range_1.Range(1, 1, selection.startLineNumber, selection.startColumn));
            var pretext = model.getValueInRange(pretextRange, editorCommon_1.EndOfLinePreference.LF);
            var lastLine = model.getLineCount();
            var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
            var posttextRange = selectionEndPageRange.intersectRanges(new range_1.Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));
            var posttext = model.getValueInRange(posttextRange, editorCommon_1.EndOfLinePreference.LF);
            var text = null;
            if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {
                // take full selection
                text = model.getValueInRange(selection, editorCommon_1.EndOfLinePreference.LF);
            }
            else {
                var selectionRange1 = selectionStartPageRange.intersectRanges(selection);
                var selectionRange2 = selectionEndPageRange.intersectRanges(selection);
                text = (model.getValueInRange(selectionRange1, editorCommon_1.EndOfLinePreference.LF)
                    + String.fromCharCode(8230)
                    + model.getValueInRange(selectionRange2, editorCommon_1.EndOfLinePreference.LF));
            }
            // Chromium handles very poorly text even of a few thousand chars
            // Cut text to avoid stalling the entire UI
            var LIMIT_CHARS = 500;
            if (pretext.length > LIMIT_CHARS) {
                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
            }
            if (posttext.length > LIMIT_CHARS) {
                posttext = posttext.substring(0, LIMIT_CHARS);
            }
            if (text.length > 2 * LIMIT_CHARS) {
                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
            }
            return new NVDAPagedTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false);
        };
        NVDAPagedTextAreaState.prototype.fromText = function (text) {
            return new NVDAPagedTextAreaState(this, text, 0, text.length, false);
        };
        NVDAPagedTextAreaState.prototype.resetSelection = function () {
            return new NVDAPagedTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode);
        };
        return NVDAPagedTextAreaState;
    }(TextAreaState));
    NVDAPagedTextAreaState.EMPTY = new NVDAPagedTextAreaState(null, '', 0, 0, false);
    NVDAPagedTextAreaState._LINES_PER_PAGE = 10;
    exports.NVDAPagedTextAreaState = NVDAPagedTextAreaState;
    var NVDAFullTextAreaState = (function (_super) {
        __extends(NVDAFullTextAreaState, _super);
        function NVDAFullTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            return _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode) || this;
        }
        NVDAFullTextAreaState.prototype.shallowClone = function () {
            return new NVDAFullTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        NVDAFullTextAreaState.prototype.toEmpty = function () {
            return NVDAFullTextAreaState.EMPTY;
        };
        NVDAFullTextAreaState.prototype.toString = function () {
            return '[ <ENTIRE TEXT' + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ']';
        };
        NVDAFullTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.NVDA) {
                return this;
            }
            return new IENarratorTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, 0);
        };
        NVDAFullTextAreaState.prototype.equals = function (other) {
            if (other instanceof NVDAFullTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode);
            }
            return false;
        };
        NVDAFullTextAreaState.prototype.fromTextArea = function (textArea) {
            return new NVDAFullTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode());
        };
        NVDAFullTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var pretext = model.getValueInRange(new range_1.Range(1, 1, selection.startLineNumber, selection.startColumn), editorCommon_1.EndOfLinePreference.LF);
            var text = model.getValueInRange(selection, editorCommon_1.EndOfLinePreference.LF);
            var lastLine = model.getLineCount();
            var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
            var posttext = model.getValueInRange(new range_1.Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn), editorCommon_1.EndOfLinePreference.LF);
            return new NVDAFullTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false);
        };
        NVDAFullTextAreaState.prototype.fromText = function (text) {
            return new NVDAFullTextAreaState(this, text, 0, text.length, false);
        };
        NVDAFullTextAreaState.prototype.resetSelection = function () {
            return new NVDAFullTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode);
        };
        return NVDAFullTextAreaState;
    }(TextAreaState));
    NVDAFullTextAreaState.EMPTY = new NVDAFullTextAreaState(null, '', 0, 0, false);
    exports.NVDAFullTextAreaState = NVDAFullTextAreaState;
});






define(__m[339/*vs/editor/common/controller/textAreaHandler*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,166/*vs/editor/common/controller/textAreaState*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, async_1, event_1, lifecycle_1, textAreaState_1, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReadFromTextArea;
    (function (ReadFromTextArea) {
        ReadFromTextArea[ReadFromTextArea["Type"] = 0] = "Type";
        ReadFromTextArea[ReadFromTextArea["Paste"] = 1] = "Paste";
    })(ReadFromTextArea || (ReadFromTextArea = {}));
    // See https://github.com/Microsoft/monaco-editor/issues/320
    var isChromev55 = (navigator.userAgent.indexOf('Chrome/55.') >= 0
        && navigator.userAgent.indexOf('Edge/') === -1);
    var TextAreaHandler = (function (_super) {
        __extends(TextAreaHandler, _super);
        function TextAreaHandler(Browser, strategy, textArea, model, flushAnyAccumulatedEvents) {
            var _this = _super.call(this) || this;
            _this._onKeyDown = _this._register(new event_1.Emitter());
            _this.onKeyDown = _this._onKeyDown.event;
            _this._onKeyUp = _this._register(new event_1.Emitter());
            _this.onKeyUp = _this._onKeyUp.event;
            _this._onCut = _this._register(new event_1.Emitter());
            _this.onCut = _this._onCut.event;
            _this._onPaste = _this._register(new event_1.Emitter());
            _this.onPaste = _this._onPaste.event;
            _this._onType = _this._register(new event_1.Emitter());
            _this.onType = _this._onType.event;
            _this._onCompositionStart = _this._register(new event_1.Emitter());
            _this.onCompositionStart = _this._onCompositionStart.event;
            _this._onCompositionUpdate = _this._register(new event_1.Emitter());
            _this.onCompositionUpdate = _this._onCompositionUpdate.event;
            _this._onCompositionEnd = _this._register(new event_1.Emitter());
            _this.onCompositionEnd = _this._onCompositionEnd.event;
            _this.Browser = Browser;
            _this.textArea = textArea;
            _this.model = model;
            _this.flushAnyAccumulatedEvents = flushAnyAccumulatedEvents;
            _this.selection = new range_1.Range(1, 1, 1, 1);
            _this.selections = [new range_1.Range(1, 1, 1, 1)];
            _this._nextCommand = 0 /* Type */;
            _this.asyncTriggerCut = new async_1.RunOnceScheduler(function () { return _this._onCut.fire(); }, 0);
            _this.lastCopiedValue = null;
            _this.lastCopiedValueIsFromEmptySelection = false;
            _this.textAreaState = textAreaState_1.createTextAreaState(strategy);
            _this.hasFocus = false;
            _this.lastCompositionEndTime = 0;
            _this._register(_this.textArea.onKeyDown(function (e) { return _this._onKeyDownHandler(e); }));
            _this._register(_this.textArea.onKeyUp(function (e) { return _this._onKeyUp.fire(e); }));
            _this._register(_this.textArea.onKeyPress(function (e) { return _this._onKeyPressHandler(e); }));
            _this.textareaIsShownAtCursor = false;
            _this._register(_this.textArea.onCompositionStart(function (e) {
                if (_this.textareaIsShownAtCursor) {
                    return;
                }
                _this.textareaIsShownAtCursor = true;
                // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
                if (!_this.Browser.isEdgeOrIE) {
                    _this.setTextAreaState('compositionstart', _this.textAreaState.toEmpty(), false);
                }
                _this._onCompositionStart.fire({
                    showAtLineNumber: _this.selection.startLineNumber,
                    showAtColumn: _this.selection.startColumn
                });
            }));
            _this._register(_this.textArea.onCompositionUpdate(function (e) {
                if (isChromev55) {
                    // See https://github.com/Microsoft/monaco-editor/issues/320
                    // where compositionupdate .data is broken in Chrome v55
                    // See https://bugs.chromium.org/p/chromium/issues/detail?id=677050#c9
                    e = {
                        locale: e.locale,
                        data: _this.textArea.getValue()
                    };
                }
                _this.textAreaState = _this.textAreaState.fromText(e.data);
                var typeInput = _this.textAreaState.updateComposition();
                _this._onType.fire(typeInput);
                _this._onCompositionUpdate.fire(e);
            }));
            var readFromTextArea = function () {
                _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
                var typeInput = _this.textAreaState.deduceInput();
                // console.log('==> DEDUCED INPUT: ' + JSON.stringify(typeInput));
                if (_this._nextCommand === 0 /* Type */) {
                    if (typeInput.text !== '') {
                        _this._onType.fire(typeInput);
                    }
                }
                else {
                    _this.executePaste(typeInput.text);
                    _this._nextCommand = 0 /* Type */;
                }
            };
            _this._register(_this.textArea.onCompositionEnd(function (e) {
                // console.log('onCompositionEnd: ' + e.data);
                _this.textAreaState = _this.textAreaState.fromText(e.data);
                var typeInput = _this.textAreaState.updateComposition();
                _this._onType.fire(typeInput);
                // Due to isEdgeOrIE (where the textarea was not cleared initially) and isChrome (the textarea is not updated correctly when composition ends)
                // we cannot assume the text at the end consists only of the composited text
                if (Browser.isEdgeOrIE || Browser.isChrome) {
                    _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
                }
                _this.lastCompositionEndTime = (new Date()).getTime();
                if (!_this.textareaIsShownAtCursor) {
                    return;
                }
                _this.textareaIsShownAtCursor = false;
                _this._onCompositionEnd.fire();
            }));
            _this._register(_this.textArea.onInput(function () {
                // console.log('onInput: ' + this.textArea.getValue());
                if (_this.textareaIsShownAtCursor) {
                    // console.log('::ignoring input event because the textarea is shown at cursor: ' + this.textArea.getValue());
                    return;
                }
                readFromTextArea();
            }));
            // --- Clipboard operations
            _this._register(_this.textArea.onCut(function (e) {
                // Ensure we have the latest selection => ask all pending events to be sent
                _this.flushAnyAccumulatedEvents();
                _this._ensureClipboardGetsEditorSelection(e);
                _this.asyncTriggerCut.schedule();
            }));
            _this._register(_this.textArea.onCopy(function (e) {
                // Ensure we have the latest selection => ask all pending events to be sent
                _this.flushAnyAccumulatedEvents();
                _this._ensureClipboardGetsEditorSelection(e);
            }));
            _this._register(_this.textArea.onPaste(function (e) {
                if (e.canUseTextData()) {
                    _this.executePaste(e.getTextData());
                }
                else {
                    if (_this.textArea.getSelectionStart() !== _this.textArea.getSelectionEnd()) {
                        // Clean up the textarea, to get a clean paste
                        _this.setTextAreaState('paste', _this.textAreaState.toEmpty(), false);
                    }
                    _this._nextCommand = 1 /* Paste */;
                }
            }));
            _this._writePlaceholderAndSelectTextArea('ctor', false);
            return _this;
        }
        TextAreaHandler.prototype.dispose = function () {
            this.asyncTriggerCut.dispose();
            _super.prototype.dispose.call(this);
        };
        // --- begin event handlers
        TextAreaHandler.prototype.setStrategy = function (strategy) {
            this.textAreaState = this.textAreaState.toStrategy(strategy);
        };
        TextAreaHandler.prototype.setHasFocus = function (isFocused) {
            if (this.hasFocus === isFocused) {
                // no change
                return;
            }
            this.hasFocus = isFocused;
            if (this.hasFocus) {
                this._writePlaceholderAndSelectTextArea('focusgain', false);
            }
        };
        TextAreaHandler.prototype.setCursorSelections = function (primary, secondary) {
            this.selection = primary;
            this.selections = [primary].concat(secondary);
            this._writePlaceholderAndSelectTextArea('selection changed', false);
        };
        // --- end event handlers
        TextAreaHandler.prototype.setTextAreaState = function (reason, textAreaState, forceFocus) {
            if (!this.hasFocus) {
                textAreaState = textAreaState.resetSelection();
            }
            textAreaState.applyToTextArea(reason, this.textArea, this.hasFocus || forceFocus);
            this.textAreaState = textAreaState;
        };
        TextAreaHandler.prototype._onKeyDownHandler = function (e) {
            if (e.equals(9 /* Escape */)) {
                // Prevent default always for `Esc`, otherwise it will generate a keypress
                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx
                e.preventDefault();
            }
            this._onKeyDown.fire(e);
        };
        TextAreaHandler.prototype._onKeyPressHandler = function (e) {
            if (!this.hasFocus) {
                // Sometimes, when doing Alt-Tab, in FF, a 'keypress' is sent before a 'focus'
                return;
            }
        };
        // ------------- Operations that are always executed asynchronously
        TextAreaHandler.prototype.executePaste = function (txt) {
            if (txt === '') {
                return;
            }
            var pasteOnNewLine = false;
            if (this.Browser.enableEmptySelectionClipboard) {
                pasteOnNewLine = (txt === this.lastCopiedValue && this.lastCopiedValueIsFromEmptySelection);
            }
            this._onPaste.fire({
                text: txt,
                pasteOnNewLine: pasteOnNewLine
            });
        };
        TextAreaHandler.prototype.focusTextArea = function () {
            this._writePlaceholderAndSelectTextArea('focusTextArea', true);
        };
        TextAreaHandler.prototype._writePlaceholderAndSelectTextArea = function (reason, forceFocus) {
            if (!this.textareaIsShownAtCursor) {
                // Do not write to the textarea if it is visible.
                if (this.Browser.isIPad) {
                    // Do not place anything in the textarea for the iPad
                    this.setTextAreaState(reason, this.textAreaState.toEmpty(), forceFocus);
                }
                else {
                    this.setTextAreaState(reason, this.textAreaState.fromEditorSelection(this.model, this.selection), forceFocus);
                }
            }
        };
        // ------------- Clipboard operations
        TextAreaHandler.prototype._ensureClipboardGetsEditorSelection = function (e) {
            var whatToCopy = this._getPlainTextToCopy();
            if (e.canUseTextData()) {
                e.setTextData(whatToCopy);
            }
            else {
                this.setTextAreaState('copy or cut', this.textAreaState.fromText(whatToCopy), false);
            }
            if (this.Browser.enableEmptySelectionClipboard) {
                if (this.Browser.isFirefox) {
                    // When writing "LINE\r\n" to the clipboard and then pasting,
                    // Firefox pastes "LINE\n", so let's work around this quirk
                    this.lastCopiedValue = whatToCopy.replace(/\r\n/g, '\n');
                }
                else {
                    this.lastCopiedValue = whatToCopy;
                }
                var selections = this.selections;
                this.lastCopiedValueIsFromEmptySelection = (selections.length === 1 && selections[0].isEmpty());
            }
        };
        TextAreaHandler.prototype._getPlainTextToCopy = function () {
            var newLineCharacter = this.model.getEOL();
            var selections = this.selections;
            if (selections.length === 1) {
                var range = selections[0];
                if (range.isEmpty()) {
                    if (this.Browser.enableEmptySelectionClipboard) {
                        var modelLineNumber = this.model.convertViewPositionToModelPosition(range.startLineNumber, 1).lineNumber;
                        return this.model.getModelLineContent(modelLineNumber) + newLineCharacter;
                    }
                    else {
                        return '';
                    }
                }
                return this.model.getValueInRange(range, editorCommon_1.EndOfLinePreference.TextDefined);
            }
            else {
                selections = selections.slice(0).sort(range_1.Range.compareRangesUsingStarts);
                var result = [];
                for (var i = 0; i < selections.length; i++) {
                    result.push(this.model.getValueInRange(selections[i], editorCommon_1.EndOfLinePreference.TextDefined));
                }
                return result.join(newLineCharacter);
            }
        };
        return TextAreaHandler;
    }(lifecycle_1.Disposable));
    exports.TextAreaHandler = TextAreaHandler;
});

define(__m[340/*vs/editor/common/core/editorState*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, strings, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorState = (function () {
        function EditorState(editor, flags) {
            var _this = this;
            this.flags = flags;
            flags.forEach(function (flag) {
                switch (flag) {
                    case editorCommon_1.CodeEditorStateFlag.Value:
                        var model = editor.getModel();
                        _this.modelVersionId = model ? strings.format('{0}#{1}', model.uri.toString(), model.getVersionId()) : null;
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Position:
                        _this.position = editor.getPosition();
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Selection:
                        _this.selection = editor.getSelection();
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Scroll:
                        _this.scrollLeft = editor.getScrollLeft();
                        _this.scrollTop = editor.getScrollTop();
                        break;
                }
            });
        }
        EditorState.prototype._equals = function (other) {
            if (!(other instanceof EditorState)) {
                return false;
            }
            var state = other;
            if (this.modelVersionId !== state.modelVersionId) {
                return false;
            }
            if (this.scrollLeft !== state.scrollLeft || this.scrollTop !== state.scrollTop) {
                return false;
            }
            if (!this.position && state.position || this.position && !state.position || this.position && state.position && !this.position.equals(state.position)) {
                return false;
            }
            if (!this.selection && state.selection || this.selection && !state.selection || this.selection && state.selection && !this.selection.equalsRange(state.selection)) {
                return false;
            }
            return true;
        };
        EditorState.prototype.validate = function (editor) {
            return this._equals(new EditorState(editor, this.flags));
        };
        return EditorState;
    }());
    exports.EditorState = EditorState;
});

define(__m[341/*vs/editor/common/model/textModelSearch*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, strings, position_1, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LIMIT_FIND_COUNT = 999;
    var SearchParams = (function () {
        function SearchParams(searchString, isRegex, matchCase, wholeWord) {
            this.searchString = searchString;
            this.isRegex = isRegex;
            this.matchCase = matchCase;
            this.wholeWord = wholeWord;
        }
        SearchParams._isMultilineRegexSource = function (searchString) {
            if (!searchString || searchString.length === 0) {
                return false;
            }
            for (var i = 0, len = searchString.length; i < len; i++) {
                var chCode = searchString.charCodeAt(i);
                if (chCode === 92 /* Backslash */) {
                    // move to next char
                    i++;
                    if (i >= len) {
                        // string ends with a \
                        break;
                    }
                    var nextChCode = searchString.charCodeAt(i);
                    if (nextChCode === 110 /* n */ || nextChCode === 114 /* r */) {
                        return true;
                    }
                }
            }
            return false;
        };
        SearchParams.prototype.parseSearchRequest = function () {
            if (this.searchString === '') {
                return null;
            }
            // Try to create a RegExp out of the params
            var multiline;
            if (this.isRegex) {
                multiline = SearchParams._isMultilineRegexSource(this.searchString);
            }
            else {
                multiline = (this.searchString.indexOf('\n') >= 0);
            }
            var regex = null;
            try {
                regex = strings.createRegExp(this.searchString, this.isRegex, {
                    matchCase: this.matchCase,
                    wholeWord: this.wholeWord,
                    multiline: multiline,
                    global: true
                });
            }
            catch (err) {
                return null;
            }
            if (!regex) {
                return null;
            }
            return regex;
        };
        return SearchParams;
    }());
    exports.SearchParams = SearchParams;
    function createFindMatch(range, rawMatches, captureMatches) {
        if (!captureMatches) {
            return new editorCommon_1.FindMatch(range, null);
        }
        var matches = [];
        for (var i = 0, len = rawMatches.length; i < len; i++) {
            matches[i] = rawMatches[i];
        }
        return new editorCommon_1.FindMatch(range, matches);
    }
    var TextModelSearch = (function () {
        function TextModelSearch() {
        }
        TextModelSearch.findMatches = function (model, searchParams, searchRange, captureMatches, limitResultCount) {
            var regex = searchParams.parseSearchRequest();
            if (!regex) {
                return [];
            }
            if (regex.multiline) {
                return this._doFindMatchesMultiline(model, searchRange, regex, captureMatches, limitResultCount);
            }
            return this._doFindMatchesLineByLine(model, searchRange, regex, captureMatches, limitResultCount);
        };
        TextModelSearch._doFindMatchesMultiline = function (model, searchRange, searchRegex, captureMatches, limitResultCount) {
            var deltaOffset = model.getOffsetAt(searchRange.getStartPosition());
            var text = model.getValueInRange(searchRange);
            var result = [];
            var prevStartOffset = 0;
            var prevEndOffset = 0;
            var counter = 0;
            var m;
            while ((m = searchRegex.exec(text))) {
                var startOffset = deltaOffset + m.index;
                var endOffset = startOffset + m[0].length;
                if (prevStartOffset === startOffset && prevEndOffset === endOffset) {
                    // Exit early if the regex matches the same range
                    return result;
                }
                var startPosition = model.getPositionAt(startOffset);
                var endPosition = model.getPositionAt(endOffset);
                result[counter++] = createFindMatch(new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column), m, captureMatches);
                if (counter >= limitResultCount) {
                    return result;
                }
                prevStartOffset = startOffset;
                prevEndOffset = endOffset;
            }
            return result;
        };
        TextModelSearch._doFindMatchesLineByLine = function (model, searchRange, searchRegex, captureMatches, limitResultCount) {
            var result = [];
            var counter = 0;
            // Early case for a search range that starts & stops on the same line number
            if (searchRange.startLineNumber === searchRange.endLineNumber) {
                var text_1 = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text_1, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, captureMatches, limitResultCount);
                return result;
            }
            // Collect results from first line
            var text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);
            counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, captureMatches, limitResultCount);
            // Collect results from middle lines
            for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && counter < limitResultCount; lineNumber++) {
                counter = this._findMatchesInLine(searchRegex, model.getLineContent(lineNumber), lineNumber, 0, counter, result, captureMatches, limitResultCount);
            }
            // Collect results from last line
            if (counter < limitResultCount) {
                var text_2 = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text_2, searchRange.endLineNumber, 0, counter, result, captureMatches, limitResultCount);
            }
            return result;
        };
        TextModelSearch._findMatchesInLine = function (searchRegex, text, lineNumber, deltaOffset, counter, result, captureMatches, limitResultCount) {
            var m;
            // Reset regex to search from the beginning
            searchRegex.lastIndex = 0;
            do {
                m = searchRegex.exec(text);
                if (m) {
                    var range = new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
                    if (result.length > 0 && range.equalsRange(result[result.length - 1].range)) {
                        // Exit early if the regex matches the same range
                        return counter;
                    }
                    result.push(createFindMatch(range, m, captureMatches));
                    counter++;
                    if (counter >= limitResultCount) {
                        return counter;
                    }
                    if (m.index + m[0].length === text.length) {
                        // Reached the end of the line
                        return counter;
                    }
                }
            } while (m);
            return counter;
        };
        TextModelSearch.findNextMatch = function (model, searchParams, searchStart, captureMatches) {
            var regex = searchParams.parseSearchRequest();
            if (!regex) {
                return null;
            }
            if (regex.multiline) {
                return this._doFindNextMatchMultiline(model, searchStart, regex, captureMatches);
            }
            return this._doFindNextMatchLineByLine(model, searchStart, regex, captureMatches);
        };
        TextModelSearch._doFindNextMatchMultiline = function (model, searchStart, searchRegex, captureMatches) {
            var searchTextStart = new position_1.Position(searchStart.lineNumber, 1);
            var deltaOffset = model.getOffsetAt(searchTextStart);
            var lineCount = model.getLineCount();
            var text = model.getValueInRange(new range_1.Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)));
            searchRegex.lastIndex = searchStart.column - 1;
            var m = searchRegex.exec(text);
            if (m) {
                var startOffset = deltaOffset + m.index;
                var endOffset = startOffset + m[0].length;
                var startPosition = model.getPositionAt(startOffset);
                var endPosition = model.getPositionAt(endOffset);
                return createFindMatch(new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column), m, captureMatches);
            }
            if (searchStart.lineNumber !== 1 || searchStart.column !== -1) {
                // Try again from the top
                return this._doFindNextMatchMultiline(model, new position_1.Position(1, 1), searchRegex, captureMatches);
            }
            return null;
        };
        TextModelSearch._doFindNextMatchLineByLine = function (model, searchStart, searchRegex, captureMatches) {
            var lineCount = model.getLineCount();
            var startLineNumber = searchStart.lineNumber;
            // Look in first line
            var text = model.getLineContent(startLineNumber);
            var r = this._findFirstMatchInLine(searchRegex, text, startLineNumber, searchStart.column, captureMatches);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (startLineNumber + i - 1) % lineCount;
                var text_3 = model.getLineContent(lineIndex + 1);
                var r_1 = this._findFirstMatchInLine(searchRegex, text_3, lineIndex + 1, 1, captureMatches);
                if (r_1) {
                    return r_1;
                }
            }
            return null;
        };
        TextModelSearch._findFirstMatchInLine = function (searchRegex, text, lineNumber, fromColumn, captureMatches) {
            // Set regex to search from column
            searchRegex.lastIndex = fromColumn - 1;
            var m = searchRegex.exec(text);
            if (m) {
                return createFindMatch(new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);
            }
            return null;
        };
        TextModelSearch.findPreviousMatch = function (model, searchParams, searchStart, captureMatches) {
            var regex = searchParams.parseSearchRequest();
            if (!regex) {
                return null;
            }
            if (regex.multiline) {
                return this._doFindPreviousMatchMultiline(model, searchStart, regex, captureMatches);
            }
            return this._doFindPreviousMatchLineByLine(model, searchStart, regex, captureMatches);
        };
        TextModelSearch._doFindPreviousMatchMultiline = function (model, searchStart, searchRegex, captureMatches) {
            var matches = this._doFindMatchesMultiline(model, new range_1.Range(1, 1, searchStart.lineNumber, searchStart.column), searchRegex, captureMatches, 10 * LIMIT_FIND_COUNT);
            if (matches.length > 0) {
                return matches[matches.length - 1];
            }
            var lineCount = model.getLineCount();
            if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {
                // Try again with all content
                return this._doFindPreviousMatchMultiline(model, new position_1.Position(lineCount, model.getLineMaxColumn(lineCount)), searchRegex, captureMatches);
            }
            return null;
        };
        TextModelSearch._doFindPreviousMatchLineByLine = function (model, searchStart, searchRegex, captureMatches) {
            var lineCount = model.getLineCount();
            var startLineNumber = searchStart.lineNumber;
            // Look in first line
            var text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);
            var r = this._findLastMatchInLine(searchRegex, text, startLineNumber, captureMatches);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
                var text_4 = model.getLineContent(lineIndex + 1);
                var r_2 = this._findLastMatchInLine(searchRegex, text_4, lineIndex + 1, captureMatches);
                if (r_2) {
                    return r_2;
                }
            }
            return null;
        };
        TextModelSearch._findLastMatchInLine = function (searchRegex, text, lineNumber, captureMatches) {
            var bestResult = null;
            var m;
            while ((m = searchRegex.exec(text))) {
                var result = new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length);
                if (bestResult && result.equalsRange(bestResult.range)) {
                    break;
                }
                bestResult = createFindMatch(result, m, captureMatches);
                if (m.index + m[0].length === text.length) {
                    // Reached the end of the line
                    break;
                }
            }
            return bestResult;
        };
        return TextModelSearch;
    }());
    exports.TextModelSearch = TextModelSearch;
});






define(__m[94/*vs/editor/common/model/textModel*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,9/*vs/base/common/strings*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,75/*vs/editor/common/model/modelLine*/,498/*vs/editor/common/model/indentationGuesser*/,44/*vs/editor/common/config/defaultConfig*/,85/*vs/editor/common/viewModel/prefixSumComputer*/,497/*vs/editor/common/model/indentRanges*/,341/*vs/editor/common/model/textModelSearch*/]), function (require, exports, eventEmitter_1, strings, position_1, range_1, editorCommon, modelLine_1, indentationGuesser_1, defaultConfig_1, prefixSumComputer_1, indentRanges_1, textModelSearch_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LIMIT_FIND_COUNT = 999;
    exports.LONG_LINE_BOUNDARY = 1000;
    var TextModel = (function (_super) {
        __extends(TextModel, _super);
        function TextModel(allowedEventTypes, rawText) {
            var _this = this;
            allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged, editorCommon.EventType.ModelOptionsChanged, editorCommon.EventType.ModelContentChanged2);
            _this = _super.call(this, allowedEventTypes) || this;
            _this._shouldSimplifyMode = (rawText.length > TextModel.MODEL_SYNC_LIMIT);
            _this._shouldDenyMode = (rawText.length > TextModel.MODEL_TOKENIZATION_LIMIT);
            _this._options = new editorCommon.TextModelResolvedOptions(rawText.options);
            _this._constructLines(rawText);
            _this._setVersionId(1);
            _this._isDisposed = false;
            _this._isDisposing = false;
            return _this;
        }
        TextModel.prototype._assertNotDisposed = function () {
            if (this._isDisposed) {
                throw new Error('Model is disposed!');
            }
        };
        TextModel.prototype.isTooLargeForHavingAMode = function () {
            this._assertNotDisposed();
            return this._shouldDenyMode;
        };
        TextModel.prototype.isTooLargeForHavingARichMode = function () {
            this._assertNotDisposed();
            return this._shouldSimplifyMode;
        };
        TextModel.prototype.getOptions = function () {
            this._assertNotDisposed();
            return this._options;
        };
        TextModel.prototype.updateOptions = function (_newOpts) {
            this._assertNotDisposed();
            var tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;
            var insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;
            var trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;
            var newOpts = new editorCommon.TextModelResolvedOptions({
                tabSize: tabSize,
                insertSpaces: insertSpaces,
                defaultEOL: this._options.defaultEOL,
                trimAutoWhitespace: trimAutoWhitespace
            });
            if (this._options.equals(newOpts)) {
                return;
            }
            var e = this._options.createChangeEvent(newOpts);
            this._options = newOpts;
            if (e.tabSize) {
                var newTabSize = this._options.tabSize;
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    this._lines[i].updateTabSize(newTabSize);
                }
            }
            this.emit(editorCommon.EventType.ModelOptionsChanged, e);
        };
        TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
            this._assertNotDisposed();
            var lines = this._lines.map(function (line) { return line.text; });
            var guessedIndentation = indentationGuesser_1.guessIndentation(lines, defaultTabSize, defaultInsertSpaces);
            this.updateOptions({
                insertSpaces: guessedIndentation.insertSpaces,
                tabSize: guessedIndentation.tabSize
            });
        };
        TextModel._normalizeIndentationFromWhitespace = function (str, tabSize, insertSpaces) {
            var spacesCnt = 0;
            for (var i = 0; i < str.length; i++) {
                if (str.charAt(i) === '\t') {
                    spacesCnt += tabSize;
                }
                else {
                    spacesCnt++;
                }
            }
            var result = '';
            if (!insertSpaces) {
                var tabsCnt = Math.floor(spacesCnt / tabSize);
                spacesCnt = spacesCnt % tabSize;
                for (var i = 0; i < tabsCnt; i++) {
                    result += '\t';
                }
            }
            for (var i = 0; i < spacesCnt; i++) {
                result += ' ';
            }
            return result;
        };
        TextModel.normalizeIndentation = function (str, tabSize, insertSpaces) {
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
            if (firstNonWhitespaceIndex === -1) {
                firstNonWhitespaceIndex = str.length;
            }
            return TextModel._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), tabSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);
        };
        TextModel.prototype.normalizeIndentation = function (str) {
            this._assertNotDisposed();
            return TextModel.normalizeIndentation(str, this._options.tabSize, this._options.insertSpaces);
        };
        TextModel.prototype.getOneIndent = function () {
            this._assertNotDisposed();
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            if (insertSpaces) {
                var result = '';
                for (var i = 0; i < tabSize; i++) {
                    result += ' ';
                }
                return result;
            }
            else {
                return '\t';
            }
        };
        TextModel.prototype.getVersionId = function () {
            this._assertNotDisposed();
            return this._versionId;
        };
        TextModel.prototype.mightContainRTL = function () {
            return this._mightContainRTL;
        };
        TextModel.prototype.mightContainNonBasicASCII = function () {
            return this._mightContainNonBasicASCII;
        };
        TextModel.prototype.getAlternativeVersionId = function () {
            this._assertNotDisposed();
            return this._alternativeVersionId;
        };
        TextModel.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var eolLength = this._EOL.length;
                var linesLength = this._lines.length;
                var lineStartValues = new Uint32Array(linesLength);
                for (var i = 0; i < linesLength; i++) {
                    lineStartValues[i] = this._lines[i].text.length + eolLength;
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        TextModel.prototype.getOffsetAt = function (rawPosition) {
            this._assertNotDisposed();
            var position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, false);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + position.column - 1;
        };
        TextModel.prototype.getPositionAt = function (offset) {
            this._assertNotDisposed();
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].text.length;
            // Ensure we return a valid position
            return new position_1.Position(out.index + 1, Math.min(out.remainder + 1, lineLength + 1));
        };
        TextModel.prototype._increaseVersionId = function () {
            this._setVersionId(this._versionId + 1);
        };
        TextModel.prototype._setVersionId = function (newVersionId) {
            this._versionId = newVersionId;
            this._alternativeVersionId = this._versionId;
        };
        TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
            this._alternativeVersionId = newAlternativeVersionId;
        };
        TextModel.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        TextModel.prototype.dispose = function () {
            this._isDisposed = true;
            // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
            this._lines = null;
            this._EOL = null;
            this._BOM = null;
            _super.prototype.dispose.call(this);
        };
        TextModel.prototype._createContentChangedFlushEvent = function () {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedFlush,
                detail: this.toRawText(),
                versionId: this._versionId,
                // TODO@Alex -> remove these fields from here
                isUndoing: false,
                isRedoing: false
            };
        };
        TextModel.prototype._emitContentChanged2 = function (startLineNumber, startColumn, endLineNumber, endColumn, rangeLength, text, isUndoing, isRedoing) {
            var e = {
                range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
                rangeLength: rangeLength,
                text: text,
                eol: this._EOL,
                versionId: this.getVersionId(),
                isUndoing: isUndoing,
                isRedoing: isRedoing
            };
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelContentChanged2, e);
            }
        };
        TextModel.prototype._resetValue = function (newValue) {
            this._constructLines(newValue);
            this._increaseVersionId();
        };
        TextModel.prototype.toRawText = function () {
            this._assertNotDisposed();
            return {
                BOM: this._BOM,
                EOL: this._EOL,
                lines: this.getLinesContent(),
                length: this.getValueLength(),
                containsRTL: this._mightContainRTL,
                isBasicASCII: !this._mightContainNonBasicASCII,
                options: this._options
            };
        };
        TextModel.prototype.equals = function (other) {
            this._assertNotDisposed();
            if (this._BOM !== other.BOM) {
                return false;
            }
            if (this._EOL !== other.EOL) {
                return false;
            }
            if (this._lines.length !== other.lines.length) {
                return false;
            }
            for (var i = 0, len = this._lines.length; i < len; i++) {
                if (this._lines[i].text !== other.lines[i]) {
                    return false;
                }
            }
            return true;
        };
        TextModel.prototype.setValue = function (value) {
            this._assertNotDisposed();
            if (value === null) {
                // There's nothing to do
                return;
            }
            var rawText = null;
            rawText = TextModel.toRawText(value, {
                tabSize: this._options.tabSize,
                insertSpaces: this._options.insertSpaces,
                trimAutoWhitespace: this._options.trimAutoWhitespace,
                detectIndentation: false,
                defaultEOL: this._options.defaultEOL
            });
            this.setValueFromRawText(rawText);
        };
        TextModel.prototype.setValueFromRawText = function (newValue) {
            this._assertNotDisposed();
            if (newValue === null) {
                // There's nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._resetValue(newValue);
            this._emitModelContentChangedFlushEvent(this._createContentChangedFlushEvent());
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getValue = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            this._assertNotDisposed();
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getValueLength = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            this._assertNotDisposed();
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM.length + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getEmptiedValueInRange = function (rawRange, fillCharacter, eol) {
            if (fillCharacter === void 0) { fillCharacter = ''; }
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            this._assertNotDisposed();
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._repeatCharacter(fillCharacter, range.endColumn - range.startColumn);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._repeatCharacter(fillCharacter, this._lines[startLineIndex].text.length - range.startColumn + 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._repeatCharacter(fillCharacter, this._lines[i].text.length));
            }
            resultLines.push(this._repeatCharacter(fillCharacter, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype._repeatCharacter = function (fillCharacter, count) {
            var r = '';
            for (var i = 0; i < count; i++) {
                r += fillCharacter;
            }
            return r;
        };
        TextModel.prototype.getValueInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            this._assertNotDisposed();
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._lines[range.startLineNumber - 1].text.substring(range.startColumn - 1, range.endColumn - 1);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._lines[startLineIndex].text.substring(range.startColumn - 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i].text);
            }
            resultLines.push(this._lines[endLineIndex].text.substring(0, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            this._assertNotDisposed();
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return 0;
            }
            if (range.startLineNumber === range.endLineNumber) {
                return (range.endColumn - range.startColumn);
            }
            var startOffset = this.getOffsetAt(new position_1.Position(range.startLineNumber, range.startColumn));
            var endOffset = this.getOffsetAt(new position_1.Position(range.endLineNumber, range.endColumn));
            return endOffset - startOffset;
        };
        TextModel.prototype.isDominatedByLongLines = function () {
            this._assertNotDisposed();
            var smallLineCharCount = 0, longLineCharCount = 0, i, len, lines = this._lines, lineLength;
            for (i = 0, len = this._lines.length; i < len; i++) {
                lineLength = lines[i].text.length;
                if (lineLength >= exports.LONG_LINE_BOUNDARY) {
                    longLineCharCount += lineLength;
                }
                else {
                    smallLineCharCount += lineLength;
                }
            }
            return (longLineCharCount > smallLineCharCount);
        };
        TextModel.prototype.getLineCount = function () {
            this._assertNotDisposed();
            return this._lines.length;
        };
        TextModel.prototype.getLineContent = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text;
        };
        TextModel.prototype.getIndentLevel = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].getIndentLevel();
        };
        TextModel.prototype._resetIndentRanges = function () {
            this._indentRanges = null;
        };
        TextModel.prototype._getIndentRanges = function () {
            if (!this._indentRanges) {
                this._indentRanges = indentRanges_1.computeRanges(this);
            }
            return this._indentRanges;
        };
        TextModel.prototype.getIndentRanges = function () {
            this._assertNotDisposed();
            var indentRanges = this._getIndentRanges();
            return indentRanges_1.IndentRange.deepCloneArr(indentRanges);
        };
        TextModel.prototype._toValidLineIndentGuide = function (lineNumber, indentGuide) {
            var lineIndentLevel = this._lines[lineNumber - 1].getIndentLevel();
            if (lineIndentLevel === -1) {
                return indentGuide;
            }
            var maxIndentGuide = Math.ceil(lineIndentLevel / this._options.tabSize);
            return Math.min(maxIndentGuide, indentGuide);
        };
        TextModel.prototype.getLineIndentGuide = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var indentRanges = this._getIndentRanges();
            for (var i = indentRanges.length - 1; i >= 0; i--) {
                var rng = indentRanges[i];
                if (rng.startLineNumber === lineNumber) {
                    return this._toValidLineIndentGuide(lineNumber, Math.ceil(rng.indent / this._options.tabSize));
                }
                if (rng.startLineNumber < lineNumber && lineNumber <= rng.endLineNumber) {
                    return this._toValidLineIndentGuide(lineNumber, 1 + Math.floor(rng.indent / this._options.tabSize));
                }
                if (rng.endLineNumber + 1 === lineNumber) {
                    var bestIndent = rng.indent;
                    while (i > 0) {
                        i--;
                        rng = indentRanges[i];
                        if (rng.endLineNumber + 1 === lineNumber) {
                            bestIndent = rng.indent;
                        }
                    }
                    return this._toValidLineIndentGuide(lineNumber, Math.ceil(bestIndent / this._options.tabSize));
                }
            }
            return 0;
        };
        TextModel.prototype.getLinesContent = function () {
            this._assertNotDisposed();
            var r = [];
            for (var i = 0, len = this._lines.length; i < len; i++) {
                r[i] = this._lines[i].text;
            }
            return r;
        };
        TextModel.prototype.getEOL = function () {
            this._assertNotDisposed();
            return this._EOL;
        };
        TextModel.prototype.setEOL = function (eol) {
            this._assertNotDisposed();
            var newEOL = (eol === editorCommon.EndOfLineSequence.CRLF ? '\r\n' : '\n');
            if (this._EOL === newEOL) {
                // Nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._EOL = newEOL;
            this._lineStarts = null;
            this._increaseVersionId();
            this._emitModelContentChangedFlushEvent(this._createContentChangedFlushEvent());
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getLineMinColumn = function (lineNumber) {
            this._assertNotDisposed();
            return 1;
        };
        TextModel.prototype.getLineMaxColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text.length + 1;
        };
        TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.firstNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.lastNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        TextModel.prototype.validateLineNumber = function (lineNumber) {
            this._assertNotDisposed();
            if (lineNumber < 1) {
                lineNumber = 1;
            }
            if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
            }
            return lineNumber;
        };
        /**
         * @param strict Do NOT allow a position inside a high-low surrogate pair
         */
        TextModel.prototype._validatePosition = function (_lineNumber, _column, strict) {
            var lineNumber = Math.floor(typeof _lineNumber === 'number' ? _lineNumber : 1);
            var column = Math.floor(typeof _column === 'number' ? _column : 1);
            if (lineNumber < 1) {
                return new position_1.Position(1, 1);
            }
            if (lineNumber > this._lines.length) {
                return new position_1.Position(this._lines.length, this.getLineMaxColumn(this._lines.length));
            }
            if (column <= 1) {
                return new position_1.Position(lineNumber, 1);
            }
            var maxColumn = this.getLineMaxColumn(lineNumber);
            if (column >= maxColumn) {
                return new position_1.Position(lineNumber, maxColumn);
            }
            if (strict) {
                // If the position would end up in the middle of a high-low surrogate pair,
                // we move it to before the pair
                // !!At this point, column > 1
                var charCodeBefore = this._lines[lineNumber - 1].text.charCodeAt(column - 2);
                if (strings.isHighSurrogate(charCodeBefore)) {
                    return new position_1.Position(lineNumber, column - 1);
                }
            }
            return new position_1.Position(lineNumber, column);
        };
        TextModel.prototype.validatePosition = function (position) {
            this._assertNotDisposed();
            return this._validatePosition(position.lineNumber, position.column, true);
        };
        TextModel.prototype.validateRange = function (_range) {
            this._assertNotDisposed();
            var start = this._validatePosition(_range.startLineNumber, _range.startColumn, false);
            var end = this._validatePosition(_range.endLineNumber, _range.endColumn, false);
            var startLineNumber = start.lineNumber;
            var startColumn = start.column;
            var endLineNumber = end.lineNumber;
            var endColumn = end.column;
            var startLineText = this._lines[startLineNumber - 1].text;
            var endLineText = this._lines[endLineNumber - 1].text;
            var charCodeBeforeStart = (startColumn > 1 ? startLineText.charCodeAt(startColumn - 2) : 0);
            var charCodeBeforeEnd = (endColumn > 1 && endColumn <= endLineText.length ? endLineText.charCodeAt(endColumn - 2) : 0);
            var startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);
            var endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);
            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {
                return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            if (startLineNumber === endLineNumber && startColumn === endColumn) {
                // do not expand a collapsed range, simply move it to a valid location
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);
            }
            if (startInsideSurrogatePair && endInsideSurrogatePair) {
                // expand range at both ends
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);
            }
            if (startInsideSurrogatePair) {
                // only expand range at the start
                return new range_1.Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);
            }
            // only expand range at the end
            return new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);
        };
        TextModel.prototype.modifyPosition = function (rawPosition, offset) {
            this._assertNotDisposed();
            return this.getPositionAt(this.getOffsetAt(rawPosition) + offset);
        };
        TextModel.prototype.getFullModelRange = function () {
            this._assertNotDisposed();
            var lineCount = this.getLineCount();
            return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
        };
        TextModel.prototype._emitModelContentChangedFlushEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelRawContentChanged, e);
            }
        };
        TextModel.toRawText = function (rawText, opts) {
            // Count the number of lines that end with \r\n
            var carriageReturnCnt = 0;
            var lastCarriageReturnIndex = -1;
            while ((lastCarriageReturnIndex = rawText.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
                carriageReturnCnt++;
            }
            var containsRTL = strings.containsRTL(rawText);
            var isBasicASCII = (containsRTL ? false : strings.isBasicASCII(rawText));
            // Split the text into lines
            var lines = rawText.split(/\r\n|\r|\n/);
            // Remove the BOM (if present)
            var BOM = '';
            if (strings.startsWithUTF8BOM(lines[0])) {
                BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
            var lineFeedCnt = lines.length - 1;
            var EOL = '';
            if (lineFeedCnt === 0) {
                // This is an empty file or a file with precisely one line
                EOL = (opts.defaultEOL === editorCommon.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            else if (carriageReturnCnt > lineFeedCnt / 2) {
                // More than half of the file contains \r\n ending lines
                EOL = '\r\n';
            }
            else {
                // At least one line more ends in \n
                EOL = '\n';
            }
            var resolvedOpts;
            if (opts.detectIndentation) {
                var guessedIndentation = indentationGuesser_1.guessIndentation(lines, opts.tabSize, opts.insertSpaces);
                resolvedOpts = new editorCommon.TextModelResolvedOptions({
                    tabSize: guessedIndentation.tabSize,
                    insertSpaces: guessedIndentation.insertSpaces,
                    trimAutoWhitespace: opts.trimAutoWhitespace,
                    defaultEOL: opts.defaultEOL
                });
            }
            else {
                resolvedOpts = new editorCommon.TextModelResolvedOptions({
                    tabSize: opts.tabSize,
                    insertSpaces: opts.insertSpaces,
                    trimAutoWhitespace: opts.trimAutoWhitespace,
                    defaultEOL: opts.defaultEOL
                });
            }
            return {
                BOM: BOM,
                EOL: EOL,
                lines: lines,
                length: rawText.length,
                containsRTL: containsRTL,
                isBasicASCII: isBasicASCII,
                options: resolvedOpts
            };
        };
        TextModel.prototype._constructLines = function (rawText) {
            var tabSize = rawText.options.tabSize;
            var rawLines = rawText.lines;
            var modelLines = [];
            for (var i = 0, len = rawLines.length; i < len; i++) {
                modelLines[i] = new modelLine_1.ModelLine(i + 1, rawLines[i], tabSize);
            }
            this._BOM = rawText.BOM;
            this._mightContainRTL = rawText.containsRTL;
            this._mightContainNonBasicASCII = !rawText.isBasicASCII;
            this._EOL = rawText.EOL;
            this._lines = modelLines;
            this._lineStarts = null;
            this._resetIndentRanges();
        };
        TextModel.prototype._getEndOfLine = function (eol) {
            switch (eol) {
                case editorCommon.EndOfLinePreference.LF:
                    return '\n';
                case editorCommon.EndOfLinePreference.CRLF:
                    return '\r\n';
                case editorCommon.EndOfLinePreference.TextDefined:
                    return this.getEOL();
            }
            throw new Error('Unknown EOL preference');
        };
        TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wholeWord, captureMatches, limitResultCount) {
            if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
            this._assertNotDisposed();
            var searchRange;
            if (range_1.Range.isIRange(rawSearchScope)) {
                searchRange = this.validateRange(rawSearchScope);
            }
            else {
                searchRange = this.getFullModelRange();
            }
            return textModelSearch_1.TextModelSearch.findMatches(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchRange, captureMatches, limitResultCount);
        };
        TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord, captureMatches) {
            this._assertNotDisposed();
            var searchStart = this.validatePosition(rawSearchStart);
            return textModelSearch_1.TextModelSearch.findNextMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchStart, captureMatches);
        };
        TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord, captureMatches) {
            this._assertNotDisposed();
            var searchStart = this.validatePosition(rawSearchStart);
            return textModelSearch_1.TextModelSearch.findPreviousMatch(this, new textModelSearch_1.SearchParams(searchString, isRegex, matchCase, wholeWord), searchStart, captureMatches);
        };
        return TextModel;
    }(eventEmitter_1.OrderGuaranteeEventEmitter));
    TextModel.MODEL_SYNC_LIMIT = 5 * 1024 * 1024; // 5 MB
    TextModel.MODEL_TOKENIZATION_LIMIT = 20 * 1024 * 1024; // 20 MB
    TextModel.DEFAULT_CREATION_OPTIONS = {
        tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
        insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
        detectIndentation: false,
        defaultEOL: editorCommon.DefaultEndOfLine.LF,
        trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
    };
    exports.TextModel = TextModel;
    var RawText = (function () {
        function RawText() {
        }
        RawText.fromString = function (rawText, opts) {
            return TextModel.toRawText(rawText, opts);
        };
        RawText.fromStringWithModelOptions = function (rawText, model) {
            var opts = model.getOptions();
            return TextModel.toRawText(rawText, {
                tabSize: opts.tabSize,
                insertSpaces: opts.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                detectIndentation: false,
                defaultEOL: opts.defaultEOL
            });
        };
        return RawText;
    }());
    exports.RawText = RawText;
});

define(__m[41/*vs/editor/common/controller/cursorCommon*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,2/*vs/editor/common/editorCommon*/,94/*vs/editor/common/model/textModel*/,20/*vs/editor/common/core/selection*/,4/*vs/editor/common/core/range*/]), function (require, exports, strings, editorCommon_1, textModel_1, selection_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CursorConfiguration = (function () {
        function CursorConfiguration(oneIndent, modelOptions, configuration, modeConfiguration) {
            var c = configuration.editor;
            this.tabSize = modelOptions.tabSize;
            this.insertSpaces = modelOptions.insertSpaces;
            this.oneIndent = oneIndent;
            this.pageSize = Math.floor(c.layoutInfo.height / c.fontInfo.lineHeight) - 2;
            this.useTabStops = c.useTabStops;
            this.wordSeparators = c.wordSeparators;
            this.autoClosingBrackets = c.autoClosingBrackets;
            this.autoClosingPairsOpen = modeConfiguration.autoClosingPairsOpen;
            this.autoClosingPairsClose = modeConfiguration.autoClosingPairsClose;
            this.surroundingPairs = modeConfiguration.surroundingPairs;
            this.electricChars = modeConfiguration.electricChars;
        }
        CursorConfiguration.shouldRecreate = function (e) {
            return (e.layoutInfo
                || e.wordSeparators
                || e.autoClosingBrackets
                || e.useTabStops);
        };
        CursorConfiguration.prototype.normalizeIndentation = function (str) {
            return textModel_1.TextModel.normalizeIndentation(str, this.tabSize, this.insertSpaces);
        };
        return CursorConfiguration;
    }());
    exports.CursorConfiguration = CursorConfiguration;
    /**
     * Represents the cursor state on either the model or on the view model.
     */
    var SingleCursorState = (function () {
        function SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns) {
            this.selectionStart = selectionStart;
            this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;
            this.position = position;
            this.leftoverVisibleColumns = leftoverVisibleColumns;
            this.selection = SingleCursorState._computeSelection(this.selectionStart, this.position);
        }
        SingleCursorState.prototype.equals = function (other) {
            return (this.selectionStartLeftoverVisibleColumns === other.selectionStartLeftoverVisibleColumns
                && this.leftoverVisibleColumns === other.leftoverVisibleColumns
                && this.position.equals(other.position)
                && this.selectionStart.equalsRange(other.selectionStart));
        };
        SingleCursorState.prototype.hasSelection = function () {
            return (!this.selection.isEmpty() || !this.selectionStart.isEmpty());
        };
        SingleCursorState.prototype.withSelectionStartLeftoverVisibleColumns = function (selectionStartLeftoverVisibleColumns) {
            return new SingleCursorState(this.selectionStart, selectionStartLeftoverVisibleColumns, this.position, this.leftoverVisibleColumns);
        };
        SingleCursorState.prototype.withSelectionStart = function (selectionStart) {
            return new SingleCursorState(selectionStart, 0, this.position, this.leftoverVisibleColumns);
        };
        SingleCursorState.prototype.collapse = function () {
            return new SingleCursorState(new range_1.Range(this.position.lineNumber, this.position.column, this.position.lineNumber, this.position.column), 0, this.position, 0);
        };
        SingleCursorState.prototype.move = function (inSelectionMode, position, leftoverVisibleColumns) {
            if (inSelectionMode) {
                // move just position
                return new SingleCursorState(this.selectionStart, this.selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);
            }
            else {
                // move everything
                return new SingleCursorState(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), leftoverVisibleColumns, position, leftoverVisibleColumns);
            }
        };
        SingleCursorState._computeSelection = function (selectionStart, position) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (selectionStart.isEmpty()) {
                startLineNumber = selectionStart.startLineNumber;
                startColumn = selectionStart.startColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
            else {
                if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {
                    startLineNumber = selectionStart.endLineNumber;
                    startColumn = selectionStart.endColumn;
                    endLineNumber = position.lineNumber;
                    endColumn = position.column;
                }
                else {
                    startLineNumber = selectionStart.startLineNumber;
                    startColumn = selectionStart.startColumn;
                    endLineNumber = position.lineNumber;
                    endColumn = position.column;
                }
            }
            return new selection_1.Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        return SingleCursorState;
    }());
    exports.SingleCursorState = SingleCursorState;
    var EditOperationResult = (function () {
        function EditOperationResult(command, opts) {
            this.command = command;
            this.shouldPushStackElementBefore = opts.shouldPushStackElementBefore;
            this.shouldPushStackElementAfter = opts.shouldPushStackElementAfter;
            this.isAutoWhitespaceCommand = false;
            this.shouldRevealHorizontal = true;
            this.cursorPositionChangeReason = editorCommon_1.CursorChangeReason.NotSet;
            if (typeof opts.isAutoWhitespaceCommand !== 'undefined') {
                this.isAutoWhitespaceCommand = opts.isAutoWhitespaceCommand;
            }
            if (typeof opts.shouldRevealHorizontal !== 'undefined') {
                this.shouldRevealHorizontal = opts.shouldRevealHorizontal;
            }
            if (typeof opts.cursorPositionChangeReason !== 'undefined') {
                this.cursorPositionChangeReason = opts.cursorPositionChangeReason;
            }
        }
        return EditOperationResult;
    }());
    exports.EditOperationResult = EditOperationResult;
    /**
     * Common operations that work and make sense both on the model and on the view model.
     */
    var CursorColumns = (function () {
        function CursorColumns() {
        }
        CursorColumns.isLowSurrogate = function (model, lineNumber, charOffset) {
            var lineContent = model.getLineContent(lineNumber);
            if (charOffset < 0 || charOffset >= lineContent.length) {
                return false;
            }
            return strings.isLowSurrogate(lineContent.charCodeAt(charOffset));
        };
        CursorColumns.isHighSurrogate = function (model, lineNumber, charOffset) {
            var lineContent = model.getLineContent(lineNumber);
            if (charOffset < 0 || charOffset >= lineContent.length) {
                return false;
            }
            return strings.isHighSurrogate(lineContent.charCodeAt(charOffset));
        };
        CursorColumns.isInsideSurrogatePair = function (model, lineNumber, column) {
            return this.isHighSurrogate(model, lineNumber, column - 2);
        };
        CursorColumns.visibleColumnFromColumn = function (lineContent, column, tabSize) {
            var endOffset = lineContent.length;
            if (endOffset > column - 1) {
                endOffset = column - 1;
            }
            var result = 0;
            for (var i = 0; i < endOffset; i++) {
                var charCode = lineContent.charCodeAt(i);
                if (charCode === 9 /* Tab */) {
                    result = this.nextTabStop(result, tabSize);
                }
                else {
                    result = result + 1;
                }
            }
            return result;
        };
        CursorColumns.visibleColumnFromColumn2 = function (config, model, position) {
            return this.visibleColumnFromColumn(model.getLineContent(position.lineNumber), position.column, config.tabSize);
        };
        CursorColumns.columnFromVisibleColumn = function (lineContent, visibleColumn, tabSize) {
            if (visibleColumn <= 0) {
                return 1;
            }
            var lineLength = lineContent.length;
            var beforeVisibleColumn = 0;
            for (var i = 0; i < lineLength; i++) {
                var charCode = lineContent.charCodeAt(i);
                var afterVisibleColumn = void 0;
                if (charCode === 9 /* Tab */) {
                    afterVisibleColumn = this.nextTabStop(beforeVisibleColumn, tabSize);
                }
                else {
                    afterVisibleColumn = beforeVisibleColumn + 1;
                }
                if (afterVisibleColumn >= visibleColumn) {
                    var prevDelta = visibleColumn - beforeVisibleColumn;
                    var afterDelta = afterVisibleColumn - visibleColumn;
                    if (afterDelta < prevDelta) {
                        return i + 2;
                    }
                    else {
                        return i + 1;
                    }
                }
                beforeVisibleColumn = afterVisibleColumn;
            }
            // walked the entire string
            return lineLength + 1;
        };
        CursorColumns.columnFromVisibleColumn2 = function (config, model, lineNumber, visibleColumn) {
            var result = this.columnFromVisibleColumn(model.getLineContent(lineNumber), visibleColumn, config.tabSize);
            var minColumn = model.getLineMinColumn(lineNumber);
            if (result < minColumn) {
                return minColumn;
            }
            var maxColumn = model.getLineMaxColumn(lineNumber);
            if (result > maxColumn) {
                return maxColumn;
            }
            return result;
        };
        /**
         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
         */
        CursorColumns.nextTabStop = function (visibleColumn, tabSize) {
            return visibleColumn + tabSize - visibleColumn % tabSize;
        };
        /**
         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
         */
        CursorColumns.prevTabStop = function (column, tabSize) {
            return column - 1 - (column - 1) % tabSize;
        };
        return CursorColumns;
    }());
    exports.CursorColumns = CursorColumns;
});

define(__m[344/*vs/editor/common/commands/shiftCommand*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,41/*vs/editor/common/controller/cursorCommon*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/]), function (require, exports, strings, cursorCommon_1, range_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ShiftCommand = (function () {
        function ShiftCommand(range, opts) {
            this._opts = opts;
            this._selection = range;
            this._useLastEditRangeForCursorEndPosition = false;
        }
        ShiftCommand.unshiftIndentCount = function (line, column, tabSize) {
            // Determine the visible column where the content starts
            var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);
            var desiredTabStop = cursorCommon_1.CursorColumns.prevTabStop(contentStartVisibleColumn, tabSize);
            // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
            return desiredTabStop / tabSize;
        };
        ShiftCommand.shiftIndentCount = function (line, column, tabSize) {
            // Determine the visible column where the content starts
            var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(line, column, tabSize);
            var desiredTabStop = cursorCommon_1.CursorColumns.nextTabStop(contentStartVisibleColumn, tabSize);
            // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
            return desiredTabStop / tabSize;
        };
        ShiftCommand.prototype.getEditOperations = function (model, builder) {
            var startLine = this._selection.startLineNumber;
            var endLine = this._selection.endLineNumber;
            if (this._selection.endColumn === 1 && startLine !== endLine) {
                endLine = endLine - 1;
            }
            var lineNumber, tabSize = this._opts.tabSize, oneIndent = this._opts.oneIndent, shouldIndentEmptyLines = (startLine === endLine);
            // indents[i] represents i * oneIndent
            var indents = ['', oneIndent];
            // if indenting or outdenting on a whitespace only line
            if (this._selection.isEmpty()) {
                if (/^\s*$/.test(model.getLineContent(startLine))) {
                    this._useLastEditRangeForCursorEndPosition = true;
                }
            }
            // keep track of previous line's "miss-alignment"
            var previousLineExtraSpaces = 0, extraSpaces = 0;
            for (lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
                extraSpaces = 0;
                var lineText = model.getLineContent(lineNumber);
                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);
                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
                    // empty line or line with no leading whitespace => nothing to do
                    continue;
                }
                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
                    // do not indent empty lines => nothing to do
                    continue;
                }
                if (indentationEndIndex === -1) {
                    // the entire line is whitespace
                    indentationEndIndex = lineText.length;
                }
                if (lineNumber > 1) {
                    var contentStartVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);
                    if (contentStartVisibleColumn % tabSize !== 0) {
                        // The current line is "miss-aligned", so let's see if this is expected...
                        // This can only happen when it has trailing commas in the indent
                        var enterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));
                        if (enterAction) {
                            extraSpaces = previousLineExtraSpaces;
                            if (enterAction.appendText) {
                                for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < tabSize; j++) {
                                    if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {
                                        extraSpaces++;
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                            if (enterAction.removeText) {
                                extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);
                            }
                            // Act as if `prefixSpaces` is not part of the indentation
                            for (var j = 0; j < extraSpaces; j++) {
                                if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {
                                    break;
                                }
                                indentationEndIndex--;
                            }
                        }
                    }
                }
                if (this._opts.isUnshift && indentationEndIndex === 0) {
                    // line with no leading whitespace => nothing to do
                    continue;
                }
                var desiredIndentCount = void 0;
                if (this._opts.isUnshift) {
                    desiredIndentCount = ShiftCommand.unshiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                else {
                    desiredIndentCount = ShiftCommand.shiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                // Fill `indents`, as needed
                for (var j = indents.length; j <= desiredIndentCount; j++) {
                    indents[j] = indents[j - 1] + oneIndent;
                }
                builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), indents[desiredIndentCount]);
            }
            this._selectionId = builder.trackSelection(this._selection);
        };
        ShiftCommand.prototype.computeCursorState = function (model, helper) {
            if (this._useLastEditRangeForCursorEndPosition) {
                var lastOp = helper.getInverseEditOperations()[0];
                return new selection_1.Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);
            }
            return helper.getTrackedSelection(this._selectionId);
        };
        return ShiftCommand;
    }());
    exports.ShiftCommand = ShiftCommand;
});

define(__m[345/*vs/editor/common/controller/cursorColumnSelection*/], __M([1/*require*/,0/*exports*/,20/*vs/editor/common/core/selection*/,16/*vs/editor/common/core/position*/,41/*vs/editor/common/controller/cursorCommon*/]), function (require, exports, selection_1, position_1, cursorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ColumnSelection = (function () {
        function ColumnSelection() {
        }
        ColumnSelection._columnSelect = function (config, model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {
            var lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;
            var reversed = (fromLineNumber > toLineNumber);
            var isRTL = (fromVisibleColumn > toVisibleColumn);
            var isLTR = (fromVisibleColumn < toVisibleColumn);
            var result = [];
            // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);
            for (var i = 0; i < lineCount; i++) {
                var lineNumber = fromLineNumber + (reversed ? -i : i);
                var startColumn = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, fromVisibleColumn);
                var endColumn = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, toVisibleColumn);
                var visibleStartColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, new position_1.Position(lineNumber, startColumn));
                var visibleEndColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, new position_1.Position(lineNumber, endColumn));
                // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);
                if (isLTR) {
                    if (visibleStartColumn > toVisibleColumn) {
                        continue;
                    }
                    if (visibleEndColumn < fromVisibleColumn) {
                        continue;
                    }
                }
                if (isRTL) {
                    if (visibleEndColumn > fromVisibleColumn) {
                        continue;
                    }
                    if (visibleStartColumn < toVisibleColumn) {
                        continue;
                    }
                }
                result.push(new selection_1.Selection(lineNumber, startColumn, lineNumber, endColumn));
            }
            return {
                viewSelections: result,
                reversed: reversed,
                toLineNumber: toLineNumber,
                toVisualColumn: toVisibleColumn
            };
        };
        ColumnSelection.columnSelect = function (config, model, fromViewPosition, toViewLineNumber, toViewVisualColumn) {
            var fromViewVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, fromViewPosition);
            return ColumnSelection._columnSelect(config, model, fromViewPosition.lineNumber, fromViewVisibleColumn, toViewLineNumber, toViewVisualColumn);
        };
        ColumnSelection.columnSelectLeft = function (config, model, cursor, toViewLineNumber, toViewVisualColumn) {
            if (toViewVisualColumn > 1) {
                toViewVisualColumn--;
            }
            return this.columnSelect(config, model, cursor.selection.getStartPosition(), toViewLineNumber, toViewVisualColumn);
        };
        ColumnSelection.columnSelectRight = function (config, model, cursor, toViewLineNumber, toViewVisualColumn) {
            var maxVisualViewColumn = 0;
            var minViewLineNumber = Math.min(cursor.position.lineNumber, toViewLineNumber);
            var maxViewLineNumber = Math.max(cursor.position.lineNumber, toViewLineNumber);
            for (var lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {
                var lineMaxViewColumn = model.getLineMaxColumn(lineNumber);
                var lineMaxVisualViewColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, new position_1.Position(lineNumber, lineMaxViewColumn));
                maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);
            }
            if (toViewVisualColumn < maxVisualViewColumn) {
                toViewVisualColumn++;
            }
            return this.columnSelect(config, model, cursor.selection.getStartPosition(), toViewLineNumber, toViewVisualColumn);
        };
        ColumnSelection.columnSelectUp = function (config, model, cursor, isPaged, toViewLineNumber, toViewVisualColumn) {
            var linesCount = isPaged ? config.pageSize : 1;
            toViewLineNumber -= linesCount;
            if (toViewLineNumber < 1) {
                toViewLineNumber = 1;
            }
            return this.columnSelect(config, model, cursor.selection.getStartPosition(), toViewLineNumber, toViewVisualColumn);
        };
        ColumnSelection.columnSelectDown = function (config, model, cursor, isPaged, toViewLineNumber, toViewVisualColumn) {
            var linesCount = isPaged ? config.pageSize : 1;
            toViewLineNumber += linesCount;
            if (toViewLineNumber > model.getLineCount()) {
                toViewLineNumber = model.getLineCount();
            }
            return this.columnSelect(config, model, cursor.selection.getStartPosition(), toViewLineNumber, toViewVisualColumn);
        };
        return ColumnSelection;
    }());
    exports.ColumnSelection = ColumnSelection;
});

define(__m[96/*vs/editor/common/controller/cursorMoveOperations*/], __M([1/*require*/,0/*exports*/,41/*vs/editor/common/controller/cursorCommon*/,2/*vs/editor/common/editorCommon*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/]), function (require, exports, cursorCommon_1, editorCommon_1, position_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CursorPosition = (function () {
        function CursorPosition(lineNumber, column, leftoverVisibleColumns) {
            this.lineNumber = lineNumber;
            this.column = column;
            this.leftoverVisibleColumns = leftoverVisibleColumns;
        }
        return CursorPosition;
    }());
    exports.CursorPosition = CursorPosition;
    var SingleMoveOperationResult = (function () {
        function SingleMoveOperationResult(state, ensureInEditableRange, reason) {
            this.state = state;
            this.ensureInEditableRange = ensureInEditableRange;
            this.reason = reason;
        }
        SingleMoveOperationResult.fromMove = function (initialState, inSelectionMode, lineNumber, column, leftoverVisibleColumns, ensureInEditableRange, reason) {
            return new SingleMoveOperationResult(initialState.move(inSelectionMode, new position_1.Position(lineNumber, column), leftoverVisibleColumns), ensureInEditableRange, reason);
        };
        return SingleMoveOperationResult;
    }());
    exports.SingleMoveOperationResult = SingleMoveOperationResult;
    var MoveOperations = (function () {
        function MoveOperations() {
        }
        MoveOperations.left = function (config, model, lineNumber, column) {
            if (column > model.getLineMinColumn(lineNumber)) {
                if (cursorCommon_1.CursorColumns.isLowSurrogate(model, lineNumber, column - 2)) {
                    // character before column is a low surrogate
                    column = column - 2;
                }
                else {
                    column = column - 1;
                }
            }
            else if (lineNumber > 1) {
                lineNumber = lineNumber - 1;
                column = model.getLineMaxColumn(lineNumber);
            }
            return new CursorPosition(lineNumber, column, 0);
        };
        MoveOperations.moveLeft = function (config, model, cursor, inSelectionMode, noOfColumns) {
            var lineNumber, column;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection
                lineNumber = cursor.selection.startLineNumber;
                column = cursor.selection.startColumn;
            }
            else {
                var r = MoveOperations.left(config, model, cursor.position.lineNumber, cursor.position.column - (noOfColumns - 1));
                lineNumber = r.lineNumber;
                column = r.column;
            }
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, column, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.right = function (config, model, lineNumber, column) {
            if (column < model.getLineMaxColumn(lineNumber)) {
                if (cursorCommon_1.CursorColumns.isHighSurrogate(model, lineNumber, column - 1)) {
                    // character after column is a high surrogate
                    column = column + 2;
                }
                else {
                    column = column + 1;
                }
            }
            else if (lineNumber < model.getLineCount()) {
                lineNumber = lineNumber + 1;
                column = model.getLineMinColumn(lineNumber);
            }
            return new CursorPosition(lineNumber, column, 0);
        };
        MoveOperations.moveRight = function (config, model, cursor, inSelectionMode, noOfColumns) {
            var lineNumber, column;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection
                lineNumber = cursor.selection.endLineNumber;
                column = cursor.selection.endColumn;
            }
            else {
                var r = MoveOperations.right(config, model, cursor.position.lineNumber, cursor.position.column + (noOfColumns - 1));
                lineNumber = r.lineNumber;
                column = r.column;
            }
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, column, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.down = function (config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
            var currentVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
            lineNumber = lineNumber + count;
            var lineCount = model.getLineCount();
            if (lineNumber > lineCount) {
                lineNumber = lineCount;
                if (allowMoveOnLastLine) {
                    column = model.getLineMaxColumn(lineNumber);
                }
                else {
                    column = Math.min(model.getLineMaxColumn(lineNumber), column);
                    if (cursorCommon_1.CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                        column = column - 1;
                    }
                }
            }
            else {
                column = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);
                if (cursorCommon_1.CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                    column = column - 1;
                }
            }
            leftoverVisibleColumns = currentVisibleColumn - cursorCommon_1.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);
            return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
        };
        MoveOperations.moveDown = function (config, model, cursor, inSelectionMode, linesCount) {
            var lineNumber, column;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move down acts relative to the end of selection
                lineNumber = cursor.selection.endLineNumber;
                column = cursor.selection.endColumn;
            }
            else {
                lineNumber = cursor.position.lineNumber;
                column = cursor.position.column;
            }
            var r = MoveOperations.down(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.translateDown = function (config, model, cursor) {
            var selection = cursor.selection;
            var selectionStart = MoveOperations.down(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
            var position = MoveOperations.down(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
            var tmp = new cursorCommon_1.SingleCursorState(new range_1.Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new position_1.Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
            return new SingleMoveOperationResult(tmp, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.up = function (config, model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
            var currentVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize) + leftoverVisibleColumns;
            lineNumber = lineNumber - count;
            if (lineNumber < 1) {
                lineNumber = 1;
                if (allowMoveOnFirstLine) {
                    column = model.getLineMinColumn(lineNumber);
                }
                else {
                    column = Math.min(model.getLineMaxColumn(lineNumber), column);
                    if (cursorCommon_1.CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                        column = column - 1;
                    }
                }
            }
            else {
                column = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, lineNumber, currentVisibleColumn);
                if (cursorCommon_1.CursorColumns.isInsideSurrogatePair(model, lineNumber, column)) {
                    column = column - 1;
                }
            }
            leftoverVisibleColumns = currentVisibleColumn - cursorCommon_1.CursorColumns.visibleColumnFromColumn(model.getLineContent(lineNumber), column, config.tabSize);
            return new CursorPosition(lineNumber, column, leftoverVisibleColumns);
        };
        MoveOperations.moveUp = function (config, model, cursor, inSelectionMode, linesCount) {
            var lineNumber, column;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move up acts relative to the beginning of selection
                lineNumber = cursor.selection.startLineNumber;
                column = cursor.selection.startColumn;
            }
            else {
                lineNumber = cursor.position.lineNumber;
                column = cursor.position.column;
            }
            var r = MoveOperations.up(config, model, lineNumber, column, cursor.leftoverVisibleColumns, linesCount, true);
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.translateUp = function (config, model, cursor) {
            var selection = cursor.selection;
            var selectionStart = MoveOperations.up(config, model, selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.selectionStartLeftoverVisibleColumns, 1, false);
            var position = MoveOperations.up(config, model, selection.positionLineNumber, selection.positionColumn, cursor.leftoverVisibleColumns, 1, false);
            var tmp = new cursorCommon_1.SingleCursorState(new range_1.Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), selectionStart.leftoverVisibleColumns, new position_1.Position(position.lineNumber, position.column), position.leftoverVisibleColumns);
            return new SingleMoveOperationResult(tmp, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.moveToBeginningOfLine = function (config, model, cursor, inSelectionMode) {
            var lineNumber = cursor.position.lineNumber;
            var minColumn = model.getLineMinColumn(lineNumber);
            var firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || minColumn;
            var column;
            var relevantColumnNumber = cursor.position.column;
            if (relevantColumnNumber === firstNonBlankColumn) {
                column = minColumn;
            }
            else {
                column = firstNonBlankColumn;
            }
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, column, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.moveToEndOfLine = function (config, model, cursor, inSelectionMode) {
            var lineNumber = cursor.position.lineNumber;
            var maxColumn = model.getLineMaxColumn(lineNumber);
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, maxColumn, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.moveToBeginningOfBuffer = function (config, model, cursor, inSelectionMode) {
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, 1, 1, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        MoveOperations.moveToEndOfBuffer = function (config, model, cursor, inSelectionMode) {
            var lastLineNumber = model.getLineCount();
            var lastColumn = model.getLineMaxColumn(lastLineNumber);
            return SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lastLineNumber, lastColumn, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        return MoveOperations;
    }());
    exports.MoveOperations = MoveOperations;
});

define(__m[123/*vs/editor/common/controller/cursorDeleteOperations*/], __M([1/*require*/,0/*exports*/,62/*vs/editor/common/commands/replaceCommand*/,41/*vs/editor/common/controller/cursorCommon*/,4/*vs/editor/common/core/range*/,96/*vs/editor/common/controller/cursorMoveOperations*/,9/*vs/base/common/strings*/]), function (require, exports, replaceCommand_1, cursorCommon_1, range_1, cursorMoveOperations_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DeleteOperations = (function () {
        function DeleteOperations() {
        }
        DeleteOperations.deleteRight = function (config, model, cursor) {
            var deleteSelection = cursor.selection;
            if (deleteSelection.isEmpty()) {
                var position = cursor.position;
                var rightOfPosition = cursorMoveOperations_1.MoveOperations.right(config, model, position.lineNumber, position.column);
                deleteSelection = new range_1.Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);
            }
            if (deleteSelection.isEmpty()) {
                // Probably at end of file => ignore
                return null;
            }
            var shouldPushStackElementBefore = false;
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                shouldPushStackElementBefore = true;
            }
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                shouldPushStackElementBefore: shouldPushStackElementBefore,
                shouldPushStackElementAfter: false
            });
        };
        DeleteOperations.autoClosingPairDelete = function (config, model, cursor) {
            if (!config.autoClosingBrackets) {
                return null;
            }
            if (!cursor.selection.isEmpty()) {
                return null;
            }
            var position = cursor.position;
            var lineText = model.getLineContent(position.lineNumber);
            var character = lineText[position.column - 2];
            if (!config.autoClosingPairsOpen.hasOwnProperty(character)) {
                return null;
            }
            var afterCharacter = lineText[position.column - 1];
            var closeCharacter = config.autoClosingPairsOpen[character];
            if (afterCharacter !== closeCharacter) {
                return null;
            }
            var deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false
            });
        };
        DeleteOperations.deleteLeft = function (config, model, cursor) {
            var r = this.autoClosingPairDelete(config, model, cursor);
            if (r) {
                // This was a case for an auto-closing pair delete
                return r;
            }
            var deleteSelection = cursor.selection;
            if (deleteSelection.isEmpty()) {
                var position = cursor.position;
                if (config.useTabStops && position.column > 1) {
                    var lineContent = model.getLineContent(position.lineNumber);
                    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
                    var lastIndentationColumn = (firstNonWhitespaceIndex === -1
                        ? lineContent.length + 1
                        : firstNonWhitespaceIndex + 1);
                    if (position.column <= lastIndentationColumn) {
                        var fromVisibleColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);
                        var toVisibleColumn = cursorCommon_1.CursorColumns.prevTabStop(fromVisibleColumn, config.tabSize);
                        var toColumn = cursorCommon_1.CursorColumns.columnFromVisibleColumn2(config, model, position.lineNumber, toVisibleColumn);
                        deleteSelection = new range_1.Range(position.lineNumber, toColumn, position.lineNumber, position.column);
                    }
                    else {
                        deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);
                    }
                }
                else {
                    var leftOfPosition = cursorMoveOperations_1.MoveOperations.left(config, model, position.lineNumber, position.column);
                    deleteSelection = new range_1.Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);
                }
            }
            if (deleteSelection.isEmpty()) {
                // Probably at beginning of file => ignore
                return null;
            }
            var shouldPushStackElementBefore = false;
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                shouldPushStackElementBefore = true;
            }
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                shouldPushStackElementBefore: shouldPushStackElementBefore,
                shouldPushStackElementAfter: false
            });
        };
        DeleteOperations.cut = function (config, model, cursor, enableEmptySelectionClipboard) {
            var selection = cursor.selection;
            if (selection.isEmpty()) {
                if (enableEmptySelectionClipboard) {
                    // This is a full line cut
                    var position = cursor.position;
                    var startLineNumber = void 0, startColumn = void 0, endLineNumber = void 0, endColumn = void 0;
                    if (position.lineNumber < model.getLineCount()) {
                        // Cutting a line in the middle of the model
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber + 1;
                        endColumn = 1;
                    }
                    else if (position.lineNumber > 1) {
                        // Cutting the last line & there are more than 1 lines in the model
                        startLineNumber = position.lineNumber - 1;
                        startColumn = model.getLineMaxColumn(position.lineNumber - 1);
                        endLineNumber = position.lineNumber;
                        endColumn = model.getLineMaxColumn(position.lineNumber);
                    }
                    else {
                        // Cutting the single line that the model contains
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber;
                        endColumn = model.getLineMaxColumn(position.lineNumber);
                    }
                    var deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
                    if (!deleteSelection.isEmpty()) {
                        return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                            shouldPushStackElementBefore: true,
                            shouldPushStackElementAfter: true
                        });
                    }
                    else {
                        return null;
                    }
                }
                else {
                    // Cannot cut empty selection
                    return null;
                }
            }
            else {
                // Delete left or right, they will both result in the selection being deleted
                return this.deleteRight(config, model, cursor);
            }
        };
        return DeleteOperations;
    }());
    exports.DeleteOperations = DeleteOperations;
});

define(__m[348/*vs/editor/common/controller/cursorTypeOperations*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,62/*vs/editor/common/commands/replaceCommand*/,41/*vs/editor/common/controller/cursorCommon*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,9/*vs/base/common/strings*/,344/*vs/editor/common/commands/shiftCommand*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,54/*vs/editor/common/modes/languageConfiguration*/,466/*vs/editor/common/commands/surroundSelectionCommand*/]), function (require, exports, errors_1, replaceCommand_1, cursorCommon_1, range_1, editorCommon_1, strings, shiftCommand_1, languageConfigurationRegistry_1, languageConfiguration_1, surroundSelectionCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TypeOperations = (function () {
        function TypeOperations() {
        }
        TypeOperations.indent = function (config, model, cursor) {
            return new cursorCommon_1.EditOperationResult(new shiftCommand_1.ShiftCommand(cursor.selection, {
                isUnshift: false,
                tabSize: config.tabSize,
                oneIndent: config.oneIndent
            }), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true,
                shouldRevealHorizontal: false
            });
        };
        TypeOperations.outdent = function (config, model, cursor) {
            return new cursorCommon_1.EditOperationResult(new shiftCommand_1.ShiftCommand(cursor.selection, {
                isUnshift: true,
                tabSize: config.tabSize,
                oneIndent: config.oneIndent
            }), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true,
                shouldRevealHorizontal: false
            });
        };
        TypeOperations.paste = function (config, model, cursor, text, pasteOnNewLine) {
            var position = cursor.position;
            var selection = cursor.selection;
            if (pasteOnNewLine && text.indexOf('\n') !== text.length - 1) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine && selection.startLineNumber !== selection.endLineNumber) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine && selection.startColumn === model.getLineMinColumn(selection.startLineNumber) && selection.endColumn === model.getLineMaxColumn(selection.startLineNumber)) {
                pasteOnNewLine = false;
            }
            if (pasteOnNewLine) {
                // Paste entire line at the beginning of line
                var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, 1);
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, text), {
                    shouldPushStackElementBefore: true,
                    shouldPushStackElementAfter: true,
                    cursorPositionChangeReason: editorCommon_1.CursorChangeReason.Paste
                });
            }
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(selection, text), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true,
                cursorPositionChangeReason: editorCommon_1.CursorChangeReason.Paste
            });
        };
        TypeOperations._goodIndentForLine = function (config, model, lineNumber) {
            var lastLineNumber = lineNumber - 1;
            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                var lineText = model.getLineContent(lastLineNumber);
                var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);
                if (nonWhitespaceIdx >= 0) {
                    break;
                }
            }
            if (lastLineNumber < 1) {
                // No previous line with content found
                return '\t';
            }
            var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterActionAtPosition(model, lastLineNumber, model.getLineMaxColumn(lastLineNumber));
            var indentation;
            if (r.enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {
                var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(r.indentation, r.indentation.length, config.tabSize);
                indentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    indentation += '\t';
                }
                indentation = config.normalizeIndentation(indentation);
            }
            else {
                indentation = r.indentation;
            }
            var result = indentation + r.enterAction.appendText;
            if (result.length === 0) {
                // good position is at column 1, but we gotta do something...
                return '\t';
            }
            return result;
        };
        TypeOperations._replaceJumpToNextIndent = function (config, model, selection) {
            var typeText = '';
            var position = selection.getStartPosition();
            if (config.insertSpaces) {
                var visibleColumnFromColumn = cursorCommon_1.CursorColumns.visibleColumnFromColumn2(config, model, position);
                var tabSize = config.tabSize;
                var spacesCnt = tabSize - (visibleColumnFromColumn % tabSize);
                for (var i = 0; i < spacesCnt; i++) {
                    typeText += ' ';
                }
            }
            else {
                typeText = '\t';
            }
            return new replaceCommand_1.ReplaceCommand(selection, typeText);
        };
        TypeOperations.tab = function (config, model, cursor) {
            var selection = cursor.selection;
            if (selection.isEmpty()) {
                var lineText = model.getLineContent(selection.startLineNumber);
                if (/^\s*$/.test(lineText)) {
                    var possibleTypeText = config.normalizeIndentation(this._goodIndentForLine(config, model, selection.startLineNumber));
                    if (!strings.startsWith(lineText, possibleTypeText)) {
                        var command = new replaceCommand_1.ReplaceCommand(new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, lineText.length + 1), possibleTypeText);
                        return new cursorCommon_1.EditOperationResult(command, {
                            shouldPushStackElementBefore: false,
                            shouldPushStackElementAfter: false,
                            isAutoWhitespaceCommand: true
                        });
                    }
                }
                return new cursorCommon_1.EditOperationResult(this._replaceJumpToNextIndent(config, model, selection), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false,
                    isAutoWhitespaceCommand: true
                });
            }
            else {
                if (selection.startLineNumber === selection.endLineNumber) {
                    var lineMaxColumn = model.getLineMaxColumn(selection.startLineNumber);
                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {
                        // This is a single line selection that is not the entire line
                        return new cursorCommon_1.EditOperationResult(this._replaceJumpToNextIndent(config, model, selection), {
                            shouldPushStackElementBefore: false,
                            shouldPushStackElementAfter: false
                        });
                    }
                }
                return this.indent(config, model, cursor);
            }
        };
        TypeOperations.replacePreviousChar = function (config, model, cursor, txt, replaceCharCnt) {
            var pos = cursor.position;
            var startColumn = Math.max(1, pos.column - replaceCharCnt);
            var range = new range_1.Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(range, txt), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false
            });
        };
        TypeOperations.typeCommand = function (range, text, keepPosition) {
            if (keepPosition) {
                return new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, text);
            }
            else {
                return new replaceCommand_1.ReplaceCommand(range, text);
            }
        };
        TypeOperations._enter = function (config, model, keepPosition, range) {
            var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterActionAtPosition(model, range.startLineNumber, range.startColumn);
            var enterAction = r.enterAction;
            var indentation = r.indentation;
            var executeCommand;
            if (enterAction.indentAction === languageConfiguration_1.IndentAction.None) {
                // Nothing special
                executeCommand = TypeOperations.typeCommand(range, '\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);
            }
            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Indent) {
                // Indent once
                executeCommand = TypeOperations.typeCommand(range, '\n' + config.normalizeIndentation(indentation + enterAction.appendText), keepPosition);
            }
            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.IndentOutdent) {
                // Ultra special
                var normalIndent = config.normalizeIndentation(indentation);
                var increasedIndent = config.normalizeIndentation(indentation + enterAction.appendText);
                var typeText = '\n' + increasedIndent + '\n' + normalIndent;
                if (keepPosition) {
                    executeCommand = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, typeText);
                }
                else {
                    executeCommand = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length);
                }
            }
            else if (enterAction.indentAction === languageConfiguration_1.IndentAction.Outdent) {
                var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + 1, config.tabSize);
                var actualIndentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    actualIndentation += '\t';
                }
                executeCommand = TypeOperations.typeCommand(range, '\n' + config.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition);
            }
            return new cursorCommon_1.EditOperationResult(executeCommand, {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: false,
                isAutoWhitespaceCommand: true
            });
        };
        TypeOperations._typeInterceptorEnter = function (config, model, cursor, ch) {
            if (ch !== '\n') {
                return null;
            }
            return TypeOperations._enter(config, model, false, cursor.selection);
        };
        TypeOperations._typeInterceptorAutoClosingCloseChar = function (config, model, cursor, ch) {
            if (!config.autoClosingBrackets) {
                return null;
            }
            var selection = cursor.selection;
            if (!selection.isEmpty() || !config.autoClosingPairsClose.hasOwnProperty(ch)) {
                return null;
            }
            var position = cursor.position;
            var lineText = model.getLineContent(position.lineNumber);
            var beforeCharacter = lineText.charAt(position.column - 1);
            if (beforeCharacter !== ch) {
                return null;
            }
            var typeSelection = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, ch), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false
            });
        };
        TypeOperations._typeInterceptorAutoClosingOpenChar = function (config, model, cursor, ch) {
            if (!config.autoClosingBrackets) {
                return null;
            }
            var selection = cursor.selection;
            if (!selection.isEmpty() || !config.autoClosingPairsOpen.hasOwnProperty(ch)) {
                return null;
            }
            var position = cursor.position;
            var lineText = model.getLineContent(position.lineNumber);
            var beforeCharacter = lineText.charAt(position.column - 1);
            // Only consider auto closing the pair if a space follows or if another autoclosed pair follows
            if (beforeCharacter) {
                var isBeforeCloseBrace = false;
                for (var closeBrace in config.autoClosingPairsClose) {
                    if (beforeCharacter === closeBrace) {
                        isBeforeCloseBrace = true;
                        break;
                    }
                }
                if (!isBeforeCloseBrace && !/\s/.test(beforeCharacter)) {
                    return null;
                }
            }
            var lineTokens = model.getLineTokens(position.lineNumber, false);
            var shouldAutoClosePair = false;
            try {
                shouldAutoClosePair = languageConfigurationRegistry_1.LanguageConfigurationRegistry.shouldAutoClosePair(ch, lineTokens, position.column);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!shouldAutoClosePair) {
                return null;
            }
            var closeCharacter = config.autoClosingPairsOpen[ch];
            return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: false
            });
        };
        TypeOperations._typeInterceptorSurroundSelection = function (config, model, cursor, ch) {
            if (!config.autoClosingBrackets) {
                return null;
            }
            var selection = cursor.selection;
            if (selection.isEmpty() || !config.surroundingPairs.hasOwnProperty(ch)) {
                return null;
            }
            var selectionContainsOnlyWhitespace = true;
            for (var lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {
                var lineText = model.getLineContent(lineNumber);
                var startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);
                var endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);
                for (var charIndex = startIndex; charIndex < endIndex; charIndex++) {
                    var charCode = lineText.charCodeAt(charIndex);
                    if (charCode !== 9 /* Tab */ && charCode !== 32 /* Space */) {
                        selectionContainsOnlyWhitespace = false;
                        // Break outer loop
                        lineNumber = selection.endLineNumber + 1;
                        // Break inner loop
                        charIndex = endIndex;
                    }
                }
            }
            if (selectionContainsOnlyWhitespace) {
                return null;
            }
            var closeCharacter = config.surroundingPairs[ch];
            return new cursorCommon_1.EditOperationResult(new surroundSelectionCommand_1.SurroundSelectionCommand(selection, ch, closeCharacter), {
                shouldPushStackElementBefore: true,
                shouldPushStackElementAfter: true
            });
        };
        TypeOperations._typeInterceptorElectricChar = function (config, model, cursor, ch) {
            if (!config.electricChars.hasOwnProperty(ch)) {
                return null;
            }
            var position = cursor.position;
            var lineTokens = model.getLineTokens(position.lineNumber, false);
            var electricAction;
            try {
                electricAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.onElectricCharacter(ch, lineTokens, position.column);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!electricAction) {
                return null;
            }
            if (electricAction.appendText) {
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithOffsetCursorState(cursor.selection, ch + electricAction.appendText, 0, -electricAction.appendText.length), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: true
                });
            }
            if (electricAction.matchOpenBracket) {
                var match = model.findMatchingBracketUp(electricAction.matchOpenBracket, {
                    lineNumber: position.lineNumber,
                    column: position.column
                });
                if (match) {
                    var matchLine = model.getLineContent(match.startLineNumber);
                    var matchLineIndentation = strings.getLeadingWhitespace(matchLine);
                    var newIndentation = config.normalizeIndentation(matchLineIndentation);
                    var lineText = model.getLineContent(position.lineNumber);
                    var lineFirstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;
                    var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);
                    var typeText = newIndentation + prefix + ch;
                    var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, position.column);
                    return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(typeSelection, typeText), {
                        shouldPushStackElementBefore: false,
                        shouldPushStackElementAfter: true
                    });
                }
            }
            return null;
        };
        TypeOperations.typeWithInterceptors = function (config, model, cursor, ch) {
            var r = null;
            r = r || this._typeInterceptorEnter(config, model, cursor, ch);
            r = r || this._typeInterceptorAutoClosingCloseChar(config, model, cursor, ch);
            r = r || this._typeInterceptorAutoClosingOpenChar(config, model, cursor, ch);
            r = r || this._typeInterceptorSurroundSelection(config, model, cursor, ch);
            r = r || this._typeInterceptorElectricChar(config, model, cursor, ch);
            r = r || this.typeWithoutInterceptors(config, model, cursor, ch);
            return r;
        };
        TypeOperations.typeWithoutInterceptors = function (config, model, cursor, str) {
            return new cursorCommon_1.EditOperationResult(TypeOperations.typeCommand(cursor.selection, str, false), {
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false
            });
        };
        TypeOperations.lineInsertBefore = function (config, model, cursor) {
            var lineNumber = cursor.position.lineNumber;
            if (lineNumber === 1) {
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommandWithoutChangingPosition(new range_1.Range(1, 1, 1, 1), '\n'), {
                    shouldPushStackElementBefore: true,
                    shouldPushStackElementAfter: true
                });
            }
            lineNumber--;
            var column = model.getLineMaxColumn(lineNumber);
            return this._enter(config, model, false, new range_1.Range(lineNumber, column, lineNumber, column));
        };
        TypeOperations.lineInsertAfter = function (config, model, cursor) {
            var position = cursor.position;
            var column = model.getLineMaxColumn(position.lineNumber);
            return this._enter(config, model, false, new range_1.Range(position.lineNumber, column, position.lineNumber, column));
        };
        TypeOperations.lineBreakInsert = function (config, model, cursor) {
            return this._enter(config, model, true, cursor.selection);
        };
        return TypeOperations;
    }());
    exports.TypeOperations = TypeOperations;
});






define(__m[124/*vs/editor/common/controller/cursorWordOperations*/], __M([1/*require*/,0/*exports*/,41/*vs/editor/common/controller/cursorCommon*/,16/*vs/editor/common/core/position*/,65/*vs/editor/common/core/characterClassifier*/,96/*vs/editor/common/controller/cursorMoveOperations*/,2/*vs/editor/common/editorCommon*/,123/*vs/editor/common/controller/cursorDeleteOperations*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/,62/*vs/editor/common/commands/replaceCommand*/]), function (require, exports, cursorCommon_1, position_1, characterClassifier_1, cursorMoveOperations_1, editorCommon_1, cursorDeleteOperations_1, strings, range_1, replaceCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var WordType;
    (function (WordType) {
        WordType[WordType["None"] = 0] = "None";
        WordType[WordType["Regular"] = 1] = "Regular";
        WordType[WordType["Separator"] = 2] = "Separator";
    })(WordType = exports.WordType || (exports.WordType = {}));
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["Regular"] = 0] = "Regular";
        CharacterClass[CharacterClass["Whitespace"] = 1] = "Whitespace";
        CharacterClass[CharacterClass["WordSeparator"] = 2] = "WordSeparator";
    })(CharacterClass || (CharacterClass = {}));
    var WordNavigationType;
    (function (WordNavigationType) {
        WordNavigationType[WordNavigationType["WordStart"] = 0] = "WordStart";
        WordNavigationType[WordNavigationType["WordEnd"] = 1] = "WordEnd";
    })(WordNavigationType = exports.WordNavigationType || (exports.WordNavigationType = {}));
    var WordCharacterClassifier = (function (_super) {
        __extends(WordCharacterClassifier, _super);
        function WordCharacterClassifier(wordSeparators) {
            var _this = _super.call(this, 0 /* Regular */) || this;
            for (var i = 0, len = wordSeparators.length; i < len; i++) {
                _this.set(wordSeparators.charCodeAt(i), 2 /* WordSeparator */);
            }
            _this.set(32 /* Space */, 1 /* Whitespace */);
            _this.set(9 /* Tab */, 1 /* Whitespace */);
            return _this;
        }
        return WordCharacterClassifier;
    }(characterClassifier_1.CharacterClassifier));
    function once(computeFn) {
        var cache = {}; // TODO@Alex unbounded cache
        return function (input) {
            if (!cache.hasOwnProperty(input)) {
                cache[input] = computeFn(input);
            }
            return cache[input];
        };
    }
    var getMapForWordSeparators = once(function (input) { return new WordCharacterClassifier(input); });
    var WordOperations = (function () {
        function WordOperations() {
        }
        WordOperations._createWord = function (lineContent, wordType, start, end) {
            // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');
            return { start: start, end: end, wordType: wordType };
        };
        WordOperations.findPreviousWordOnLine = function (config, model, position) {
            var wordSeparators = getMapForWordSeparators(config.wordSeparators);
            var lineContent = model.getLineContent(position.lineNumber);
            return this._findPreviousWordOnLine(lineContent, wordSeparators, position);
        };
        WordOperations._findPreviousWordOnLine = function (lineContent, wordSeparators, position) {
            var wordType = 0 /* None */;
            for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = wordSeparators.get(chCode);
                if (chClass === 0 /* Regular */) {
                    if (wordType === 2 /* Separator */) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                    wordType = 1 /* Regular */;
                }
                else if (chClass === 2 /* WordSeparator */) {
                    if (wordType === 1 /* Regular */) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                    wordType = 2 /* Separator */;
                }
                else if (chClass === 1 /* Whitespace */) {
                    if (wordType !== 0 /* None */) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                }
            }
            if (wordType !== 0 /* None */) {
                return this._createWord(lineContent, wordType, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));
            }
            return null;
        };
        WordOperations._findEndOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
            var len = lineContent.length;
            for (var chIndex = startIndex; chIndex < len; chIndex++) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = wordSeparators.get(chCode);
                if (chClass === 1 /* Whitespace */) {
                    return chIndex;
                }
                if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {
                    return chIndex;
                }
                if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {
                    return chIndex;
                }
            }
            return len;
        };
        WordOperations.findNextWordOnLine = function (config, model, position) {
            var wordSeparators = getMapForWordSeparators(config.wordSeparators);
            var lineContent = model.getLineContent(position.lineNumber);
            return this._findNextWordOnLine(lineContent, wordSeparators, position);
        };
        WordOperations._findNextWordOnLine = function (lineContent, wordSeparators, position) {
            var wordType = 0 /* None */;
            var len = lineContent.length;
            for (var chIndex = position.column - 1; chIndex < len; chIndex++) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = wordSeparators.get(chCode);
                if (chClass === 0 /* Regular */) {
                    if (wordType === 2 /* Separator */) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                    wordType = 1 /* Regular */;
                }
                else if (chClass === 2 /* WordSeparator */) {
                    if (wordType === 1 /* Regular */) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                    wordType = 2 /* Separator */;
                }
                else if (chClass === 1 /* Whitespace */) {
                    if (wordType !== 0 /* None */) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                }
            }
            if (wordType !== 0 /* None */) {
                return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);
            }
            return null;
        };
        WordOperations._findStartOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
            for (var chIndex = startIndex; chIndex >= 0; chIndex--) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = wordSeparators.get(chCode);
                if (chClass === 1 /* Whitespace */) {
                    return chIndex + 1;
                }
                if (wordType === 1 /* Regular */ && chClass === 2 /* WordSeparator */) {
                    return chIndex + 1;
                }
                if (wordType === 2 /* Separator */ && chClass === 0 /* Regular */) {
                    return chIndex + 1;
                }
            }
            return 0;
        };
        WordOperations.moveWordLeft = function (config, model, cursor, inSelectionMode, wordNavigationType) {
            var position = cursor.position;
            var lineNumber = position.lineNumber;
            var column = position.column;
            if (column === 1) {
                if (lineNumber > 1) {
                    lineNumber = lineNumber - 1;
                    column = model.getLineMaxColumn(lineNumber);
                }
            }
            var prevWordOnLine = WordOperations.findPreviousWordOnLine(config, model, new position_1.Position(lineNumber, column));
            if (wordNavigationType === 0 /* WordStart */) {
                if (prevWordOnLine) {
                    column = prevWordOnLine.start + 1;
                }
                else {
                    column = 1;
                }
            }
            else {
                if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                    prevWordOnLine = WordOperations.findPreviousWordOnLine(config, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));
                }
                if (prevWordOnLine) {
                    column = prevWordOnLine.end + 1;
                }
                else {
                    column = 1;
                }
            }
            return cursorMoveOperations_1.SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, column, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        WordOperations.moveWordRight = function (config, model, cursor, inSelectionMode, wordNavigationType) {
            var position = cursor.position;
            var lineNumber = position.lineNumber;
            var column = position.column;
            if (column === model.getLineMaxColumn(lineNumber)) {
                if (lineNumber < model.getLineCount()) {
                    lineNumber = lineNumber + 1;
                    column = 1;
                }
            }
            var nextWordOnLine = WordOperations.findNextWordOnLine(config, model, new position_1.Position(lineNumber, column));
            if (wordNavigationType === 1 /* WordEnd */) {
                if (nextWordOnLine) {
                    column = nextWordOnLine.end + 1;
                }
                else {
                    column = model.getLineMaxColumn(lineNumber);
                }
            }
            else {
                if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                    nextWordOnLine = WordOperations.findNextWordOnLine(config, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));
                }
                if (nextWordOnLine) {
                    column = nextWordOnLine.start + 1;
                }
                else {
                    column = model.getLineMaxColumn(lineNumber);
                }
            }
            return cursorMoveOperations_1.SingleMoveOperationResult.fromMove(cursor, inSelectionMode, lineNumber, column, 0, true, editorCommon_1.CursorChangeReason.Explicit);
        };
        WordOperations._deleteWordLeftWhitespace = function (config, model, cursor) {
            var position = cursor.position;
            var lineContent = model.getLineContent(position.lineNumber);
            var startIndex = position.column - 2;
            var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);
            if (lastNonWhitespace + 1 < startIndex) {
                var deleteRange = new range_1.Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column);
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteRange, ''), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false
                });
            }
            return null;
        };
        WordOperations.deleteWordLeft = function (config, model, cursor, whitespaceHeuristics, wordNavigationType) {
            var r = cursorDeleteOperations_1.DeleteOperations.autoClosingPairDelete(config, model, cursor);
            if (r) {
                // This was a case for an auto-closing pair delete
                return r;
            }
            var selection = cursor.selection;
            if (selection.isEmpty()) {
                var position = cursor.position;
                var lineNumber = position.lineNumber;
                var column = position.column;
                if (lineNumber === 1 && column === 1) {
                    // Ignore deleting at beginning of file
                    return null;
                }
                if (whitespaceHeuristics) {
                    var r_1 = this._deleteWordLeftWhitespace(config, model, cursor);
                    if (r_1) {
                        return r_1;
                    }
                }
                var prevWordOnLine = WordOperations.findPreviousWordOnLine(config, model, position);
                if (wordNavigationType === 0 /* WordStart */) {
                    if (prevWordOnLine) {
                        column = prevWordOnLine.start + 1;
                    }
                    else {
                        column = 1;
                    }
                }
                else {
                    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                        prevWordOnLine = WordOperations.findPreviousWordOnLine(config, model, new position_1.Position(lineNumber, prevWordOnLine.start + 1));
                    }
                    if (prevWordOnLine) {
                        column = prevWordOnLine.end + 1;
                    }
                    else {
                        column = 1;
                    }
                }
                var deleteSelection = new range_1.Range(lineNumber, column, lineNumber, position.column);
                if (!deleteSelection.isEmpty()) {
                    return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                        shouldPushStackElementBefore: false,
                        shouldPushStackElementAfter: false
                    });
                }
            }
            return cursorDeleteOperations_1.DeleteOperations.deleteLeft(config, model, cursor);
        };
        WordOperations._findFirstNonWhitespaceChar = function (str, startIndex) {
            var len = str.length;
            for (var chIndex = startIndex; chIndex < len; chIndex++) {
                var ch = str.charAt(chIndex);
                if (ch !== ' ' && ch !== '\t') {
                    return chIndex;
                }
            }
            return len;
        };
        WordOperations._deleteWordRightWhitespace = function (config, model, cursor) {
            var position = cursor.position;
            var lineContent = model.getLineContent(position.lineNumber);
            var startIndex = position.column - 1;
            var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);
            if (startIndex + 1 < firstNonWhitespace) {
                // bingo
                var deleteRange = new range_1.Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1);
                return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteRange, ''), {
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false
                });
            }
            return null;
        };
        WordOperations.deleteWordRight = function (config, model, cursor, whitespaceHeuristics, wordNavigationType) {
            var selection = cursor.selection;
            if (selection.isEmpty()) {
                var position = cursor.position;
                var lineNumber = position.lineNumber;
                var column = position.column;
                var lineCount = model.getLineCount();
                var maxColumn = model.getLineMaxColumn(lineNumber);
                if (lineNumber === lineCount && column === maxColumn) {
                    // Ignore deleting at end of file
                    return null;
                }
                if (whitespaceHeuristics) {
                    var r = this._deleteWordRightWhitespace(config, model, cursor);
                    if (r) {
                        return r;
                    }
                }
                var nextWordOnLine = WordOperations.findNextWordOnLine(config, model, position);
                if (wordNavigationType === 1 /* WordEnd */) {
                    if (nextWordOnLine) {
                        column = nextWordOnLine.end + 1;
                    }
                    else {
                        if (column < maxColumn || lineNumber === lineCount) {
                            column = maxColumn;
                        }
                        else {
                            lineNumber++;
                            nextWordOnLine = WordOperations.findNextWordOnLine(config, model, new position_1.Position(lineNumber, 1));
                            if (nextWordOnLine) {
                                column = nextWordOnLine.start + 1;
                            }
                            else {
                                column = model.getLineMaxColumn(lineNumber);
                            }
                        }
                    }
                }
                else {
                    if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                        nextWordOnLine = WordOperations.findNextWordOnLine(config, model, new position_1.Position(lineNumber, nextWordOnLine.end + 1));
                    }
                    if (nextWordOnLine) {
                        column = nextWordOnLine.start + 1;
                    }
                    else {
                        if (column < maxColumn || lineNumber === lineCount) {
                            column = maxColumn;
                        }
                        else {
                            lineNumber++;
                            nextWordOnLine = WordOperations.findNextWordOnLine(config, model, new position_1.Position(lineNumber, 1));
                            if (nextWordOnLine) {
                                column = nextWordOnLine.start + 1;
                            }
                            else {
                                column = model.getLineMaxColumn(lineNumber);
                            }
                        }
                    }
                }
                var deleteSelection = new range_1.Range(lineNumber, column, position.lineNumber, position.column);
                if (!deleteSelection.isEmpty()) {
                    return new cursorCommon_1.EditOperationResult(new replaceCommand_1.ReplaceCommand(deleteSelection, ''), {
                        shouldPushStackElementBefore: false,
                        shouldPushStackElementAfter: false
                    });
                }
            }
            // fall back to normal deleteRight behavior
            return cursorDeleteOperations_1.DeleteOperations.deleteRight(config, model, cursor);
        };
        WordOperations.word = function (config, model, cursor, inSelectionMode, position) {
            var prevWord = WordOperations.findPreviousWordOnLine(config, model, position);
            var isInPrevWord = (prevWord && prevWord.wordType === 1 /* Regular */ && prevWord.start < position.column - 1 && position.column - 1 <= prevWord.end);
            var nextWord = WordOperations.findNextWordOnLine(config, model, position);
            var isInNextWord = (nextWord && nextWord.wordType === 1 /* Regular */ && nextWord.start < position.column - 1 && position.column - 1 <= nextWord.end);
            if (!inSelectionMode || !cursor.hasSelection()) {
                var startColumn_1;
                var endColumn_1;
                if (isInPrevWord) {
                    startColumn_1 = prevWord.start + 1;
                    endColumn_1 = prevWord.end + 1;
                }
                else if (isInNextWord) {
                    startColumn_1 = nextWord.start + 1;
                    endColumn_1 = nextWord.end + 1;
                }
                else {
                    if (prevWord) {
                        startColumn_1 = prevWord.end + 1;
                    }
                    else {
                        startColumn_1 = 1;
                    }
                    if (nextWord) {
                        endColumn_1 = nextWord.start + 1;
                    }
                    else {
                        endColumn_1 = model.getLineMaxColumn(position.lineNumber);
                    }
                }
                return new cursorMoveOperations_1.SingleMoveOperationResult(new cursorCommon_1.SingleCursorState(new range_1.Range(position.lineNumber, startColumn_1, position.lineNumber, endColumn_1), 0, new position_1.Position(position.lineNumber, endColumn_1), 0), false, editorCommon_1.CursorChangeReason.Explicit);
            }
            var startColumn;
            var endColumn;
            if (isInPrevWord) {
                startColumn = prevWord.start + 1;
                endColumn = prevWord.end + 1;
            }
            else if (isInNextWord) {
                startColumn = nextWord.start + 1;
                endColumn = nextWord.end + 1;
            }
            else {
                startColumn = position.column;
                endColumn = position.column;
            }
            var lineNumber = position.lineNumber;
            var column;
            if (position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())) {
                column = startColumn;
                var possiblePosition = new position_1.Position(lineNumber, column);
                if (cursor.selectionStart.containsPosition(possiblePosition)) {
                    column = cursor.selectionStart.endColumn;
                }
            }
            else {
                column = endColumn;
                var possiblePosition = new position_1.Position(lineNumber, column);
                if (cursor.selectionStart.containsPosition(possiblePosition)) {
                    column = cursor.selectionStart.startColumn;
                }
            }
            return cursorMoveOperations_1.SingleMoveOperationResult.fromMove(cursor, cursor.hasSelection(), lineNumber, column, 0, false, editorCommon_1.CursorChangeReason.Explicit);
        };
        return WordOperations;
    }());
    exports.WordOperations = WordOperations;
});

define(__m[125/*vs/editor/common/controller/oneCursor*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,41/*vs/editor/common/controller/cursorCommon*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,96/*vs/editor/common/controller/cursorMoveOperations*/,124/*vs/editor/common/controller/cursorWordOperations*/]), function (require, exports, errors_1, cursorCommon_1, position_1, range_1, selection_1, editorCommon, cursorMoveOperations_1, cursorWordOperations_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveOperationResult = (function () {
        function MoveOperationResult(modelState, viewState, ensureInEditableRange, reason) {
            this.modelState = modelState;
            this.viewState = viewState;
            this.ensureInEditableRange = ensureInEditableRange;
            this.reason = reason;
        }
        return MoveOperationResult;
    }());
    exports.MoveOperationResult = MoveOperationResult;
    var OneCursor = (function () {
        function OneCursor(model, configuration, modeConfiguration, viewModelHelper) {
            var _this = this;
            this.model = model;
            this.configuration = configuration;
            this.modeConfiguration = modeConfiguration;
            this.viewModelHelper = viewModelHelper;
            this.viewModel = this.viewModelHelper.viewModel;
            this._recreateCursorConfig();
            this._modelOptionsListener = model.onDidChangeOptions(function () { return _this._recreateCursorConfig(); });
            this._configChangeListener = this.configuration.onDidChange(function (e) {
                if (cursorCommon_1.CursorConfiguration.shouldRecreate(e)) {
                    _this._recreateCursorConfig();
                }
            });
            this._setState(new cursorCommon_1.SingleCursorState(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(1, 1), 0), new cursorCommon_1.SingleCursorState(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(1, 1), 0), false);
        }
        /**
         * Sometimes, the line mapping changes and the stored view position is stale.
         */
        OneCursor.prototype.ensureValidState = function () {
            this._setState(this.modelState, this.viewState, false);
        };
        OneCursor.prototype._recreateCursorConfig = function () {
            this.config = new cursorCommon_1.CursorConfiguration(this.model.getOneIndent(), this.model.getOptions(), this.configuration, this.modeConfiguration);
        };
        OneCursor.prototype._ensureInEditableRange = function (position) {
            var editableRange = this.model.getEditableRange();
            if (position.lineNumber < editableRange.startLineNumber || (position.lineNumber === editableRange.startLineNumber && position.column < editableRange.startColumn)) {
                return new position_1.Position(editableRange.startLineNumber, editableRange.startColumn);
            }
            else if (position.lineNumber > editableRange.endLineNumber || (position.lineNumber === editableRange.endLineNumber && position.column > editableRange.endColumn)) {
                return new position_1.Position(editableRange.endLineNumber, editableRange.endColumn);
            }
            return position;
        };
        OneCursor.prototype._setState = function (modelState, viewState, ensureInEditableRange) {
            // Validate new model state
            var selectionStart = this.model.validateRange(modelState.selectionStart);
            var selectionStartLeftoverVisibleColumns = modelState.selectionStart.equalsRange(selectionStart) ? modelState.selectionStartLeftoverVisibleColumns : 0;
            var position = this.model.validatePosition(modelState.position);
            if (ensureInEditableRange) {
                position = this._ensureInEditableRange(position);
            }
            var leftoverVisibleColumns = modelState.position.equals(position) ? modelState.leftoverVisibleColumns : 0;
            modelState = new cursorCommon_1.SingleCursorState(selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns);
            // Validate new view state
            var viewSelectionStart = this.viewModelHelper.validateViewRange(viewState.selectionStart, modelState.selectionStart);
            var viewPosition = this.viewModelHelper.validateViewPosition(viewState.position, modelState.position);
            viewState = new cursorCommon_1.SingleCursorState(viewSelectionStart, selectionStartLeftoverVisibleColumns, viewPosition, leftoverVisibleColumns);
            if (this.modelState && this.viewState && this.modelState.equals(modelState) && this.viewState.equals(viewState)) {
                // No-op, early return
                return;
            }
            this.modelState = modelState;
            this.viewState = viewState;
            this._selStartMarker = this._ensureMarker(this._selStartMarker, this.modelState.selection.startLineNumber, this.modelState.selection.startColumn, true);
            this._selEndMarker = this._ensureMarker(this._selEndMarker, this.modelState.selection.endLineNumber, this.modelState.selection.endColumn, false);
        };
        OneCursor.prototype._ensureMarker = function (markerId, lineNumber, column, stickToPreviousCharacter) {
            if (!markerId) {
                return this.model._addMarker(0, lineNumber, column, stickToPreviousCharacter);
            }
            else {
                this.model._changeMarker(markerId, lineNumber, column);
                this.model._changeMarkerStickiness(markerId, stickToPreviousCharacter);
                return markerId;
            }
        };
        OneCursor.prototype.saveState = function () {
            return {
                selectionStart: this.modelState.selectionStart,
                viewSelectionStart: this.viewState.selectionStart,
                position: this.modelState.position,
                viewPosition: this.viewState.position,
                leftoverVisibleColumns: this.modelState.leftoverVisibleColumns,
                selectionStartLeftoverVisibleColumns: this.modelState.selectionStartLeftoverVisibleColumns
            };
        };
        OneCursor.prototype.restoreState = function (state) {
            var position = this.model.validatePosition(state.position);
            var selectionStart;
            if (state.selectionStart) {
                selectionStart = this.model.validateRange(state.selectionStart);
            }
            else {
                selectionStart = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            }
            var viewPosition = this.viewModelHelper.validateViewPosition(new position_1.Position(state.viewPosition.lineNumber, state.viewPosition.column), position);
            var viewSelectionStart;
            if (state.viewSelectionStart) {
                viewSelectionStart = this.viewModelHelper.validateViewRange(new range_1.Range(state.viewSelectionStart.startLineNumber, state.viewSelectionStart.startColumn, state.viewSelectionStart.endLineNumber, state.viewSelectionStart.endColumn), selectionStart);
            }
            else {
                viewSelectionStart = this.viewModelHelper.convertModelRangeToViewRange(selectionStart);
            }
            this._setState(new cursorCommon_1.SingleCursorState(selectionStart, state.selectionStartLeftoverVisibleColumns, position, state.leftoverVisibleColumns), new cursorCommon_1.SingleCursorState(viewSelectionStart, state.selectionStartLeftoverVisibleColumns, viewPosition, state.leftoverVisibleColumns), false);
        };
        OneCursor.prototype.updateModeConfiguration = function (modeConfiguration) {
            this.modeConfiguration = modeConfiguration;
            this._recreateCursorConfig();
        };
        OneCursor.prototype.duplicate = function () {
            var result = new OneCursor(this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            result._setState(this.modelState, this.viewState, false);
            return result;
        };
        OneCursor.prototype.dispose = function () {
            this._modelOptionsListener.dispose();
            this._configChangeListener.dispose();
            this.model._removeMarker(this._selStartMarker);
            this.model._removeMarker(this._selEndMarker);
        };
        OneCursor.prototype.setSelection = function (selection, viewSelection) {
            if (viewSelection === void 0) { viewSelection = null; }
            var position = this.model.validatePosition({
                lineNumber: selection.positionLineNumber,
                column: selection.positionColumn
            });
            var selectionStart = this.model.validatePosition({
                lineNumber: selection.selectionStartLineNumber,
                column: selection.selectionStartColumn
            });
            var viewPosition;
            var viewSelectionStart;
            if (viewSelection) {
                viewPosition = this.viewModelHelper.validateViewPosition(new position_1.Position(viewSelection.positionLineNumber, viewSelection.positionColumn), position);
                viewSelectionStart = this.viewModelHelper.validateViewPosition(new position_1.Position(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn), selectionStart);
            }
            else {
                viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(position.lineNumber, position.column);
                viewSelectionStart = this.viewModelHelper.convertModelPositionToViewPosition(selectionStart.lineNumber, selectionStart.column);
            }
            this._setState(new cursorCommon_1.SingleCursorState(new range_1.Range(selectionStart.lineNumber, selectionStart.column, selectionStart.lineNumber, selectionStart.column), 0, position, 0), new cursorCommon_1.SingleCursorState(new range_1.Range(viewSelectionStart.lineNumber, viewSelectionStart.column, viewSelectionStart.lineNumber, viewSelectionStart.column), 0, viewPosition, 0), false);
        };
        // -------------------- START modifications
        OneCursor.prototype.setSelectionStart = function (range) {
            this._setState(this.modelState.withSelectionStart(range), this.viewState.withSelectionStart(this.viewModelHelper.convertModelRangeToViewRange(range)), false);
        };
        OneCursor.prototype.collapseSelection = function () {
            this._setState(this.modelState.collapse(), this.viewState.collapse(), false);
        };
        OneCursor.prototype.moveModelPosition = function (inSelectionMode, lineNumber, column, leftoverVisibleColumns, ensureInEditableRange) {
            var viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
            this._move(inSelectionMode, lineNumber, column, viewPosition.lineNumber, viewPosition.column, leftoverVisibleColumns, ensureInEditableRange);
        };
        OneCursor.prototype.moveViewPosition = function (inSelectionMode, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange) {
            var modelPosition = this.viewModelHelper.convertViewToModelPosition(viewLineNumber, viewColumn);
            this._move(inSelectionMode, modelPosition.lineNumber, modelPosition.column, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange);
        };
        OneCursor.prototype._move = function (inSelectionMode, lineNumber, column, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange) {
            this._setState(this.modelState.move(inSelectionMode, new position_1.Position(lineNumber, column), leftoverVisibleColumns), this.viewState.move(inSelectionMode, new position_1.Position(viewLineNumber, viewColumn), leftoverVisibleColumns), ensureInEditableRange);
        };
        OneCursor.prototype.setState = function (modelState, viewState, ensureInEditableRange) {
            this._setState(modelState, viewState, ensureInEditableRange);
        };
        OneCursor.prototype.beginRecoverSelectionFromMarkers = function () {
            var start = this.model._getMarker(this._selStartMarker);
            var end = this.model._getMarker(this._selEndMarker);
            if (this.modelState.selection.getDirection() === selection_1.SelectionDirection.LTR) {
                return new selection_1.Selection(start.lineNumber, start.column, end.lineNumber, end.column);
            }
            return new selection_1.Selection(end.lineNumber, end.column, start.lineNumber, start.column);
        };
        OneCursor.prototype.endRecoverSelectionFromMarkers = function (ctx, recoveredSelection) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.RecoverFromMarkers;
            ctx.shouldPushStackElementBefore = true;
            ctx.shouldPushStackElementAfter = true;
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            var selectionStart = new range_1.Range(recoveredSelection.selectionStartLineNumber, recoveredSelection.selectionStartColumn, recoveredSelection.selectionStartLineNumber, recoveredSelection.selectionStartColumn);
            var position = new position_1.Position(recoveredSelection.positionLineNumber, recoveredSelection.positionColumn);
            var viewSelectionStart = this.viewModelHelper.convertModelRangeToViewRange(selectionStart);
            var viewPosition = this.viewModelHelper.convertViewToModelPosition(position.lineNumber, position.column);
            this._setState(new cursorCommon_1.SingleCursorState(selectionStart, 0, position, 0), new cursorCommon_1.SingleCursorState(viewSelectionStart, 0, viewPosition, 0), false);
            return true;
        };
        // -------------------- END modifications
        // -------------------- START reading API
        OneCursor.prototype.setSelectionStartLeftoverVisibleColumns = function (value) {
            this._setState(this.modelState.withSelectionStartLeftoverVisibleColumns(value), this.viewState.withSelectionStartLeftoverVisibleColumns(value), false);
        };
        // -- utils
        OneCursor.prototype.validatePosition = function (position) {
            return this.model.validatePosition(position);
        };
        OneCursor.prototype.validateViewPosition = function (viewLineNumber, viewColumn, modelPosition) {
            return this.viewModelHelper.validateViewPosition(new position_1.Position(viewLineNumber, viewColumn), modelPosition);
        };
        OneCursor.prototype.convertViewSelectionToModelSelection = function (viewSelection) {
            return this.viewModelHelper.convertViewSelectionToModelSelection(viewSelection);
        };
        OneCursor.prototype.convertViewToModelPosition = function (lineNumber, column) {
            return this.viewModelHelper.convertViewToModelPosition(lineNumber, column);
        };
        OneCursor.prototype.convertModelPositionToViewPosition = function (lineNumber, column) {
            return this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
        };
        // -- model
        OneCursor.prototype.getRangeToRevealModelLinesBeforeViewPortTop = function (noOfLinesBeforeTop) {
            var visibleModelRange = this.viewModelHelper.getCurrentCompletelyVisibleModelLinesRangeInViewport();
            var startLineNumber;
            if (this.model.getLineMinColumn(visibleModelRange.startLineNumber) !== visibleModelRange.startColumn) {
                // Start line is partially visible by wrapping so reveal start line
                startLineNumber = visibleModelRange.startLineNumber;
            }
            else {
                // Reveal previous line
                startLineNumber = visibleModelRange.startLineNumber - 1;
            }
            startLineNumber -= (noOfLinesBeforeTop - 1);
            startLineNumber = this.model.validateRange({ startLineNumber: startLineNumber, startColumn: 1, endLineNumber: startLineNumber, endColumn: 1 }).startLineNumber;
            var startColumn = this.model.getLineMinColumn(startLineNumber);
            var endColumn = this.model.getLineMaxColumn(visibleModelRange.startLineNumber);
            return new range_1.Range(startLineNumber, startColumn, startLineNumber, endColumn);
        };
        OneCursor.prototype.getRangeToRevealModelLinesAfterViewPortBottom = function (noOfLinesAfterBottom) {
            var visibleModelRange = this.viewModelHelper.getCurrentCompletelyVisibleModelLinesRangeInViewport();
            // Last line in the view port is not considered revealed because scroll bar would cover it
            // Hence consider last line to reveal in the range
            var startLineNumber = visibleModelRange.endLineNumber + (noOfLinesAfterBottom - 1);
            startLineNumber = this.model.validateRange({ startLineNumber: startLineNumber, startColumn: 1, endLineNumber: startLineNumber, endColumn: 1 }).startLineNumber;
            var startColumn = this.model.getLineMinColumn(startLineNumber);
            var endColumn = this.model.getLineMaxColumn(startLineNumber);
            return new range_1.Range(startLineNumber, startColumn, startLineNumber, endColumn);
        };
        OneCursor.prototype.getLineFromViewPortTop = function (lineFromTop) {
            if (lineFromTop === void 0) { lineFromTop = 1; }
            var visibleRange = this.viewModelHelper.getCurrentCompletelyVisibleModelLinesRangeInViewport();
            var startColumn = this.model.getLineMinColumn(visibleRange.startLineNumber);
            // Use next line if the first line is partially visible
            var visibleLineNumber = visibleRange.startColumn === startColumn ? visibleRange.startLineNumber : visibleRange.startLineNumber + 1;
            visibleLineNumber = visibleLineNumber + lineFromTop - 1;
            return visibleLineNumber > visibleRange.endLineNumber ? visibleRange.endLineNumber : visibleLineNumber;
        };
        OneCursor.prototype.getCenterLineInViewPort = function () {
            return Math.round((this.getLineFromViewPortTop() + this.getLineFromViewPortBottom() - 1) / 2);
        };
        OneCursor.prototype.getLineFromViewPortBottom = function (lineFromBottom) {
            if (lineFromBottom === void 0) { lineFromBottom = 1; }
            var visibleRange = this.viewModelHelper.getCurrentCompletelyVisibleModelLinesRangeInViewport();
            var visibleLineNumber = visibleRange.endLineNumber - (lineFromBottom - 1);
            return visibleLineNumber > visibleRange.startLineNumber ? visibleLineNumber : this.getLineFromViewPortTop();
        };
        // -- view
        OneCursor.prototype.isLastLineVisibleInViewPort = function () {
            return this.viewModel.getLineCount() <= this.getCompletelyVisibleViewLinesRangeInViewport().getEndPosition().lineNumber;
        };
        OneCursor.prototype.getCompletelyVisibleViewLinesRangeInViewport = function () {
            return this.viewModelHelper.getCurrentCompletelyVisibleViewLinesRangeInViewport();
        };
        OneCursor.prototype.getRevealViewLinesRangeInViewport = function () {
            var visibleRange = this.getCompletelyVisibleViewLinesRangeInViewport().cloneRange();
            if (!this.isLastLineVisibleInViewPort() && visibleRange.endLineNumber > visibleRange.startLineNumber) {
                visibleRange = new range_1.Range(visibleRange.startLineNumber, visibleRange.startColumn, visibleRange.endLineNumber - 1, this.viewModel.getLineLastNonWhitespaceColumn(visibleRange.endLineNumber - 1));
            }
            return visibleRange;
        };
        OneCursor.prototype.getNearestRevealViewPositionInViewport = function () {
            var position = this.viewState.position;
            var revealRange = this.getRevealViewLinesRangeInViewport();
            if (position.lineNumber < revealRange.startLineNumber) {
                return new position_1.Position(revealRange.startLineNumber, this.viewModel.getLineFirstNonWhitespaceColumn(revealRange.startLineNumber));
            }
            if (position.lineNumber > revealRange.endLineNumber) {
                return new position_1.Position(revealRange.endLineNumber, this.viewModel.getLineFirstNonWhitespaceColumn(revealRange.endLineNumber));
            }
            return position;
        };
        return OneCursor;
    }());
    exports.OneCursor = OneCursor;
    var OneCursorOp = (function () {
        function OneCursorOp() {
        }
        // -------------------- START handlers that simply change cursor state
        OneCursorOp.moveTo = function (cursor, inSelectionMode, position, viewPosition, eventSource, ctx) {
            var validatedPosition = cursor.model.validatePosition(position);
            var validatedViewPosition;
            if (viewPosition) {
                validatedViewPosition = cursor.validateViewPosition(viewPosition.lineNumber, viewPosition.column, validatedPosition);
            }
            else {
                validatedViewPosition = cursor.convertModelPositionToViewPosition(validatedPosition.lineNumber, validatedPosition.column);
            }
            var reason = (eventSource === 'mouse' ? editorCommon.CursorChangeReason.Explicit : editorCommon.CursorChangeReason.NotSet);
            if (eventSource === 'api') {
                ctx.shouldRevealVerticalInCenter = true;
            }
            if (reason) {
                ctx.cursorPositionChangeReason = reason;
            }
            cursor.moveViewPosition(inSelectionMode, validatedViewPosition.lineNumber, validatedViewPosition.column, 0, false);
            return true;
        };
        OneCursorOp._getViewHalfLineSize = function (cursor, lineNumber) {
            return Math.round((cursor.viewModel.getLineMaxColumn(lineNumber) - cursor.viewModel.getLineMinColumn(lineNumber)) / 2);
        };
        OneCursorOp.move = function (cursor, moveParams, eventSource, ctx) {
            if (!moveParams.to) {
                errors_1.illegalArgument('to');
            }
            var inSelectionMode = !!moveParams.select;
            var validatedViewPosition = cursor.viewState.position;
            var viewLineNumber = validatedViewPosition.lineNumber;
            var viewColumn;
            switch (moveParams.to) {
                case editorCommon.CursorMovePosition.Left:
                    return this._moveLeft(cursor, inSelectionMode, editorCommon.CursorMoveByUnit.HalfLine === moveParams.by ? this._getViewHalfLineSize(cursor, viewLineNumber) : moveParams.value, ctx);
                case editorCommon.CursorMovePosition.Right:
                    return this._moveRight(cursor, inSelectionMode, editorCommon.CursorMoveByUnit.HalfLine === moveParams.by ? this._getViewHalfLineSize(cursor, viewLineNumber) : moveParams.value, ctx);
                case editorCommon.CursorMovePosition.Up:
                    return this._moveUp(cursor, moveParams, ctx);
                case editorCommon.CursorMovePosition.Down:
                    return this._moveDown(cursor, moveParams, ctx);
                case editorCommon.CursorMovePosition.WrappedLineStart:
                    viewColumn = cursor.viewModel.getLineMinColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.WrappedLineFirstNonWhitespaceCharacter:
                    viewColumn = cursor.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.WrappedLineColumnCenter:
                    viewColumn = Math.round((cursor.viewModel.getLineMaxColumn(viewLineNumber) + cursor.viewModel.getLineMinColumn(viewLineNumber)) / 2);
                    break;
                case editorCommon.CursorMovePosition.WrappedLineEnd:
                    viewColumn = cursor.viewModel.getLineMaxColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.WrappedLineLastNonWhitespaceCharacter:
                    viewColumn = cursor.viewModel.getLineLastNonWhitespaceColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.ViewPortTop:
                    viewLineNumber = cursor.convertModelPositionToViewPosition(cursor.getLineFromViewPortTop(moveParams.value), 1).lineNumber;
                    viewColumn = cursor.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.ViewPortBottom:
                    viewLineNumber = cursor.convertModelPositionToViewPosition(cursor.getLineFromViewPortBottom(moveParams.value), 1).lineNumber;
                    ;
                    viewColumn = cursor.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.ViewPortCenter:
                    viewLineNumber = cursor.convertModelPositionToViewPosition(cursor.getCenterLineInViewPort(), 1).lineNumber;
                    ;
                    viewColumn = cursor.viewModel.getLineFirstNonWhitespaceColumn(viewLineNumber);
                    break;
                case editorCommon.CursorMovePosition.ViewPortIfOutside:
                    var position = cursor.getNearestRevealViewPositionInViewport();
                    viewLineNumber = position.lineNumber;
                    viewColumn = position.column;
                    break;
                default:
                    return false;
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, viewLineNumber, viewColumn, 0, true);
            return true;
        };
        OneCursorOp._applyMoveOperationResult = function (cursor, ctx, r) {
            ctx.cursorPositionChangeReason = r.reason;
            cursor.setState(r.modelState, r.viewState, r.ensureInEditableRange);
            return true;
        };
        OneCursorOp._fromModelCursorState = function (cursor, r) {
            var viewSelectionStart1 = cursor.convertModelPositionToViewPosition(r.state.selectionStart.startLineNumber, r.state.selectionStart.startColumn);
            var viewSelectionStart2 = cursor.convertModelPositionToViewPosition(r.state.selectionStart.endLineNumber, r.state.selectionStart.endColumn);
            var viewSelectionStart = new range_1.Range(viewSelectionStart1.lineNumber, viewSelectionStart1.column, viewSelectionStart2.lineNumber, viewSelectionStart2.column);
            var viewPosition = cursor.convertModelPositionToViewPosition(r.state.position.lineNumber, r.state.position.column);
            return new MoveOperationResult(r.state, new cursorCommon_1.SingleCursorState(viewSelectionStart, r.state.selectionStartLeftoverVisibleColumns, viewPosition, r.state.leftoverVisibleColumns), r.ensureInEditableRange, r.reason);
        };
        OneCursorOp._fromViewCursorState = function (cursor, r) {
            var selectionStart1 = cursor.convertViewToModelPosition(r.state.selectionStart.startLineNumber, r.state.selectionStart.startColumn);
            var selectionStart2 = cursor.convertViewToModelPosition(r.state.selectionStart.endLineNumber, r.state.selectionStart.endColumn);
            var selectionStart = new range_1.Range(selectionStart1.lineNumber, selectionStart1.column, selectionStart2.lineNumber, selectionStart2.column);
            var position = cursor.convertViewToModelPosition(r.state.position.lineNumber, r.state.position.column);
            return new MoveOperationResult(new cursorCommon_1.SingleCursorState(selectionStart, r.state.selectionStartLeftoverVisibleColumns, position, r.state.leftoverVisibleColumns), r.state, r.ensureInEditableRange, r.reason);
        };
        OneCursorOp._moveLeft = function (cursor, inSelectionMode, noOfColumns, ctx) {
            if (noOfColumns === void 0) { noOfColumns = 1; }
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveLeft(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode, noOfColumns)));
        };
        OneCursorOp.moveWordLeft = function (cursor, inSelectionMode, wordNavigationType, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorWordOperations_1.WordOperations.moveWordLeft(cursor.config, cursor.model, cursor.modelState, inSelectionMode, wordNavigationType)));
        };
        OneCursorOp._moveRight = function (cursor, inSelectionMode, noOfColumns, ctx) {
            if (noOfColumns === void 0) { noOfColumns = 1; }
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveRight(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode, noOfColumns)));
        };
        OneCursorOp.moveWordRight = function (cursor, inSelectionMode, wordNavigationType, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorWordOperations_1.WordOperations.moveWordRight(cursor.config, cursor.model, cursor.modelState, inSelectionMode, wordNavigationType)));
        };
        OneCursorOp._moveDown = function (cursor, moveArguments, ctx) {
            var linesCount = (moveArguments.isPaged ? (moveArguments.pageSize || cursor.config.pageSize) : moveArguments.value) || 1;
            if (editorCommon.CursorMoveByUnit.WrappedLine === moveArguments.by) {
                return this._moveDownByViewLines(cursor, moveArguments.select, linesCount, ctx);
            }
            return this._moveDownByModelLines(cursor, moveArguments.select, linesCount, ctx);
        };
        OneCursorOp._moveDownByViewLines = function (cursor, inSelectionMode, linesCount, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveDown(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode, linesCount)));
        };
        OneCursorOp._moveDownByModelLines = function (cursor, inSelectionMode, linesCount, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveDown(cursor.config, cursor.model, cursor.modelState, inSelectionMode, linesCount)));
        };
        OneCursorOp.translateDown = function (cursor, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.translateDown(cursor.config, cursor.viewModel, cursor.viewState)));
        };
        OneCursorOp._moveUp = function (cursor, moveArguments, ctx) {
            var linesCount = (moveArguments.isPaged ? (moveArguments.pageSize || cursor.config.pageSize) : moveArguments.value) || 1;
            if (editorCommon.CursorMoveByUnit.WrappedLine === moveArguments.by) {
                return this._moveUpByViewLines(cursor, moveArguments.select, linesCount, ctx);
            }
            return this._moveUpByModelLines(cursor, moveArguments.select, linesCount, ctx);
        };
        OneCursorOp._moveUpByViewLines = function (cursor, inSelectionMode, linesCount, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveUp(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode, linesCount)));
        };
        OneCursorOp._moveUpByModelLines = function (cursor, inSelectionMode, linesCount, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveUp(cursor.config, cursor.model, cursor.modelState, inSelectionMode, linesCount)));
        };
        OneCursorOp.translateUp = function (cursor, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.translateUp(cursor.config, cursor.viewModel, cursor.viewState)));
        };
        OneCursorOp.moveToBeginningOfLine = function (cursor, inSelectionMode, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveToBeginningOfLine(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode)));
        };
        OneCursorOp.moveToEndOfLine = function (cursor, inSelectionMode, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromViewCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveToEndOfLine(cursor.config, cursor.viewModel, cursor.viewState, inSelectionMode)));
        };
        OneCursorOp.expandLineSelection = function (cursor, ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            var viewSel = cursor.viewState.selection;
            var viewStartLineNumber = viewSel.startLineNumber;
            var viewStartColumn = viewSel.startColumn;
            var viewEndLineNumber = viewSel.endLineNumber;
            var viewEndColumn = viewSel.endColumn;
            var viewEndMaxColumn = cursor.viewModel.getLineMaxColumn(viewEndLineNumber);
            if (viewStartColumn !== 1 || viewEndColumn !== viewEndMaxColumn) {
                viewStartColumn = 1;
                viewEndColumn = viewEndMaxColumn;
            }
            else {
                // Expand selection with one more line down
                var moveResult = cursorMoveOperations_1.MoveOperations.down(cursor.config, cursor.viewModel, viewEndLineNumber, viewEndColumn, 0, 1, true);
                viewEndLineNumber = moveResult.lineNumber;
                viewEndColumn = cursor.viewModel.getLineMaxColumn(viewEndLineNumber);
            }
            cursor.moveViewPosition(false, viewStartLineNumber, viewStartColumn, 0, true);
            cursor.moveViewPosition(true, viewEndLineNumber, viewEndColumn, 0, true);
            return true;
        };
        OneCursorOp.moveToBeginningOfBuffer = function (cursor, inSelectionMode, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveToBeginningOfBuffer(cursor.config, cursor.model, cursor.modelState, inSelectionMode)));
        };
        OneCursorOp.moveToEndOfBuffer = function (cursor, inSelectionMode, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorMoveOperations_1.MoveOperations.moveToEndOfBuffer(cursor.config, cursor.model, cursor.modelState, inSelectionMode)));
        };
        OneCursorOp.selectAll = function (cursor, ctx) {
            var selectEntireBuffer = true;
            var newSelectionStartLineNumber, newSelectionStartColumn, newPositionLineNumber, newPositionColumn;
            if (cursor.model.hasEditableRange()) {
                // Toggle between selecting editable range and selecting the entire buffer
                var editableRange = cursor.model.getEditableRange();
                var selection = cursor.modelState.selection;
                if (!selection.equalsRange(editableRange)) {
                    // Selection is not editable range => select editable range
                    selectEntireBuffer = false;
                    newSelectionStartLineNumber = editableRange.startLineNumber;
                    newSelectionStartColumn = editableRange.startColumn;
                    newPositionLineNumber = editableRange.endLineNumber;
                    newPositionColumn = editableRange.endColumn;
                }
            }
            if (selectEntireBuffer) {
                newSelectionStartLineNumber = 1;
                newSelectionStartColumn = 1;
                newPositionLineNumber = cursor.model.getLineCount();
                newPositionColumn = cursor.model.getLineMaxColumn(newPositionLineNumber);
            }
            cursor.moveModelPosition(false, newSelectionStartLineNumber, newSelectionStartColumn, 0, false);
            cursor.moveModelPosition(true, newPositionLineNumber, newPositionColumn, 0, false);
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        OneCursorOp.line = function (cursor, inSelectionMode, _position, _viewPosition, ctx) {
            // TODO@Alex -> select in editable range
            var position = cursor.validatePosition(_position);
            var viewPosition = (_viewPosition ?
                cursor.validateViewPosition(_viewPosition.lineNumber, _viewPosition.column, position)
                : cursor.convertModelPositionToViewPosition(position.lineNumber, position.column));
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            ctx.shouldRevealHorizontal = false;
            if (!inSelectionMode || !cursor.modelState.hasSelection()) {
                // Entering line selection for the first time
                var selectToLineNumber = position.lineNumber + 1;
                var selectToColumn = 1;
                if (selectToLineNumber > cursor.model.getLineCount()) {
                    selectToLineNumber = cursor.model.getLineCount();
                    selectToColumn = cursor.model.getLineMaxColumn(selectToLineNumber);
                }
                var selectionStartRange = new range_1.Range(position.lineNumber, 1, selectToLineNumber, selectToColumn);
                cursor.setSelectionStart(selectionStartRange);
                cursor.moveModelPosition(cursor.modelState.hasSelection(), selectionStartRange.endLineNumber, selectionStartRange.endColumn, 0, false);
                return true;
            }
            else {
                // Continuing line selection
                var enteringLineNumber = cursor.modelState.selectionStart.getStartPosition().lineNumber;
                if (position.lineNumber < enteringLineNumber) {
                    cursor.moveViewPosition(cursor.modelState.hasSelection(), viewPosition.lineNumber, 1, 0, false);
                }
                else if (position.lineNumber > enteringLineNumber) {
                    var selectToViewLineNumber = viewPosition.lineNumber + 1;
                    var selectToViewColumn = 1;
                    if (selectToViewLineNumber > cursor.viewModel.getLineCount()) {
                        selectToViewLineNumber = cursor.viewModel.getLineCount();
                        selectToViewColumn = cursor.viewModel.getLineMaxColumn(selectToViewLineNumber);
                    }
                    cursor.moveViewPosition(cursor.modelState.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0, false);
                }
                else {
                    var endPositionOfSelectionStart = cursor.modelState.selectionStart.getEndPosition();
                    cursor.moveModelPosition(cursor.modelState.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0, false);
                }
                return true;
            }
        };
        OneCursorOp.word = function (cursor, inSelectionMode, validatedPosition, ctx) {
            return this._applyMoveOperationResult(cursor, ctx, this._fromModelCursorState(cursor, cursorWordOperations_1.WordOperations.word(cursor.config, cursor.model, cursor.modelState, inSelectionMode, validatedPosition)));
        };
        OneCursorOp.cancelSelection = function (cursor, ctx) {
            if (!cursor.modelState.hasSelection()) {
                return false;
            }
            cursor.collapseSelection();
            return true;
        };
        return OneCursorOp;
    }());
    exports.OneCursorOp = OneCursorOp;
});

define(__m[351/*vs/editor/common/controller/cursorCollection*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,125/*vs/editor/common/controller/oneCursor*/,20/*vs/editor/common/core/selection*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/]), function (require, exports, errors_1, oneCursor_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CursorCollection = (function () {
        function CursorCollection(model, configuration, viewModelHelper) {
            this.model = model;
            this.configuration = configuration;
            this.viewModelHelper = viewModelHelper;
            this.modeConfiguration = this.getModeConfiguration();
            this.primaryCursor = new oneCursor_1.OneCursor(this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            this.secondaryCursors = [];
            this.lastAddedCursorIndex = 0;
        }
        CursorCollection.prototype.dispose = function () {
            this.primaryCursor.dispose();
            this.killSecondaryCursors();
        };
        CursorCollection.prototype.ensureValidState = function () {
            this.primaryCursor.ensureValidState();
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                this.secondaryCursors[i].ensureValidState();
            }
        };
        CursorCollection.prototype.saveState = function () {
            return {
                primary: this.primaryCursor.saveState(),
                secondary: this.secondaryCursors.map(function (c) { return c.saveState(); })
            };
        };
        CursorCollection.prototype.restoreState = function (state) {
            this.primaryCursor.restoreState(state.primary);
            this.killSecondaryCursors();
            for (var i = 0; i < state.secondary.length; i++) {
                this.addSecondaryCursor(null);
                this.secondaryCursors[i].restoreState(state.secondary[i]);
            }
        };
        CursorCollection.prototype.updateMode = function () {
            var _this = this;
            this.modeConfiguration = this.getModeConfiguration();
            this.getAll().forEach(function (cursor) {
                cursor.updateModeConfiguration(_this.modeConfiguration);
            });
        };
        CursorCollection.prototype.getAll = function () {
            var result = [];
            result.push(this.primaryCursor);
            result = result.concat(this.secondaryCursors);
            return result;
        };
        CursorCollection.prototype.getPosition = function (index) {
            if (index === 0) {
                return this.primaryCursor.modelState.position;
            }
            else {
                return this.secondaryCursors[index - 1].modelState.position;
            }
        };
        CursorCollection.prototype.getViewPosition = function (index) {
            if (index === 0) {
                return this.primaryCursor.viewState.position;
            }
            else {
                return this.secondaryCursors[index - 1].viewState.position;
            }
        };
        CursorCollection.prototype.getPositions = function () {
            var result = [];
            result.push(this.primaryCursor.modelState.position);
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].modelState.position);
            }
            return result;
        };
        CursorCollection.prototype.getViewPositions = function () {
            var result = [];
            result.push(this.primaryCursor.viewState.position);
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].viewState.position);
            }
            return result;
        };
        CursorCollection.prototype.getSelection = function (index) {
            if (index === 0) {
                return this.primaryCursor.modelState.selection;
            }
            else {
                return this.secondaryCursors[index - 1].modelState.selection;
            }
        };
        CursorCollection.prototype.getSelections = function () {
            var result = [];
            result.push(this.primaryCursor.modelState.selection);
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].modelState.selection);
            }
            return result;
        };
        CursorCollection.prototype.getViewSelections = function () {
            var result = [];
            result.push(this.primaryCursor.viewState.selection);
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].viewState.selection);
            }
            return result;
        };
        CursorCollection.prototype.setSelections = function (selections, viewSelections) {
            this.primaryCursor.setSelection(selections[0], viewSelections ? viewSelections[0] : null);
            this._setSecondarySelections(selections.slice(1), viewSelections ? viewSelections.slice(1) : null);
        };
        CursorCollection.prototype.killSecondaryCursors = function () {
            return (this._setSecondarySelections([], []) > 0);
        };
        CursorCollection.prototype.normalize = function () {
            this._mergeCursorsIfNecessary();
        };
        CursorCollection.prototype.addSecondaryCursor = function (selection) {
            var newCursor = new oneCursor_1.OneCursor(this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            if (selection) {
                newCursor.setSelection(selection);
            }
            this.secondaryCursors.push(newCursor);
            this.lastAddedCursorIndex = this.secondaryCursors.length;
        };
        CursorCollection.prototype.duplicateCursors = function () {
            var newCursors = [];
            newCursors.push(this.primaryCursor.duplicate());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                newCursors.push(this.secondaryCursors[i].duplicate());
            }
            this.secondaryCursors = this.secondaryCursors.concat(newCursors);
            this.lastAddedCursorIndex = this.secondaryCursors.length;
        };
        CursorCollection.prototype.getLastAddedCursor = function () {
            if (this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0) {
                return this.primaryCursor;
            }
            return this.secondaryCursors[this.lastAddedCursorIndex - 1];
        };
        /**
         * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
         * Return value:
         * 		- a positive number indicates the number of secondary cursors added
         * 		- a negative number indicates the number of secondary cursors removed
         * 		- 0 indicates that no changes have been done to the secondary cursors list
         */
        CursorCollection.prototype._setSecondarySelections = function (secondarySelections, viewSelections) {
            var secondaryCursorsLength = this.secondaryCursors.length;
            var secondarySelectionsLength = secondarySelections.length;
            var returnValue = secondarySelectionsLength - secondaryCursorsLength;
            if (secondaryCursorsLength < secondarySelectionsLength) {
                var createCnt = secondarySelectionsLength - secondaryCursorsLength;
                for (var i = 0; i < createCnt; i++) {
                    this.addSecondaryCursor(null);
                }
            }
            else if (secondaryCursorsLength > secondarySelectionsLength) {
                var removeCnt = secondaryCursorsLength - secondarySelectionsLength;
                for (var i = 0; i < removeCnt; i++) {
                    this._removeSecondaryCursor(this.secondaryCursors.length - 1);
                }
            }
            for (var i = 0; i < secondarySelectionsLength; i++) {
                if (secondarySelections[i]) {
                    this.secondaryCursors[i].setSelection(secondarySelections[i], viewSelections ? viewSelections[i] : null);
                }
            }
            return returnValue;
        };
        CursorCollection.prototype._removeSecondaryCursor = function (removeIndex) {
            if (this.lastAddedCursorIndex >= removeIndex + 1) {
                this.lastAddedCursorIndex--;
            }
            this.secondaryCursors[removeIndex].dispose();
            this.secondaryCursors.splice(removeIndex, 1);
        };
        CursorCollection.prototype._mergeCursorsIfNecessary = function () {
            if (this.secondaryCursors.length === 0) {
                return;
            }
            var cursors = this.getAll();
            var sortedCursors = [];
            for (var i = 0; i < cursors.length; i++) {
                sortedCursors.push({
                    index: i,
                    selection: cursors[i].modelState.selection,
                    viewSelection: cursors[i].viewState.selection
                });
            }
            sortedCursors.sort(function (a, b) {
                if (a.viewSelection.startLineNumber === b.viewSelection.startLineNumber) {
                    return a.viewSelection.startColumn - b.viewSelection.startColumn;
                }
                return a.viewSelection.startLineNumber - b.viewSelection.startLineNumber;
            });
            for (var sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {
                var current = sortedCursors[sortedCursorIndex];
                var next = sortedCursors[sortedCursorIndex + 1];
                var currentViewSelection = current.viewSelection;
                var nextViewSelection = next.viewSelection;
                if (nextViewSelection.getStartPosition().isBeforeOrEqual(currentViewSelection.getEndPosition())) {
                    var winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;
                    var looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;
                    var looserIndex = sortedCursors[looserSortedCursorIndex].index;
                    var winnerIndex = sortedCursors[winnerSortedCursorIndex].index;
                    var looserSelection = sortedCursors[looserSortedCursorIndex].selection;
                    var winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;
                    if (!looserSelection.equalsSelection(winnerSelection)) {
                        var resultingRange = looserSelection.plusRange(winnerSelection);
                        var looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);
                        var winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);
                        // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)
                        var resultingSelectionIsLTR;
                        if (looserIndex === this.lastAddedCursorIndex) {
                            resultingSelectionIsLTR = looserSelectionIsLTR;
                            this.lastAddedCursorIndex = winnerIndex;
                        }
                        else {
                            // Winner takes it all
                            resultingSelectionIsLTR = winnerSelectionIsLTR;
                        }
                        var resultingSelection;
                        if (resultingSelectionIsLTR) {
                            resultingSelection = new selection_1.Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);
                        }
                        else {
                            resultingSelection = new selection_1.Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);
                        }
                        sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;
                        cursors[winnerIndex].setSelection(resultingSelection);
                    }
                    for (var j = 0; j < sortedCursors.length; j++) {
                        if (sortedCursors[j].index > looserIndex) {
                            sortedCursors[j].index--;
                        }
                    }
                    cursors.splice(looserIndex, 1);
                    sortedCursors.splice(looserSortedCursorIndex, 1);
                    this._removeSecondaryCursor(looserIndex - 1);
                    sortedCursorIndex--;
                }
            }
        };
        CursorCollection.prototype.getModeConfiguration = function () {
            var i;
            var result = {
                electricChars: {},
                autoClosingPairsOpen: {},
                autoClosingPairsClose: {},
                surroundingPairs: {}
            };
            var electricChars = null;
            try {
                electricChars = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getElectricCharacters(this.model.getLanguageIdentifier().id);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                electricChars = null;
            }
            if (electricChars) {
                for (i = 0; i < electricChars.length; i++) {
                    result.electricChars[electricChars[i]] = true;
                }
            }
            var autoClosingPairs;
            try {
                autoClosingPairs = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getAutoClosingPairs(this.model.getLanguageIdentifier().id);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                autoClosingPairs = null;
            }
            if (autoClosingPairs) {
                for (i = 0; i < autoClosingPairs.length; i++) {
                    result.autoClosingPairsOpen[autoClosingPairs[i].open] = autoClosingPairs[i].close;
                    result.autoClosingPairsClose[autoClosingPairs[i].close] = autoClosingPairs[i].open;
                }
            }
            var surroundingPairs;
            try {
                surroundingPairs = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getSurroundingPairs(this.model.getLanguageIdentifier().id);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                surroundingPairs = null;
            }
            if (surroundingPairs) {
                for (i = 0; i < surroundingPairs.length; i++) {
                    result.surroundingPairs[surroundingPairs[i].open] = surroundingPairs[i].close;
                }
            }
            return result;
        };
        return CursorCollection;
    }());
    exports.CursorCollection = CursorCollection;
});






define(__m[352/*vs/editor/common/controller/cursor*/], __M([1/*require*/,0/*exports*/,271/*vs/nls!vs/editor/common/controller/cursor*/,9/*vs/base/common/strings*/,10/*vs/base/common/errors*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,62/*vs/editor/common/commands/replaceCommand*/,351/*vs/editor/common/controller/cursorCollection*/,125/*vs/editor/common/controller/oneCursor*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,41/*vs/editor/common/controller/cursorCommon*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,124/*vs/editor/common/controller/cursorWordOperations*/,345/*vs/editor/common/controller/cursorColumnSelection*/,123/*vs/editor/common/controller/cursorDeleteOperations*/,348/*vs/editor/common/controller/cursorTypeOperations*/]), function (require, exports, nls, strings, errors_1, eventEmitter_1, lifecycle_1, replaceCommand_1, cursorCollection_1, oneCursor_1, range_1, selection_1, editorCommon, cursorCommon_1, languageConfigurationRegistry_1, cursorWordOperations_1, cursorColumnSelection_1, cursorDeleteOperations_1, cursorTypeOperations_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RevealTarget;
    (function (RevealTarget) {
        RevealTarget[RevealTarget["Primary"] = 0] = "Primary";
        RevealTarget[RevealTarget["TopMost"] = 1] = "TopMost";
        RevealTarget[RevealTarget["BottomMost"] = 2] = "BottomMost";
    })(RevealTarget || (RevealTarget = {}));
    var Cursor = (function (_super) {
        __extends(Cursor, _super);
        function Cursor(configuration, model, viewModelHelper, enableEmptySelectionClipboard) {
            var _this = _super.call(this, [
                editorCommon.EventType.CursorPositionChanged,
                editorCommon.EventType.CursorSelectionChanged,
                editorCommon.EventType.CursorRevealRange,
                editorCommon.EventType.CursorScrollRequest
            ]) || this;
            _this._columnSelectToLineNumber = 0;
            _this._columnSelectToVisualColumn = 0;
            _this.configuration = configuration;
            _this.model = model;
            _this.viewModelHelper = viewModelHelper;
            _this.enableEmptySelectionClipboard = enableEmptySelectionClipboard;
            _this.cursors = new cursorCollection_1.CursorCollection(_this.model, _this.configuration, _this.viewModelHelper);
            _this.cursorUndoStack = [];
            _this._isHandling = false;
            _this.modelUnbinds = [];
            _this.modelUnbinds.push(_this.model.onDidChangeRawContent(function (e) {
                _this._onModelContentChanged(e);
            }));
            _this.modelUnbinds.push(_this.model.onDidChangeLanguage(function (e) {
                _this._onModelLanguageChanged();
            }));
            _this.modelUnbinds.push(languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange(function () {
                // TODO@Alex: react only if certain supports changed? (and if my model's mode changed)
                _this._onModelLanguageChanged();
            }));
            _this._handlers = {};
            _this._registerHandlers();
            return _this;
        }
        Cursor.prototype.dispose = function () {
            this.modelUnbinds = lifecycle_1.dispose(this.modelUnbinds);
            this.model = null;
            this.cursors.dispose();
            this.cursors = null;
            this.configuration = null;
            this.viewModelHelper = null;
            _super.prototype.dispose.call(this);
        };
        Cursor.prototype.saveState = function () {
            var selections = this.cursors.getSelections(), result = [], selection;
            for (var i = 0; i < selections.length; i++) {
                selection = selections[i];
                result.push({
                    inSelectionMode: !selection.isEmpty(),
                    selectionStart: {
                        lineNumber: selection.selectionStartLineNumber,
                        column: selection.selectionStartColumn,
                    },
                    position: {
                        lineNumber: selection.positionLineNumber,
                        column: selection.positionColumn,
                    }
                });
            }
            return result;
        };
        Cursor.prototype.restoreState = function (states) {
            var _this = this;
            var desiredSelections = [], state;
            for (var i = 0; i < states.length; i++) {
                state = states[i];
                var positionLineNumber = 1, positionColumn = 1;
                // Avoid missing properties on the literal
                if (state.position && state.position.lineNumber) {
                    positionLineNumber = state.position.lineNumber;
                }
                if (state.position && state.position.column) {
                    positionColumn = state.position.column;
                }
                var selectionStartLineNumber = positionLineNumber, selectionStartColumn = positionColumn;
                // Avoid missing properties on the literal
                if (state.selectionStart && state.selectionStart.lineNumber) {
                    selectionStartLineNumber = state.selectionStart.lineNumber;
                }
                if (state.selectionStart && state.selectionStart.column) {
                    selectionStartColumn = state.selectionStart.column;
                }
                desiredSelections.push({
                    selectionStartLineNumber: selectionStartLineNumber,
                    selectionStartColumn: selectionStartColumn,
                    positionLineNumber: positionLineNumber,
                    positionColumn: positionColumn
                });
            }
            this._onHandler('restoreState', function (ctx) {
                _this.cursors.setSelections(desiredSelections);
                return false;
            }, 'restoreState', null);
        };
        Cursor.prototype._onModelLanguageChanged = function () {
            // the mode of this model has changed
            this.cursors.updateMode();
        };
        Cursor.prototype._onModelContentChanged = function (e) {
            var _this = this;
            if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                // a model.setValue() was called
                this.cursors.dispose();
                this.cursors = new cursorCollection_1.CursorCollection(this.model, this.configuration, this.viewModelHelper);
                this.emitCursorPositionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
                this.emitCursorSelectionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
            }
            else {
                if (!this._isHandling) {
                    // Read the markers before entering `_onHandler`, since that would validate
                    // the position and ruin the markers
                    var selections_1 = this.cursors.getAll().map(function (cursor) {
                        return cursor.beginRecoverSelectionFromMarkers();
                    });
                    this._onHandler('recoverSelectionFromMarkers', function (ctx) {
                        var result = _this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor.endRecoverSelectionFromMarkers(oneCtx, selections_1[cursorIndex]); });
                        ctx.shouldPushStackElementBefore = false;
                        ctx.shouldPushStackElementAfter = false;
                        return result;
                    }, 'modelChange', null);
                }
            }
        };
        // ------ some getters/setters
        Cursor.prototype.getSelection = function () {
            return this.cursors.getSelection(0);
        };
        Cursor.prototype.getSelections = function () {
            return this.cursors.getSelections();
        };
        Cursor.prototype.getPosition = function () {
            return this.cursors.getPosition(0);
        };
        Cursor.prototype.setSelections = function (source, selections) {
            var _this = this;
            this._onHandler('setSelections', function (ctx) {
                ctx.shouldReveal = false;
                _this.cursors.setSelections(selections);
                return false;
            }, source, null);
        };
        // ------ auxiliary handling logic
        Cursor.prototype._createAndInterpretHandlerCtx = function (eventSource, eventData, callback) {
            var currentHandlerCtx = {
                cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
                shouldReveal: true,
                shouldRevealVerticalInCenter: false,
                shouldRevealHorizontal: true,
                shouldRevealTarget: 0 /* Primary */,
                eventSource: eventSource,
                eventData: eventData,
                executeCommands: [],
                isAutoWhitespaceCommand: [],
                hasExecutedCommands: false,
                isCursorUndo: false,
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false,
                setColumnSelectToLineNumber: 0,
                setColumnSelectToVisualColumn: 0
            };
            callback(currentHandlerCtx);
            this._interpretHandlerContext(currentHandlerCtx);
            this.cursors.normalize();
            return currentHandlerCtx.hasExecutedCommands;
        };
        Cursor.prototype._onHandler = function (command, handler, source, data) {
            this._isHandling = true;
            var handled = false;
            try {
                var oldSelections = this.cursors.getSelections();
                var oldViewSelections = this.cursors.getViewSelections();
                // ensure valid state on all cursors
                this.cursors.ensureValidState();
                var prevCursorsState = this.cursors.saveState();
                var eventSource = source;
                var cursorPositionChangeReason;
                var shouldReveal;
                var shouldRevealVerticalInCenter;
                var shouldRevealHorizontal;
                var shouldRevealTarget;
                var isCursorUndo;
                var hasExecutedCommands = this._createAndInterpretHandlerCtx(eventSource, data, function (currentHandlerCtx) {
                    handled = handler(currentHandlerCtx);
                    cursorPositionChangeReason = currentHandlerCtx.cursorPositionChangeReason;
                    shouldReveal = currentHandlerCtx.shouldReveal;
                    shouldRevealTarget = currentHandlerCtx.shouldRevealTarget;
                    shouldRevealVerticalInCenter = currentHandlerCtx.shouldRevealVerticalInCenter;
                    shouldRevealHorizontal = currentHandlerCtx.shouldRevealHorizontal;
                    isCursorUndo = currentHandlerCtx.isCursorUndo;
                });
                if (hasExecutedCommands) {
                    this.cursorUndoStack = [];
                }
                var newSelections = this.cursors.getSelections();
                var newViewSelections = this.cursors.getViewSelections();
                var somethingChanged = false;
                if (oldSelections.length !== newSelections.length) {
                    somethingChanged = true;
                }
                else {
                    for (var i = 0, len = oldSelections.length; !somethingChanged && i < len; i++) {
                        if (!oldSelections[i].equalsSelection(newSelections[i])) {
                            somethingChanged = true;
                        }
                    }
                    for (var i = 0, len = oldViewSelections.length; !somethingChanged && i < len; i++) {
                        if (!oldViewSelections[i].equalsSelection(newViewSelections[i])) {
                            somethingChanged = true;
                        }
                    }
                }
                if (somethingChanged) {
                    if (!hasExecutedCommands && !isCursorUndo) {
                        this.cursorUndoStack.push(prevCursorsState);
                    }
                    if (this.cursorUndoStack.length > 50) {
                        this.cursorUndoStack = this.cursorUndoStack.splice(0, this.cursorUndoStack.length - 50);
                    }
                    this.emitCursorPositionChanged(eventSource, cursorPositionChangeReason);
                    if (shouldReveal) {
                        this.revealRange(shouldRevealTarget, shouldRevealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, shouldRevealHorizontal);
                    }
                    this.emitCursorSelectionChanged(eventSource, cursorPositionChangeReason);
                }
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
            }
            this._isHandling = false;
            return handled;
        };
        Cursor.prototype._interpretHandlerContext = function (ctx) {
            if (ctx.shouldPushStackElementBefore) {
                this.model.pushStackElement();
                ctx.shouldPushStackElementBefore = false;
            }
            this._columnSelectToLineNumber = ctx.setColumnSelectToLineNumber;
            this._columnSelectToVisualColumn = ctx.setColumnSelectToVisualColumn;
            ctx.hasExecutedCommands = this._internalExecuteCommands(ctx.executeCommands, ctx.isAutoWhitespaceCommand) || ctx.hasExecutedCommands;
            ctx.executeCommands = [];
            if (ctx.shouldPushStackElementAfter) {
                this.model.pushStackElement();
                ctx.shouldPushStackElementAfter = false;
            }
        };
        Cursor.prototype._interpretCommandResult = function (cursorState) {
            if (!cursorState || cursorState.length === 0) {
                return false;
            }
            this.cursors.setSelections(cursorState);
            return true;
        };
        Cursor.prototype._getEditOperationsFromCommand = function (ctx, majorIdentifier, command, isAutoWhitespaceCommand) {
            var _this = this;
            // This method acts as a transaction, if the command fails
            // everything it has done is ignored
            var operations = [], operationMinor = 0;
            var addEditOperation = function (selection, text) {
                if (selection.isEmpty() && text === '') {
                    // This command wants to add a no-op => no thank you
                    return;
                }
                operations.push({
                    identifier: {
                        major: majorIdentifier,
                        minor: operationMinor++
                    },
                    range: selection,
                    text: text,
                    forceMoveMarkers: false,
                    isAutoWhitespaceEdit: isAutoWhitespaceCommand
                });
            };
            var hadTrackedRange = false;
            var trackSelection = function (selection, trackPreviousOnEmpty) {
                var selectionMarkerStickToPreviousCharacter, positionMarkerStickToPreviousCharacter;
                if (selection.isEmpty()) {
                    // Try to lock it with surrounding text
                    if (typeof trackPreviousOnEmpty === 'boolean') {
                        selectionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                        positionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                    }
                    else {
                        var maxLineColumn = _this.model.getLineMaxColumn(selection.startLineNumber);
                        if (selection.startColumn === maxLineColumn) {
                            selectionMarkerStickToPreviousCharacter = true;
                            positionMarkerStickToPreviousCharacter = true;
                        }
                        else {
                            selectionMarkerStickToPreviousCharacter = false;
                            positionMarkerStickToPreviousCharacter = false;
                        }
                    }
                }
                else {
                    if (selection.getDirection() === selection_1.SelectionDirection.LTR) {
                        selectionMarkerStickToPreviousCharacter = false;
                        positionMarkerStickToPreviousCharacter = true;
                    }
                    else {
                        selectionMarkerStickToPreviousCharacter = true;
                        positionMarkerStickToPreviousCharacter = false;
                    }
                }
                var l = ctx.selectionStartMarkers.length;
                ctx.selectionStartMarkers[l] = _this.model._addMarker(0, selection.selectionStartLineNumber, selection.selectionStartColumn, selectionMarkerStickToPreviousCharacter);
                ctx.positionMarkers[l] = _this.model._addMarker(0, selection.positionLineNumber, selection.positionColumn, positionMarkerStickToPreviousCharacter);
                return l.toString();
            };
            var editOperationBuilder = {
                addEditOperation: addEditOperation,
                trackSelection: trackSelection
            };
            try {
                command.getEditOperations(this.model, editOperationBuilder);
            }
            catch (e) {
                e.friendlyMessage = nls.localize(0, null);
                errors_1.onUnexpectedError(e);
                return {
                    operations: [],
                    hadTrackedRange: false
                };
            }
            return {
                operations: operations,
                hadTrackedRange: hadTrackedRange
            };
        };
        Cursor.prototype._getEditOperations = function (ctx, commands, isAutoWhitespaceCommand) {
            var oneResult;
            var operations = [];
            var hadTrackedRanges = [];
            var anyoneHadTrackedRange;
            for (var i = 0; i < commands.length; i++) {
                if (commands[i]) {
                    oneResult = this._getEditOperationsFromCommand(ctx, i, commands[i], isAutoWhitespaceCommand[i]);
                    operations = operations.concat(oneResult.operations);
                    hadTrackedRanges[i] = oneResult.hadTrackedRange;
                    anyoneHadTrackedRange = anyoneHadTrackedRange || hadTrackedRanges[i];
                }
                else {
                    hadTrackedRanges[i] = false;
                }
            }
            return {
                operations: operations,
                hadTrackedRanges: hadTrackedRanges,
                anyoneHadTrackedRange: anyoneHadTrackedRange
            };
        };
        Cursor.prototype._getLoserCursorMap = function (operations) {
            // This is destructive on the array
            operations = operations.slice(0);
            // Sort operations with last one first
            operations.sort(function (a, b) {
                // Note the minus!
                return -(range_1.Range.compareRangesUsingEnds(a.range, b.range));
            });
            // Operations can not overlap!
            var loserCursorsMap = {};
            var previousOp;
            var currentOp;
            var loserMajor;
            for (var i = 1; i < operations.length; i++) {
                previousOp = operations[i - 1];
                currentOp = operations[i];
                if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {
                    if (previousOp.identifier.major > currentOp.identifier.major) {
                        // previousOp loses the battle
                        loserMajor = previousOp.identifier.major;
                    }
                    else {
                        loserMajor = currentOp.identifier.major;
                    }
                    loserCursorsMap[loserMajor.toString()] = true;
                    for (var j = 0; j < operations.length; j++) {
                        if (operations[j].identifier.major === loserMajor) {
                            operations.splice(j, 1);
                            if (j < i) {
                                i--;
                            }
                            j--;
                        }
                    }
                    if (i > 0) {
                        i--;
                    }
                }
            }
            return loserCursorsMap;
        };
        Cursor.prototype._collapseDeleteCommands = function (rawCmds, isAutoWhitespaceCommand) {
            if (rawCmds.length === 1) {
                return;
            }
            // Merge adjacent delete commands
            var allAreDeleteCommands = rawCmds.every(function (command) {
                if (!(command instanceof replaceCommand_1.ReplaceCommand)) {
                    return false;
                }
                var replCmd = command;
                if (replCmd.getText().length > 0) {
                    return false;
                }
                return true;
            });
            if (!allAreDeleteCommands) {
                return;
            }
            var commands = rawCmds;
            var cursors = commands.map(function (cmd, i) {
                return {
                    range: commands[i].getRange(),
                    order: i
                };
            });
            cursors.sort(function (a, b) {
                return range_1.Range.compareRangesUsingStarts(a.range, b.range);
            });
            var previousCursor = cursors[0];
            for (var i = 1; i < cursors.length; i++) {
                if (previousCursor.range.endLineNumber === cursors[i].range.startLineNumber && previousCursor.range.endColumn === cursors[i].range.startColumn) {
                    // Merge ranges
                    var mergedRange = new range_1.Range(previousCursor.range.startLineNumber, previousCursor.range.startColumn, cursors[i].range.endLineNumber, cursors[i].range.endColumn);
                    previousCursor.range = mergedRange;
                    commands[cursors[i].order].setRange(mergedRange);
                    commands[previousCursor.order].setRange(mergedRange);
                }
                else {
                    // Push previous cursor
                    previousCursor = cursors[i];
                }
            }
        };
        Cursor.prototype._internalExecuteCommands = function (commands, isAutoWhitespaceCommand) {
            var ctx = {
                selectionStartMarkers: [],
                positionMarkers: []
            };
            this._collapseDeleteCommands(commands, isAutoWhitespaceCommand);
            var r = this._innerExecuteCommands(ctx, commands, isAutoWhitespaceCommand);
            for (var i = 0; i < ctx.selectionStartMarkers.length; i++) {
                this.model._removeMarker(ctx.selectionStartMarkers[i]);
                this.model._removeMarker(ctx.positionMarkers[i]);
            }
            return r;
        };
        Cursor.prototype._arrayIsEmpty = function (commands) {
            var i, len;
            for (i = 0, len = commands.length; i < len; i++) {
                if (commands[i]) {
                    return false;
                }
            }
            return true;
        };
        Cursor.prototype._innerExecuteCommands = function (ctx, commands, isAutoWhitespaceCommand) {
            var _this = this;
            if (this.configuration.editor.readOnly) {
                return false;
            }
            if (this._arrayIsEmpty(commands)) {
                return false;
            }
            var selectionsBefore = this.cursors.getSelections();
            var commandsData = this._getEditOperations(ctx, commands, isAutoWhitespaceCommand);
            if (commandsData.operations.length === 0 && !commandsData.anyoneHadTrackedRange) {
                return false;
            }
            var rawOperations = commandsData.operations;
            var editableRange = this.model.getEditableRange();
            var editableRangeStart = editableRange.getStartPosition();
            var editableRangeEnd = editableRange.getEndPosition();
            for (var i = 0; i < rawOperations.length; i++) {
                var operationRange = rawOperations[i].range;
                if (!editableRangeStart.isBeforeOrEqual(operationRange.getStartPosition()) || !operationRange.getEndPosition().isBeforeOrEqual(editableRangeEnd)) {
                    // These commands are outside of the editable range
                    return false;
                }
            }
            var loserCursorsMap = this._getLoserCursorMap(rawOperations);
            if (loserCursorsMap.hasOwnProperty('0')) {
                // These commands are very messed up
                console.warn('Ignoring commands');
                return false;
            }
            // Remove operations belonging to losing cursors
            var filteredOperations = [];
            for (var i = 0; i < rawOperations.length; i++) {
                if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {
                    filteredOperations.push(rawOperations[i]);
                }
            }
            var selectionsAfter = this.model.pushEditOperations(selectionsBefore, filteredOperations, function (inverseEditOperations) {
                var groupedInverseEditOperations = [];
                for (var i = 0; i < selectionsBefore.length; i++) {
                    groupedInverseEditOperations[i] = [];
                }
                for (var i = 0; i < inverseEditOperations.length; i++) {
                    var op = inverseEditOperations[i];
                    if (!op.identifier) {
                        // perhaps auto whitespace trim edits
                        continue;
                    }
                    groupedInverseEditOperations[op.identifier.major].push(op);
                }
                var minorBasedSorter = function (a, b) {
                    return a.identifier.minor - b.identifier.minor;
                };
                var cursorSelections = [];
                for (var i = 0; i < selectionsBefore.length; i++) {
                    if (groupedInverseEditOperations[i].length > 0 || commandsData.hadTrackedRanges[i]) {
                        groupedInverseEditOperations[i].sort(minorBasedSorter);
                        cursorSelections[i] = commands[i].computeCursorState(_this.model, {
                            getInverseEditOperations: function () {
                                return groupedInverseEditOperations[i];
                            },
                            getTrackedSelection: function (id) {
                                var idx = parseInt(id, 10);
                                var selectionStartMarker = _this.model._getMarker(ctx.selectionStartMarkers[idx]);
                                var positionMarker = _this.model._getMarker(ctx.positionMarkers[idx]);
                                return new selection_1.Selection(selectionStartMarker.lineNumber, selectionStartMarker.column, positionMarker.lineNumber, positionMarker.column);
                            }
                        });
                    }
                    else {
                        cursorSelections[i] = selectionsBefore[i];
                    }
                }
                return cursorSelections;
            });
            // Extract losing cursors
            var losingCursorIndex;
            var losingCursors = [];
            for (losingCursorIndex in loserCursorsMap) {
                if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {
                    losingCursors.push(parseInt(losingCursorIndex, 10));
                }
            }
            // Sort losing cursors descending
            losingCursors.sort(function (a, b) {
                return b - a;
            });
            // Remove losing cursors
            for (var i = 0; i < losingCursors.length; i++) {
                selectionsAfter.splice(losingCursors[i], 1);
            }
            return this._interpretCommandResult(selectionsAfter);
        };
        // -----------------------------------------------------------------------------------------------------------
        // ----- emitting events
        Cursor.prototype.emitCursorPositionChanged = function (source, reason) {
            var positions = this.cursors.getPositions();
            var primaryPosition = positions[0];
            var secondaryPositions = positions.slice(1);
            var viewPositions = this.cursors.getViewPositions();
            var primaryViewPosition = viewPositions[0];
            var secondaryViewPositions = viewPositions.slice(1);
            var isInEditableRange = true;
            if (this.model.hasEditableRange()) {
                var editableRange = this.model.getEditableRange();
                if (!editableRange.containsPosition(primaryPosition)) {
                    isInEditableRange = false;
                }
            }
            var e = {
                position: primaryPosition,
                viewPosition: primaryViewPosition,
                secondaryPositions: secondaryPositions,
                secondaryViewPositions: secondaryViewPositions,
                reason: reason,
                source: source,
                isInEditableRange: isInEditableRange
            };
            this.emit(editorCommon.EventType.CursorPositionChanged, e);
        };
        Cursor.prototype.emitCursorSelectionChanged = function (source, reason) {
            var selections = this.cursors.getSelections();
            var primarySelection = selections[0];
            var secondarySelections = selections.slice(1);
            var viewSelections = this.cursors.getViewSelections();
            var primaryViewSelection = viewSelections[0];
            var secondaryViewSelections = viewSelections.slice(1);
            var e = {
                selection: primarySelection,
                viewSelection: primaryViewSelection,
                secondarySelections: secondarySelections,
                secondaryViewSelections: secondaryViewSelections,
                source: source,
                reason: reason
            };
            this.emit(editorCommon.EventType.CursorSelectionChanged, e);
        };
        Cursor.prototype.emitCursorScrollRequest = function (deltaLines, revealCursor) {
            var e = {
                deltaLines: deltaLines,
                revealCursor: revealCursor
            };
            this.emit(editorCommon.EventType.CursorScrollRequest, e);
        };
        Cursor.prototype.revealRange = function (revealTarget, verticalType, revealHorizontal) {
            var positions = this.cursors.getPositions();
            var viewPositions = this.cursors.getViewPositions();
            var position = positions[0];
            var viewPosition = viewPositions[0];
            if (revealTarget === 1 /* TopMost */) {
                for (var i = 1; i < positions.length; i++) {
                    if (positions[i].isBefore(position)) {
                        position = positions[i];
                        viewPosition = viewPositions[i];
                    }
                }
            }
            else if (revealTarget === 2 /* BottomMost */) {
                for (var i = 1; i < positions.length; i++) {
                    if (position.isBeforeOrEqual(positions[i])) {
                        position = positions[i];
                        viewPosition = viewPositions[i];
                    }
                }
            }
            else {
                if (positions.length > 1) {
                    // no revealing!
                    return;
                }
            }
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            var viewRange = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
            this.emitCursorRevealRange(range, viewRange, verticalType, revealHorizontal, false);
        };
        Cursor.prototype.emitCursorRevealRange = function (range, viewRange, verticalType, revealHorizontal, revealCursor) {
            var e = {
                range: range,
                viewRange: viewRange,
                verticalType: verticalType,
                revealHorizontal: revealHorizontal,
                revealCursor: revealCursor
            };
            this.emit(editorCommon.EventType.CursorRevealRange, e);
        };
        // -----------------------------------------------------------------------------------------------------------
        // ----- handlers beyond this point
        Cursor.prototype.trigger = function (source, handlerId, payload) {
            if (!this._handlers.hasOwnProperty(handlerId)) {
                return;
            }
            var handler = this._handlers[handlerId];
            this._onHandler(handlerId, handler, source, payload);
        };
        Cursor.prototype._registerHandlers = function () {
            var _this = this;
            var H = editorCommon.Handler;
            this._handlers[H.CursorMove] = function (ctx) { return _this._cursorMove(ctx); };
            this._handlers[H.MoveTo] = function (ctx) { return _this._moveTo(false, ctx); };
            this._handlers[H.MoveToSelect] = function (ctx) { return _this._moveTo(true, ctx); };
            this._handlers[H.ColumnSelect] = function (ctx) { return _this._columnSelectMouse(ctx); };
            this._handlers[H.AddCursorUp] = function (ctx) { return _this._addCursorUp(ctx); };
            this._handlers[H.AddCursorDown] = function (ctx) { return _this._addCursorDown(ctx); };
            this._handlers[H.CreateCursor] = function (ctx) { return _this._createCursor(ctx); };
            this._handlers[H.LastCursorMoveToSelect] = function (ctx) { return _this._lastCursorMoveTo(ctx); };
            this._handlers[H.CursorLeft] = function (ctx) { return _this._moveLeft(false, ctx); };
            this._handlers[H.CursorLeftSelect] = function (ctx) { return _this._moveLeft(true, ctx); };
            this._handlers[H.CursorWordLeft] = function (ctx) { return _this._moveWordLeft(false, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordStartLeft] = function (ctx) { return _this._moveWordLeft(false, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordEndLeft] = function (ctx) { return _this._moveWordLeft(false, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorWordLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordStartLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordEndLeftSelect] = function (ctx) { return _this._moveWordLeft(true, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorRight] = function (ctx) { return _this._moveRight(false, ctx); };
            this._handlers[H.CursorRightSelect] = function (ctx) { return _this._moveRight(true, ctx); };
            this._handlers[H.CursorWordRight] = function (ctx) { return _this._moveWordRight(false, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorWordStartRight] = function (ctx) { return _this._moveWordRight(false, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordEndRight] = function (ctx) { return _this._moveWordRight(false, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorWordRightSelect] = function (ctx) { return _this._moveWordRight(true, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorWordStartRightSelect] = function (ctx) { return _this._moveWordRight(true, 0 /* WordStart */, ctx); };
            this._handlers[H.CursorWordEndRightSelect] = function (ctx) { return _this._moveWordRight(true, 1 /* WordEnd */, ctx); };
            this._handlers[H.CursorUp] = function (ctx) { return _this._moveUp(false, false, ctx); };
            this._handlers[H.CursorUpSelect] = function (ctx) { return _this._moveUp(true, false, ctx); };
            this._handlers[H.CursorDown] = function (ctx) { return _this._moveDown(false, false, ctx); };
            this._handlers[H.CursorDownSelect] = function (ctx) { return _this._moveDown(true, false, ctx); };
            this._handlers[H.CursorPageUp] = function (ctx) { return _this._moveUp(false, true, ctx); };
            this._handlers[H.CursorPageUpSelect] = function (ctx) { return _this._moveUp(true, true, ctx); };
            this._handlers[H.CursorPageDown] = function (ctx) { return _this._moveDown(false, true, ctx); };
            this._handlers[H.CursorPageDownSelect] = function (ctx) { return _this._moveDown(true, true, ctx); };
            this._handlers[H.CursorHome] = function (ctx) { return _this._moveToBeginningOfLine(false, ctx); };
            this._handlers[H.CursorHomeSelect] = function (ctx) { return _this._moveToBeginningOfLine(true, ctx); };
            this._handlers[H.CursorEnd] = function (ctx) { return _this._moveToEndOfLine(false, ctx); };
            this._handlers[H.CursorEndSelect] = function (ctx) { return _this._moveToEndOfLine(true, ctx); };
            this._handlers[H.CursorTop] = function (ctx) { return _this._moveToBeginningOfBuffer(false, ctx); };
            this._handlers[H.CursorTopSelect] = function (ctx) { return _this._moveToBeginningOfBuffer(true, ctx); };
            this._handlers[H.CursorBottom] = function (ctx) { return _this._moveToEndOfBuffer(false, ctx); };
            this._handlers[H.CursorBottomSelect] = function (ctx) { return _this._moveToEndOfBuffer(true, ctx); };
            this._handlers[H.CursorColumnSelectLeft] = function (ctx) { return _this._columnSelectLeft(ctx); };
            this._handlers[H.CursorColumnSelectRight] = function (ctx) { return _this._columnSelectRight(ctx); };
            this._handlers[H.CursorColumnSelectUp] = function (ctx) { return _this._columnSelectUp(false, ctx); };
            this._handlers[H.CursorColumnSelectPageUp] = function (ctx) { return _this._columnSelectUp(true, ctx); };
            this._handlers[H.CursorColumnSelectDown] = function (ctx) { return _this._columnSelectDown(false, ctx); };
            this._handlers[H.CursorColumnSelectPageDown] = function (ctx) { return _this._columnSelectDown(true, ctx); };
            this._handlers[H.SelectAll] = function (ctx) { return _this._selectAll(ctx); };
            this._handlers[H.LineSelect] = function (ctx) { return _this._line(false, ctx); };
            this._handlers[H.LineSelectDrag] = function (ctx) { return _this._line(true, ctx); };
            this._handlers[H.LastCursorLineSelect] = function (ctx) { return _this._lastCursorLine(false, ctx); };
            this._handlers[H.LastCursorLineSelectDrag] = function (ctx) { return _this._lastCursorLine(true, ctx); };
            this._handlers[H.LineInsertBefore] = function (ctx) { return _this._lineInsertBefore(ctx); };
            this._handlers[H.LineInsertAfter] = function (ctx) { return _this._lineInsertAfter(ctx); };
            this._handlers[H.LineBreakInsert] = function (ctx) { return _this._lineBreakInsert(ctx); };
            this._handlers[H.WordSelect] = function (ctx) { return _this._word(false, ctx); };
            this._handlers[H.WordSelectDrag] = function (ctx) { return _this._word(true, ctx); };
            this._handlers[H.LastCursorWordSelect] = function (ctx) { return _this._lastCursorWord(ctx); };
            this._handlers[H.CancelSelection] = function (ctx) { return _this._cancelSelection(ctx); };
            this._handlers[H.RemoveSecondaryCursors] = function (ctx) { return _this._removeSecondaryCursors(ctx); };
            this._handlers[H.Type] = function (ctx) { return _this._type(ctx); };
            this._handlers[H.ReplacePreviousChar] = function (ctx) { return _this._replacePreviousChar(ctx); };
            this._handlers[H.Tab] = function (ctx) { return _this._tab(ctx); };
            this._handlers[H.Indent] = function (ctx) { return _this._indent(ctx); };
            this._handlers[H.Outdent] = function (ctx) { return _this._outdent(ctx); };
            this._handlers[H.Paste] = function (ctx) { return _this._paste(ctx); };
            this._handlers[H.EditorScroll] = function (ctx) { return _this._editorScroll(ctx); };
            this._handlers[H.ScrollLineUp] = function (ctx) { return _this._scrollUp(false, ctx); };
            this._handlers[H.ScrollLineDown] = function (ctx) { return _this._scrollDown(false, ctx); };
            this._handlers[H.ScrollPageUp] = function (ctx) { return _this._scrollUp(true, ctx); };
            this._handlers[H.ScrollPageDown] = function (ctx) { return _this._scrollDown(true, ctx); };
            this._handlers[H.DeleteLeft] = function (ctx) { return _this._deleteLeft(ctx); };
            this._handlers[H.DeleteWordLeft] = function (ctx) { return _this._deleteWordLeft(true, 0 /* WordStart */, ctx); };
            this._handlers[H.DeleteWordStartLeft] = function (ctx) { return _this._deleteWordLeft(false, 0 /* WordStart */, ctx); };
            this._handlers[H.DeleteWordEndLeft] = function (ctx) { return _this._deleteWordLeft(false, 1 /* WordEnd */, ctx); };
            this._handlers[H.DeleteRight] = function (ctx) { return _this._deleteRight(ctx); };
            this._handlers[H.DeleteWordRight] = function (ctx) { return _this._deleteWordRight(true, 1 /* WordEnd */, ctx); };
            this._handlers[H.DeleteWordStartRight] = function (ctx) { return _this._deleteWordRight(false, 0 /* WordStart */, ctx); };
            this._handlers[H.DeleteWordEndRight] = function (ctx) { return _this._deleteWordRight(false, 1 /* WordEnd */, ctx); };
            this._handlers[H.Cut] = function (ctx) { return _this._cut(ctx); };
            this._handlers[H.ExpandLineSelection] = function (ctx) { return _this._expandLineSelection(ctx); };
            this._handlers[H.Undo] = function (ctx) { return _this._undo(ctx); };
            this._handlers[H.CursorUndo] = function (ctx) { return _this._cursorUndo(ctx); };
            this._handlers[H.Redo] = function (ctx) { return _this._redo(ctx); };
            this._handlers[H.ExecuteCommand] = function (ctx) { return _this._externalExecuteCommand(ctx); };
            this._handlers[H.ExecuteCommands] = function (ctx) { return _this._externalExecuteCommands(ctx); };
            this._handlers[H.RevealLine] = function (ctx) { return _this._revealLine(ctx); };
        };
        Cursor.prototype._invokeForAllSorted = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            return this._doInvokeForAll(ctx, true, callable, pushStackElementBefore, pushStackElementAfter);
        };
        Cursor.prototype._invokeForAll = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            return this._doInvokeForAll(ctx, false, callable, pushStackElementBefore, pushStackElementAfter);
        };
        Cursor.prototype._doInvokeForAll = function (ctx, sorted, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            var result = false;
            var cursors = this.cursors.getAll();
            if (sorted) {
                cursors = cursors.sort(function (a, b) {
                    return range_1.Range.compareRangesUsingStarts(a.modelState.selection, b.modelState.selection);
                });
            }
            var context;
            ctx.shouldPushStackElementBefore = pushStackElementBefore;
            ctx.shouldPushStackElementAfter = pushStackElementAfter;
            for (var i = 0; i < cursors.length; i++) {
                context = {
                    cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
                    shouldReveal: true,
                    shouldRevealVerticalInCenter: false,
                    shouldRevealHorizontal: true,
                    executeCommand: null,
                    isAutoWhitespaceCommand: false,
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false
                };
                result = callable(i, cursors[i], context) || result;
                if (i === 0) {
                    ctx.cursorPositionChangeReason = context.cursorPositionChangeReason;
                    ctx.shouldRevealHorizontal = context.shouldRevealHorizontal;
                    ctx.shouldReveal = context.shouldReveal;
                    ctx.shouldRevealVerticalInCenter = context.shouldRevealVerticalInCenter;
                }
                ctx.shouldPushStackElementBefore = ctx.shouldPushStackElementBefore || context.shouldPushStackElementBefore;
                ctx.shouldPushStackElementAfter = ctx.shouldPushStackElementAfter || context.shouldPushStackElementAfter;
                ctx.executeCommands[i] = context.executeCommand;
                ctx.isAutoWhitespaceCommand[i] = context.isAutoWhitespaceCommand;
            }
            return result;
        };
        Cursor.prototype._moveTo = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveTo(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx); });
        };
        Cursor.prototype._cursorMove = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.move(oneCursor, ctx.eventData, ctx.eventSource, oneCtx); });
        };
        Cursor.prototype._getColumnSelectToLineNumber = function () {
            if (!this._columnSelectToLineNumber) {
                var primaryCursor = this.cursors.getAll()[0];
                var primaryPos = primaryCursor.viewState.position;
                return primaryPos.lineNumber;
            }
            return this._columnSelectToLineNumber;
        };
        Cursor.prototype._getColumnSelectToVisualColumn = function () {
            if (!this._columnSelectToVisualColumn) {
                var primaryCursor = this.cursors.getAll()[0];
                var primaryPos = primaryCursor.viewState.position;
                return cursorCommon_1.CursorColumns.visibleColumnFromColumn2(primaryCursor.config, primaryCursor.viewModel, primaryPos);
            }
            return this._columnSelectToVisualColumn;
        };
        Cursor.prototype._columnSelectMouse = function (ctx) {
            var primary = this.cursors.getAll()[0];
            // validate `eventData`
            var validatedPosition = primary.model.validatePosition(ctx.eventData.position);
            var validatedViewPosition;
            if (ctx.eventData.viewPosition) {
                validatedViewPosition = primary.validateViewPosition(ctx.eventData.viewPosition.lineNumber, ctx.eventData.viewPosition.column, validatedPosition);
            }
            else {
                validatedViewPosition = primary.convertModelPositionToViewPosition(validatedPosition.lineNumber, validatedPosition.column);
            }
            var result = cursorColumnSelection_1.ColumnSelection.columnSelect(primary.config, primary.viewModel, primary.viewState.selection.getStartPosition(), validatedViewPosition.lineNumber, ctx.eventData.mouseColumn - 1);
            var selections = result.viewSelections.map(function (viewSel) { return primary.convertViewSelectionToModelSelection(viewSel); });
            ctx.shouldRevealTarget = (result.reversed ? 1 /* TopMost */ : 2 /* BottomMost */);
            ctx.shouldReveal = true;
            ctx.setColumnSelectToLineNumber = result.toLineNumber;
            ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
            this.cursors.setSelections(selections, result.viewSelections);
            return true;
        };
        Cursor.prototype._columnSelectOp = function (ctx, op) {
            var primary = this.cursors.getAll()[0];
            var result = op(primary, this._getColumnSelectToLineNumber(), this._getColumnSelectToVisualColumn());
            var selections = result.viewSelections.map(function (viewSel) { return primary.convertViewSelectionToModelSelection(viewSel); });
            ctx.shouldRevealTarget = (result.reversed ? 1 /* TopMost */ : 2 /* BottomMost */);
            ctx.shouldReveal = true;
            ctx.setColumnSelectToLineNumber = result.toLineNumber;
            ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
            this.cursors.setSelections(selections, result.viewSelections);
            return true;
        };
        Cursor.prototype._columnSelectLeft = function (ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectLeft(cursor.config, cursor.viewModel, cursor.viewState, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectRight = function (ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectRight(cursor.config, cursor.viewModel, cursor.viewState, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectUp = function (isPaged, ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectUp(cursor.config, cursor.viewModel, cursor.viewState, isPaged, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectDown = function (isPaged, ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return cursorColumnSelection_1.ColumnSelection.columnSelectDown(cursor.config, cursor.viewModel, cursor.viewState, isPaged, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._createCursor = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            this.cursors.addSecondaryCursor({
                selectionStartLineNumber: 1,
                selectionStartColumn: 1,
                positionLineNumber: 1,
                positionColumn: 1
            });
            // Manually move to get events
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    if (ctx.eventData.wholeLine) {
                        return oneCursor_1.OneCursorOp.line(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
                    }
                    else {
                        return oneCursor_1.OneCursorOp.moveTo(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
                    }
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._lastCursorMoveTo = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.moveTo(oneCursor, true, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._addCursorUp = function (ctx) {
            if (this.configuration.editor.readOnly) {
                return false;
            }
            var originalCnt = this.cursors.getSelections().length;
            this.cursors.duplicateCursors();
            ctx.shouldRevealTarget = 1 /* TopMost */;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (cursorIndex >= originalCnt) {
                    return oneCursor_1.OneCursorOp.translateUp(oneCursor, oneCtx);
                }
                return false;
            });
        };
        Cursor.prototype._addCursorDown = function (ctx) {
            if (this.configuration.editor.readOnly) {
                return false;
            }
            var originalCnt = this.cursors.getSelections().length;
            this.cursors.duplicateCursors();
            ctx.shouldRevealTarget = 2 /* BottomMost */;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (cursorIndex >= originalCnt) {
                    return oneCursor_1.OneCursorOp.translateDown(oneCursor, oneCtx);
                }
                return false;
            });
        };
        Cursor.prototype._moveLeft = function (inSelectionMode, ctx) {
            ctx.eventData = ctx.eventData || {};
            ctx.eventData.to = editorCommon.CursorMovePosition.Left;
            ctx.eventData.select = inSelectionMode;
            return this._cursorMove(ctx);
        };
        Cursor.prototype._moveWordLeft = function (inSelectionMode, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordLeft(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
        };
        Cursor.prototype._moveRight = function (inSelectionMode, ctx) {
            ctx.eventData = ctx.eventData || {};
            ctx.eventData.to = editorCommon.CursorMovePosition.Right;
            ctx.eventData.select = inSelectionMode;
            return this._cursorMove(ctx);
        };
        Cursor.prototype._moveWordRight = function (inSelectionMode, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordRight(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
        };
        Cursor.prototype._moveDown = function (inSelectionMode, isPaged, ctx) {
            ctx.eventData = ctx.eventData || {};
            ctx.eventData.to = editorCommon.CursorMovePosition.Down;
            ctx.eventData.select = inSelectionMode;
            ctx.eventData.by = editorCommon.CursorMoveByUnit.WrappedLine;
            ctx.eventData.isPaged = isPaged;
            return this._cursorMove(ctx);
        };
        Cursor.prototype._moveUp = function (inSelectionMode, isPaged, ctx) {
            ctx.eventData = ctx.eventData || {};
            ctx.eventData.to = editorCommon.CursorMovePosition.Up;
            ctx.eventData.select = inSelectionMode;
            ctx.eventData.by = editorCommon.CursorMoveByUnit.WrappedLine;
            ctx.eventData.isPaged = isPaged;
            return this._cursorMove(ctx);
        };
        Cursor.prototype._moveToBeginningOfLine = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfLine(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToEndOfLine = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfLine(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToBeginningOfBuffer = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfBuffer(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToEndOfBuffer = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfBuffer(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._selectAll = function (ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.selectAll(oneCursor, oneCtx); });
        };
        Cursor.prototype._line = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx); });
        };
        Cursor.prototype._lastCursorLine = function (inSelectionMode, ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._expandLineSelection = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.expandLineSelection(oneCursor, oneCtx); });
        };
        Cursor.prototype._word = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.word(oneCursor, inSelectionMode, oneCursor.validatePosition(ctx.eventData.position), oneCtx); });
        };
        Cursor.prototype._lastCursorWord = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.word(oneCursor, true, oneCursor.validatePosition(ctx.eventData.position), oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._removeSecondaryCursors = function (ctx) {
            this.cursors.killSecondaryCursors();
            return true;
        };
        Cursor.prototype._cancelSelection = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.cancelSelection(oneCursor, oneCtx); });
        };
        // -------------------- START editing operations
        Cursor.prototype._doApplyEdit = function (cursorIndex, oneCursor, oneCtx, callable) {
            var r = callable(oneCursor, cursorIndex);
            if (r) {
                oneCtx.executeCommand = r.command;
                oneCtx.shouldPushStackElementBefore = r.shouldPushStackElementBefore;
                oneCtx.shouldPushStackElementAfter = r.shouldPushStackElementAfter;
                oneCtx.isAutoWhitespaceCommand = r.isAutoWhitespaceCommand;
                oneCtx.shouldRevealHorizontal = r.shouldRevealHorizontal;
                oneCtx.cursorPositionChangeReason = r.cursorPositionChangeReason;
            }
            return true;
        };
        Cursor.prototype._applyEditForAll = function (ctx, callable) {
            var _this = this;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return _this._doApplyEdit(cursorIndex, oneCursor, oneCtx, callable); }, false, false);
        };
        Cursor.prototype._applyEditForAllSorted = function (ctx, callable) {
            var _this = this;
            return this._invokeForAllSorted(ctx, function (cursorIndex, oneCursor, oneCtx) { return _this._doApplyEdit(cursorIndex, oneCursor, oneCtx, callable); }, false, false);
        };
        Cursor.prototype._lineInsertBefore = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineInsertBefore(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._lineInsertAfter = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineInsertAfter(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._lineBreakInsert = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.lineBreakInsert(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._type = function (ctx) {
            var _this = this;
            var text = ctx.eventData.text;
            if (ctx.eventSource === 'keyboard') {
                var _loop_1 = function (i, len) {
                    var charCode = text.charCodeAt(i);
                    var chr;
                    if (strings.isHighSurrogate(charCode) && i + 1 < len) {
                        chr = text.charAt(i) + text.charAt(i + 1);
                        i++;
                    }
                    else {
                        chr = text.charAt(i);
                    }
                    // Here we must interpret each typed character individually, that's why we create a new context
                    ctx.hasExecutedCommands = this_1._createAndInterpretHandlerCtx(ctx.eventSource, ctx.eventData, function (charHandlerCtx) {
                        _this._applyEditForAll(charHandlerCtx, function (cursor) { return cursorTypeOperations_1.TypeOperations.typeWithInterceptors(cursor.config, cursor.model, cursor.modelState, chr); });
                        // The last typed character gets to win
                        ctx.cursorPositionChangeReason = charHandlerCtx.cursorPositionChangeReason;
                        ctx.shouldReveal = charHandlerCtx.shouldReveal;
                        ctx.shouldRevealVerticalInCenter = charHandlerCtx.shouldRevealVerticalInCenter;
                        ctx.shouldRevealHorizontal = charHandlerCtx.shouldRevealHorizontal;
                    }) || ctx.hasExecutedCommands;
                    out_i_1 = i;
                };
                var this_1 = this, out_i_1;
                // If this event is coming straight from the keyboard, look for electric characters and enter
                for (var i = 0, len = text.length; i < len; i++) {
                    _loop_1(i, len);
                    i = out_i_1;
                }
            }
            else {
                this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.typeWithoutInterceptors(cursor.config, cursor.model, cursor.modelState, text); });
            }
            return true;
        };
        Cursor.prototype._replacePreviousChar = function (ctx) {
            var text = ctx.eventData.text;
            var replaceCharCnt = ctx.eventData.replaceCharCnt;
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.replacePreviousChar(cursor.config, cursor.model, cursor.modelState, text, replaceCharCnt); });
        };
        Cursor.prototype._tab = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.tab(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._indent = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.indent(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._outdent = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.outdent(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._distributePasteToCursors = function (ctx) {
            if (ctx.eventData.pasteOnNewLine) {
                return null;
            }
            var selections = this.cursors.getSelections();
            if (selections.length === 1) {
                return null;
            }
            for (var i = 0; i < selections.length; i++) {
                if (selections[i].startLineNumber !== selections[i].endLineNumber) {
                    return null;
                }
            }
            var pastePieces = ctx.eventData.text.split(/\r\n|\r|\n/);
            if (pastePieces.length !== selections.length) {
                return null;
            }
            return pastePieces;
        };
        Cursor.prototype._paste = function (ctx) {
            var distributedPaste = this._distributePasteToCursors(ctx);
            if (distributedPaste) {
                return this._applyEditForAllSorted(ctx, function (cursor, cursorIndex) { return cursorTypeOperations_1.TypeOperations.paste(cursor.config, cursor.model, cursor.modelState, distributedPaste[cursorIndex], false); });
            }
            else {
                return this._applyEditForAll(ctx, function (cursor) { return cursorTypeOperations_1.TypeOperations.paste(cursor.config, cursor.model, cursor.modelState, ctx.eventData.text, ctx.eventData.pasteOnNewLine); });
            }
        };
        Cursor.prototype._deleteLeft = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.deleteLeft(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._deleteWordLeft = function (whitespaceHeuristics, wordNavigationType, ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorWordOperations_1.WordOperations.deleteWordLeft(cursor.config, cursor.model, cursor.modelState, whitespaceHeuristics, wordNavigationType); });
        };
        Cursor.prototype._deleteRight = function (ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.deleteRight(cursor.config, cursor.model, cursor.modelState); });
        };
        Cursor.prototype._deleteWordRight = function (whitespaceHeuristics, wordNavigationType, ctx) {
            return this._applyEditForAll(ctx, function (cursor) { return cursorWordOperations_1.WordOperations.deleteWordRight(cursor.config, cursor.model, cursor.modelState, whitespaceHeuristics, wordNavigationType); });
        };
        Cursor.prototype._cut = function (ctx) {
            var _this = this;
            return this._applyEditForAll(ctx, function (cursor) { return cursorDeleteOperations_1.DeleteOperations.cut(cursor.config, cursor.model, cursor.modelState, _this.enableEmptySelectionClipboard); });
        };
        // -------------------- END editing operations
        Cursor.prototype._revealLine = function (ctx) {
            var revealLineArg = ctx.eventData;
            var lineNumber = revealLineArg.lineNumber + 1;
            var range = this.model.validateRange({
                startLineNumber: lineNumber,
                startColumn: 1,
                endLineNumber: lineNumber,
                endColumn: 1
            });
            range = new range_1.Range(range.startLineNumber, range.startColumn, range.endLineNumber, this.model.getLineMaxColumn(range.endLineNumber));
            var revealAt = 0 /* Simple */;
            if (revealLineArg.at) {
                switch (revealLineArg.at) {
                    case editorCommon.RevealLineAtArgument.Top:
                        revealAt = 3 /* Top */;
                        break;
                    case editorCommon.RevealLineAtArgument.Center:
                        revealAt = 1 /* Center */;
                        break;
                    case editorCommon.RevealLineAtArgument.Bottom:
                        revealAt = 4 /* Bottom */;
                        break;
                    default:
                        break;
                }
            }
            this.emitCursorRevealRange(range, null, revealAt, false, false);
            return true;
        };
        Cursor.prototype._editorScroll = function (ctx) {
            var editorScrollArg = ctx.eventData;
            editorScrollArg.value = editorScrollArg.value || 1;
            switch (editorScrollArg.to) {
                case editorCommon.EditorScrollDirection.Up:
                case editorCommon.EditorScrollDirection.Down:
                    return this._scrollUpOrDown(editorScrollArg, ctx);
            }
            return true;
        };
        Cursor.prototype._scrollUpOrDown = function (editorScrollArg, ctx) {
            if (this._scrollByReveal(editorScrollArg, ctx)) {
                return true;
            }
            var up = editorScrollArg.to === editorCommon.EditorScrollDirection.Up;
            var cursor = this.cursors.getAll()[0];
            var noOfLines = editorScrollArg.value || 1;
            switch (editorScrollArg.by) {
                case editorCommon.EditorScrollByUnit.Page:
                    noOfLines = cursor.config.pageSize * noOfLines;
                    break;
                case editorCommon.EditorScrollByUnit.HalfPage:
                    noOfLines = Math.round(cursor.config.pageSize / 2) * noOfLines;
                    break;
            }
            this.emitCursorScrollRequest((up ? -1 : 1) * noOfLines, !!editorScrollArg.revealCursor);
            return true;
        };
        Cursor.prototype._scrollByReveal = function (editorScrollArg, ctx) {
            var up = editorScrollArg.to === editorCommon.EditorScrollDirection.Up;
            var cursor = this.cursors.getAll()[0];
            if (editorCommon.EditorScrollByUnit.Line !== editorScrollArg.by) {
                // Scroll by reveal is done only when unit is line.
                return false;
            }
            if (!up && cursor.isLastLineVisibleInViewPort()) {
                // Scroll by reveal is not done if last line is visible and scrolling down.
                return false;
            }
            var range = up ? cursor.getRangeToRevealModelLinesBeforeViewPortTop(editorScrollArg.value) : cursor.getRangeToRevealModelLinesAfterViewPortBottom(editorScrollArg.value);
            this.emitCursorRevealRange(range, null, up ? 3 /* Top */ : 4 /* Bottom */, false, true);
            return true;
        };
        Cursor.prototype._scrollUp = function (isPaged, ctx) {
            ctx.eventData = { to: editorCommon.EditorScrollDirection.Up, value: 1 };
            ctx.eventData.by = isPaged ? editorCommon.EditorScrollByUnit.Page : editorCommon.EditorScrollByUnit.WrappedLine;
            return this._editorScroll(ctx);
        };
        Cursor.prototype._scrollDown = function (isPaged, ctx) {
            ctx.eventData = { to: editorCommon.EditorScrollDirection.Down, value: 1 };
            ctx.eventData.by = isPaged ? editorCommon.EditorScrollByUnit.Page : editorCommon.EditorScrollByUnit.WrappedLine;
            return this._editorScroll(ctx);
        };
        Cursor.prototype._undo = function (ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
            ctx.hasExecutedCommands = true;
            this._interpretCommandResult(this.model.undo());
            return true;
        };
        Cursor.prototype._cursorUndo = function (ctx) {
            if (this.cursorUndoStack.length === 0) {
                return false;
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
            ctx.isCursorUndo = true;
            this.cursors.restoreState(this.cursorUndoStack.pop());
            return true;
        };
        Cursor.prototype._redo = function (ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Redo;
            ctx.hasExecutedCommands = true;
            this._interpretCommandResult(this.model.redo());
            return true;
        };
        Cursor.prototype._externalExecuteCommand = function (ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                oneCtx.shouldPushStackElementBefore = true;
                oneCtx.shouldPushStackElementAfter = true;
                oneCtx.executeCommand = ctx.eventData;
                return false;
            });
        };
        Cursor.prototype._externalExecuteCommands = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                oneCtx.shouldPushStackElementBefore = true;
                oneCtx.shouldPushStackElementAfter = true;
                oneCtx.executeCommand = ctx.eventData[cursorIndex];
                return false;
            });
        };
        return Cursor;
    }(eventEmitter_1.EventEmitter));
    exports.Cursor = Cursor;
});






define(__m[353/*vs/editor/common/model/textModelWithTokens*/], __M([1/*require*/,0/*exports*/,272/*vs/nls!vs/editor/common/model/textModelWithTokens*/,10/*vs/base/common/errors*/,439/*vs/base/common/stopwatch*/,2/*vs/editor/common/editorCommon*/,94/*vs/editor/common/model/textModel*/,499/*vs/editor/common/model/tokenIterator*/,15/*vs/editor/common/modes*/,64/*vs/editor/common/modes/nullMode*/,81/*vs/editor/common/modes/supports*/,73/*vs/editor/common/modes/supports/richEditBrackets*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,74/*vs/editor/common/model/wordHelper*/]), function (require, exports, nls, errors_1, stopwatch_1, editorCommon, textModel_1, tokenIterator_1, modes_1, nullMode_1, supports_1, richEditBrackets_1, languageConfigurationRegistry_1, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModelTokensChangedEventBuilder = (function () {
        function ModelTokensChangedEventBuilder() {
            this._ranges = [];
        }
        ModelTokensChangedEventBuilder.prototype.registerChangedTokens = function (lineNumber) {
            var ranges = this._ranges;
            var rangesLength = ranges.length;
            var previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;
            if (previousRange && previousRange.toLineNumber === lineNumber - 1) {
                // extend previous range
                previousRange.toLineNumber++;
            }
            else {
                // insert new range
                ranges[rangesLength] = {
                    fromLineNumber: lineNumber,
                    toLineNumber: lineNumber
                };
            }
        };
        ModelTokensChangedEventBuilder.prototype.build = function () {
            if (this._ranges.length === 0) {
                return null;
            }
            return {
                ranges: this._ranges
            };
        };
        return ModelTokensChangedEventBuilder;
    }());
    var TextModelWithTokens = (function (_super) {
        __extends(TextModelWithTokens, _super);
        function TextModelWithTokens(allowedEventTypes, rawText, languageIdentifier) {
            var _this = this;
            allowedEventTypes.push(editorCommon.EventType.ModelTokensChanged);
            allowedEventTypes.push(editorCommon.EventType.ModelLanguageChanged);
            _this = _super.call(this, allowedEventTypes, rawText) || this;
            _this._languageIdentifier = languageIdentifier || nullMode_1.NULL_LANGUAGE_IDENTIFIER;
            _this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange(function (e) {
                if (e.languages.indexOf(_this._languageIdentifier.language) === -1) {
                    return;
                }
                _this._resetTokenizationState();
                _this.emitModelTokensChangedEvent({
                    ranges: [{
                            fromLineNumber: 1,
                            toLineNumber: _this.getLineCount()
                        }]
                });
            });
            _this._revalidateTokensTimeout = -1;
            _this._resetTokenizationState();
            return _this;
        }
        TextModelWithTokens.prototype.dispose = function () {
            this._tokenizationListener.dispose();
            this._clearTimers();
            this._lastState = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithTokens.prototype._shouldAutoTokenize = function () {
            return false;
        };
        TextModelWithTokens.prototype._resetValue = function (newValue) {
            _super.prototype._resetValue.call(this, newValue);
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._resetTokenizationState();
        };
        TextModelWithTokens.prototype._resetTokenizationState = function () {
            this._clearTimers();
            for (var i = 0; i < this._lines.length; i++) {
                this._lines[i].resetTokenizationState();
            }
            this._tokenizationSupport = null;
            if (!this.isTooLargeForHavingAMode()) {
                this._tokenizationSupport = modes_1.TokenizationRegistry.get(this._languageIdentifier.language);
            }
            if (this._tokenizationSupport) {
                var initialState = null;
                try {
                    initialState = this._tokenizationSupport.getInitialState();
                }
                catch (e) {
                    e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                    errors_1.onUnexpectedError(e);
                    this._tokenizationSupport = null;
                }
                if (initialState) {
                    this._lines[0].setState(initialState);
                }
            }
            this._colorMap = modes_1.TokenizationRegistry.getColorMap();
            this._lastState = null;
            this._invalidLineStartIndex = 0;
            this._beginBackgroundTokenization();
        };
        TextModelWithTokens.prototype._clearTimers = function () {
            if (this._revalidateTokensTimeout !== -1) {
                clearTimeout(this._revalidateTokensTimeout);
                this._revalidateTokensTimeout = -1;
            }
        };
        TextModelWithTokens.prototype._withModelTokensChangedEventBuilder = function (callback) {
            var eventBuilder = new ModelTokensChangedEventBuilder();
            var result = callback(eventBuilder);
            if (!this._isDisposing) {
                var e = eventBuilder.build();
                if (e) {
                    this.emit(editorCommon.EventType.ModelTokensChanged, e);
                }
            }
            return result;
        };
        TextModelWithTokens.prototype.getLineTokens = function (lineNumber, inaccurateTokensAcceptable) {
            var _this = this;
            if (inaccurateTokensAcceptable === void 0) { inaccurateTokensAcceptable = false; }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            if (!inaccurateTokensAcceptable) {
                this._withModelTokensChangedEventBuilder(function (eventBuilder) {
                    _this._updateTokensUntilLine(eventBuilder, lineNumber, true);
                });
            }
            return this._getLineTokens(lineNumber);
        };
        TextModelWithTokens.prototype._getLineTokens = function (lineNumber) {
            return this._lines[lineNumber - 1].getTokens(this._languageIdentifier.id, this._colorMap);
        };
        TextModelWithTokens.prototype.getLanguageIdentifier = function () {
            return this._languageIdentifier;
        };
        TextModelWithTokens.prototype.getModeId = function () {
            return this._languageIdentifier.language;
        };
        TextModelWithTokens.prototype.setMode = function (languageIdentifier) {
            if (this._languageIdentifier.id === languageIdentifier.id) {
                // There's nothing to do
                return;
            }
            var e = {
                oldLanguage: this._languageIdentifier.language,
                newLanguage: languageIdentifier.language
            };
            this._languageIdentifier = languageIdentifier;
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._resetTokenizationState();
            this.emitModelTokensChangedEvent({
                ranges: [{
                        fromLineNumber: 1,
                        toLineNumber: this.getLineCount()
                    }]
            });
            this._emitModelModeChangedEvent(e);
        };
        TextModelWithTokens.prototype.getLanguageIdAtPosition = function (_lineNumber, _column) {
            var _this = this;
            if (!this._tokenizationSupport) {
                return this._languageIdentifier.id;
            }
            var _a = this.validatePosition({ lineNumber: _lineNumber, column: _column }), lineNumber = _a.lineNumber, column = _a.column;
            this._withModelTokensChangedEventBuilder(function (eventBuilder) {
                _this._updateTokensUntilLine(eventBuilder, lineNumber, true);
            });
            var lineTokens = this._getLineTokens(lineNumber);
            var token = lineTokens.findTokenAtOffset(column - 1);
            return token.languageId;
        };
        TextModelWithTokens.prototype._invalidateLine = function (lineIndex) {
            this._lines[lineIndex].isInvalid = true;
            if (lineIndex < this._invalidLineStartIndex) {
                if (this._invalidLineStartIndex < this._lines.length) {
                    this._lines[this._invalidLineStartIndex].isInvalid = true;
                }
                this._invalidLineStartIndex = lineIndex;
                this._beginBackgroundTokenization();
            }
        };
        TextModelWithTokens.prototype._beginBackgroundTokenization = function () {
            var _this = this;
            if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {
                this._revalidateTokensTimeout = setTimeout(function () {
                    _this._revalidateTokensTimeout = -1;
                    _this._revalidateTokensNow();
                }, 0);
            }
        };
        TextModelWithTokens.prototype._warmUpTokens = function () {
            // Warm up first 100 lines (if it takes less than 50ms)
            var maxLineNumber = Math.min(100, this.getLineCount());
            var toLineNumber = maxLineNumber;
            for (var lineNumber = 1; lineNumber <= maxLineNumber; lineNumber++) {
                var text = this._lines[lineNumber - 1].text;
                if (text.length >= 200) {
                    // This line is over 200 chars long, so warm up without it
                    toLineNumber = lineNumber - 1;
                    break;
                }
            }
            this._revalidateTokensNow(toLineNumber);
            if (this._invalidLineStartIndex < this._lines.length) {
                this._beginBackgroundTokenization();
            }
        };
        TextModelWithTokens.prototype._revalidateTokensNow = function (toLineNumber) {
            var _this = this;
            if (toLineNumber === void 0) { toLineNumber = this._invalidLineStartIndex + 1000000; }
            this._withModelTokensChangedEventBuilder(function (eventBuilder) {
                toLineNumber = Math.min(_this._lines.length, toLineNumber);
                var MAX_ALLOWED_TIME = 20, fromLineNumber = _this._invalidLineStartIndex + 1, tokenizedChars = 0, currentCharsToTokenize = 0, currentEstimatedTimeToTokenize = 0, sw = stopwatch_1.StopWatch.create(false), elapsedTime;
                // Tokenize at most 1000 lines. Estimate the tokenization speed per character and stop when:
                // - MAX_ALLOWED_TIME is reached
                // - tokenizing the next line would go above MAX_ALLOWED_TIME
                for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                    elapsedTime = sw.elapsed();
                    if (elapsedTime > MAX_ALLOWED_TIME) {
                        // Stop if MAX_ALLOWED_TIME is reached
                        toLineNumber = lineNumber - 1;
                        break;
                    }
                    // Compute how many characters will be tokenized for this line
                    currentCharsToTokenize = _this._lines[lineNumber - 1].text.length;
                    if (tokenizedChars > 0) {
                        // If we have enough history, estimate how long tokenizing this line would take
                        currentEstimatedTimeToTokenize = (elapsedTime / tokenizedChars) * currentCharsToTokenize;
                        if (elapsedTime + currentEstimatedTimeToTokenize > MAX_ALLOWED_TIME) {
                            // Tokenizing this line will go above MAX_ALLOWED_TIME
                            toLineNumber = lineNumber - 1;
                            break;
                        }
                    }
                    _this._updateTokensUntilLine(eventBuilder, lineNumber, false);
                    tokenizedChars += currentCharsToTokenize;
                    // Skip the lines that got tokenized
                    lineNumber = Math.max(lineNumber, _this._invalidLineStartIndex + 1);
                }
                elapsedTime = sw.elapsed();
                if (_this._invalidLineStartIndex < _this._lines.length) {
                    _this._beginBackgroundTokenization();
                }
            });
        };
        TextModelWithTokens.prototype._updateTokensUntilLine = function (eventBuilder, lineNumber, emitEvents) {
            if (!this._tokenizationSupport) {
                this._invalidLineStartIndex = this._lines.length;
                return;
            }
            var linesLength = this._lines.length;
            var endLineIndex = lineNumber - 1;
            // Validate all states up to and including endLineIndex
            for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
                var endStateIndex = lineIndex + 1;
                var r = null;
                var text = this._lines[lineIndex].text;
                try {
                    // Tokenize only the first X characters
                    var freshState = this._lines[lineIndex].getState().clone();
                    r = this._tokenizationSupport.tokenize2(this._lines[lineIndex].text, freshState, 0);
                }
                catch (e) {
                    e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                    errors_1.onUnexpectedError(e);
                }
                if (!r) {
                    r = nullMode_1.nullTokenize2(this._languageIdentifier.id, text, this._lines[lineIndex].getState(), 0);
                }
                this._lines[lineIndex].setTokens(this._languageIdentifier.id, r.tokens);
                eventBuilder.registerChangedTokens(lineIndex + 1);
                this._lines[lineIndex].isInvalid = false;
                if (endStateIndex < linesLength) {
                    if (this._lines[endStateIndex].getState() !== null && r.endState.equals(this._lines[endStateIndex].getState())) {
                        // The end state of this line remains the same
                        var nextInvalidLineIndex = lineIndex + 1;
                        while (nextInvalidLineIndex < linesLength) {
                            if (this._lines[nextInvalidLineIndex].isInvalid) {
                                break;
                            }
                            if (nextInvalidLineIndex + 1 < linesLength) {
                                if (this._lines[nextInvalidLineIndex + 1].getState() === null) {
                                    break;
                                }
                            }
                            else {
                                if (this._lastState === null) {
                                    break;
                                }
                            }
                            nextInvalidLineIndex++;
                        }
                        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                        lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                    }
                    else {
                        this._lines[endStateIndex].setState(r.endState);
                    }
                }
                else {
                    this._lastState = r.endState;
                }
            }
            this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
        };
        TextModelWithTokens.prototype.emitModelTokensChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelTokensChanged, e);
            }
        };
        TextModelWithTokens.prototype._emitModelModeChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelLanguageChanged, e);
            }
        };
        // Having tokens allows implementing additional helper methods
        TextModelWithTokens.prototype.getWordAtPosition = function (_position) {
            this._assertNotDisposed();
            var position = this.validatePosition(_position);
            var lineContent = this.getLineContent(position.lineNumber);
            if (this._invalidLineStartIndex <= position.lineNumber) {
                // this line is not tokenized
                return wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(this._languageIdentifier.id), lineContent, 0);
            }
            var lineTokens = this._getLineTokens(position.lineNumber);
            var offset = position.column - 1;
            var token = lineTokens.findTokenAtOffset(offset);
            var result = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(token.languageId), lineContent.substring(token.startOffset, token.endOffset), token.startOffset);
            if (!result && token.hasPrev && token.startOffset === offset) {
                // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too
                var prevToken = token.prev();
                result = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(prevToken.languageId), lineContent.substring(prevToken.startOffset, prevToken.endOffset), prevToken.startOffset);
            }
            return result;
        };
        TextModelWithTokens.prototype.getWordUntilPosition = function (position) {
            var wordAtPosition = this.getWordAtPosition(position);
            if (!wordAtPosition) {
                return {
                    word: '',
                    startColumn: position.column,
                    endColumn: position.column
                };
            }
            return {
                word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
                startColumn: wordAtPosition.startColumn,
                endColumn: position.column
            };
        };
        TextModelWithTokens.prototype.tokenIterator = function (position, callback) {
            var iter = new tokenIterator_1.TokenIterator(this, this.validatePosition(position));
            var result = callback(iter);
            iter._invalidate();
            return result;
        };
        TextModelWithTokens.prototype.findMatchingBracketUp = function (_bracket, _position) {
            var bracket = _bracket.toLowerCase();
            var position = this.validatePosition(_position);
            var lineTokens = this._getLineTokens(position.lineNumber);
            var token = lineTokens.findTokenAtOffset(position.column - 1);
            var bracketsSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(token.languageId);
            if (!bracketsSupport) {
                return null;
            }
            var data = bracketsSupport.textIsBracket[bracket];
            if (!data) {
                return null;
            }
            return this._findMatchingBracketUp(data, position);
        };
        TextModelWithTokens.prototype.matchBracket = function (position) {
            return this._matchBracket(this.validatePosition(position));
        };
        TextModelWithTokens.prototype._matchBracket = function (position) {
            var lineNumber = position.lineNumber;
            var lineTokens = this._getLineTokens(lineNumber);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = lineTokens.findTokenAtOffset(position.column - 1);
            if (!currentToken) {
                return null;
            }
            var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentToken.languageId);
            // check that the token is not to be ignored
            if (currentModeBrackets && !supports_1.ignoreBracketsInToken(currentToken.tokenType)) {
                // limit search to not go before `maxBracketLength`
                var searchStartOffset = Math.max(currentToken.startOffset, position.column - 1 - currentModeBrackets.maxBracketLength);
                // limit search to not go after `maxBracketLength`
                var searchEndOffset = Math.min(currentToken.endOffset, position.column - 1 + currentModeBrackets.maxBracketLength);
                // first, check if there is a bracket to the right of `position`
                var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, position.column - 1, searchEndOffset);
                if (foundBracket && foundBracket.startColumn === position.column) {
                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
                // it might still be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
                while (true) {
                    var foundBracket_1 = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                    if (!foundBracket_1) {
                        // there are no brackets in this text
                        break;
                    }
                    // check that we didn't hit a bracket too far away from position
                    if (foundBracket_1.startColumn <= position.column && position.column <= foundBracket_1.endColumn) {
                        var foundBracketText = lineText.substring(foundBracket_1.startColumn - 1, foundBracket_1.endColumn - 1);
                        foundBracketText = foundBracketText.toLowerCase();
                        var r = this._matchFoundBracket(foundBracket_1, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                        // check that we can actually match this bracket
                        if (r) {
                            return r;
                        }
                    }
                    searchStartOffset = foundBracket_1.endColumn - 1;
                }
            }
            // If position is in between two tokens, try also looking in the previous token
            if (currentToken.hasPrev && currentToken.startOffset === position.column - 1) {
                var prevToken = currentToken.prev();
                var prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(prevToken.languageId);
                // check that previous token is not to be ignored
                if (prevModeBrackets && !supports_1.ignoreBracketsInToken(prevToken.tokenType)) {
                    // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                    var searchStartOffset = Math.max(prevToken.startOffset, position.column - 1 - prevModeBrackets.maxBracketLength);
                    var searchEndOffset = currentToken.startOffset;
                    var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                    // check that we didn't hit a bracket too far away from position
                    if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                        var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                        foundBracketText = foundBracketText.toLowerCase();
                        var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                        // check that we can actually match this bracket
                        if (r) {
                            return r;
                        }
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
            if (isOpen) {
                var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            else {
                var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._findMatchingBracketUp = function (bracket, position) {
            // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var languageId = bracket.languageIdentifier.id;
            var reversedBracketRegex = bracket.reversedRegex;
            var count = -1;
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._getLineTokens(lineNumber);
                var lineText = this._lines[lineNumber - 1].text;
                var currentToken = void 0;
                var searchStopOffset = void 0;
                if (lineNumber === position.lineNumber) {
                    currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                    searchStopOffset = position.column - 1;
                }
                else {
                    currentToken = lineTokens.lastToken();
                    if (currentToken) {
                        searchStopOffset = currentToken.endOffset;
                    }
                }
                while (currentToken) {
                    if (currentToken.languageId === languageId && !supports_1.ignoreBracketsInToken(currentToken.tokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            hitText = hitText.toLowerCase();
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            searchStopOffset = r.startColumn - 1;
                        }
                    }
                    currentToken = currentToken.prev();
                    if (currentToken) {
                        searchStopOffset = currentToken.endOffset;
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._findMatchingBracketDown = function (bracket, position) {
            // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var languageId = bracket.languageIdentifier.id;
            var bracketRegex = bracket.forwardRegex;
            var count = 1;
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._getLineTokens(lineNumber);
                var lineText = this._lines[lineNumber - 1].text;
                var currentToken = void 0;
                var searchStartOffset = void 0;
                if (lineNumber === position.lineNumber) {
                    currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                    searchStartOffset = position.column - 1;
                }
                else {
                    currentToken = lineTokens.firstToken();
                    if (currentToken) {
                        searchStartOffset = currentToken.startOffset;
                    }
                }
                while (currentToken) {
                    if (currentToken.languageId === languageId && !supports_1.ignoreBracketsInToken(currentToken.tokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            hitText = hitText.toLowerCase();
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            searchStartOffset = r.endColumn - 1;
                        }
                    }
                    currentToken = currentToken.next();
                    if (currentToken) {
                        searchStartOffset = currentToken.startOffset;
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype.findPrevBracket = function (_position) {
            var position = this.validatePosition(_position);
            var languageId = -1;
            var modeBrackets = null;
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._getLineTokens(lineNumber);
                var lineText = this._lines[lineNumber - 1].text;
                var currentToken = void 0;
                var searchStopOffset = void 0;
                if (lineNumber === position.lineNumber) {
                    currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                    searchStopOffset = position.column - 1;
                }
                else {
                    currentToken = lineTokens.lastToken();
                    if (currentToken) {
                        searchStopOffset = currentToken.endOffset;
                    }
                }
                while (currentToken) {
                    if (languageId !== currentToken.languageId) {
                        languageId = currentToken.languageId;
                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);
                    }
                    if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.tokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                        if (r) {
                            return this._toFoundBracket(modeBrackets, r);
                        }
                    }
                    currentToken = currentToken.prev();
                    if (currentToken) {
                        searchStopOffset = currentToken.endOffset;
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype.findNextBracket = function (_position) {
            var position = this.validatePosition(_position);
            var languageId = -1;
            var modeBrackets = null;
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._getLineTokens(lineNumber);
                var lineText = this._lines[lineNumber - 1].text;
                var currentToken = void 0;
                var searchStartOffset = void 0;
                if (lineNumber === position.lineNumber) {
                    currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                    searchStartOffset = position.column - 1;
                }
                else {
                    currentToken = lineTokens.firstToken();
                    if (currentToken) {
                        searchStartOffset = currentToken.startOffset;
                    }
                }
                while (currentToken) {
                    if (languageId !== currentToken.languageId) {
                        languageId = currentToken.languageId;
                        modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(languageId);
                    }
                    if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.tokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                        if (r) {
                            return this._toFoundBracket(modeBrackets, r);
                        }
                    }
                    currentToken = currentToken.next();
                    if (currentToken) {
                        searchStartOffset = currentToken.startOffset;
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._toFoundBracket = function (modeBrackets, r) {
            if (!r) {
                return null;
            }
            var text = this.getValueInRange(r);
            text = text.toLowerCase();
            var data = modeBrackets.textIsBracket[text];
            if (!data) {
                return null;
            }
            return {
                range: r,
                open: data.open,
                close: data.close,
                isOpen: modeBrackets.textIsOpenBracket[text]
            };
        };
        return TextModelWithTokens;
    }(textModel_1.TextModel));
    TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG = nls.localize(0, null);
    exports.TextModelWithTokens = TextModelWithTokens;
});






define(__m[354/*vs/editor/common/model/textModelWithMarkers*/], __M([1/*require*/,0/*exports*/,113/*vs/base/common/idGenerator*/,16/*vs/editor/common/core/position*/,75/*vs/editor/common/model/modelLine*/,353/*vs/editor/common/model/textModelWithTokens*/]), function (require, exports, idGenerator_1, position_1, modelLine_1, textModelWithTokens_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var _INSTANCE_COUNT = 0;
    var TextModelWithMarkers = (function (_super) {
        __extends(TextModelWithMarkers, _super);
        function TextModelWithMarkers(allowedEventTypes, rawText, languageIdentifier) {
            var _this = _super.call(this, allowedEventTypes, rawText, languageIdentifier) || this;
            _this._markerIdGenerator = new idGenerator_1.IdGenerator((++_INSTANCE_COUNT) + ';');
            _this._markerIdToMarker = Object.create(null);
            return _this;
        }
        TextModelWithMarkers.prototype.dispose = function () {
            this._markerIdToMarker = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithMarkers.prototype._resetValue = function (newValue) {
            _super.prototype._resetValue.call(this, newValue);
            // Destroy all my markers
            this._markerIdToMarker = Object.create(null);
        };
        TextModelWithMarkers.prototype._addMarker = function (internalDecorationId, lineNumber, column, stickToPreviousCharacter) {
            var pos = this.validatePosition(new position_1.Position(lineNumber, column));
            var marker = new modelLine_1.LineMarker(this._markerIdGenerator.nextId(), internalDecorationId, pos, stickToPreviousCharacter);
            this._markerIdToMarker[marker.id] = marker;
            this._lines[pos.lineNumber - 1].addMarker(marker);
            return marker.id;
        };
        TextModelWithMarkers.prototype._addMarkers = function (newMarkers) {
            if (newMarkers.length === 0) {
                return [];
            }
            var markers = [];
            for (var i = 0, len = newMarkers.length; i < len; i++) {
                var newMarker = newMarkers[i];
                var marker = new modelLine_1.LineMarker(this._markerIdGenerator.nextId(), newMarker.internalDecorationId, newMarker.position, newMarker.stickToPreviousCharacter);
                this._markerIdToMarker[marker.id] = marker;
                markers[i] = marker;
            }
            var sortedMarkers = markers.slice(0);
            sortedMarkers.sort(function (a, b) {
                return a.position.lineNumber - b.position.lineNumber;
            });
            var currentLineNumber = 0;
            var currentMarkers = [], currentMarkersLen = 0;
            for (var i = 0, len = sortedMarkers.length; i < len; i++) {
                var marker = sortedMarkers[i];
                if (marker.position.lineNumber !== currentLineNumber) {
                    if (currentLineNumber !== 0) {
                        this._lines[currentLineNumber - 1].addMarkers(currentMarkers);
                    }
                    currentLineNumber = marker.position.lineNumber;
                    currentMarkers.length = 0;
                    currentMarkersLen = 0;
                }
                currentMarkers[currentMarkersLen++] = marker;
            }
            this._lines[currentLineNumber - 1].addMarkers(currentMarkers);
            return markers;
        };
        TextModelWithMarkers.prototype._changeMarker = function (id, lineNumber, column) {
            var marker = this._markerIdToMarker[id];
            if (!marker) {
                return;
            }
            var newPos = this.validatePosition(new position_1.Position(lineNumber, column));
            if (newPos.lineNumber !== marker.position.lineNumber) {
                // Move marker between lines
                this._lines[marker.position.lineNumber - 1].removeMarker(marker);
                this._lines[newPos.lineNumber - 1].addMarker(marker);
            }
            marker.setPosition(newPos);
        };
        TextModelWithMarkers.prototype._changeMarkerStickiness = function (id, newStickToPreviousCharacter) {
            var marker = this._markerIdToMarker[id];
            if (!marker) {
                return;
            }
            marker.stickToPreviousCharacter = newStickToPreviousCharacter;
        };
        TextModelWithMarkers.prototype._getMarker = function (id) {
            var marker = this._markerIdToMarker[id];
            if (!marker) {
                return null;
            }
            return marker.position;
        };
        TextModelWithMarkers.prototype._getMarkersCount = function () {
            return Object.keys(this._markerIdToMarker).length;
        };
        TextModelWithMarkers.prototype._getLineMarkers = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].getMarkers();
        };
        TextModelWithMarkers.prototype._removeMarker = function (id) {
            var marker = this._markerIdToMarker[id];
            if (!marker) {
                return;
            }
            this._lines[marker.position.lineNumber - 1].removeMarker(marker);
            delete this._markerIdToMarker[id];
        };
        TextModelWithMarkers.prototype._removeMarkers = function (markers) {
            markers.sort(function (a, b) {
                return a.position.lineNumber - b.position.lineNumber;
            });
            var currentLineNumber = 0;
            var currentMarkers = null;
            for (var i = 0, len = markers.length; i < len; i++) {
                var marker = markers[i];
                delete this._markerIdToMarker[marker.id];
                if (marker.position.lineNumber !== currentLineNumber) {
                    if (currentLineNumber !== 0) {
                        this._lines[currentLineNumber - 1].removeMarkers(currentMarkers);
                    }
                    currentLineNumber = marker.position.lineNumber;
                    currentMarkers = Object.create(null);
                }
                currentMarkers[marker.id] = true;
            }
            this._lines[currentLineNumber - 1].removeMarkers(currentMarkers);
        };
        return TextModelWithMarkers;
    }(textModelWithTokens_1.TextModelWithTokens));
    exports.TextModelWithMarkers = TextModelWithMarkers;
});






define(__m[355/*vs/editor/common/model/textModelWithDecorations*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,109/*vs/base/common/htmlContent*/,9/*vs/base/common/strings*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,75/*vs/editor/common/model/modelLine*/,16/*vs/editor/common/core/position*/,354/*vs/editor/common/model/textModelWithMarkers*/]), function (require, exports, errors_1, htmlContent_1, strings, range_1, editorCommon, modelLine_1, position_1, textModelWithMarkers_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DecorationsTracker = (function () {
        function DecorationsTracker() {
            this.addedDecorations = [];
            this.addedDecorationsLen = 0;
            this.changedDecorations = [];
            this.changedDecorationsLen = 0;
            this.removedDecorations = [];
            this.removedDecorationsLen = 0;
        }
        // --- Build decoration events
        DecorationsTracker.prototype.addNewDecoration = function (id) {
            this.addedDecorations[this.addedDecorationsLen++] = id;
        };
        DecorationsTracker.prototype.addRemovedDecoration = function (id) {
            this.removedDecorations[this.removedDecorationsLen++] = id;
        };
        DecorationsTracker.prototype.addMovedDecoration = function (id) {
            this.changedDecorations[this.changedDecorationsLen++] = id;
        };
        DecorationsTracker.prototype.addUpdatedDecoration = function (id) {
            this.changedDecorations[this.changedDecorationsLen++] = id;
        };
        return DecorationsTracker;
    }());
    var InternalDecoration = (function () {
        function InternalDecoration(id, internalId, ownerId, range, startMarker, endMarker, options) {
            this.id = id;
            this.internalId = internalId;
            this.ownerId = ownerId;
            this.range = range;
            this.startMarker = startMarker;
            this.endMarker = endMarker;
            this.setOptions(options);
        }
        InternalDecoration.prototype.setOptions = function (options) {
            this.options = options;
            this.isForValidation = (this.options.className === editorCommon.ClassName.EditorErrorDecoration
                || this.options.className === editorCommon.ClassName.EditorWarningDecoration);
        };
        InternalDecoration.prototype.setRange = function (multiLineDecorationsMap, range) {
            if (this.range.equalsRange(range)) {
                return;
            }
            var rangeWasMultiLine = (this.range.startLineNumber !== this.range.endLineNumber);
            this.range = range;
            var rangeIsMultiline = (this.range.startLineNumber !== this.range.endLineNumber);
            if (rangeWasMultiLine === rangeIsMultiline) {
                return;
            }
            if (rangeIsMultiline) {
                multiLineDecorationsMap[this.id] = this;
            }
            else {
                delete multiLineDecorationsMap[this.id];
            }
        };
        return InternalDecoration;
    }());
    exports.InternalDecoration = InternalDecoration;
    var _INSTANCE_COUNT = 0;
    /**
     * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
     */
    function nextInstanceId() {
        var LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
        var result = _INSTANCE_COUNT++;
        result = result % (2 * LETTERS_CNT);
        if (result < LETTERS_CNT) {
            return String.fromCharCode(97 /* a */ + result);
        }
        return String.fromCharCode(65 /* A */ + result - LETTERS_CNT);
    }
    var TextModelWithDecorations = (function (_super) {
        __extends(TextModelWithDecorations, _super);
        function TextModelWithDecorations(allowedEventTypes, rawText, languageIdentifier) {
            var _this = this;
            allowedEventTypes.push(editorCommon.EventType.ModelDecorationsChanged);
            _this = _super.call(this, allowedEventTypes, rawText, languageIdentifier) || this;
            _this._instanceId = nextInstanceId();
            _this._lastDecorationId = 0;
            // Initialize decorations
            _this._currentDecorationsTracker = null;
            _this._currentDecorationsTrackerCnt = 0;
            _this._currentMarkersTracker = null;
            _this._currentMarkersTrackerCnt = 0;
            _this._decorations = Object.create(null);
            _this._internalDecorations = Object.create(null);
            _this._multiLineDecorationsMap = Object.create(null);
            return _this;
        }
        TextModelWithDecorations.prototype.dispose = function () {
            this._decorations = null;
            this._internalDecorations = null;
            this._multiLineDecorationsMap = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithDecorations.prototype._resetValue = function (newValue) {
            _super.prototype._resetValue.call(this, newValue);
            // Destroy all my decorations
            this._decorations = Object.create(null);
            this._internalDecorations = Object.create(null);
            this._multiLineDecorationsMap = Object.create(null);
        };
        TextModelWithDecorations._shouldStartMarkerSticksToPreviousCharacter = function (stickiness) {
            if (stickiness === editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges || stickiness === editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore) {
                return true;
            }
            return false;
        };
        TextModelWithDecorations._shouldEndMarkerSticksToPreviousCharacter = function (stickiness) {
            if (stickiness === editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges || stickiness === editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore) {
                return true;
            }
            return false;
        };
        TextModelWithDecorations.prototype._getTrackedRangesCount = function () {
            return Object.keys(this._decorations).length;
        };
        // --- END TrackedRanges
        TextModelWithDecorations.prototype.changeDecorations = function (callback, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            this._assertNotDisposed();
            try {
                this._beginDeferredEmit();
                var decorationsTracker = this._acquireDecorationsTracker();
                return this._changeDecorations(decorationsTracker, ownerId, callback);
            }
            finally {
                this._releaseDecorationsTracker();
                this._endDeferredEmit();
            }
        };
        TextModelWithDecorations.prototype._changeDecorations = function (decorationsTracker, ownerId, callback) {
            var _this = this;
            var changeAccessor = {
                addDecoration: function (range, options) {
                    return _this._addDecorationImpl(decorationsTracker, ownerId, _this.validateRange(range), _normalizeOptions(options));
                },
                changeDecoration: function (id, newRange) {
                    _this._changeDecorationImpl(decorationsTracker, id, _this.validateRange(newRange));
                },
                changeDecorationOptions: function (id, options) {
                    _this._changeDecorationOptionsImpl(decorationsTracker, id, _normalizeOptions(options));
                },
                removeDecoration: function (id) {
                    _this._removeDecorationImpl(decorationsTracker, id);
                },
                deltaDecorations: function (oldDecorations, newDecorations) {
                    return _this._deltaDecorationsImpl(decorationsTracker, ownerId, oldDecorations, _this._normalizeDeltaDecorations(newDecorations));
                }
            };
            var result = null;
            try {
                result = callback(changeAccessor);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            // Invalidate change accessor
            changeAccessor.addDecoration = null;
            changeAccessor.changeDecoration = null;
            changeAccessor.removeDecoration = null;
            changeAccessor.deltaDecorations = null;
            return result;
        };
        TextModelWithDecorations.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            this._assertNotDisposed();
            if (!oldDecorations) {
                oldDecorations = [];
            }
            return this.changeDecorations(function (changeAccessor) {
                return changeAccessor.deltaDecorations(oldDecorations, newDecorations);
            }, ownerId);
        };
        TextModelWithDecorations.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {
            var toRemove = [];
            for (var decorationId in this._decorations) {
                // No `hasOwnProperty` call due to using Object.create(null)
                var decoration = this._decorations[decorationId];
                if (decoration.ownerId === ownerId) {
                    toRemove.push(decoration.id);
                }
            }
            this._removeDecorationsImpl(null, toRemove);
        };
        TextModelWithDecorations.prototype.getDecorationOptions = function (decorationId) {
            var decoration = this._decorations[decorationId];
            if (!decoration) {
                return null;
            }
            return decoration.options;
        };
        TextModelWithDecorations.prototype.getDecorationRange = function (decorationId) {
            var decoration = this._decorations[decorationId];
            if (!decoration) {
                return null;
            }
            return decoration.range;
        };
        TextModelWithDecorations.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                return [];
            }
            return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
        };
        /**
         * Fetch only multi-line decorations that intersect with the given line number range
         */
        TextModelWithDecorations.prototype._getMultiLineDecorations = function (filterRange, filterOwnerId, filterOutValidation) {
            var filterStartLineNumber = filterRange.startLineNumber;
            var filterStartColumn = filterRange.startColumn;
            var filterEndLineNumber = filterRange.endLineNumber;
            var filterEndColumn = filterRange.endColumn;
            var result = [];
            for (var decorationId in this._multiLineDecorationsMap) {
                // No `hasOwnProperty` call due to using Object.create(null)
                var decoration = this._multiLineDecorationsMap[decorationId];
                if (filterOwnerId && decoration.ownerId && decoration.ownerId !== filterOwnerId) {
                    continue;
                }
                if (filterOutValidation && decoration.isForValidation) {
                    continue;
                }
                var range = decoration.range;
                if (range.startLineNumber > filterEndLineNumber) {
                    continue;
                }
                if (range.startLineNumber === filterEndLineNumber && range.startColumn > filterEndColumn) {
                    continue;
                }
                if (range.endLineNumber < filterStartLineNumber) {
                    continue;
                }
                if (range.endLineNumber === filterStartLineNumber && range.endColumn < filterStartColumn) {
                    continue;
                }
                result.push(decoration);
            }
            return result;
        };
        TextModelWithDecorations.prototype._getDecorationsInRange = function (filterRange, filterOwnerId, filterOutValidation) {
            var filterStartLineNumber = filterRange.startLineNumber;
            var filterStartColumn = filterRange.startColumn;
            var filterEndLineNumber = filterRange.endLineNumber;
            var filterEndColumn = filterRange.endColumn;
            var result = this._getMultiLineDecorations(filterRange, filterOwnerId, filterOutValidation);
            var resultMap = {};
            for (var i = 0, len = result.length; i < len; i++) {
                resultMap[result[i].id] = true;
            }
            for (var lineNumber = filterStartLineNumber; lineNumber <= filterEndLineNumber; lineNumber++) {
                var lineMarkers = this._getLineMarkers(lineNumber);
                for (var i = 0, len = lineMarkers.length; i < len; i++) {
                    var lineMarker = lineMarkers[i];
                    var internalDecorationId = lineMarker.internalDecorationId;
                    if (internalDecorationId === 0) {
                        // marker does not belong to any decoration
                        continue;
                    }
                    var decoration = this._internalDecorations[internalDecorationId];
                    if (resultMap.hasOwnProperty(decoration.id)) {
                        // decoration already in result
                        continue;
                    }
                    if (filterOwnerId && decoration.ownerId && decoration.ownerId !== filterOwnerId) {
                        continue;
                    }
                    if (filterOutValidation && decoration.isForValidation) {
                        continue;
                    }
                    var range = decoration.range;
                    if (range.startLineNumber > filterEndLineNumber) {
                        continue;
                    }
                    if (range.startLineNumber === filterEndLineNumber && range.startColumn > filterEndColumn) {
                        continue;
                    }
                    if (range.endLineNumber < filterStartLineNumber) {
                        continue;
                    }
                    if (range.endLineNumber === filterStartLineNumber && range.endColumn < filterStartColumn) {
                        continue;
                    }
                    result.push(decoration);
                    resultMap[decoration.id] = true;
                }
            }
            return result;
        };
        TextModelWithDecorations.prototype.getLinesDecorations = function (_startLineNumber, _endLineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var lineCount = this.getLineCount();
            var startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));
            var endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));
            var endColumn = this.getLineMaxColumn(endLineNumber);
            return this._getDecorationsInRange(new range_1.Range(startLineNumber, 1, endLineNumber, endColumn), ownerId, filterOutValidation);
        };
        TextModelWithDecorations.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
            var validatedRange = this.validateRange(range);
            return this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation);
        };
        TextModelWithDecorations.prototype.getAllDecorations = function (ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var result = [];
            for (var decorationId in this._decorations) {
                // No `hasOwnProperty` call due to using Object.create(null)
                var decoration = this._decorations[decorationId];
                if (ownerId && decoration.ownerId && decoration.ownerId !== ownerId) {
                    continue;
                }
                if (filterOutValidation && decoration.isForValidation) {
                    continue;
                }
                result.push(decoration);
            }
            return result;
        };
        TextModelWithDecorations.prototype._acquireMarkersTracker = function () {
            if (this._currentMarkersTrackerCnt === 0) {
                this._currentMarkersTracker = new modelLine_1.MarkersTracker();
            }
            this._currentMarkersTrackerCnt++;
            return this._currentMarkersTracker;
        };
        TextModelWithDecorations.prototype._releaseMarkersTracker = function () {
            this._currentMarkersTrackerCnt--;
            if (this._currentMarkersTrackerCnt === 0) {
                var markersTracker = this._currentMarkersTracker;
                this._currentMarkersTracker = null;
                this._handleTrackedMarkers(markersTracker);
            }
        };
        /**
         * Handle changed markers (i.e. update decorations ranges and return the changed decorations, unique and sorted by id)
         */
        TextModelWithDecorations.prototype._handleTrackedMarkers = function (markersTracker) {
            var changedInternalDecorationIds = markersTracker.getDecorationIds();
            if (changedInternalDecorationIds.length === 0) {
                return;
            }
            changedInternalDecorationIds.sort();
            var uniqueChangedDecorations = [], uniqueChangedDecorationsLen = 0;
            var previousInternalDecorationId = 0;
            for (var i = 0, len = changedInternalDecorationIds.length; i < len; i++) {
                var internalDecorationId = changedInternalDecorationIds[i];
                if (internalDecorationId === previousInternalDecorationId) {
                    continue;
                }
                previousInternalDecorationId = internalDecorationId;
                var decoration = this._internalDecorations[internalDecorationId];
                if (!decoration) {
                    // perhaps the decoration was removed in the meantime
                    continue;
                }
                var startMarker = decoration.startMarker.position;
                var endMarker = decoration.endMarker.position;
                var range = TextModelWithDecorations._createRangeFromMarkers(startMarker, endMarker);
                decoration.setRange(this._multiLineDecorationsMap, range);
                uniqueChangedDecorations[uniqueChangedDecorationsLen++] = decoration.id;
            }
            if (uniqueChangedDecorations.length > 0) {
                var e = {
                    addedDecorations: [],
                    changedDecorations: uniqueChangedDecorations,
                    removedDecorations: []
                };
                this.emitModelDecorationsChangedEvent(e);
            }
        };
        TextModelWithDecorations._createRangeFromMarkers = function (startPosition, endPosition) {
            if (endPosition.isBefore(startPosition)) {
                // This tracked range has turned in on itself (end marker before start marker)
                // This can happen in extreme editing conditions where lots of text is removed and lots is added
                // Treat it as a collapsed range
                return new range_1.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column);
            }
            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        };
        TextModelWithDecorations.prototype._acquireDecorationsTracker = function () {
            if (this._currentDecorationsTrackerCnt === 0) {
                this._currentDecorationsTracker = new DecorationsTracker();
            }
            this._currentDecorationsTrackerCnt++;
            return this._currentDecorationsTracker;
        };
        TextModelWithDecorations.prototype._releaseDecorationsTracker = function () {
            this._currentDecorationsTrackerCnt--;
            if (this._currentDecorationsTrackerCnt === 0) {
                var decorationsTracker = this._currentDecorationsTracker;
                this._currentDecorationsTracker = null;
                this._handleTrackedDecorations(decorationsTracker);
            }
        };
        TextModelWithDecorations.prototype._handleTrackedDecorations = function (decorationsTracker) {
            if (decorationsTracker.addedDecorationsLen === 0
                && decorationsTracker.changedDecorationsLen === 0
                && decorationsTracker.removedDecorationsLen === 0) {
                return;
            }
            var e = {
                addedDecorations: decorationsTracker.addedDecorations,
                changedDecorations: decorationsTracker.changedDecorations,
                removedDecorations: decorationsTracker.removedDecorations
            };
            this.emitModelDecorationsChangedEvent(e);
        };
        TextModelWithDecorations.prototype.emitModelDecorationsChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelDecorationsChanged, e);
            }
        };
        TextModelWithDecorations.prototype._normalizeDeltaDecorations = function (deltaDecorations) {
            var result = [];
            for (var i = 0, len = deltaDecorations.length; i < len; i++) {
                var deltaDecoration = deltaDecorations[i];
                result.push(new ModelDeltaDecoration(i, this.validateRange(deltaDecoration.range), _normalizeOptions(deltaDecoration.options)));
            }
            return result;
        };
        TextModelWithDecorations.prototype._externalDecorationId = function (internalId) {
            return this._instanceId + ";" + internalId;
        };
        TextModelWithDecorations.prototype._addDecorationImpl = function (decorationsTracker, ownerId, _range, options) {
            var range = this.validateRange(_range);
            var internalDecorationId = (++this._lastDecorationId);
            var decorationId = this._externalDecorationId(internalDecorationId);
            var markers = this._addMarkers([
                {
                    internalDecorationId: internalDecorationId,
                    position: new position_1.Position(range.startLineNumber, range.startColumn),
                    stickToPreviousCharacter: TextModelWithDecorations._shouldStartMarkerSticksToPreviousCharacter(options.stickiness)
                },
                {
                    internalDecorationId: internalDecorationId,
                    position: new position_1.Position(range.endLineNumber, range.endColumn),
                    stickToPreviousCharacter: TextModelWithDecorations._shouldEndMarkerSticksToPreviousCharacter(options.stickiness)
                }
            ]);
            var decoration = new InternalDecoration(decorationId, internalDecorationId, ownerId, range, markers[0], markers[1], options);
            this._decorations[decorationId] = decoration;
            this._internalDecorations[internalDecorationId] = decoration;
            if (range.startLineNumber !== range.endLineNumber) {
                this._multiLineDecorationsMap[decorationId] = decoration;
            }
            decorationsTracker.addNewDecoration(decorationId);
            return decorationId;
        };
        TextModelWithDecorations.prototype._addDecorationsImpl = function (decorationsTracker, ownerId, newDecorations) {
            var internalDecorationIds = [];
            var decorationIds = [];
            var newMarkers = [];
            for (var i = 0, len = newDecorations.length; i < len; i++) {
                var newDecoration = newDecorations[i];
                var range = newDecoration.range;
                var stickiness = newDecoration.options.stickiness;
                var internalDecorationId = (++this._lastDecorationId);
                var decorationId = this._externalDecorationId(internalDecorationId);
                internalDecorationIds[i] = internalDecorationId;
                decorationIds[i] = decorationId;
                newMarkers[2 * i] = {
                    internalDecorationId: internalDecorationId,
                    position: new position_1.Position(range.startLineNumber, range.startColumn),
                    stickToPreviousCharacter: TextModelWithDecorations._shouldStartMarkerSticksToPreviousCharacter(stickiness)
                };
                newMarkers[2 * i + 1] = {
                    internalDecorationId: internalDecorationId,
                    position: new position_1.Position(range.endLineNumber, range.endColumn),
                    stickToPreviousCharacter: TextModelWithDecorations._shouldEndMarkerSticksToPreviousCharacter(stickiness)
                };
            }
            var markerIds = this._addMarkers(newMarkers);
            for (var i = 0, len = newDecorations.length; i < len; i++) {
                var newDecoration = newDecorations[i];
                var range = newDecoration.range;
                var internalDecorationId = internalDecorationIds[i];
                var decorationId = decorationIds[i];
                var startMarker = markerIds[2 * i];
                var endMarker = markerIds[2 * i + 1];
                var decoration = new InternalDecoration(decorationId, internalDecorationId, ownerId, range, startMarker, endMarker, newDecoration.options);
                this._decorations[decorationId] = decoration;
                this._internalDecorations[internalDecorationId] = decoration;
                if (range.startLineNumber !== range.endLineNumber) {
                    this._multiLineDecorationsMap[decorationId] = decoration;
                }
                decorationsTracker.addNewDecoration(decorationId);
            }
            return decorationIds;
        };
        TextModelWithDecorations.prototype._changeDecorationImpl = function (decorationsTracker, decorationId, newRange) {
            var decoration = this._decorations[decorationId];
            if (!decoration) {
                return;
            }
            var startMarker = decoration.startMarker;
            if (newRange.startLineNumber !== startMarker.position.lineNumber) {
                // move marker between lines
                this._lines[startMarker.position.lineNumber - 1].removeMarker(startMarker);
                this._lines[newRange.startLineNumber - 1].addMarker(startMarker);
            }
            startMarker.setPosition(new position_1.Position(newRange.startLineNumber, newRange.startColumn));
            var endMarker = decoration.endMarker;
            if (newRange.endLineNumber !== endMarker.position.lineNumber) {
                // move marker between lines
                this._lines[endMarker.position.lineNumber - 1].removeMarker(endMarker);
                this._lines[newRange.endLineNumber - 1].addMarker(endMarker);
            }
            endMarker.setPosition(new position_1.Position(newRange.endLineNumber, newRange.endColumn));
            decoration.setRange(this._multiLineDecorationsMap, newRange);
            decorationsTracker.addMovedDecoration(decorationId);
        };
        TextModelWithDecorations.prototype._changeDecorationOptionsImpl = function (decorationsTracker, decorationId, options) {
            var decoration = this._decorations[decorationId];
            if (!decoration) {
                return;
            }
            if (decoration.options.stickiness !== options.stickiness) {
                decoration.startMarker.stickToPreviousCharacter = TextModelWithDecorations._shouldStartMarkerSticksToPreviousCharacter(options.stickiness);
                decoration.endMarker.stickToPreviousCharacter = TextModelWithDecorations._shouldEndMarkerSticksToPreviousCharacter(options.stickiness);
            }
            decoration.setOptions(options);
            decorationsTracker.addUpdatedDecoration(decorationId);
        };
        TextModelWithDecorations.prototype._removeDecorationImpl = function (decorationsTracker, decorationId) {
            var decoration = this._decorations[decorationId];
            if (!decoration) {
                return;
            }
            this._removeMarkers([decoration.startMarker, decoration.endMarker]);
            delete this._multiLineDecorationsMap[decorationId];
            delete this._decorations[decorationId];
            delete this._internalDecorations[decoration.internalId];
            if (decorationsTracker) {
                decorationsTracker.addRemovedDecoration(decorationId);
            }
        };
        TextModelWithDecorations.prototype._removeDecorationsImpl = function (decorationsTracker, decorationIds) {
            var removeMarkers = [], removeMarkersLen = 0;
            for (var i = 0, len = decorationIds.length; i < len; i++) {
                var decorationId = decorationIds[i];
                var decoration = this._decorations[decorationId];
                if (!decoration) {
                    continue;
                }
                if (decorationsTracker) {
                    decorationsTracker.addRemovedDecoration(decorationId);
                }
                removeMarkers[removeMarkersLen++] = decoration.startMarker;
                removeMarkers[removeMarkersLen++] = decoration.endMarker;
                delete this._multiLineDecorationsMap[decorationId];
                delete this._decorations[decorationId];
                delete this._internalDecorations[decoration.internalId];
            }
            if (removeMarkers.length > 0) {
                this._removeMarkers(removeMarkers);
            }
        };
        TextModelWithDecorations.prototype._resolveOldDecorations = function (oldDecorations) {
            var result = [];
            for (var i = 0, len = oldDecorations.length; i < len; i++) {
                var id = oldDecorations[i];
                var decoration = this._decorations[id];
                if (!decoration) {
                    continue;
                }
                result.push(decoration);
            }
            return result;
        };
        TextModelWithDecorations.prototype._deltaDecorationsImpl = function (decorationsTracker, ownerId, oldDecorationsIds, newDecorations) {
            if (oldDecorationsIds.length === 0) {
                // Nothing to remove
                return this._addDecorationsImpl(decorationsTracker, ownerId, newDecorations);
            }
            if (newDecorations.length === 0) {
                // Nothing to add
                this._removeDecorationsImpl(decorationsTracker, oldDecorationsIds);
                return [];
            }
            var oldDecorations = this._resolveOldDecorations(oldDecorationsIds);
            oldDecorations.sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.range, b.range); });
            newDecorations.sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.range, b.range); });
            var result = [], oldDecorationsIndex = 0, oldDecorationsLength = oldDecorations.length, newDecorationsIndex = 0, newDecorationsLength = newDecorations.length, decorationsToAdd = [], decorationsToRemove = [];
            while (oldDecorationsIndex < oldDecorationsLength && newDecorationsIndex < newDecorationsLength) {
                var oldDecoration = oldDecorations[oldDecorationsIndex];
                var newDecoration = newDecorations[newDecorationsIndex];
                var comparison = range_1.Range.compareRangesUsingStarts(oldDecoration.range, newDecoration.range);
                if (comparison < 0) {
                    // `oldDecoration` is before `newDecoration` => remove `oldDecoration`
                    decorationsToRemove.push(oldDecoration.id);
                    oldDecorationsIndex++;
                    continue;
                }
                if (comparison > 0) {
                    // `newDecoration` is before `oldDecoration` => add `newDecoration`
                    decorationsToAdd.push(newDecoration);
                    newDecorationsIndex++;
                    continue;
                }
                // The ranges of `oldDecoration` and `newDecoration` are equal
                if (!oldDecoration.options.equals(newDecoration.options)) {
                    // The options do not match => remove `oldDecoration`
                    decorationsToRemove.push(oldDecoration.id);
                    oldDecorationsIndex++;
                    continue;
                }
                // Bingo! We can reuse `oldDecoration` for `newDecoration`
                result[newDecoration.index] = oldDecoration.id;
                oldDecorationsIndex++;
                newDecorationsIndex++;
            }
            while (oldDecorationsIndex < oldDecorationsLength) {
                // No more new decorations => remove decoration at `oldDecorationsIndex`
                decorationsToRemove.push(oldDecorations[oldDecorationsIndex].id);
                oldDecorationsIndex++;
            }
            while (newDecorationsIndex < newDecorationsLength) {
                // No more old decorations => add decoration at `newDecorationsIndex`
                decorationsToAdd.push(newDecorations[newDecorationsIndex]);
                newDecorationsIndex++;
            }
            // Remove `decorationsToRemove`
            if (decorationsToRemove.length > 0) {
                this._removeDecorationsImpl(decorationsTracker, decorationsToRemove);
            }
            // Add `decorationsToAdd`
            if (decorationsToAdd.length > 0) {
                var newIds = this._addDecorationsImpl(decorationsTracker, ownerId, decorationsToAdd);
                for (var i = 0, len = decorationsToAdd.length; i < len; i++) {
                    result[decorationsToAdd[i].index] = newIds[i];
                }
            }
            return result;
        };
        return TextModelWithDecorations;
    }(textModelWithMarkers_1.TextModelWithMarkers));
    exports.TextModelWithDecorations = TextModelWithDecorations;
    function cleanClassName(className) {
        return className.replace(/[^a-z0-9\-]/gi, ' ');
    }
    var ModelDecorationOptions = (function () {
        function ModelDecorationOptions(options) {
            this.stickiness = options.stickiness || editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            this.className = options.className ? cleanClassName(options.className) : strings.empty;
            this.hoverMessage = options.hoverMessage || [];
            this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || strings.empty;
            this.isWholeLine = options.isWholeLine || false;
            this.overviewRuler = _normalizeOverviewRulerOptions(options.overviewRuler, options.showInOverviewRuler);
            this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : strings.empty;
            this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : strings.empty;
            this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : strings.empty;
            this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : strings.empty;
            this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : strings.empty;
            this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : strings.empty;
        }
        ModelDecorationOptions._overviewRulerEquals = function (a, b) {
            return (a.color === b.color
                && a.position === b.position
                && a.darkColor === b.darkColor);
        };
        ModelDecorationOptions.prototype.equals = function (other) {
            return (this.stickiness === other.stickiness
                && this.className === other.className
                && this.isWholeLine === other.isWholeLine
                && this.showInOverviewRuler === other.showInOverviewRuler
                && this.glyphMarginClassName === other.glyphMarginClassName
                && this.linesDecorationsClassName === other.linesDecorationsClassName
                && this.marginClassName === other.marginClassName
                && this.inlineClassName === other.inlineClassName
                && this.beforeContentClassName === other.beforeContentClassName
                && this.afterContentClassName === other.afterContentClassName
                && htmlContent_1.markedStringsEquals(this.hoverMessage, other.hoverMessage)
                && htmlContent_1.markedStringsEquals(this.glyphMarginHoverMessage, other.glyphMarginHoverMessage)
                && ModelDecorationOptions._overviewRulerEquals(this.overviewRuler, other.overviewRuler));
        };
        return ModelDecorationOptions;
    }());
    exports.ModelDecorationOptions = ModelDecorationOptions;
    var ModelDeltaDecoration = (function () {
        function ModelDeltaDecoration(index, range, options) {
            this.index = index;
            this.range = range;
            this.options = options;
        }
        return ModelDeltaDecoration;
    }());
    function _normalizeOptions(options) {
        return new ModelDecorationOptions(options);
    }
    var ModelDecorationOverviewRulerOptions = (function () {
        function ModelDecorationOverviewRulerOptions(options, legacyShowInOverviewRuler) {
            this.color = strings.empty;
            this.darkColor = strings.empty;
            this.position = editorCommon.OverviewRulerLane.Center;
            if (legacyShowInOverviewRuler) {
                this.color = legacyShowInOverviewRuler;
            }
            if (options && options.color) {
                this.color = options.color;
            }
            if (options && options.darkColor) {
                this.darkColor = options.darkColor;
            }
            if (options && options.hasOwnProperty('position')) {
                this.position = options.position;
            }
        }
        return ModelDecorationOverviewRulerOptions;
    }());
    function _normalizeOverviewRulerOptions(options, legacyShowInOverviewRuler) {
        if (legacyShowInOverviewRuler === void 0) { legacyShowInOverviewRuler = null; }
        return new ModelDecorationOverviewRulerOptions(options, legacyShowInOverviewRuler);
    }
});






define(__m[356/*vs/editor/common/model/editableTextModel*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,495/*vs/editor/common/model/editStack*/,75/*vs/editor/common/model/modelLine*/,355/*vs/editor/common/model/textModelWithDecorations*/,9/*vs/base/common/strings*/,16/*vs/editor/common/core/position*/]), function (require, exports, range_1, editorCommon, editStack_1, modelLine_1, textModelWithDecorations_1, strings, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditableTextModel = (function (_super) {
        __extends(EditableTextModel, _super);
        function EditableTextModel(allowedEventTypes, rawText, languageIdentifier) {
            var _this = this;
            allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged);
            _this = _super.call(this, allowedEventTypes, rawText, languageIdentifier) || this;
            _this._commandManager = new editStack_1.EditStack(_this);
            _this._isUndoing = false;
            _this._isRedoing = false;
            _this._hasEditableRange = false;
            _this._editableRangeId = null;
            _this._trimAutoWhitespaceLines = null;
            return _this;
        }
        EditableTextModel.prototype.onDidChangeRawContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelRawContentChanged, listener);
        };
        EditableTextModel.prototype.onDidChangeContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelContentChanged2, listener);
        };
        EditableTextModel.prototype.dispose = function () {
            this._commandManager = null;
            _super.prototype.dispose.call(this);
        };
        EditableTextModel.prototype._resetValue = function (newValue) {
            _super.prototype._resetValue.call(this, newValue);
            // Destroy my edit history and settings
            this._commandManager = new editStack_1.EditStack(this);
            this._hasEditableRange = false;
            this._editableRangeId = null;
            this._trimAutoWhitespaceLines = null;
        };
        EditableTextModel.prototype.pushStackElement = function () {
            this._commandManager.pushStackElement();
        };
        EditableTextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
            try {
                this._beginDeferredEmit();
                return this._pushEditOperations(beforeCursorState, editOperations, cursorStateComputer);
            }
            finally {
                this._endDeferredEmit();
            }
        };
        EditableTextModel.prototype._pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
            var _this = this;
            if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
                // Go through each saved line number and insert a trim whitespace edit
                // if it is safe to do so (no conflicts with other edits).
                var incomingEdits = editOperations.map(function (op) {
                    return {
                        range: _this.validateRange(op.range),
                        text: op.text
                    };
                });
                // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor
                // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace
                var editsAreNearCursors = true;
                for (var i = 0, len = beforeCursorState.length; i < len; i++) {
                    var sel = beforeCursorState[i];
                    var foundEditNearSel = false;
                    for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                        var editRange = incomingEdits[j].range;
                        var selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                        var selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                        if (!selIsAbove && !selIsBelow) {
                            foundEditNearSel = true;
                            break;
                        }
                    }
                    if (!foundEditNearSel) {
                        editsAreNearCursors = false;
                        break;
                    }
                }
                if (editsAreNearCursors) {
                    for (var i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {
                        var trimLineNumber = this._trimAutoWhitespaceLines[i];
                        var maxLineColumn = this.getLineMaxColumn(trimLineNumber);
                        var allowTrimLine = true;
                        for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                            var editRange = incomingEdits[j].range;
                            var editText = incomingEdits[j].text;
                            if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                                // `trimLine` is completely outside this edit
                                continue;
                            }
                            // At this point:
                            //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber
                            if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn
                                && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\n') {
                                // This edit inserts a new line (and maybe other text) after `trimLine`
                                continue;
                            }
                            // Looks like we can't trim this line as it would interfere with an incoming edit
                            allowTrimLine = false;
                            break;
                        }
                        if (allowTrimLine) {
                            editOperations.push({
                                identifier: null,
                                range: new range_1.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),
                                text: null,
                                forceMoveMarkers: false,
                                isAutoWhitespaceEdit: false
                            });
                        }
                    }
                }
                this._trimAutoWhitespaceLines = null;
            }
            return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
        };
        /**
         * Transform operations such that they represent the same logic edit,
         * but that they also do not cause OOM crashes.
         */
        EditableTextModel.prototype._reduceOperations = function (operations) {
            if (operations.length < 1000) {
                // We know from empirical testing that a thousand edits work fine regardless of their shape.
                return operations;
            }
            // At one point, due to how events are emitted and how each operation is handled,
            // some operations can trigger a high ammount of temporary string allocations,
            // that will immediately get edited again.
            // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
            // Therefore, the strategy is to collapse all the operations into a huge single edit operation
            return [this._toSingleEditOperation(operations)];
        };
        EditableTextModel.prototype._toSingleEditOperation = function (operations) {
            var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new range_1.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];
            for (var i = 0, len = operations.length; i < len; i++) {
                var operation = operations[i], range = operation.range;
                forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
                // (1) -- Push old text
                for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {
                    if (lineNumber === lastEndLineNumber) {
                        result.push(this._lines[lineNumber - 1].text.substring(lastEndColumn - 1));
                    }
                    else {
                        result.push('\n');
                        result.push(this._lines[lineNumber - 1].text);
                    }
                }
                if (range.startLineNumber === lastEndLineNumber) {
                    result.push(this._lines[range.startLineNumber - 1].text.substring(lastEndColumn - 1, range.startColumn - 1));
                }
                else {
                    result.push('\n');
                    result.push(this._lines[range.startLineNumber - 1].text.substring(0, range.startColumn - 1));
                }
                // (2) -- Push new text
                if (operation.lines) {
                    for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {
                        if (j !== 0) {
                            result.push('\n');
                        }
                        result.push(operation.lines[j]);
                    }
                }
                lastEndLineNumber = operation.range.endLineNumber;
                lastEndColumn = operation.range.endColumn;
            }
            return {
                sortIndex: 0,
                identifier: operations[0].identifier,
                range: entireEditRange,
                rangeLength: this.getValueLengthInRange(entireEditRange),
                lines: result.join('').split('\n'),
                forceMoveMarkers: forceMoveMarkers,
                isAutoWhitespaceEdit: false
            };
        };
        EditableTextModel._sortOpsAscending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return a.sortIndex - b.sortIndex;
            }
            return r;
        };
        EditableTextModel._sortOpsDescending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return b.sortIndex - a.sortIndex;
            }
            return -r;
        };
        EditableTextModel.prototype.applyEdits = function (rawOperations) {
            try {
                this._beginDeferredEmit();
                var markersTracker = this._acquireMarkersTracker();
                return this._applyEdits(markersTracker, rawOperations);
            }
            finally {
                this._releaseMarkersTracker();
                this._endDeferredEmit();
            }
        };
        EditableTextModel.prototype._applyEdits = function (markersTracker, rawOperations) {
            if (rawOperations.length === 0) {
                return [];
            }
            var mightContainRTL = this._mightContainRTL;
            var mightContainNonBasicASCII = this._mightContainNonBasicASCII;
            var operations = [];
            for (var i = 0; i < rawOperations.length; i++) {
                var op = rawOperations[i];
                var validatedRange = this.validateRange(op.range);
                if (!mightContainRTL && op.text) {
                    // check if the new inserted text contains RTL
                    mightContainRTL = strings.containsRTL(op.text);
                }
                if (!mightContainNonBasicASCII && op.text) {
                    mightContainNonBasicASCII = !strings.isBasicASCII(op.text);
                }
                operations[i] = {
                    sortIndex: i,
                    identifier: op.identifier,
                    range: validatedRange,
                    rangeLength: this.getValueLengthInRange(validatedRange),
                    lines: op.text ? op.text.split(/\r\n|\r|\n/) : null,
                    forceMoveMarkers: op.forceMoveMarkers,
                    isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
                };
            }
            // Sort operations ascending
            operations.sort(EditableTextModel._sortOpsAscending);
            for (var i = 0, count = operations.length - 1; i < count; i++) {
                var rangeEnd = operations[i].range.getEndPosition();
                var nextRangeStart = operations[i + 1].range.getStartPosition();
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    throw new Error('Overlapping ranges are not allowed!');
                }
            }
            operations = this._reduceOperations(operations);
            var editableRange = this.getEditableRange();
            var editableRangeStart = editableRange.getStartPosition();
            var editableRangeEnd = editableRange.getEndPosition();
            for (var i = 0; i < operations.length; i++) {
                var operationRange = operations[i].range;
                if (!editableRangeStart.isBeforeOrEqual(operationRange.getStartPosition()) || !operationRange.getEndPosition().isBeforeOrEqual(editableRangeEnd)) {
                    throw new Error('Editing outside of editable range not allowed!');
                }
            }
            // Delta encode operations
            var reverseRanges = EditableTextModel._getInverseEditRanges(operations);
            var reverseOperations = [];
            var newTrimAutoWhitespaceCandidates = [];
            for (var i = 0; i < operations.length; i++) {
                var op = operations[i];
                var reverseRange = reverseRanges[i];
                reverseOperations[i] = {
                    identifier: op.identifier,
                    range: reverseRange,
                    text: this.getValueInRange(op.range),
                    forceMoveMarkers: op.forceMoveMarkers
                };
                if (this._options.trimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                    for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                        var currentLineContent = '';
                        if (lineNumber === reverseRange.startLineNumber) {
                            currentLineContent = this.getLineContent(op.range.startLineNumber);
                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {
                                continue;
                            }
                        }
                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                    }
                }
            }
            this._mightContainRTL = mightContainRTL;
            this._mightContainNonBasicASCII = mightContainNonBasicASCII;
            this._doApplyEdits(markersTracker, operations);
            this._trimAutoWhitespaceLines = null;
            if (this._options.trimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
                // sort line numbers auto whitespace removal candidates for next edit descending
                newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });
                this._trimAutoWhitespaceLines = [];
                for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                    var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                    if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                        // Do not have the same line number twice
                        continue;
                    }
                    var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                    var lineContent = this.getLineContent(lineNumber);
                    if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {
                        continue;
                    }
                    this._trimAutoWhitespaceLines.push(lineNumber);
                }
            }
            return reverseOperations;
        };
        /**
         * Assumes `operations` are validated and sorted ascending
         */
        EditableTextModel._getInverseEditRanges = function (operations) {
            var result = [];
            var prevOpEndLineNumber;
            var prevOpEndColumn;
            var prevOp = null;
            for (var i = 0, len = operations.length; i < len; i++) {
                var op = operations[i];
                var startLineNumber = void 0;
                var startColumn = void 0;
                if (prevOp) {
                    if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                        startLineNumber = prevOpEndLineNumber;
                        startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                    }
                    else {
                        startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                        startColumn = op.range.startColumn;
                    }
                }
                else {
                    startLineNumber = op.range.startLineNumber;
                    startColumn = op.range.startColumn;
                }
                var resultRange = void 0;
                if (op.lines && op.lines.length > 0) {
                    // the operation inserts something
                    var lineCount = op.lines.length;
                    var firstLine = op.lines[0];
                    var lastLine = op.lines[lineCount - 1];
                    if (lineCount === 1) {
                        // single line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);
                    }
                    else {
                        // multi line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);
                    }
                }
                else {
                    // There is nothing to insert
                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn);
                }
                prevOpEndLineNumber = resultRange.endLineNumber;
                prevOpEndColumn = resultRange.endColumn;
                result.push(resultRange);
                prevOp = op;
            }
            return result;
        };
        EditableTextModel.prototype._doApplyEdits = function (markersTracker, operations) {
            var _this = this;
            var tabSize = this._options.tabSize;
            // Sort operations descending
            operations.sort(EditableTextModel._sortOpsDescending);
            var contentChangedEvents = [];
            var contentChanged2Events = [];
            var lineEditsQueue = [];
            var queueLineEdit = function (lineEdit) {
                if (lineEdit.startColumn === lineEdit.endColumn && lineEdit.text.length === 0) {
                    // empty edit => ignore it
                    return;
                }
                lineEditsQueue.push(lineEdit);
            };
            var flushLineEdits = function () {
                if (lineEditsQueue.length === 0) {
                    return;
                }
                lineEditsQueue.reverse();
                // `lineEditsQueue` now contains edits from smaller (line number,column) to larger (line number,column)
                var currentLineNumber = lineEditsQueue[0].lineNumber;
                var currentLineNumberStart = 0;
                for (var i = 1, len = lineEditsQueue.length; i < len; i++) {
                    var lineNumber = lineEditsQueue[i].lineNumber;
                    if (lineNumber === currentLineNumber) {
                        continue;
                    }
                    _this._invalidateLine(currentLineNumber - 1);
                    _this._lines[currentLineNumber - 1].applyEdits(markersTracker, lineEditsQueue.slice(currentLineNumberStart, i), tabSize);
                    if (_this._lineStarts) {
                        // update prefix sum
                        _this._lineStarts.changeValue(currentLineNumber - 1, _this._lines[currentLineNumber - 1].text.length + _this._EOL.length);
                    }
                    contentChangedEvents.push(_this._createLineChangedEvent(currentLineNumber));
                    currentLineNumber = lineNumber;
                    currentLineNumberStart = i;
                }
                _this._invalidateLine(currentLineNumber - 1);
                _this._lines[currentLineNumber - 1].applyEdits(markersTracker, lineEditsQueue.slice(currentLineNumberStart, lineEditsQueue.length), tabSize);
                if (_this._lineStarts) {
                    // update prefix sum
                    _this._lineStarts.changeValue(currentLineNumber - 1, _this._lines[currentLineNumber - 1].text.length + _this._EOL.length);
                }
                contentChangedEvents.push(_this._createLineChangedEvent(currentLineNumber));
                lineEditsQueue = [];
            };
            var minTouchedLineNumber = operations[operations.length - 1].range.startLineNumber;
            var maxTouchedLineNumber = operations[0].range.endLineNumber + 1;
            var totalLinesCountDelta = 0;
            for (var i = 0, len = operations.length; i < len; i++) {
                var op = operations[i];
                // console.log();
                // console.log('-------------------');
                // console.log('OPERATION #' + (i));
                // console.log('op: ', op);
                // console.log('<<<\n' + this._lines.map(l => l.text).join('\n') + '\n>>>');
                var startLineNumber = op.range.startLineNumber;
                var startColumn = op.range.startColumn;
                var endLineNumber = op.range.endLineNumber;
                var endColumn = op.range.endColumn;
                if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {
                    // no-op
                    continue;
                }
                var deletingLinesCnt = endLineNumber - startLineNumber;
                var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);
                var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                totalLinesCountDelta += (insertingLinesCnt - deletingLinesCnt);
                // Iterating descending to overlap with previous op
                // in case there are common lines being edited in both
                for (var j = editingLinesCnt; j >= 0; j--) {
                    var editLineNumber = startLineNumber + j;
                    queueLineEdit({
                        lineNumber: editLineNumber,
                        startColumn: (editLineNumber === startLineNumber ? startColumn : 1),
                        endColumn: (editLineNumber === endLineNumber ? endColumn : this.getLineMaxColumn(editLineNumber)),
                        text: (op.lines ? op.lines[j] : ''),
                        forceMoveMarkers: op.forceMoveMarkers
                    });
                }
                if (editingLinesCnt < deletingLinesCnt) {
                    // Must delete some lines
                    // Flush any pending line edits
                    flushLineEdits();
                    var spliceStartLineNumber = startLineNumber + editingLinesCnt;
                    var spliceStartColumn = this.getLineMaxColumn(spliceStartLineNumber);
                    var endLineRemains = this._lines[endLineNumber - 1].split(markersTracker, endColumn, false, tabSize);
                    this._invalidateLine(spliceStartLineNumber - 1);
                    var spliceCnt = endLineNumber - spliceStartLineNumber;
                    // Collect all these markers
                    var markersOnDeletedLines = [];
                    for (var j = 0; j < spliceCnt; j++) {
                        var deleteLineIndex = spliceStartLineNumber + j;
                        markersOnDeletedLines = markersOnDeletedLines.concat(this._lines[deleteLineIndex].deleteLine());
                    }
                    this._lines.splice(spliceStartLineNumber, spliceCnt);
                    if (this._lineStarts) {
                        // update prefix sum
                        this._lineStarts.removeValues(spliceStartLineNumber, spliceCnt);
                    }
                    // Reconstruct first line
                    this._lines[spliceStartLineNumber - 1].append(markersTracker, endLineRemains, tabSize);
                    if (this._lineStarts) {
                        // update prefix sum
                        this._lineStarts.changeValue(spliceStartLineNumber - 1, this._lines[spliceStartLineNumber - 1].text.length + this._EOL.length);
                    }
                    // Update deleted markers
                    var deletedMarkersPosition = new position_1.Position(spliceStartLineNumber, spliceStartColumn);
                    for (var j = 0, lenJ = markersOnDeletedLines.length; j < lenJ; j++) {
                        markersOnDeletedLines[j].updatePosition(markersTracker, deletedMarkersPosition);
                    }
                    this._lines[spliceStartLineNumber - 1].addMarkers(markersOnDeletedLines);
                    contentChangedEvents.push(this._createLineChangedEvent(spliceStartLineNumber));
                    contentChangedEvents.push(this._createLinesDeletedEvent(spliceStartLineNumber + 1, spliceStartLineNumber + spliceCnt));
                }
                if (editingLinesCnt < insertingLinesCnt) {
                    // Must insert some lines
                    // Flush any pending line edits
                    flushLineEdits();
                    var spliceLineNumber = startLineNumber + editingLinesCnt;
                    var spliceColumn = (spliceLineNumber === startLineNumber ? startColumn : 1);
                    if (op.lines) {
                        spliceColumn += op.lines[editingLinesCnt].length;
                    }
                    // Split last line
                    var leftoverLine = this._lines[spliceLineNumber - 1].split(markersTracker, spliceColumn, op.forceMoveMarkers, tabSize);
                    if (this._lineStarts) {
                        // update prefix sum
                        this._lineStarts.changeValue(spliceLineNumber - 1, this._lines[spliceLineNumber - 1].text.length + this._EOL.length);
                    }
                    contentChangedEvents.push(this._createLineChangedEvent(spliceLineNumber));
                    this._invalidateLine(spliceLineNumber - 1);
                    // Lines in the middle
                    var newLinesContent = [];
                    var newLinesLengths = new Uint32Array(insertingLinesCnt - editingLinesCnt);
                    for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {
                        var newLineNumber = startLineNumber + j;
                        this._lines.splice(newLineNumber - 1, 0, new modelLine_1.ModelLine(newLineNumber, op.lines[j], tabSize));
                        newLinesContent.push(op.lines[j]);
                        newLinesLengths[j - editingLinesCnt - 1] = op.lines[j].length + this._EOL.length;
                    }
                    newLinesContent[newLinesContent.length - 1] += leftoverLine.text;
                    if (this._lineStarts) {
                        // update prefix sum
                        this._lineStarts.insertValues(startLineNumber + editingLinesCnt, newLinesLengths);
                    }
                    // Last line
                    this._lines[startLineNumber + insertingLinesCnt - 1].append(markersTracker, leftoverLine, tabSize);
                    if (this._lineStarts) {
                        // update prefix sum
                        this._lineStarts.changeValue(startLineNumber + insertingLinesCnt - 1, this._lines[startLineNumber + insertingLinesCnt - 1].text.length + this._EOL.length);
                    }
                    contentChangedEvents.push(this._createLinesInsertedEvent(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLinesContent.join('\n')));
                }
                contentChanged2Events.push({
                    range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
                    rangeLength: op.rangeLength,
                    text: op.lines ? op.lines.join(this.getEOL()) : '',
                    eol: this._EOL,
                    versionId: -1,
                    isUndoing: this._isUndoing,
                    isRedoing: this._isRedoing
                });
            }
            flushLineEdits();
            maxTouchedLineNumber = Math.max(1, Math.min(this.getLineCount(), maxTouchedLineNumber + totalLinesCountDelta));
            if (totalLinesCountDelta !== 0) {
                // must update line numbers all the way to the bottom
                maxTouchedLineNumber = this.getLineCount();
            }
            for (var lineNumber = minTouchedLineNumber; lineNumber <= maxTouchedLineNumber; lineNumber++) {
                this._lines[lineNumber - 1].updateLineNumber(markersTracker, lineNumber);
            }
            if (contentChangedEvents.length !== 0 || contentChanged2Events.length !== 0) {
                if (contentChangedEvents.length === 0) {
                    // Fabricate a fake line changed event to get an event out
                    // This most likely occurs when there edit operations are no-ops
                    contentChangedEvents.push(this._createLineChangedEvent(minTouchedLineNumber));
                }
                var versionBumps = Math.max(contentChangedEvents.length, contentChanged2Events.length);
                var finalVersionId = this.getVersionId() + versionBumps;
                this._setVersionId(finalVersionId);
                for (var i = contentChangedEvents.length - 1, versionId = finalVersionId; i >= 0; i--, versionId--) {
                    contentChangedEvents[i].versionId = versionId;
                }
                for (var i = contentChanged2Events.length - 1, versionId = finalVersionId; i >= 0; i--, versionId--) {
                    contentChanged2Events[i].versionId = versionId;
                }
                for (var i = 0, len = contentChangedEvents.length; i < len; i++) {
                    this.emit(editorCommon.EventType.ModelRawContentChanged, contentChangedEvents[i]);
                }
                for (var i = 0, len = contentChanged2Events.length; i < len; i++) {
                    this.emit(editorCommon.EventType.ModelContentChanged2, contentChanged2Events[i]);
                }
            }
            // this._assertLineNumbersOK();
            this._resetIndentRanges();
        };
        EditableTextModel.prototype._assertLineNumbersOK = function () {
            var foundMarkersCnt = 0;
            for (var i = 0, len = this._lines.length; i < len; i++) {
                var line = this._lines[i];
                var lineNumber = i + 1;
                if (line.lineNumber !== lineNumber) {
                    throw new Error('Invalid lineNumber at line: ' + lineNumber + '; text is: ' + this.getValue());
                }
                var markers = line.getMarkers();
                for (var j = 0, lenJ = markers.length; j < lenJ; j++) {
                    foundMarkersCnt++;
                    var markerId = markers[j].id;
                    var marker = this._markerIdToMarker[markerId];
                    if (marker.position.lineNumber !== line.lineNumber) {
                        throw new Error('Misplaced marker with id ' + markerId);
                    }
                }
            }
            var totalMarkersCnt = Object.keys(this._markerIdToMarker).length;
            if (totalMarkersCnt !== foundMarkersCnt) {
                throw new Error('There are misplaced markers!');
            }
        };
        EditableTextModel.prototype._undo = function () {
            this._isUndoing = true;
            var r = this._commandManager.undo();
            this._isUndoing = false;
            if (!r) {
                return null;
            }
            this._overwriteAlternativeVersionId(r.recordedVersionId);
            return r.selections;
        };
        EditableTextModel.prototype.undo = function () {
            try {
                this._beginDeferredEmit();
                this._acquireMarkersTracker();
                return this._undo();
            }
            finally {
                this._releaseMarkersTracker();
                this._endDeferredEmit();
            }
        };
        EditableTextModel.prototype._redo = function () {
            this._isRedoing = true;
            var r = this._commandManager.redo();
            this._isRedoing = false;
            if (!r) {
                return null;
            }
            this._overwriteAlternativeVersionId(r.recordedVersionId);
            return r.selections;
        };
        EditableTextModel.prototype.redo = function () {
            try {
                this._beginDeferredEmit();
                this._acquireMarkersTracker();
                return this._redo();
            }
            finally {
                this._releaseMarkersTracker();
                this._endDeferredEmit();
            }
        };
        EditableTextModel.prototype.setEditableRange = function (range) {
            var _this = this;
            this._commandManager.clear();
            if (!this._hasEditableRange && !range) {
                // Nothing to do
                return;
            }
            this.changeDecorations(function (changeAccessor) {
                if (_this._hasEditableRange) {
                    changeAccessor.removeDecoration(_this._editableRangeId);
                    _this._editableRangeId = null;
                    _this._hasEditableRange = false;
                }
                if (range) {
                    _this._hasEditableRange = true;
                    _this._editableRangeId = changeAccessor.addDecoration(range, {
                        stickiness: editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
                    });
                }
            });
        };
        EditableTextModel.prototype.hasEditableRange = function () {
            return this._hasEditableRange;
        };
        EditableTextModel.prototype.getEditableRange = function () {
            if (this._hasEditableRange) {
                return this.getDecorationRange(this._editableRangeId);
            }
            else {
                return this.getFullModelRange();
            }
        };
        EditableTextModel.prototype._createLineChangedEvent = function (lineNumber) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLineChanged,
                lineNumber: lineNumber,
                detail: this._lines[lineNumber - 1].text,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        EditableTextModel.prototype._createLinesDeletedEvent = function (fromLineNumber, toLineNumber) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLinesDeleted,
                fromLineNumber: fromLineNumber,
                toLineNumber: toLineNumber,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        EditableTextModel.prototype._createLinesInsertedEvent = function (fromLineNumber, toLineNumber, newLinesContent) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLinesInserted,
                fromLineNumber: fromLineNumber,
                toLineNumber: toLineNumber,
                detail: newLinesContent,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        return EditableTextModel;
    }(textModelWithDecorations_1.TextModelWithDecorations));
    exports.EditableTextModel = EditableTextModel;
});






define(__m[126/*vs/editor/common/model/model*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/uri*/,2/*vs/editor/common/editorCommon*/,356/*vs/editor/common/model/editableTextModel*/,94/*vs/editor/common/model/textModel*/]), function (require, exports, uri_1, editorCommon_1, editableTextModel_1, textModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // The hierarchy is:
    // Model -> EditableTextModel -> TextModelWithDecorations -> TextModelWithTrackedRanges -> TextModelWithMarkers -> TextModelWithTokens -> TextModel
    var MODEL_ID = 0;
    var aliveModels = {};
    // var LAST_CNT = 0;
    // setInterval(() => {
    // 	var cnt = Object.keys(aliveModels).length;
    // 	if (cnt === LAST_CNT) {
    // 		return;
    // 	}
    // 	console.warn('ALIVE MODELS:');
    // 	console.log(Object.keys(aliveModels).join('\n'));
    // 	LAST_CNT = cnt;
    // }, 100);
    var Model = (function (_super) {
        __extends(Model, _super);
        /**
         * Instantiates a new model
         * @param rawText
         *   The raw text buffer. It may start with a UTF-16 BOM, which can be
         *   optionally preserved when doing a getValue call. The lines may be
         *   separated by different EOL combinations, such as \n or \r\n. These
         *   can also be preserved when doing a getValue call.
         * @param mode
         *   The language service name this model is bound to.
         * @param associatedResource
         *   The resource associated with this model. If the value is not provided an
         *   unique in memory URL is constructed as the associated resource.
         */
        function Model(rawText, languageIdentifier, associatedResource) {
            if (associatedResource === void 0) { associatedResource = null; }
            var _this = _super.call(this, [editorCommon_1.EventType.ModelDispose], rawText, languageIdentifier) || this;
            // Generate a new unique model id
            MODEL_ID++;
            _this.id = '$model' + MODEL_ID;
            if (typeof associatedResource === 'undefined' || associatedResource === null) {
                _this._associatedResource = uri_1.default.parse('inmemory://model/' + MODEL_ID);
            }
            else {
                _this._associatedResource = associatedResource;
            }
            if (aliveModels[String(_this._associatedResource)]) {
                throw new Error('Cannot instantiate a second Model with the same URI');
            }
            _this._attachedEditorCount = 0;
            aliveModels[String(_this._associatedResource)] = true;
            return _this;
            // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
        }
        Model.prototype.onDidChangeDecorations = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelDecorationsChanged, listener);
        };
        Model.prototype.onDidChangeOptions = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelOptionsChanged, listener);
        };
        Model.prototype.onWillDispose = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelDispose, listener);
        };
        Model.prototype.onDidChangeLanguage = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelLanguageChanged, listener);
        };
        Model.prototype.addBulkListener = function (listener) {
            return _super.prototype.addBulkListener.call(this, listener);
        };
        Model.createFromString = function (text, options, languageIdentifier, uri) {
            if (options === void 0) { options = textModel_1.TextModel.DEFAULT_CREATION_OPTIONS; }
            if (languageIdentifier === void 0) { languageIdentifier = null; }
            if (uri === void 0) { uri = null; }
            var rawText = textModel_1.TextModel.toRawText(text, options);
            return new Model(rawText, languageIdentifier, uri);
        };
        Model.prototype.destroy = function () {
            this.dispose();
        };
        Model.prototype.dispose = function () {
            this._isDisposing = true;
            delete aliveModels[String(this._associatedResource)];
            this.emit(editorCommon_1.EventType.ModelDispose);
            _super.prototype.dispose.call(this);
            this._isDisposing = false;
            // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
        };
        Model.prototype.onBeforeAttached = function () {
            this._attachedEditorCount++;
            // Warm up tokens for the editor
            this._warmUpTokens();
        };
        Model.prototype.onBeforeDetached = function () {
            this._attachedEditorCount--;
            // Intentional empty (for now)
        };
        Model.prototype._shouldAutoTokenize = function () {
            return this.isAttachedToEditor();
        };
        Model.prototype.isAttachedToEditor = function () {
            return this._attachedEditorCount > 0;
        };
        Object.defineProperty(Model.prototype, "uri", {
            get: function () {
                return this._associatedResource;
            },
            enumerable: true,
            configurable: true
        });
        return Model;
    }(editableTextModel_1.EditableTextModel));
    exports.Model = Model;
});

define(__m[358/*vs/editor/common/modes/editorModeContext*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,15/*vs/editor/common/modes*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, lifecycle_1, modes, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorModeContext = (function () {
        function EditorModeContext(editor, contextKeyService) {
            var _this = this;
            this._disposables = [];
            this._editor = editor;
            this._langId = editorCommon_1.EditorContextKeys.LanguageId.bindTo(contextKeyService);
            this._hasCompletionItemProvider = editorCommon_1.ModeContextKeys.hasCompletionItemProvider.bindTo(contextKeyService);
            this._hasCodeActionsProvider = editorCommon_1.ModeContextKeys.hasCodeActionsProvider.bindTo(contextKeyService);
            this._hasCodeLensProvider = editorCommon_1.ModeContextKeys.hasCodeLensProvider.bindTo(contextKeyService);
            this._hasDefinitionProvider = editorCommon_1.ModeContextKeys.hasDefinitionProvider.bindTo(contextKeyService);
            this._hasTypeDefinitionProvider = editorCommon_1.ModeContextKeys.hasTypeDefinitionProvider.bindTo(contextKeyService);
            this._hasHoverProvider = editorCommon_1.ModeContextKeys.hasHoverProvider.bindTo(contextKeyService);
            this._hasDocumentHighlightProvider = editorCommon_1.ModeContextKeys.hasDocumentHighlightProvider.bindTo(contextKeyService);
            this._hasDocumentSymbolProvider = editorCommon_1.ModeContextKeys.hasDocumentSymbolProvider.bindTo(contextKeyService);
            this._hasReferenceProvider = editorCommon_1.ModeContextKeys.hasReferenceProvider.bindTo(contextKeyService);
            this._hasRenameProvider = editorCommon_1.ModeContextKeys.hasRenameProvider.bindTo(contextKeyService);
            this._hasDocumentFormattingProvider = editorCommon_1.ModeContextKeys.hasDocumentFormattingProvider.bindTo(contextKeyService);
            this._hasDocumentSelectionFormattingProvider = editorCommon_1.ModeContextKeys.hasDocumentSelectionFormattingProvider.bindTo(contextKeyService);
            this._hasSignatureHelpProvider = editorCommon_1.ModeContextKeys.hasSignatureHelpProvider.bindTo(contextKeyService);
            // update when model/mode changes
            this._disposables.push(editor.onDidChangeModel(function () { return _this._update(); }));
            this._disposables.push(editor.onDidChangeModelLanguage(function () { return _this._update(); }));
            // update when registries change
            modes.SuggestRegistry.onDidChange(this._update, this, this._disposables);
            modes.CodeActionProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.CodeLensProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.DefinitionProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.TypeDefinitionProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.HoverProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.DocumentHighlightProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.DocumentSymbolProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.ReferenceProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.RenameProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.DocumentFormattingEditProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.DocumentRangeFormattingEditProviderRegistry.onDidChange(this._update, this, this._disposables);
            modes.SignatureHelpProviderRegistry.onDidChange(this._update, this, this._disposables);
            this._update();
        }
        EditorModeContext.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        EditorModeContext.prototype.reset = function () {
            this._langId.reset();
            this._hasCompletionItemProvider.reset();
            this._hasCodeActionsProvider.reset();
            this._hasCodeLensProvider.reset();
            this._hasDefinitionProvider.reset();
            this._hasTypeDefinitionProvider.reset();
            this._hasHoverProvider.reset();
            this._hasDocumentHighlightProvider.reset();
            this._hasDocumentSymbolProvider.reset();
            this._hasReferenceProvider.reset();
            this._hasRenameProvider.reset();
            this._hasDocumentFormattingProvider.reset();
            this._hasDocumentSelectionFormattingProvider.reset();
            this._hasSignatureHelpProvider.reset();
        };
        EditorModeContext.prototype._update = function () {
            var model = this._editor.getModel();
            if (!model) {
                this.reset();
                return;
            }
            this._langId.set(model.getLanguageIdentifier().language);
            this._hasCompletionItemProvider.set(modes.SuggestRegistry.has(model));
            this._hasCodeActionsProvider.set(modes.CodeActionProviderRegistry.has(model));
            this._hasCodeLensProvider.set(modes.CodeLensProviderRegistry.has(model));
            this._hasDefinitionProvider.set(modes.DefinitionProviderRegistry.has(model));
            this._hasTypeDefinitionProvider.set(modes.TypeDefinitionProviderRegistry.has(model));
            this._hasHoverProvider.set(modes.HoverProviderRegistry.has(model));
            this._hasDocumentHighlightProvider.set(modes.DocumentHighlightProviderRegistry.has(model));
            this._hasDocumentSymbolProvider.set(modes.DocumentSymbolProviderRegistry.has(model));
            this._hasReferenceProvider.set(modes.ReferenceProviderRegistry.has(model));
            this._hasRenameProvider.set(modes.RenameProviderRegistry.has(model));
            this._hasSignatureHelpProvider.set(modes.SignatureHelpProviderRegistry.has(model));
            this._hasDocumentFormattingProvider.set(modes.DocumentFormattingEditProviderRegistry.has(model) || modes.DocumentRangeFormattingEditProviderRegistry.has(model));
            this._hasDocumentSelectionFormattingProvider.set(modes.DocumentRangeFormattingEditProviderRegistry.has(model));
        };
        return EditorModeContext;
    }());
    exports.EditorModeContext = EditorModeContext;
});

define(__m[45/*vs/editor/common/services/codeEditorService*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, instantiation_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ICodeEditorService = instantiation_1.createDecorator('codeEditorService');
    /**
     * Uses `editor.getControl()` and returns either a `codeEditor` or a `diffEditor` or nothing.
     */
    function getCodeOrDiffEditor(editor) {
        if (editor) {
            var control = editor.getControl();
            if (control) {
                if (editorCommon_1.isCommonCodeEditor(control)) {
                    return {
                        codeEditor: control,
                        diffEditor: null
                    };
                }
                if (editorCommon_1.isCommonDiffEditor(control)) {
                    return {
                        codeEditor: null,
                        diffEditor: control
                    };
                }
            }
        }
        return {
            codeEditor: null,
            diffEditor: null
        };
    }
    exports.getCodeOrDiffEditor = getCodeOrDiffEditor;
    /**
     * Uses `editor.getControl()` and returns either the code editor, or the modified editor of a diff editor or nothing.
     */
    function getCodeEditor(editor) {
        var r = getCodeOrDiffEditor(editor);
        return r.codeEditor || (r.diffEditor && r.diffEditor.getModifiedEditor()) || null;
    }
    exports.getCodeEditor = getCodeEditor;
});















define(__m[128/*vs/editor/common/services/editorWorkerServiceImpl*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,148/*vs/base/common/worker/simpleWorker*/,187/*vs/base/worker/defaultWorkerFactory*/,2/*vs/editor/common/editorCommon*/,15/*vs/editor/common/modes*/,43/*vs/editor/common/services/modelService*/,213/*vs/editor/common/services/editorSimpleWorker*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,56/*vs/platform/configuration/common/configuration*/]), function (require, exports, async_1, lifecycle_1, winjs_base_1, simpleWorker_1, defaultWorkerFactory_1, editorCommon, modes, modelService_1, editorSimpleWorker_1, languageConfigurationRegistry_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Stop syncing a model to the worker if it was not needed for 1 min.
     */
    var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;
    /**
     * Stop the worker if it was not needed for 5 min.
     */
    var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1000;
    var EditorWorkerServiceImpl = (function () {
        function EditorWorkerServiceImpl(modelService, configurationService) {
            var _this = this;
            this._workerManager = new WorkerManager(modelService);
            // todo@joh make sure this happens only once
            var linkProvider = modes.LinkProviderRegistry.register('*', {
                provideLinks: function (model, token) {
                    return async_1.wireCancellationToken(token, _this._workerManager.withWorker().then(function (client) { return client.computeLinks(model.uri); }));
                }
            });
            var completionProvider = modes.SuggestRegistry.register('*', {
                triggerCharacters: [],
                provideCompletionItems: function (model, position, token) {
                    if (configurationService.lookup('editor.wordBasedSuggestions').value) {
                        return _this._workerManager.withWorker().then(function (client) { return client.textualSuggest(model.uri, position); });
                    }
                }
            });
            this._registrations = [linkProvider, completionProvider];
        }
        EditorWorkerServiceImpl.prototype.dispose = function () {
            this._workerManager.dispose();
            lifecycle_1.dispose(this._registrations);
        };
        EditorWorkerServiceImpl.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._workerManager.withWorker().then(function (client) { return client.computeDiff(original, modified, ignoreTrimWhitespace); });
        };
        EditorWorkerServiceImpl.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._workerManager.withWorker().then(function (client) { return client.computeDirtyDiff(original, modified, ignoreTrimWhitespace); });
        };
        EditorWorkerServiceImpl.prototype.computeMoreMinimalEdits = function (resource, edits, ranges) {
            if (!Array.isArray(edits) || edits.length === 0) {
                return winjs_base_1.TPromise.as(edits);
            }
            else {
                return this._workerManager.withWorker().then(function (client) { return client.computeMoreMinimalEdits(resource, edits, ranges); });
            }
        };
        EditorWorkerServiceImpl.prototype.navigateValueSet = function (resource, range, up) {
            return this._workerManager.withWorker().then(function (client) { return client.navigateValueSet(resource, range, up); });
        };
        return EditorWorkerServiceImpl;
    }());
    EditorWorkerServiceImpl = __decorate([
        __param(0, modelService_1.IModelService),
        __param(1, configuration_1.IConfigurationService)
    ], EditorWorkerServiceImpl);
    exports.EditorWorkerServiceImpl = EditorWorkerServiceImpl;
    var WorkerManager = (function (_super) {
        __extends(WorkerManager, _super);
        function WorkerManager(modelService) {
            var _this = _super.call(this) || this;
            _this._modelService = modelService;
            _this._editorWorkerClient = null;
            var stopWorkerInterval = _this._register(new async_1.IntervalTimer());
            stopWorkerInterval.cancelAndSet(function () { return _this._checkStopIdleWorker(); }, Math.round(STOP_WORKER_DELTA_TIME_MS / 2));
            _this._register(_this._modelService.onModelRemoved(function (_) { return _this._checkStopEmptyWorker(); }));
            return _this;
        }
        WorkerManager.prototype.dispose = function () {
            if (this._editorWorkerClient) {
                this._editorWorkerClient.dispose();
                this._editorWorkerClient = null;
            }
            _super.prototype.dispose.call(this);
        };
        /**
         * Check if the model service has no more models and stop the worker if that is the case.
         */
        WorkerManager.prototype._checkStopEmptyWorker = function () {
            if (!this._editorWorkerClient) {
                return;
            }
            var models = this._modelService.getModels();
            if (models.length === 0) {
                // There are no more models => nothing possible for me to do
                this._editorWorkerClient.dispose();
                this._editorWorkerClient = null;
            }
        };
        /**
         * Check if the worker has been idle for a while and then stop it.
         */
        WorkerManager.prototype._checkStopIdleWorker = function () {
            if (!this._editorWorkerClient) {
                return;
            }
            var timeSinceLastWorkerUsedTime = (new Date()).getTime() - this._lastWorkerUsedTime;
            if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
                this._editorWorkerClient.dispose();
                this._editorWorkerClient = null;
            }
        };
        WorkerManager.prototype.withWorker = function () {
            this._lastWorkerUsedTime = (new Date()).getTime();
            if (!this._editorWorkerClient) {
                this._editorWorkerClient = new EditorWorkerClient(this._modelService, 'editorWorkerService');
            }
            return winjs_base_1.TPromise.as(this._editorWorkerClient);
        };
        return WorkerManager;
    }(lifecycle_1.Disposable));
    var EditorModelManager = (function (_super) {
        __extends(EditorModelManager, _super);
        function EditorModelManager(proxy, modelService, keepIdleModels) {
            var _this = _super.call(this) || this;
            _this._syncedModels = Object.create(null);
            _this._syncedModelsLastUsedTime = Object.create(null);
            _this._proxy = proxy;
            _this._modelService = modelService;
            if (!keepIdleModels) {
                var timer = new async_1.IntervalTimer();
                timer.cancelAndSet(function () { return _this._checkStopModelSync(); }, Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
                _this._register(timer);
            }
            return _this;
        }
        EditorModelManager.prototype.dispose = function () {
            for (var modelUrl in this._syncedModels) {
                lifecycle_1.dispose(this._syncedModels[modelUrl]);
            }
            this._syncedModels = Object.create(null);
            this._syncedModelsLastUsedTime = Object.create(null);
            _super.prototype.dispose.call(this);
        };
        EditorModelManager.prototype.esureSyncedResources = function (resources) {
            for (var i = 0; i < resources.length; i++) {
                var resource = resources[i];
                var resourceStr = resource.toString();
                if (!this._syncedModels[resourceStr]) {
                    this._beginModelSync(resource);
                }
                if (this._syncedModels[resourceStr]) {
                    this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();
                }
            }
        };
        EditorModelManager.prototype._checkStopModelSync = function () {
            var currentTime = (new Date()).getTime();
            var toRemove = [];
            for (var modelUrl in this._syncedModelsLastUsedTime) {
                var elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
                if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
                    toRemove.push(modelUrl);
                }
            }
            for (var i = 0; i < toRemove.length; i++) {
                this._stopModelSync(toRemove[i]);
            }
        };
        EditorModelManager.prototype._beginModelSync = function (resource) {
            var _this = this;
            var model = this._modelService.getModel(resource);
            if (!model) {
                return;
            }
            var modelUrl = resource.toString();
            this._proxy.acceptNewModel({
                url: model.uri.toString(),
                value: model.toRawText(),
                versionId: model.getVersionId()
            });
            var toDispose = [];
            toDispose.push(model.addBulkListener(function (events) {
                var changedEvents = [];
                for (var i = 0, len = events.length; i < len; i++) {
                    var e = events[i];
                    switch (e.getType()) {
                        case editorCommon.EventType.ModelContentChanged2:
                            changedEvents.push(e.getData());
                            break;
                        case editorCommon.EventType.ModelDispose:
                            _this._stopModelSync(modelUrl);
                            return;
                    }
                }
                if (changedEvents.length > 0) {
                    _this._proxy.acceptModelChanged(modelUrl.toString(), changedEvents);
                }
            }));
            toDispose.push({
                dispose: function () {
                    _this._proxy.acceptRemovedModel(modelUrl);
                }
            });
            this._syncedModels[modelUrl] = toDispose;
        };
        EditorModelManager.prototype._stopModelSync = function (modelUrl) {
            var toDispose = this._syncedModels[modelUrl];
            delete this._syncedModels[modelUrl];
            delete this._syncedModelsLastUsedTime[modelUrl];
            lifecycle_1.dispose(toDispose);
        };
        return EditorModelManager;
    }(lifecycle_1.Disposable));
    var SynchronousWorkerClient = (function () {
        function SynchronousWorkerClient(instance) {
            this._instance = instance;
            this._proxyObj = winjs_base_1.TPromise.as(this._instance);
        }
        SynchronousWorkerClient.prototype.dispose = function () {
            this._instance.dispose();
            this._instance = null;
            this._proxyObj = null;
        };
        SynchronousWorkerClient.prototype.getProxyObject = function () {
            return new async_1.ShallowCancelThenPromise(this._proxyObj);
        };
        return SynchronousWorkerClient;
    }());
    var EditorWorkerClient = (function (_super) {
        __extends(EditorWorkerClient, _super);
        function EditorWorkerClient(modelService, label) {
            var _this = _super.call(this) || this;
            _this._modelService = modelService;
            _this._workerFactory = new defaultWorkerFactory_1.DefaultWorkerFactory(label);
            _this._worker = null;
            _this._modelManager = null;
            return _this;
        }
        EditorWorkerClient.prototype._getOrCreateWorker = function () {
            if (!this._worker) {
                try {
                    this._worker = this._register(new simpleWorker_1.SimpleWorkerClient(this._workerFactory, 'vs/editor/common/services/editorSimpleWorker'));
                }
                catch (err) {
                    simpleWorker_1.logOnceWebWorkerWarning(err);
                    this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl());
                }
            }
            return this._worker;
        };
        EditorWorkerClient.prototype._getProxy = function () {
            var _this = this;
            return new async_1.ShallowCancelThenPromise(this._getOrCreateWorker().getProxyObject().then(null, function (err) {
                simpleWorker_1.logOnceWebWorkerWarning(err);
                _this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl());
                return _this._getOrCreateWorker().getProxyObject();
            }));
        };
        EditorWorkerClient.prototype._getOrCreateModelManager = function (proxy) {
            if (!this._modelManager) {
                this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, false));
            }
            return this._modelManager;
        };
        EditorWorkerClient.prototype._withSyncedResources = function (resources) {
            var _this = this;
            return this._getProxy().then(function (proxy) {
                _this._getOrCreateModelManager(proxy).esureSyncedResources(resources);
                return proxy;
            });
        };
        EditorWorkerClient.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._withSyncedResources([original, modified]).then(function (proxy) {
                return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
            });
        };
        EditorWorkerClient.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._withSyncedResources([original, modified]).then(function (proxy) {
                return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
            });
        };
        EditorWorkerClient.prototype.computeMoreMinimalEdits = function (resource, edits, ranges) {
            return this._withSyncedResources([resource]).then(function (proxy) {
                return proxy.computeMoreMinimalEdits(resource.toString(), edits, ranges);
            });
        };
        EditorWorkerClient.prototype.computeLinks = function (resource) {
            return this._withSyncedResources([resource]).then(function (proxy) {
                return proxy.computeLinks(resource.toString());
            });
        };
        EditorWorkerClient.prototype.textualSuggest = function (resource, position) {
            var _this = this;
            return this._withSyncedResources([resource]).then(function (proxy) {
                var model = _this._modelService.getModel(resource);
                if (!model) {
                    return null;
                }
                var wordDefRegExp = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
                var wordDef = wordDefRegExp.source;
                var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
                return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);
            });
        };
        EditorWorkerClient.prototype.navigateValueSet = function (resource, range, up) {
            var _this = this;
            return this._withSyncedResources([resource]).then(function (proxy) {
                var model = _this._modelService.getModel(resource);
                if (!model) {
                    return null;
                }
                var wordDefRegExp = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(model.getLanguageIdentifier().id);
                var wordDef = wordDefRegExp.source;
                var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
                return proxy.navigateValueSet(resource.toString(), range, up, wordDef, wordDefFlags);
            });
        };
        return EditorWorkerClient;
    }(lifecycle_1.Disposable));
    exports.EditorWorkerClient = EditorWorkerClient;
});






define(__m[361/*vs/editor/common/services/webWorker*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,128/*vs/editor/common/services/editorWorkerServiceImpl*/]), function (require, exports, async_1, editorWorkerServiceImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Create a new web worker that has model syncing capabilities built in.
     * Specify an AMD module to load that will `create` an object that will be proxied.
     */
    function createWebWorker(modelService, opts) {
        return new MonacoWebWorkerImpl(modelService, opts);
    }
    exports.createWebWorker = createWebWorker;
    var MonacoWebWorkerImpl = (function (_super) {
        __extends(MonacoWebWorkerImpl, _super);
        function MonacoWebWorkerImpl(modelService, opts) {
            var _this = _super.call(this, modelService, opts.label) || this;
            _this._foreignModuleId = opts.moduleId;
            _this._foreignModuleCreateData = opts.createData || null;
            _this._foreignProxy = null;
            return _this;
        }
        MonacoWebWorkerImpl.prototype._getForeignProxy = function () {
            var _this = this;
            if (!this._foreignProxy) {
                this._foreignProxy = new async_1.ShallowCancelThenPromise(this._getProxy().then(function (proxy) {
                    return proxy.loadForeignModule(_this._foreignModuleId, _this._foreignModuleCreateData).then(function (foreignMethods) {
                        _this._foreignModuleId = null;
                        _this._foreignModuleCreateData = null;
                        var proxyMethodRequest = function (method, args) {
                            return proxy.fmr(method, args);
                        };
                        var createProxyMethod = function (method, proxyMethodRequest) {
                            return function () {
                                var args = Array.prototype.slice.call(arguments, 0);
                                return proxyMethodRequest(method, args);
                            };
                        };
                        var foreignProxy = {};
                        for (var i = 0; i < foreignMethods.length; i++) {
                            foreignProxy[foreignMethods[i]] = createProxyMethod(foreignMethods[i], proxyMethodRequest);
                        }
                        return foreignProxy;
                    });
                }));
            }
            return this._foreignProxy;
        };
        MonacoWebWorkerImpl.prototype.getProxy = function () {
            return this._getForeignProxy();
        };
        MonacoWebWorkerImpl.prototype.withSyncedResources = function (resources) {
            var _this = this;
            return this._withSyncedResources(resources).then(function (_) { return _this.getProxy(); });
        };
        return MonacoWebWorkerImpl;
    }(editorWorkerServiceImpl_1.EditorWorkerClient));
});

define(__m[362/*vs/editor/common/view/overviewZoneManager*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewZoneManager = (function () {
        function OverviewZoneManager(getVerticalOffsetForLine) {
            this._getVerticalOffsetForLine = getVerticalOffsetForLine;
            this._zones = [];
            this._colorZonesInvalid = false;
            this._lineHeight = 0;
            this._domWidth = 0;
            this._domHeight = 0;
            this._outerHeight = 0;
            this._maximumHeight = 0;
            this._minimumHeight = 0;
            this._useDarkColor = false;
            this._pixelRatio = 1;
            this._lastAssignedId = 0;
            this._color2Id = Object.create(null);
            this._id2Color = [];
        }
        OverviewZoneManager.prototype.getId2Color = function () {
            return this._id2Color;
        };
        OverviewZoneManager.prototype.setZones = function (newZones) {
            newZones.sort(function (a, b) { return a.compareTo(b); });
            var oldZones = this._zones;
            var oldIndex = 0;
            var oldLength = this._zones.length;
            var newIndex = 0;
            var newLength = newZones.length;
            var result = [];
            while (newIndex < newLength) {
                var newZone = newZones[newIndex];
                if (oldIndex >= oldLength) {
                    result.push(newZone);
                    newIndex++;
                }
                else {
                    var oldZone = oldZones[oldIndex];
                    var cmp = oldZone.compareTo(newZone);
                    if (cmp < 0) {
                        oldIndex++;
                    }
                    else if (cmp > 0) {
                        result.push(newZone);
                        newIndex++;
                    }
                    else {
                        // cmp === 0
                        result.push(oldZone);
                        oldIndex++;
                        newIndex++;
                    }
                }
            }
            this._zones = result;
        };
        OverviewZoneManager.prototype.setLineHeight = function (lineHeight) {
            if (this._lineHeight === lineHeight) {
                return false;
            }
            this._lineHeight = lineHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setPixelRatio = function (pixelRatio) {
            this._pixelRatio = pixelRatio;
            this._colorZonesInvalid = true;
        };
        OverviewZoneManager.prototype.getDOMWidth = function () {
            return this._domWidth;
        };
        OverviewZoneManager.prototype.getCanvasWidth = function () {
            return this._domWidth * this._pixelRatio;
        };
        OverviewZoneManager.prototype.setDOMWidth = function (width) {
            if (this._domWidth === width) {
                return false;
            }
            this._domWidth = width;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.getDOMHeight = function () {
            return this._domHeight;
        };
        OverviewZoneManager.prototype.getCanvasHeight = function () {
            return this._domHeight * this._pixelRatio;
        };
        OverviewZoneManager.prototype.setDOMHeight = function (height) {
            if (this._domHeight === height) {
                return false;
            }
            this._domHeight = height;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.getOuterHeight = function () {
            return this._outerHeight;
        };
        OverviewZoneManager.prototype.setOuterHeight = function (outerHeight) {
            if (this._outerHeight === outerHeight) {
                return false;
            }
            this._outerHeight = outerHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setMaximumHeight = function (maximumHeight) {
            if (this._maximumHeight === maximumHeight) {
                return false;
            }
            this._maximumHeight = maximumHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setMinimumHeight = function (minimumHeight) {
            if (this._minimumHeight === minimumHeight) {
                return false;
            }
            this._minimumHeight = minimumHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setUseDarkColor = function (useDarkColor) {
            if (this._useDarkColor === useDarkColor) {
                return false;
            }
            this._useDarkColor = useDarkColor;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.resolveColorZones = function () {
            var colorZonesInvalid = this._colorZonesInvalid;
            var lineHeight = Math.floor(this._lineHeight); // @perf
            var totalHeight = Math.floor(this.getCanvasHeight()); // @perf
            var maximumHeight = Math.floor(this._maximumHeight * this._pixelRatio); // @perf
            var minimumHeight = Math.floor(this._minimumHeight * this._pixelRatio); // @perf
            var useDarkColor = this._useDarkColor; // @perf
            var outerHeight = Math.floor(this._outerHeight); // @perf
            var heightRatio = totalHeight / outerHeight;
            var allColorZones = [];
            for (var i = 0, len = this._zones.length; i < len; i++) {
                var zone = this._zones[i];
                if (!colorZonesInvalid) {
                    var colorZones_1 = zone.getColorZones();
                    if (colorZones_1) {
                        for (var j = 0, lenJ = colorZones_1.length; j < lenJ; j++) {
                            allColorZones.push(colorZones_1[j]);
                        }
                        continue;
                    }
                }
                var colorZones = [];
                if (zone.forceHeight) {
                    var forcedHeight = Math.floor(zone.forceHeight * this._pixelRatio);
                    var y1 = Math.floor(this._getVerticalOffsetForLine(zone.startLineNumber));
                    y1 = Math.floor(y1 * heightRatio);
                    var y2 = y1 + forcedHeight;
                    colorZones.push(this.createZone(totalHeight, y1, y2, forcedHeight, forcedHeight, zone.getColor(useDarkColor), zone.position));
                }
                else {
                    var y1 = Math.floor(this._getVerticalOffsetForLine(zone.startLineNumber));
                    var y2 = Math.floor(this._getVerticalOffsetForLine(zone.endLineNumber)) + lineHeight;
                    y1 = Math.floor(y1 * heightRatio);
                    y2 = Math.floor(y2 * heightRatio);
                    // Figure out if we can render this in one continuous zone
                    var zoneLineNumbers = zone.endLineNumber - zone.startLineNumber + 1;
                    var zoneMaximumHeight = zoneLineNumbers * maximumHeight;
                    if (y2 - y1 > zoneMaximumHeight) {
                        // We need to draw one zone per line
                        for (var lineNumber = zone.startLineNumber; lineNumber <= zone.endLineNumber; lineNumber++) {
                            y1 = Math.floor(this._getVerticalOffsetForLine(lineNumber));
                            y2 = y1 + lineHeight;
                            y1 = Math.floor(y1 * heightRatio);
                            y2 = Math.floor(y2 * heightRatio);
                            colorZones.push(this.createZone(totalHeight, y1, y2, minimumHeight, maximumHeight, zone.getColor(useDarkColor), zone.position));
                        }
                    }
                    else {
                        colorZones.push(this.createZone(totalHeight, y1, y2, minimumHeight, zoneMaximumHeight, zone.getColor(useDarkColor), zone.position));
                    }
                }
                zone.setColorZones(colorZones);
                for (var j = 0, lenJ = colorZones.length; j < lenJ; j++) {
                    allColorZones.push(colorZones[j]);
                }
            }
            this._colorZonesInvalid = false;
            var sortFunc = function (a, b) {
                if (a.colorId === b.colorId) {
                    if (a.from === b.from) {
                        return a.to - b.to;
                    }
                    return a.from - b.from;
                }
                return a.colorId - b.colorId;
            };
            allColorZones.sort(sortFunc);
            return allColorZones;
        };
        OverviewZoneManager.prototype.createZone = function (totalHeight, y1, y2, minimumHeight, maximumHeight, color, position) {
            totalHeight = Math.floor(totalHeight); // @perf
            y1 = Math.floor(y1); // @perf
            y2 = Math.floor(y2); // @perf
            minimumHeight = Math.floor(minimumHeight); // @perf
            maximumHeight = Math.floor(maximumHeight); // @perf
            var ycenter = Math.floor((y1 + y2) / 2);
            var halfHeight = (y2 - ycenter);
            if (halfHeight > maximumHeight / 2) {
                halfHeight = maximumHeight / 2;
            }
            if (halfHeight < minimumHeight / 2) {
                halfHeight = minimumHeight / 2;
            }
            if (ycenter - halfHeight < 0) {
                ycenter = halfHeight;
            }
            if (ycenter + halfHeight > totalHeight) {
                ycenter = totalHeight - halfHeight;
            }
            var colorId = this._color2Id[color];
            if (!colorId) {
                colorId = (++this._lastAssignedId);
                this._color2Id[color] = colorId;
                this._id2Color[colorId] = color;
            }
            return new editorCommon_1.ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId, position);
        };
        return OverviewZoneManager;
    }());
    exports.OverviewZoneManager = OverviewZoneManager;
});

define(__m[129/*vs/editor/browser/viewParts/overviewRuler/overviewRulerImpl*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,2/*vs/editor/common/editorCommon*/,23/*vs/base/browser/browser*/,362/*vs/editor/common/view/overviewZoneManager*/]), function (require, exports, styleMutator_1, editorCommon_1, browser, overviewZoneManager_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewRulerImpl = (function () {
        function OverviewRulerImpl(canvasLeftOffset, cssClassName, scrollHeight, lineHeight, canUseTranslate3d, minimumHeight, maximumHeight, getVerticalOffsetForLine) {
            var _this = this;
            this._canvasLeftOffset = canvasLeftOffset;
            this._domNode = document.createElement('canvas');
            this._domNode.className = cssClassName;
            this._domNode.style.position = 'absolute';
            this._lanesCount = 3;
            this._canUseTranslate3d = canUseTranslate3d;
            this._zoneManager = new overviewZoneManager_1.OverviewZoneManager(getVerticalOffsetForLine);
            this._zoneManager.setMinimumHeight(minimumHeight);
            this._zoneManager.setMaximumHeight(maximumHeight);
            this._zoneManager.setUseDarkColor(false);
            this._zoneManager.setDOMWidth(0);
            this._zoneManager.setDOMHeight(0);
            this._zoneManager.setOuterHeight(scrollHeight);
            this._zoneManager.setLineHeight(lineHeight);
            this._zoomListener = browser.onDidChangeZoomLevel(function () {
                _this._zoneManager.setPixelRatio(browser.getPixelRatio());
                _this._domNode.style.width = _this._zoneManager.getDOMWidth() + 'px';
                _this._domNode.style.height = _this._zoneManager.getDOMHeight() + 'px';
                _this._domNode.width = _this._zoneManager.getCanvasWidth();
                _this._domNode.height = _this._zoneManager.getCanvasHeight();
                _this.render(true);
            });
            this._zoneManager.setPixelRatio(browser.getPixelRatio());
        }
        OverviewRulerImpl.prototype.dispose = function () {
            this._zoomListener.dispose();
            this._zoneManager = null;
        };
        OverviewRulerImpl.prototype.setLayout = function (position, render) {
            styleMutator_1.StyleMutator.setTop(this._domNode, position.top);
            styleMutator_1.StyleMutator.setRight(this._domNode, position.right);
            var hasChanged = false;
            hasChanged = this._zoneManager.setDOMWidth(position.width) || hasChanged;
            hasChanged = this._zoneManager.setDOMHeight(position.height) || hasChanged;
            if (hasChanged) {
                this._domNode.style.width = this._zoneManager.getDOMWidth() + 'px';
                this._domNode.style.height = this._zoneManager.getDOMHeight() + 'px';
                this._domNode.width = this._zoneManager.getCanvasWidth();
                this._domNode.height = this._zoneManager.getCanvasHeight();
                if (render) {
                    this.render(true);
                }
            }
        };
        OverviewRulerImpl.prototype.getLanesCount = function () {
            return this._lanesCount;
        };
        OverviewRulerImpl.prototype.setLanesCount = function (newLanesCount, render) {
            this._lanesCount = newLanesCount;
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setUseDarkColor = function (useDarkColor, render) {
            this._zoneManager.setUseDarkColor(useDarkColor);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverviewRulerImpl.prototype.getPixelWidth = function () {
            return this._zoneManager.getCanvasWidth();
        };
        OverviewRulerImpl.prototype.getPixelHeight = function () {
            return this._zoneManager.getCanvasHeight();
        };
        OverviewRulerImpl.prototype.setScrollHeight = function (scrollHeight, render) {
            this._zoneManager.setOuterHeight(scrollHeight);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setLineHeight = function (lineHeight, render) {
            this._zoneManager.setLineHeight(lineHeight);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setCanUseTranslate3d = function (canUseTranslate3d, render) {
            this._canUseTranslate3d = canUseTranslate3d;
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setZones = function (zones, render) {
            this._zoneManager.setZones(zones);
            if (render) {
                this.render(false);
            }
        };
        OverviewRulerImpl.prototype.render = function (forceRender) {
            if (this._zoneManager.getOuterHeight() === 0) {
                return false;
            }
            if (this._canUseTranslate3d) {
                styleMutator_1.StyleMutator.setTransform(this._domNode, 'translate3d(0px, 0px, 0px)');
            }
            else {
                styleMutator_1.StyleMutator.setTransform(this._domNode, '');
            }
            var width = this._zoneManager.getCanvasWidth();
            var height = this._zoneManager.getCanvasHeight();
            var colorZones = this._zoneManager.resolveColorZones();
            var id2Color = this._zoneManager.getId2Color();
            var ctx = this._domNode.getContext('2d');
            ctx.clearRect(0, 0, width, height);
            if (colorZones.length > 0) {
                var remainingWidth = width - this._canvasLeftOffset;
                if (this._lanesCount >= 3) {
                    this._renderThreeLanes(ctx, colorZones, id2Color, remainingWidth);
                }
                else if (this._lanesCount === 2) {
                    this._renderTwoLanes(ctx, colorZones, id2Color, remainingWidth);
                }
                else if (this._lanesCount === 1) {
                    this._renderOneLane(ctx, colorZones, id2Color, remainingWidth);
                }
            }
            return true;
        };
        OverviewRulerImpl.prototype._renderOneLane = function (ctx, colorZones, id2Color, w) {
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left | editorCommon_1.OverviewRulerLane.Center | editorCommon_1.OverviewRulerLane.Right, this._canvasLeftOffset, w);
        };
        OverviewRulerImpl.prototype._renderTwoLanes = function (ctx, colorZones, id2Color, w) {
            var leftWidth = Math.floor(w / 2);
            var rightWidth = w - leftWidth;
            var leftOffset = this._canvasLeftOffset;
            var rightOffset = this._canvasLeftOffset + leftWidth;
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left | editorCommon_1.OverviewRulerLane.Center, leftOffset, leftWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Right, rightOffset, rightWidth);
        };
        OverviewRulerImpl.prototype._renderThreeLanes = function (ctx, colorZones, id2Color, w) {
            var leftWidth = Math.floor(w / 3);
            var rightWidth = Math.floor(w / 3);
            var centerWidth = w - leftWidth - rightWidth;
            var leftOffset = this._canvasLeftOffset;
            var centerOffset = this._canvasLeftOffset + leftWidth;
            var rightOffset = this._canvasLeftOffset + leftWidth + centerWidth;
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left, leftOffset, leftWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Center, centerOffset, centerWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Right, rightOffset, rightWidth);
        };
        OverviewRulerImpl.prototype._renderVerticalPatch = function (ctx, colorZones, id2Color, laneMask, xpos, width) {
            var currentColorId = 0;
            var currentFrom = 0;
            var currentTo = 0;
            for (var i = 0, len = colorZones.length; i < len; i++) {
                var zone = colorZones[i];
                if (!(zone.position & laneMask)) {
                    continue;
                }
                var zoneColorId = zone.colorId;
                var zoneFrom = zone.from;
                var zoneTo = zone.to;
                if (zoneColorId !== currentColorId) {
                    ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
                    currentColorId = zoneColorId;
                    ctx.fillStyle = id2Color[currentColorId];
                    currentFrom = zoneFrom;
                    currentTo = zoneTo;
                }
                else {
                    if (currentTo >= zoneFrom) {
                        currentTo = Math.max(currentTo, zoneTo);
                    }
                    else {
                        ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
                        currentFrom = zoneFrom;
                        currentTo = zoneTo;
                    }
                }
            }
            ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
        };
        return OverviewRulerImpl;
    }());
    exports.OverviewRulerImpl = OverviewRulerImpl;
});

define(__m[364/*vs/editor/common/viewLayout/editorLayoutProvider*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorLayoutProvider = (function () {
        function EditorLayoutProvider() {
        }
        EditorLayoutProvider.compute = function (_opts) {
            var outerWidth = _opts.outerWidth | 0;
            var outerHeight = _opts.outerHeight | 0;
            var showGlyphMargin = Boolean(_opts.showGlyphMargin);
            var lineHeight = _opts.lineHeight | 0;
            var showLineNumbers = Boolean(_opts.showLineNumbers);
            var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
            var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
            var maxDigitWidth = Number(_opts.maxDigitWidth);
            var maxLineNumber = _opts.maxLineNumber | 0;
            var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
            var verticalScrollbarHasArrows = Boolean(_opts.verticalScrollbarHasArrows);
            var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
            var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
            var lineNumbersWidth = 0;
            if (showLineNumbers) {
                var digitCount = Math.max(this.digitCount(maxLineNumber), lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            var glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight;
            }
            var contentWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            var glyphMarginLeft = 0;
            var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            var contentLeft = decorationsLeft + lineDecorationsWidth;
            var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            return new editorCommon_1.EditorLayoutInfo({
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginHeight: outerHeight,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                lineNumbersHeight: outerHeight,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                decorationsHeight: outerHeight,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                contentHeight: outerHeight,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: new editorCommon_1.OverviewRulerPosition({
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                })
            });
        };
        EditorLayoutProvider.digitCount = function (n) {
            var r = 0;
            while (n) {
                n = Math.floor(n / 10);
                r++;
            }
            return r ? r : 1;
        };
        return EditorLayoutProvider;
    }());
    exports.EditorLayoutProvider = EditorLayoutProvider;
});

define(__m[130/*vs/editor/common/viewModel/splitLinesCollection*/], __M([1/*require*/,0/*exports*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,85/*vs/editor/common/viewModel/prefixSumComputer*/]), function (require, exports, position_1, range_1, editorCommon, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OutputPosition = (function () {
        function OutputPosition(outputLineIndex, outputOffset) {
            this.outputLineIndex = outputLineIndex;
            this.outputOffset = outputOffset;
        }
        return OutputPosition;
    }());
    exports.OutputPosition = OutputPosition;
    var VisibleIdentitySplitLine = (function () {
        function VisibleIdentitySplitLine() {
        }
        VisibleIdentitySplitLine.prototype.isVisible = function () {
            return true;
        };
        VisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {
            if (isVisible) {
                return this;
            }
            return InvisibleIdentitySplitLine.INSTANCE;
        };
        VisibleIdentitySplitLine.prototype.getOutputLineCount = function () {
            return 1;
        };
        VisibleIdentitySplitLine.prototype.getOutputLineContent = function (model, myLineNumber, outputLineIndex) {
            return model.getLineContent(myLineNumber);
        };
        VisibleIdentitySplitLine.prototype.getOutputLineMinColumn = function (model, myLineNumber, outputLineIndex) {
            return model.getLineMinColumn(myLineNumber);
        };
        VisibleIdentitySplitLine.prototype.getOutputLineMaxColumn = function (model, myLineNumber, outputLineIndex) {
            return model.getLineMaxColumn(myLineNumber);
        };
        VisibleIdentitySplitLine.prototype.getOutputLineTokens = function (model, myLineNumber, outputLineIndex) {
            var lineTokens = model.getLineTokens(myLineNumber, true);
            return lineTokens.inflate();
        };
        VisibleIdentitySplitLine.prototype.getInputColumnOfOutputPosition = function (outputLineIndex, outputColumn) {
            return outputColumn;
        };
        VisibleIdentitySplitLine.prototype.getOutputPositionOfInputPosition = function (deltaLineNumber, inputColumn) {
            return new position_1.Position(deltaLineNumber, inputColumn);
        };
        return VisibleIdentitySplitLine;
    }());
    VisibleIdentitySplitLine.INSTANCE = new VisibleIdentitySplitLine();
    var InvisibleIdentitySplitLine = (function () {
        function InvisibleIdentitySplitLine() {
        }
        InvisibleIdentitySplitLine.prototype.isVisible = function () {
            return false;
        };
        InvisibleIdentitySplitLine.prototype.setVisible = function (isVisible) {
            if (!isVisible) {
                return this;
            }
            return VisibleIdentitySplitLine.INSTANCE;
        };
        InvisibleIdentitySplitLine.prototype.getOutputLineCount = function () {
            return 0;
        };
        InvisibleIdentitySplitLine.prototype.getOutputLineContent = function (model, myLineNumber, outputLineIndex) {
            throw new Error('Not supported');
        };
        InvisibleIdentitySplitLine.prototype.getOutputLineMinColumn = function (model, myLineNumber, outputLineIndex) {
            throw new Error('Not supported');
        };
        InvisibleIdentitySplitLine.prototype.getOutputLineMaxColumn = function (model, myLineNumber, outputLineIndex) {
            throw new Error('Not supported');
        };
        InvisibleIdentitySplitLine.prototype.getOutputLineTokens = function (model, myLineNumber, outputLineIndex) {
            throw new Error('Not supported');
        };
        InvisibleIdentitySplitLine.prototype.getInputColumnOfOutputPosition = function (outputLineIndex, outputColumn) {
            throw new Error('Not supported');
        };
        InvisibleIdentitySplitLine.prototype.getOutputPositionOfInputPosition = function (deltaLineNumber, inputColumn) {
            throw new Error('Not supported');
        };
        return InvisibleIdentitySplitLine;
    }());
    InvisibleIdentitySplitLine.INSTANCE = new InvisibleIdentitySplitLine();
    var SplitLine = (function () {
        function SplitLine(positionMapper, isVisible) {
            this.positionMapper = positionMapper;
            this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();
            this.wrappedIndentLength = this.wrappedIndent.length;
            this.outputLineCount = this.positionMapper.getOutputLineCount();
            this._isVisible = isVisible;
        }
        SplitLine.prototype.isVisible = function () {
            return this._isVisible;
        };
        SplitLine.prototype.setVisible = function (isVisible) {
            this._isVisible = isVisible;
            return this;
        };
        SplitLine.prototype.getOutputLineCount = function () {
            if (!this._isVisible) {
                return 0;
            }
            return this.outputLineCount;
        };
        SplitLine.prototype.getInputStartOffsetOfOutputLineIndex = function (outputLineIndex) {
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);
        };
        SplitLine.prototype.getInputEndOffsetOfOutputLineIndex = function (model, myLineNumber, outputLineIndex) {
            if (outputLineIndex + 1 === this.outputLineCount) {
                return model.getLineMaxColumn(myLineNumber) - 1;
            }
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);
        };
        SplitLine.prototype.getOutputLineContent = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
            var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, myLineNumber, outputLineIndex);
            var r = model.getLineContent(myLineNumber).substring(startOffset, endOffset);
            if (outputLineIndex > 0) {
                r = this.wrappedIndent + r;
            }
            return r;
        };
        SplitLine.prototype.getOutputLineMinColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            if (outputLineIndex > 0) {
                return this.wrappedIndentLength + 1;
            }
            return 1;
        };
        SplitLine.prototype.getOutputLineMaxColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return this.getOutputLineContent(model, myLineNumber, outputLineIndex).length + 1;
        };
        SplitLine.prototype.getOutputLineTokens = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
            var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, myLineNumber, outputLineIndex);
            var deltaStartIndex = 0;
            if (outputLineIndex > 0) {
                deltaStartIndex = this.wrappedIndentLength;
            }
            var lineTokens = model.getLineTokens(myLineNumber, true);
            return lineTokens.sliceAndInflate(startOffset, endOffset, deltaStartIndex);
        };
        SplitLine.prototype.getInputColumnOfOutputPosition = function (outputLineIndex, outputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var adjustedColumn = outputColumn - 1;
            if (outputLineIndex > 0) {
                if (adjustedColumn < this.wrappedIndentLength) {
                    adjustedColumn = 0;
                }
                else {
                    adjustedColumn -= this.wrappedIndentLength;
                }
            }
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;
        };
        SplitLine.prototype.getOutputPositionOfInputPosition = function (deltaLineNumber, inputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);
            var outputLineIndex = r.outputLineIndex;
            var outputColumn = r.outputOffset + 1;
            if (outputLineIndex > 0) {
                outputColumn += this.wrappedIndentLength;
            }
            //		console.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);
            return new position_1.Position(deltaLineNumber + outputLineIndex, outputColumn);
        };
        return SplitLine;
    }());
    exports.SplitLine = SplitLine;
    function createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {
        var positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);
        if (positionMapper === null) {
            // No mapping needed
            if (isVisible) {
                return VisibleIdentitySplitLine.INSTANCE;
            }
            return InvisibleIdentitySplitLine.INSTANCE;
        }
        else {
            return new SplitLine(positionMapper, isVisible);
        }
    }
    var SplitLinesCollection = (function () {
        function SplitLinesCollection(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {
            this.model = model;
            this._validModelVersionId = -1;
            this.tabSize = tabSize;
            this.wrappingColumn = wrappingColumn;
            this.columnsForFullWidthChar = columnsForFullWidthChar;
            this.wrappingIndent = wrappingIndent;
            this.linePositionMapperFactory = linePositionMapperFactory;
            this._constructLines(true);
        }
        SplitLinesCollection.prototype.dispose = function () {
            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
        };
        SplitLinesCollection.prototype._ensureValidState = function () {
            var modelVersion = this.model.getVersionId();
            if (modelVersion !== this._validModelVersionId) {
                throw new Error('SplitLinesCollection: attempt to access a \'newer\' model');
            }
        };
        SplitLinesCollection.prototype._constructLines = function (resetHiddenAreas) {
            var _this = this;
            this.lines = [];
            if (resetHiddenAreas) {
                this.hiddenAreasIds = [];
            }
            var linesContent = this.model.getLinesContent();
            var lineCount = linesContent.length;
            var values = new Uint32Array(lineCount);
            var hiddenAreas = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);
            var hiddenAreaStart = 1, hiddenAreaEnd = 0;
            var hiddenAreaIdx = -1;
            var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
            for (var i = 0; i < lineCount; i++) {
                var lineNumber = i + 1;
                if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                    hiddenAreaIdx++;
                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
                }
                var isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);
                var line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
                values[i] = line.getOutputLineCount();
                this.lines[i] = line;
            }
            this._validModelVersionId = this.model.getVersionId();
            this.prefixSumComputer = new prefixSumComputer_1.PrefixSumComputer(values);
        };
        SplitLinesCollection.prototype.getHiddenAreas = function () {
            var _this = this;
            return this.hiddenAreasIds.map(function (decId) {
                return _this.model.getDecorationRange(decId);
            }).sort(range_1.Range.compareRangesUsingStarts);
        };
        SplitLinesCollection.prototype._reduceRanges = function (_ranges) {
            var _this = this;
            if (_ranges.length === 0) {
                return [];
            }
            var ranges = _ranges.map(function (r) { return _this.model.validateRange(r); }).sort(range_1.Range.compareRangesUsingStarts);
            var result = [];
            var currentRangeStart = ranges[0].startLineNumber;
            var currentRangeEnd = ranges[0].endLineNumber;
            for (var i = 1, len = ranges.length; i < len; i++) {
                var range = ranges[i];
                if (range.startLineNumber > currentRangeEnd + 1) {
                    result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));
                    currentRangeStart = range.startLineNumber;
                    currentRangeEnd = range.endLineNumber;
                }
                else if (range.endLineNumber > currentRangeEnd) {
                    currentRangeEnd = range.endLineNumber;
                }
            }
            result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));
            return result;
        };
        SplitLinesCollection.prototype.setHiddenAreas = function (_ranges, emit) {
            var _this = this;
            var newRanges = this._reduceRanges(_ranges);
            // BEGIN TODO@Martin: Please stop calling this method on each model change!
            var oldRanges = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);
            if (newRanges.length === oldRanges.length) {
                var hasDifference = false;
                for (var i = 0; i < newRanges.length; i++) {
                    if (!newRanges[i].equalsRange(oldRanges[i])) {
                        hasDifference = true;
                        break;
                    }
                }
                if (!hasDifference) {
                    return false;
                }
            }
            // END TODO@Martin: Please stop calling this method on each model change!
            var newDecorations = [];
            for (var i = 0; i < newRanges.length; i++) {
                newDecorations.push({
                    range: newRanges[i],
                    options: {}
                });
            }
            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);
            var hiddenAreas = newRanges;
            var hiddenAreaStart = 1, hiddenAreaEnd = 0;
            var hiddenAreaIdx = -1;
            var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
            for (var i = 0; i < this.lines.length; i++) {
                var lineNumber = i + 1;
                if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                    hiddenAreaIdx++;
                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
                }
                var lineChanged = false;
                if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {
                    // Line should be hidden
                    if (this.lines[i].isVisible()) {
                        this.lines[i] = this.lines[i].setVisible(false);
                        lineChanged = true;
                    }
                }
                else {
                    // Line should be visible
                    if (!this.lines[i].isVisible()) {
                        this.lines[i] = this.lines[i].setVisible(true);
                        lineChanged = true;
                    }
                }
                if (lineChanged) {
                    var newOutputLineCount = this.lines[i].getOutputLineCount();
                    this.prefixSumComputer.changeValue(i, newOutputLineCount);
                }
            }
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.inputPositionIsVisible = function (inputLineNumber, inputColumn) {
            if (inputLineNumber < 1 || inputLineNumber > this.lines.length) {
                // invalid arguments
                return false;
            }
            return this.lines[inputLineNumber - 1].isVisible();
        };
        SplitLinesCollection.prototype.setTabSize = function (newTabSize, emit) {
            if (this.tabSize === newTabSize) {
                return false;
            }
            this.tabSize = newTabSize;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.setWrappingIndent = function (newWrappingIndent, emit) {
            if (this.wrappingIndent === newWrappingIndent) {
                return false;
            }
            this.wrappingIndent = newWrappingIndent;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.setWrappingColumn = function (newWrappingColumn, columnsForFullWidthChar, emit) {
            if (this.wrappingColumn === newWrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {
                return false;
            }
            this.wrappingColumn = newWrappingColumn;
            this.columnsForFullWidthChar = columnsForFullWidthChar;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.onModelFlushed = function (versionId, emit) {
            this._constructLines(true);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
        };
        SplitLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
            var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);
            this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
            this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
            var e = {
                fromLineNumber: outputFromLineNumber,
                toLineNumber: outputToLineNumber
            };
            emit(editorCommon.ViewEventNames.LinesDeletedEvent, e);
        };
        SplitLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, toLineNumber, text, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var hiddenAreas = this.getHiddenAreas();
            var isInHiddenArea = false;
            var testPosition = new position_1.Position(fromLineNumber, 1);
            for (var i = 0; i < hiddenAreas.length; i++) {
                if (hiddenAreas[i].containsPosition(testPosition)) {
                    isInHiddenArea = true;
                    break;
                }
            }
            var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
            var totalOutputLineCount = 0;
            var insertLines = [];
            var insertPrefixSumValues = new Uint32Array(text.length);
            for (var i = 0, len = text.length; i < len; i++) {
                var line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
                insertLines.push(line);
                var outputLineCount = line.getOutputLineCount();
                totalOutputLineCount += outputLineCount;
                insertPrefixSumValues[i] = outputLineCount;
            }
            this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));
            this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);
            var e = {
                fromLineNumber: outputFromLineNumber,
                toLineNumber: outputFromLineNumber + totalOutputLineCount - 1
            };
            emit(editorCommon.ViewEventNames.LinesInsertedEvent, e);
        };
        SplitLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var lineIndex = lineNumber - 1;
            var oldOutputLineCount = this.lines[lineIndex].getOutputLineCount();
            var isVisible = this.lines[lineIndex].isVisible();
            var line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);
            this.lines[lineIndex] = line;
            var newOutputLineCount = this.lines[lineIndex].getOutputLineCount();
            var lineMappingChanged = false;
            var changeFrom = 0;
            var changeTo = -1;
            var insertFrom = 0;
            var insertTo = -1;
            var deleteFrom = 0;
            var deleteTo = -1;
            if (oldOutputLineCount > newOutputLineCount) {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + newOutputLineCount - 1;
                deleteFrom = changeTo + 1;
                deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;
                lineMappingChanged = true;
            }
            else if (oldOutputLineCount < newOutputLineCount) {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + oldOutputLineCount - 1;
                insertFrom = changeTo + 1;
                insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;
                lineMappingChanged = true;
            }
            else {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + newOutputLineCount - 1;
            }
            this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);
            var e1;
            var e2;
            var e3;
            if (changeFrom <= changeTo) {
                for (var i = changeFrom; i <= changeTo; i++) {
                    e1 = {
                        lineNumber: i
                    };
                    emit(editorCommon.ViewEventNames.LineChangedEvent, e1);
                }
            }
            if (insertFrom <= insertTo) {
                e2 = {
                    fromLineNumber: insertFrom,
                    toLineNumber: insertTo
                };
                emit(editorCommon.ViewEventNames.LinesInsertedEvent, e2);
            }
            if (deleteFrom <= deleteTo) {
                e3 = {
                    fromLineNumber: deleteFrom,
                    toLineNumber: deleteTo
                };
                emit(editorCommon.ViewEventNames.LinesDeletedEvent, e3);
            }
            return lineMappingChanged;
        };
        SplitLinesCollection.prototype.getOutputLineCount = function () {
            this._ensureValidState();
            return this.prefixSumComputer.getTotalValue();
        };
        SplitLinesCollection.prototype._toValidOutputLineNumber = function (outputLineNumber) {
            if (outputLineNumber < 1) {
                return 1;
            }
            var outputLineCount = this.getOutputLineCount();
            if (outputLineNumber > outputLineCount) {
                return outputLineCount;
            }
            return outputLineNumber;
        };
        SplitLinesCollection.prototype.getOutputLineContent = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineContent(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputIndentGuide = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            return this.model.getLineIndentGuide(r.index + 1);
        };
        SplitLinesCollection.prototype.getOutputLineMinColumn = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineMinColumn(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputLineMaxColumn = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineMaxColumn(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputLineTokens = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineTokens(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.convertOutputPositionToInputPosition = function (viewLineNumber, viewColumn) {
            this._ensureValidState();
            viewLineNumber = this._toValidOutputLineNumber(viewLineNumber);
            var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            var inputColumn = this.lines[lineIndex].getInputColumnOfOutputPosition(remainder, viewColumn);
            // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);
            return this.model.validatePosition(new position_1.Position(lineIndex + 1, inputColumn));
        };
        SplitLinesCollection.prototype.convertInputPositionToOutputPosition = function (_inputLineNumber, _inputColumn) {
            this._ensureValidState();
            var validPosition = this.model.validatePosition(new position_1.Position(_inputLineNumber, _inputColumn));
            var inputLineNumber = validPosition.lineNumber;
            var inputColumn = validPosition.column;
            var lineIndex = inputLineNumber - 1, lineIndexChanged = false;
            while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
                lineIndex--;
                lineIndexChanged = true;
            }
            if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
                // Could not reach a real line
                // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);
                return new position_1.Position(1, 1);
            }
            var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
            var r;
            if (lineIndexChanged) {
                r = this.lines[lineIndex].getOutputPositionOfInputPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
            }
            else {
                r = this.lines[inputLineNumber - 1].getOutputPositionOfInputPosition(deltaLineNumber, inputColumn);
            }
            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);
            return r;
        };
        return SplitLinesCollection;
    }());
    exports.SplitLinesCollection = SplitLinesCollection;
});






define(__m[366/*vs/editor/common/viewModel/characterHardWrappingLineMapper*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,2/*vs/editor/common/editorCommon*/,85/*vs/editor/common/viewModel/prefixSumComputer*/,130/*vs/editor/common/viewModel/splitLinesCollection*/,65/*vs/editor/common/core/characterClassifier*/,80/*vs/editor/common/core/uint*/]), function (require, exports, strings, editorCommon_1, prefixSumComputer_1, splitLinesCollection_1, characterClassifier_1, uint_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["NONE"] = 0] = "NONE";
        CharacterClass[CharacterClass["BREAK_BEFORE"] = 1] = "BREAK_BEFORE";
        CharacterClass[CharacterClass["BREAK_AFTER"] = 2] = "BREAK_AFTER";
        CharacterClass[CharacterClass["BREAK_OBTRUSIVE"] = 3] = "BREAK_OBTRUSIVE";
        CharacterClass[CharacterClass["BREAK_IDEOGRAPHIC"] = 4] = "BREAK_IDEOGRAPHIC"; // for Han and Kana.
    })(CharacterClass || (CharacterClass = {}));
    var WrappingCharacterClassifier = (function (_super) {
        __extends(WrappingCharacterClassifier, _super);
        function WrappingCharacterClassifier(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {
            var _this = _super.call(this, 0 /* NONE */) || this;
            for (var i = 0; i < BREAK_BEFORE.length; i++) {
                _this.set(BREAK_BEFORE.charCodeAt(i), 1 /* BREAK_BEFORE */);
            }
            for (var i = 0; i < BREAK_AFTER.length; i++) {
                _this.set(BREAK_AFTER.charCodeAt(i), 2 /* BREAK_AFTER */);
            }
            for (var i = 0; i < BREAK_OBTRUSIVE.length; i++) {
                _this.set(BREAK_OBTRUSIVE.charCodeAt(i), 3 /* BREAK_OBTRUSIVE */);
            }
            return _this;
        }
        WrappingCharacterClassifier.prototype.get = function (charCode) {
            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:
            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)
            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)
            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)
            if ((charCode >= 0x3040 && charCode <= 0x30FF)
                || (charCode >= 0x3400 && charCode <= 0x4DBF)
                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {
                return 4 /* BREAK_IDEOGRAPHIC */;
            }
            return _super.prototype.get.call(this, charCode);
        };
        return WrappingCharacterClassifier;
    }(characterClassifier_1.CharacterClassifier));
    var CharacterHardWrappingLineMapperFactory = (function () {
        function CharacterHardWrappingLineMapperFactory(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {
            this.classifier = new WrappingCharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);
        }
        // TODO@Alex -> duplicated in lineCommentCommand
        CharacterHardWrappingLineMapperFactory.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
            currentVisibleColumn = +currentVisibleColumn; //@perf
            tabSize = +tabSize; //@perf
            columnSize = +columnSize; //@perf
            if (isTab) {
                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
            }
            return currentVisibleColumn + columnSize;
        };
        CharacterHardWrappingLineMapperFactory.prototype.createLineMapping = function (lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {
            if (breakingColumn === -1) {
                return null;
            }
            tabSize = +tabSize; //@perf
            breakingColumn = +breakingColumn; //@perf
            columnsForFullWidthChar = +columnsForFullWidthChar; //@perf
            hardWrappingIndent = +hardWrappingIndent; //@perf
            var wrappedTextIndentVisibleColumn = 0;
            var wrappedTextIndent = '';
            var firstNonWhitespaceIndex = -1;
            if (hardWrappingIndent !== editorCommon_1.WrappingIndent.None) {
                firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);
                if (firstNonWhitespaceIndex !== -1) {
                    wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);
                    for (var i = 0; i < firstNonWhitespaceIndex; i++) {
                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === 9 /* Tab */, 1);
                    }
                    if (hardWrappingIndent === editorCommon_1.WrappingIndent.Indent) {
                        wrappedTextIndent += '\t';
                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);
                    }
                    // Force sticking to beginning of line if indentColumn > 66% breakingColumn
                    if (wrappedTextIndentVisibleColumn > 1 / 2 * breakingColumn) {
                        wrappedTextIndent = '';
                        wrappedTextIndentVisibleColumn = 0;
                    }
                }
            }
            var classifier = this.classifier;
            var lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened
            var breakingLengths = []; // The length of each broken-up line text
            var breakingLengthsIndex = 0; // The count of breaks already done
            var visibleColumn = 0; // Visible column since the beginning of the current line
            var niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)
            var niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`
            var obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)
            var obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`
            var len = lineText.length;
            for (var i = 0; i < len; i++) {
                // At this point, there is a certainty that the character before `i` fits on the current line,
                // but the character at `i` might not fit
                var charCode = lineText.charCodeAt(i);
                var charCodeIsTab = (charCode === 9 /* Tab */);
                var charCodeClass = classifier.get(charCode);
                if (charCodeClass === 1 /* BREAK_BEFORE */) {
                    // This is a character that indicates that a break should happen before it
                    // Since we are certain the character before `i` fits, there's no extra checking needed,
                    // just mark it as a nice breaking opportunity
                    niceBreakOffset = i;
                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
                // CJK breaking : before break
                if (charCodeClass === 4 /* BREAK_IDEOGRAPHIC */ && i > 0) {
                    var prevCode = lineText.charCodeAt(i - 1);
                    var prevClass = classifier.get(prevCode);
                    if (prevClass !== 1 /* BREAK_BEFORE */) {
                        niceBreakOffset = i;
                        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                    }
                }
                var charColumnSize = 1;
                if (strings.isFullWidthCharacter(charCode)) {
                    charColumnSize = columnsForFullWidthChar;
                }
                // Advance visibleColumn with character at `i`
                visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);
                if (visibleColumn > breakingColumn && i !== 0) {
                    // We need to break at least before character at `i`:
                    //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))
                    //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))
                    //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))
                    var breakBeforeOffset = void 0;
                    var restoreVisibleColumnFrom = void 0;
                    if (niceBreakOffset !== -1) {
                        // We will break before `niceBreakLastOffset`
                        breakBeforeOffset = niceBreakOffset;
                        restoreVisibleColumnFrom = niceBreakVisibleColumn;
                    }
                    else if (obtrusiveBreakOffset !== -1) {
                        // We will break before `obtrusiveBreakLastOffset`
                        breakBeforeOffset = obtrusiveBreakOffset;
                        restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;
                    }
                    else {
                        // We will break before `i`
                        breakBeforeOffset = i;
                        restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;
                    }
                    // Break before character at `breakBeforeOffset`
                    breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;
                    lastBreakingOffset = breakBeforeOffset;
                    // Re-establish visibleColumn by taking character at `i` into account
                    visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);
                    // Reset markers
                    niceBreakOffset = -1;
                    niceBreakVisibleColumn = 0;
                    obtrusiveBreakOffset = -1;
                    obtrusiveBreakVisibleColumn = 0;
                }
                // At this point, there is a certainty that the character at `i` fits on the current line
                if (niceBreakOffset !== -1) {
                    // Advance niceBreakVisibleColumn
                    niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
                }
                if (obtrusiveBreakOffset !== -1) {
                    // Advance obtrusiveBreakVisibleColumn
                    obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
                }
                if (charCodeClass === 2 /* BREAK_AFTER */ && (hardWrappingIndent === editorCommon_1.WrappingIndent.None || i >= firstNonWhitespaceIndex)) {
                    // This is a character that indicates that a break should happen after it
                    niceBreakOffset = i + 1;
                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
                // CJK breaking : after break
                if (charCodeClass === 4 /* BREAK_IDEOGRAPHIC */ && i < len - 1) {
                    var nextCode = lineText.charCodeAt(i + 1);
                    var nextClass = classifier.get(nextCode);
                    if (nextClass !== 2 /* BREAK_AFTER */) {
                        niceBreakOffset = i + 1;
                        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                    }
                }
                if (charCodeClass === 3 /* BREAK_OBTRUSIVE */) {
                    // This is an obtrusive character that indicates that a break should happen after it
                    obtrusiveBreakOffset = i + 1;
                    obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
            }
            if (breakingLengthsIndex === 0) {
                return null;
            }
            // Add last segment
            breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;
            return new CharacterHardWrappingLineMapping(new prefixSumComputer_1.PrefixSumComputer(uint_1.toUint32Array(breakingLengths)), wrappedTextIndent);
        };
        return CharacterHardWrappingLineMapperFactory;
    }());
    exports.CharacterHardWrappingLineMapperFactory = CharacterHardWrappingLineMapperFactory;
    var CharacterHardWrappingLineMapping = (function () {
        function CharacterHardWrappingLineMapping(prefixSums, wrappedLinesIndent) {
            this._prefixSums = prefixSums;
            this._wrappedLinesIndent = wrappedLinesIndent;
        }
        CharacterHardWrappingLineMapping.prototype.getOutputLineCount = function () {
            return this._prefixSums.getCount();
        };
        CharacterHardWrappingLineMapping.prototype.getWrappedLinesIndent = function () {
            return this._wrappedLinesIndent;
        };
        CharacterHardWrappingLineMapping.prototype.getInputOffsetOfOutputPosition = function (outputLineIndex, outputOffset) {
            if (outputLineIndex === 0) {
                return outputOffset;
            }
            else {
                return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;
            }
        };
        CharacterHardWrappingLineMapping.prototype.getOutputPositionOfInputOffset = function (inputOffset) {
            var r = this._prefixSums.getIndexOf(inputOffset);
            return new splitLinesCollection_1.OutputPosition(r.index, r.remainder);
        };
        return CharacterHardWrappingLineMapping;
    }());
    exports.CharacterHardWrappingLineMapping = CharacterHardWrappingLineMapping;
});

define(__m[47/*vs/editor/common/viewModel/viewEventHandler*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewEventHandler = (function () {
        function ViewEventHandler() {
            this._shouldRender = true;
        }
        ViewEventHandler.prototype.shouldRender = function () {
            return this._shouldRender;
        };
        ViewEventHandler.prototype.setShouldRender = function () {
            this._shouldRender = true;
        };
        ViewEventHandler.prototype.onDidRender = function () {
            this._shouldRender = false;
        };
        // --- begin event handlers
        ViewEventHandler.prototype.onLineMappingChanged = function () {
            return false;
        };
        ViewEventHandler.prototype.onModelFlushed = function () {
            return false;
        };
        ViewEventHandler.prototype.onModelDecorationsChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLinesDeleted = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLineChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLinesInserted = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelTokensChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorScrollRequest = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onConfigurationChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onLayoutChanged = function (layoutInfo) {
            return false;
        };
        ViewEventHandler.prototype.onScrollChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onZonesChanged = function () {
            return false;
        };
        ViewEventHandler.prototype.onViewFocusChanged = function (isFocused) {
            return false;
        };
        // --- end event handlers
        ViewEventHandler.prototype.handleEvents = function (events) {
            var shouldRender = false;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                var data = e.getData();
                switch (e.getType()) {
                    case editorCommon.ViewEventNames.LineMappingChangedEvent:
                        if (this.onLineMappingChanged()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.ModelFlushedEvent:
                        if (this.onModelFlushed()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LinesDeletedEvent:
                        if (this.onModelLinesDeleted(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LinesInsertedEvent:
                        if (this.onModelLinesInserted(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LineChangedEvent:
                        if (this.onModelLineChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.TokensChangedEvent:
                        if (this.onModelTokensChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.DecorationsChangedEvent:
                        if (this.onModelDecorationsChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.CursorPositionChangedEvent:
                        if (this.onCursorPositionChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.CursorSelectionChangedEvent:
                        if (this.onCursorSelectionChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.RevealRangeEvent:
                        if (this.onCursorRevealRange(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.ScrollRequestEvent:
                        if (this.onCursorScrollRequest(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ConfigurationChanged:
                        if (this.onConfigurationChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewLayoutChanged:
                        if (this.onLayoutChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewScrollChanged:
                        if (this.onScrollChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewZonesChanged:
                        if (this.onZonesChanged()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewFocusChanged:
                        if (this.onViewFocusChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    default:
                        console.info('View received unknown event: ');
                        console.info(e);
                }
            }
            if (shouldRender) {
                this._shouldRender = true;
            }
        };
        return ViewEventHandler;
    }());
    exports.ViewEventHandler = ViewEventHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[48/*vs/editor/browser/view/dynamicViewOverlay*/], __M([1/*require*/,0/*exports*/,47/*vs/editor/common/viewModel/viewEventHandler*/]), function (require, exports, viewEventHandler_1) {
    'use strict';
    var DynamicViewOverlay = (function (_super) {
        __extends(DynamicViewOverlay, _super);
        function DynamicViewOverlay() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return DynamicViewOverlay;
    }(viewEventHandler_1.ViewEventHandler));
    exports.DynamicViewOverlay = DynamicViewOverlay;
});






define(__m[31/*vs/editor/browser/view/viewPart*/], __M([1/*require*/,0/*exports*/,47/*vs/editor/common/viewModel/viewEventHandler*/]), function (require, exports, viewEventHandler_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewPart = (function (_super) {
        __extends(ViewPart, _super);
        function ViewPart(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._context.addEventHandler(_this);
            return _this;
        }
        ViewPart.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
        };
        return ViewPart;
    }(viewEventHandler_1.ViewEventHandler));
    exports.ViewPart = ViewPart;
    var PartFingerprint;
    (function (PartFingerprint) {
        PartFingerprint[PartFingerprint["None"] = 0] = "None";
        PartFingerprint[PartFingerprint["ContentWidgets"] = 1] = "ContentWidgets";
        PartFingerprint[PartFingerprint["OverflowingContentWidgets"] = 2] = "OverflowingContentWidgets";
        PartFingerprint[PartFingerprint["OverflowGuard"] = 3] = "OverflowGuard";
        PartFingerprint[PartFingerprint["OverlayWidgets"] = 4] = "OverlayWidgets";
        PartFingerprint[PartFingerprint["ScrollableElement"] = 5] = "ScrollableElement";
        PartFingerprint[PartFingerprint["TextArea"] = 6] = "TextArea";
        PartFingerprint[PartFingerprint["ViewLines"] = 7] = "ViewLines";
    })(PartFingerprint = exports.PartFingerprint || (exports.PartFingerprint = {}));
    var PartFingerprints = (function () {
        function PartFingerprints() {
        }
        PartFingerprints.write = function (target, partId) {
            target.setAttribute('data-mprt', String(partId));
        };
        PartFingerprints.read = function (target) {
            var r = target.getAttribute('data-mprt');
            if (r === null) {
                return 0 /* None */;
            }
            return parseInt(r, 10);
        };
        PartFingerprints.collect = function (child, stopAt) {
            var result = [], resultLen = 0;
            while (child && child !== document.body) {
                if (child === stopAt) {
                    break;
                }
                if (child.nodeType === child.ELEMENT_NODE) {
                    result[resultLen++] = this.read(child);
                }
                child = child.parentElement;
            }
            var r = new Uint8Array(resultLen);
            for (var i = 0; i < resultLen; i++) {
                r[i] = result[resultLen - i - 1];
            }
            return r;
        };
        return PartFingerprints;
    }());
    exports.PartFingerprints = PartFingerprints;
});






define(__m[134/*vs/editor/browser/controller/mouseTarget*/], __M([1/*require*/,0/*exports*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,21/*vs/editor/browser/editorBrowser*/,104/*vs/editor/browser/editorDom*/,23/*vs/base/browser/browser*/,31/*vs/editor/browser/view/viewPart*/]), function (require, exports, position_1, range_1, editorCommon_1, editorBrowser_1, editorDom_1, browser, viewPart_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MouseTarget = (function () {
        function MouseTarget(element, type, mouseColumn, position, range, detail) {
            if (mouseColumn === void 0) { mouseColumn = 0; }
            if (position === void 0) { position = null; }
            if (range === void 0) { range = null; }
            if (detail === void 0) { detail = null; }
            this.element = element;
            this.type = type;
            this.mouseColumn = mouseColumn;
            this.position = position;
            if (!range && position) {
                range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            }
            this.range = range;
            this.detail = detail;
        }
        MouseTarget._typeToString = function (type) {
            if (type === editorCommon_1.MouseTargetType.TEXTAREA) {
                return 'TEXTAREA';
            }
            if (type === editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                return 'GUTTER_GLYPH_MARGIN';
            }
            if (type === editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS) {
                return 'GUTTER_LINE_NUMBERS';
            }
            if (type === editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS) {
                return 'GUTTER_LINE_DECORATIONS';
            }
            if (type === editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE) {
                return 'GUTTER_VIEW_ZONE';
            }
            if (type === editorCommon_1.MouseTargetType.CONTENT_TEXT) {
                return 'CONTENT_TEXT';
            }
            if (type === editorCommon_1.MouseTargetType.CONTENT_EMPTY) {
                return 'CONTENT_EMPTY';
            }
            if (type === editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE) {
                return 'CONTENT_VIEW_ZONE';
            }
            if (type === editorCommon_1.MouseTargetType.CONTENT_WIDGET) {
                return 'CONTENT_WIDGET';
            }
            if (type === editorCommon_1.MouseTargetType.OVERVIEW_RULER) {
                return 'OVERVIEW_RULER';
            }
            if (type === editorCommon_1.MouseTargetType.SCROLLBAR) {
                return 'SCROLLBAR';
            }
            if (type === editorCommon_1.MouseTargetType.OVERLAY_WIDGET) {
                return 'OVERLAY_WIDGET';
            }
            return 'UNKNOWN';
        };
        MouseTarget.toString = function (target) {
            return this._typeToString(target.type) + ': ' + target.position + ' - ' + target.range + ' - ' + target.detail;
        };
        MouseTarget.prototype.toString = function () {
            return MouseTarget.toString(this);
        };
        return MouseTarget;
    }());
    exports.MouseTarget = MouseTarget;
    var ElementPath = (function () {
        function ElementPath() {
        }
        ElementPath.isTextArea = function (path) {
            return (path.length === 2
                && path[0] === 3 /* OverflowGuard */
                && path[1] === 6 /* TextArea */);
        };
        ElementPath.isChildOfViewLines = function (path) {
            return (path.length >= 4
                && path[0] === 3 /* OverflowGuard */
                && path[3] === 7 /* ViewLines */);
        };
        ElementPath.isChildOfScrollableElement = function (path) {
            return (path.length >= 2
                && path[0] === 3 /* OverflowGuard */
                && path[1] === 5 /* ScrollableElement */);
        };
        ElementPath.isChildOfContentWidgets = function (path) {
            return (path.length >= 4
                && path[0] === 3 /* OverflowGuard */
                && path[3] === 1 /* ContentWidgets */);
        };
        ElementPath.isChildOfOverflowingContentWidgets = function (path) {
            return (path.length >= 1
                && path[0] === 2 /* OverflowingContentWidgets */);
        };
        ElementPath.isChildOfOverlayWidgets = function (path) {
            return (path.length >= 2
                && path[0] === 3 /* OverflowGuard */
                && path[1] === 4 /* OverlayWidgets */);
        };
        return ElementPath;
    }());
    var HitTestContext = (function () {
        function HitTestContext(context, viewHelper, lastViewCursorsRenderData) {
            this.model = context.model;
            this.layoutInfo = context.configuration.editor.layoutInfo;
            this.viewDomNode = viewHelper.viewDomNode;
            this.lineHeight = context.configuration.editor.lineHeight;
            this.typicalHalfwidthCharacterWidth = context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            this.lastViewCursorsRenderData = lastViewCursorsRenderData;
            this._context = context;
            this._viewHelper = viewHelper;
        }
        HitTestContext.prototype.getZoneAtCoord = function (mouseVerticalOffset) {
            // The target is either a view zone or the empty space after the last view-line
            var viewZoneWhitespace = this._viewHelper.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
            if (viewZoneWhitespace) {
                var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = this._context.model.getLineCount(), positionBefore = null, position = void 0, positionAfter = null;
                if (viewZoneWhitespace.afterLineNumber !== lineCount) {
                    // There are more lines after this view zone
                    positionAfter = new position_1.Position(viewZoneWhitespace.afterLineNumber + 1, 1);
                }
                if (viewZoneWhitespace.afterLineNumber > 0) {
                    // There are more lines above this view zone
                    positionBefore = new position_1.Position(viewZoneWhitespace.afterLineNumber, this._context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));
                }
                if (positionAfter === null) {
                    position = positionBefore;
                }
                else if (positionBefore === null) {
                    position = positionAfter;
                }
                else if (mouseVerticalOffset < viewZoneMiddle) {
                    position = positionBefore;
                }
                else {
                    position = positionAfter;
                }
                return {
                    viewZoneId: viewZoneWhitespace.id,
                    afterLineNumber: viewZoneWhitespace.afterLineNumber,
                    positionBefore: positionBefore,
                    positionAfter: positionAfter,
                    position: position
                };
            }
            return null;
        };
        HitTestContext.prototype.getFullLineRangeAtCoord = function (mouseVerticalOffset) {
            if (this._viewHelper.isAfterLines(mouseVerticalOffset)) {
                // Below the last line
                var lineNumber_1 = this._context.model.getLineCount();
                var maxLineColumn_1 = this._context.model.getLineMaxColumn(lineNumber_1);
                return {
                    range: new range_1.Range(lineNumber_1, maxLineColumn_1, lineNumber_1, maxLineColumn_1),
                    isAfterLines: true
                };
            }
            var lineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
            var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);
            return {
                range: new range_1.Range(lineNumber, 1, lineNumber, maxLineColumn),
                isAfterLines: false
            };
        };
        HitTestContext.prototype.getLineNumberAtVerticalOffset = function (mouseVerticalOffset) {
            return this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
        };
        HitTestContext.prototype.isAfterLines = function (mouseVerticalOffset) {
            return this._viewHelper.isAfterLines(mouseVerticalOffset);
        };
        HitTestContext.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
            return this._viewHelper.getVerticalOffsetForLineNumber(lineNumber);
        };
        HitTestContext.prototype.findAttribute = function (element, attr) {
            return HitTestContext._findAttribute(element, attr, this._viewHelper.viewDomNode);
        };
        HitTestContext._findAttribute = function (element, attr, stopAt) {
            while (element && element !== document.body) {
                if (element.hasAttribute && element.hasAttribute(attr)) {
                    return element.getAttribute(attr);
                }
                if (element === stopAt) {
                    return null;
                }
                element = element.parentNode;
            }
            return null;
        };
        HitTestContext.prototype.getLineWidth = function (lineNumber) {
            return this._viewHelper.getLineWidth(lineNumber);
        };
        HitTestContext.prototype.visibleRangeForPosition2 = function (lineNumber, column) {
            return this._viewHelper.visibleRangeForPosition2(lineNumber, column);
        };
        HitTestContext.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
            return this._viewHelper.getPositionFromDOMInfo(spanNode, offset);
        };
        HitTestContext.prototype.getScrollTop = function () {
            return this._viewHelper.getScrollTop();
        };
        HitTestContext.prototype.getScrollLeft = function () {
            return this._viewHelper.getScrollLeft();
        };
        return HitTestContext;
    }());
    var BareHitTestRequest = (function () {
        function BareHitTestRequest(ctx, editorPos, pos) {
            this.editorPos = editorPos;
            this.pos = pos;
            this.mouseVerticalOffset = Math.max(0, ctx.getScrollTop() + pos.y - editorPos.y);
            this.mouseContentHorizontalOffset = ctx.getScrollLeft() + pos.x - editorPos.x - ctx.layoutInfo.contentLeft;
            this.isInMarginArea = (pos.x - editorPos.x < ctx.layoutInfo.contentLeft);
            this.isInContentArea = !this.isInMarginArea;
            this.mouseColumn = Math.max(0, MouseTargetFactory._getMouseColumn(this.mouseContentHorizontalOffset, ctx.typicalHalfwidthCharacterWidth));
        }
        return BareHitTestRequest;
    }());
    var HitTestRequest = (function (_super) {
        __extends(HitTestRequest, _super);
        function HitTestRequest(ctx, editorPos, pos, target) {
            var _this = _super.call(this, ctx, editorPos, pos) || this;
            _this._ctx = ctx;
            if (target) {
                _this.target = target;
                _this.targetPath = viewPart_1.PartFingerprints.collect(target, ctx.viewDomNode);
            }
            else {
                _this.target = null;
                _this.targetPath = new Uint8Array(0);
            }
            return _this;
        }
        HitTestRequest.prototype.toString = function () {
            return "pos(" + this.pos.x + "," + this.pos.y + "), editorPos(" + this.editorPos.x + "," + this.editorPos.y + "), mouseVerticalOffset: " + this.mouseVerticalOffset + ", mouseContentHorizontalOffset: " + this.mouseContentHorizontalOffset + "\n\ttarget: " + (this.target ? this.target.outerHTML : null);
        };
        HitTestRequest.prototype.fulfill = function (type, position, range, detail) {
            if (position === void 0) { position = null; }
            if (range === void 0) { range = null; }
            if (detail === void 0) { detail = null; }
            return new MouseTarget(this.target, type, this.mouseColumn, position, range, detail);
        };
        HitTestRequest.prototype.withTarget = function (target) {
            return new HitTestRequest(this._ctx, this.editorPos, this.pos, target);
        };
        return HitTestRequest;
    }(BareHitTestRequest));
    var MouseTargetFactory = (function () {
        function MouseTargetFactory(context, viewHelper) {
            this._context = context;
            this._viewHelper = viewHelper;
        }
        MouseTargetFactory.prototype.mouseTargetIsWidget = function (e) {
            var t = e.target;
            var path = viewPart_1.PartFingerprints.collect(t, this._viewHelper.viewDomNode);
            // Is it a content widget?
            if (ElementPath.isChildOfContentWidgets(path) || ElementPath.isChildOfOverflowingContentWidgets(path)) {
                return true;
            }
            // Is it an overlay widget?
            if (ElementPath.isChildOfOverlayWidgets(path)) {
                return true;
            }
            return false;
        };
        MouseTargetFactory.prototype.createMouseTarget = function (lastViewCursorsRenderData, editorPos, pos, target) {
            var ctx = new HitTestContext(this._context, this._viewHelper, lastViewCursorsRenderData);
            var request = new HitTestRequest(ctx, editorPos, pos, target);
            try {
                var r = MouseTargetFactory._createMouseTarget(ctx, request, false);
                // console.log(r.toString());
                return r;
            }
            catch (err) {
                // console.log(err);
                return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN);
            }
        };
        MouseTargetFactory._createMouseTarget = function (ctx, request, domHitTestExecuted) {
            // console.log(`${domHitTestExecuted ? '=>' : ''}CAME IN REQUEST: ${request}`);
            // First ensure the request has a target
            if (request.target === null) {
                if (domHitTestExecuted) {
                    // Still no target... and we have already executed hit test...
                    return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN);
                }
                var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
                if (hitTestResult.position) {
                    return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
                }
                return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
            }
            var result = null;
            result = result || MouseTargetFactory._hitTestContentWidget(ctx, request);
            result = result || MouseTargetFactory._hitTestOverlayWidget(ctx, request);
            result = result || MouseTargetFactory._hitTestViewZone(ctx, request);
            result = result || MouseTargetFactory._hitTestMargin(ctx, request);
            result = result || MouseTargetFactory._hitTestViewCursor(ctx, request);
            result = result || MouseTargetFactory._hitTestTextArea(ctx, request);
            result = result || MouseTargetFactory._hitTestViewLines(ctx, request, domHitTestExecuted);
            result = result || MouseTargetFactory._hitTestScrollbar(ctx, request);
            return (result || request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN));
        };
        MouseTargetFactory._hitTestContentWidget = function (ctx, request) {
            // Is it a content widget?
            if (ElementPath.isChildOfContentWidgets(request.targetPath) || ElementPath.isChildOfOverflowingContentWidgets(request.targetPath)) {
                var widgetId = ctx.findAttribute(request.target, 'widgetId');
                if (widgetId) {
                    return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_WIDGET, null, null, widgetId);
                }
                else {
                    return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN);
                }
            }
            return null;
        };
        MouseTargetFactory._hitTestOverlayWidget = function (ctx, request) {
            // Is it an overlay widget?
            if (ElementPath.isChildOfOverlayWidgets(request.targetPath)) {
                var widgetId = ctx.findAttribute(request.target, 'widgetId');
                if (widgetId) {
                    return request.fulfill(editorCommon_1.MouseTargetType.OVERLAY_WIDGET, null, null, widgetId);
                }
                else {
                    return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN);
                }
            }
            return null;
        };
        MouseTargetFactory._hitTestViewCursor = function (ctx, request) {
            if (request.isInContentArea) {
                // Edge has a bug when hit-testing the exact position of a cursor,
                // instead of returning the correct dom node, it returns the
                // first or last rendered view line dom node, therefore help it out
                // and first check if we are on top of a cursor
                var lastViewCursorsRenderData = ctx.lastViewCursorsRenderData;
                var mouseContentHorizontalOffset = request.mouseContentHorizontalOffset;
                var mouseVerticalOffset = request.mouseVerticalOffset;
                for (var i = 0, len = lastViewCursorsRenderData.length; i < len; i++) {
                    var d = lastViewCursorsRenderData[i];
                    if (d.contentLeft <= mouseContentHorizontalOffset
                        && mouseContentHorizontalOffset <= d.contentLeft + d.width
                        && d.contentTop <= mouseVerticalOffset
                        && mouseVerticalOffset <= d.contentTop + d.height) {
                        return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, d.position);
                    }
                }
            }
            // Is it a cursor ?
            if (request.target.getAttribute) {
                // Target is an Element
                var lineNumberAttribute = request.target.getAttribute('lineNumber');
                if (lineNumberAttribute) {
                    var columnAttribute = request.target.getAttribute('column');
                    if (columnAttribute) {
                        var position = new position_1.Position(parseInt(lineNumberAttribute, 10), parseInt(columnAttribute, 10));
                        return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, position);
                    }
                }
            }
            return null;
        };
        MouseTargetFactory._hitTestViewZone = function (ctx, request) {
            var viewZoneData = ctx.getZoneAtCoord(request.mouseVerticalOffset);
            if (viewZoneData) {
                var mouseTargetType = (request.isInContentArea ? editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE : editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE);
                return request.fulfill(mouseTargetType, viewZoneData.position, null, viewZoneData);
            }
            return null;
        };
        MouseTargetFactory._hitTestTextArea = function (ctx, request) {
            // Is it the textarea?
            if (ElementPath.isTextArea(request.targetPath)) {
                return request.fulfill(editorCommon_1.MouseTargetType.TEXTAREA);
            }
            return null;
        };
        MouseTargetFactory._hitTestMargin = function (ctx, request) {
            if (request.isInMarginArea) {
                var res = ctx.getFullLineRangeAtCoord(request.mouseVerticalOffset);
                var pos = res.range.getStartPosition();
                var offset = Math.abs(request.pos.x - request.editorPos.x);
                if (offset <= ctx.layoutInfo.glyphMarginWidth) {
                    // On the glyph margin
                    return request.fulfill(editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN, pos, res.range, res.isAfterLines);
                }
                offset -= ctx.layoutInfo.glyphMarginWidth;
                if (offset <= ctx.layoutInfo.lineNumbersWidth) {
                    // On the line numbers
                    return request.fulfill(editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS, pos, res.range, res.isAfterLines);
                }
                offset -= ctx.layoutInfo.lineNumbersWidth;
                // On the line decorations
                return request.fulfill(editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS, pos, res.range, res.isAfterLines);
            }
            return null;
        };
        MouseTargetFactory._hitTestViewLines = function (ctx, request, domHitTestExecuted) {
            if (!ElementPath.isChildOfViewLines(request.targetPath)) {
                return null;
            }
            // Check if it is below any lines and any view zones
            if (ctx.isAfterLines(request.mouseVerticalOffset)) {
                // This most likely indicates it happened after the last view-line
                var lineCount = ctx.model.getLineCount();
                var maxLineColumn = ctx.model.getLineMaxColumn(lineCount);
                return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_EMPTY, new position_1.Position(lineCount, maxLineColumn));
            }
            if (domHitTestExecuted) {
                // We have already executed hit test...
                return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN);
            }
            var hitTestResult = MouseTargetFactory._doHitTest(ctx, request);
            if (hitTestResult.position) {
                return MouseTargetFactory.createMouseTargetFromHitTestPosition(ctx, request, hitTestResult.position.lineNumber, hitTestResult.position.column);
            }
            return this._createMouseTarget(ctx, request.withTarget(hitTestResult.hitTarget), true);
        };
        MouseTargetFactory._hitTestScrollbar = function (ctx, request) {
            // Is it the overview ruler?
            // Is it a child of the scrollable element?
            if (ElementPath.isChildOfScrollableElement(request.targetPath)) {
                var possibleLineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
                var maxColumn = ctx.model.getLineMaxColumn(possibleLineNumber);
                return request.fulfill(editorCommon_1.MouseTargetType.SCROLLBAR, new position_1.Position(possibleLineNumber, maxColumn));
            }
            return null;
        };
        MouseTargetFactory.prototype.getMouseColumn = function (editorPos, pos) {
            var layoutInfo = this._context.configuration.editor.layoutInfo;
            var mouseContentHorizontalOffset = this._viewHelper.getScrollLeft() + pos.x - editorPos.x - layoutInfo.contentLeft;
            return MouseTargetFactory._getMouseColumn(mouseContentHorizontalOffset, this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth);
        };
        MouseTargetFactory._getMouseColumn = function (mouseContentHorizontalOffset, typicalHalfwidthCharacterWidth) {
            if (mouseContentHorizontalOffset < 0) {
                return 1;
            }
            var chars = Math.round(mouseContentHorizontalOffset / typicalHalfwidthCharacterWidth);
            return (chars + 1);
        };
        MouseTargetFactory.createMouseTargetFromHitTestPosition = function (ctx, request, lineNumber, column) {
            var pos = new position_1.Position(lineNumber, column);
            var lineWidth = ctx.getLineWidth(lineNumber);
            if (request.mouseContentHorizontalOffset > lineWidth) {
                if (browser.isEdge && pos.column === 1) {
                    // See https://github.com/Microsoft/vscode/issues/10875
                    return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_EMPTY, new position_1.Position(lineNumber, ctx.model.getLineMaxColumn(lineNumber)));
                }
                return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_EMPTY, pos);
            }
            var visibleRange = ctx.visibleRangeForPosition2(lineNumber, column);
            if (!visibleRange) {
                return request.fulfill(editorCommon_1.MouseTargetType.UNKNOWN, pos);
            }
            var columnHorizontalOffset = visibleRange.left;
            if (request.mouseContentHorizontalOffset === columnHorizontalOffset) {
                return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, pos);
            }
            var mouseIsBetween;
            if (column > 1) {
                var prevColumnHorizontalOffset = visibleRange.left;
                mouseIsBetween = false;
                mouseIsBetween = mouseIsBetween || (prevColumnHorizontalOffset < request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset < columnHorizontalOffset); // LTR case
                mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset < prevColumnHorizontalOffset); // RTL case
                if (mouseIsBetween) {
                    var rng = new range_1.Range(lineNumber, column, lineNumber, column - 1);
                    return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, pos, rng);
                }
            }
            var lineMaxColumn = ctx.model.getLineMaxColumn(lineNumber);
            if (column < lineMaxColumn) {
                var nextColumnVisibleRange = ctx.visibleRangeForPosition2(lineNumber, column + 1);
                if (nextColumnVisibleRange) {
                    var nextColumnHorizontalOffset = nextColumnVisibleRange.left;
                    mouseIsBetween = false;
                    mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset < nextColumnHorizontalOffset); // LTR case
                    mouseIsBetween = mouseIsBetween || (nextColumnHorizontalOffset < request.mouseContentHorizontalOffset && request.mouseContentHorizontalOffset < columnHorizontalOffset); // RTL case
                    if (mouseIsBetween) {
                        var rng = new range_1.Range(lineNumber, column, lineNumber, column + 1);
                        return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, pos, rng);
                    }
                }
            }
            return request.fulfill(editorCommon_1.MouseTargetType.CONTENT_TEXT, pos);
        };
        /**
         * Most probably WebKit browsers and Edge
         */
        MouseTargetFactory._doHitTestWithCaretRangeFromPoint = function (ctx, request) {
            // In Chrome, especially on Linux it is possible to click between lines,
            // so try to adjust the `hity` below so that it lands in the center of a line
            var lineNumber = ctx.getLineNumberAtVerticalOffset(request.mouseVerticalOffset);
            var lineVerticalOffset = ctx.getVerticalOffsetForLineNumber(lineNumber);
            var lineCenteredVerticalOffset = lineVerticalOffset + Math.floor(ctx.lineHeight / 2);
            var adjustedPageY = request.pos.y + (lineCenteredVerticalOffset - request.mouseVerticalOffset);
            if (adjustedPageY <= request.editorPos.y) {
                adjustedPageY = request.editorPos.y + 1;
            }
            if (adjustedPageY >= request.editorPos.y + ctx.layoutInfo.height) {
                adjustedPageY = request.editorPos.y + ctx.layoutInfo.height - 1;
            }
            var adjustedPage = new editorDom_1.PageCoordinates(request.pos.x, adjustedPageY);
            var r = this._actualDoHitTestWithCaretRangeFromPoint(ctx, adjustedPage.toClientCoordinates());
            if (r.position) {
                return r;
            }
            // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)
            return this._actualDoHitTestWithCaretRangeFromPoint(ctx, request.pos.toClientCoordinates());
        };
        MouseTargetFactory._actualDoHitTestWithCaretRangeFromPoint = function (ctx, coords) {
            var range = document.caretRangeFromPoint(coords.clientX, coords.clientY);
            if (!range || !range.startContainer) {
                return {
                    position: null,
                    hitTarget: null
                };
            }
            // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span
            var startContainer = range.startContainer;
            var hitTarget;
            if (startContainer.nodeType === startContainer.TEXT_NODE) {
                // startContainer is expected to be the token text
                var parent1 = startContainer.parentNode; // expected to be the token span
                var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
                var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
                var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
                if (parent3ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                    var p = ctx.getPositionFromDOMInfo(parent1, range.startOffset);
                    return {
                        position: p,
                        hitTarget: null
                    };
                }
                else {
                    hitTarget = startContainer.parentNode;
                }
            }
            else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {
                // startContainer is expected to be the token span
                var parent1 = startContainer.parentNode; // expected to be the view line container span
                var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div
                var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
                if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                    var p = ctx.getPositionFromDOMInfo(startContainer, startContainer.textContent.length);
                    return {
                        position: p,
                        hitTarget: null
                    };
                }
                else {
                    hitTarget = startContainer;
                }
            }
            return {
                position: null,
                hitTarget: hitTarget
            };
        };
        /**
         * Most probably Gecko
         */
        MouseTargetFactory._doHitTestWithCaretPositionFromPoint = function (ctx, coords) {
            var hitResult = document.caretPositionFromPoint(coords.clientX, coords.clientY);
            if (hitResult.offsetNode.nodeType === hitResult.offsetNode.TEXT_NODE) {
                // offsetNode is expected to be the token text
                var parent1 = hitResult.offsetNode.parentNode; // expected to be the token span
                var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
                var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
                var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
                if (parent3ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                    var p = ctx.getPositionFromDOMInfo(hitResult.offsetNode.parentNode, hitResult.offset);
                    return {
                        position: p,
                        hitTarget: null
                    };
                }
                else {
                    return {
                        position: null,
                        hitTarget: hitResult.offsetNode.parentNode
                    };
                }
            }
            return {
                position: null,
                hitTarget: hitResult.offsetNode
            };
        };
        /**
         * Most probably IE
         */
        MouseTargetFactory._doHitTestWithMoveToPoint = function (ctx, coords) {
            var resultPosition = null;
            var resultHitTarget = null;
            var textRange = document.body.createTextRange();
            try {
                textRange.moveToPoint(coords.clientX, coords.clientY);
            }
            catch (err) {
                return {
                    position: null,
                    hitTarget: null
                };
            }
            textRange.collapse(true);
            // Now, let's do our best to figure out what we hit :)
            var parentElement = textRange ? textRange.parentElement() : null;
            var parent1 = parentElement ? parentElement.parentNode : null;
            var parent2 = parent1 ? parent1.parentNode : null;
            var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';
            if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                var rangeToContainEntireSpan = textRange.duplicate();
                rangeToContainEntireSpan.moveToElementText(parentElement);
                rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);
                resultPosition = ctx.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);
                // Move range out of the span node, IE doesn't like having many ranges in
                // the same spot and will act badly for lines containing dashes ('-')
                rangeToContainEntireSpan.moveToElementText(ctx.viewDomNode);
            }
            else {
                // Looks like we've hit the hover or something foreign
                resultHitTarget = parentElement;
            }
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            textRange.moveToElementText(ctx.viewDomNode);
            return {
                position: resultPosition,
                hitTarget: resultHitTarget
            };
        };
        MouseTargetFactory._doHitTest = function (ctx, request) {
            // State of the art (18.10.2012):
            // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)
            // Gecko:
            //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352
            //    - however, they do give out rangeParent/rangeOffset properties on mouse events
            // Webkit:
            //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint
            // IE:
            //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx
            // 24.08.2016: Edge has added WebKit's document.caretRangeFromPoint, but it is quite buggy
            //    - when hit testing the cursor it returns the first or the last line in the viewport
            //    - it inconsistently hits text nodes or span nodes, while WebKit only hits text nodes
            //    - when toggling render whitespace on, and hit testing in the empty content after a line, it always hits offset 0 of the first span of the line
            // Thank you browsers for making this so 'easy' :)
            if (document.caretRangeFromPoint) {
                return this._doHitTestWithCaretRangeFromPoint(ctx, request);
            }
            else if (document.caretPositionFromPoint) {
                return this._doHitTestWithCaretPositionFromPoint(ctx, request.pos.toClientCoordinates());
            }
            else if (document.body.createTextRange) {
                return this._doHitTestWithMoveToPoint(ctx, request.pos.toClientCoordinates());
            }
            return {
                position: null,
                hitTarget: null
            };
        };
        return MouseTargetFactory;
    }());
    exports.MouseTargetFactory = MouseTargetFactory;
});






define(__m[371/*vs/editor/browser/controller/mouseHandler*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,19/*vs/base/common/platform*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,16/*vs/editor/common/core/position*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,47/*vs/editor/common/viewModel/viewEventHandler*/,134/*vs/editor/browser/controller/mouseTarget*/,17/*vs/base/common/async*/,104/*vs/editor/browser/editorDom*/,34/*vs/base/browser/mouseEvent*/,106/*vs/editor/common/config/editorZoom*/]), function (require, exports, lifecycle_1, platform, browser, dom, position_1, selection_1, editorCommon, viewEventHandler_1, mouseTarget_1, async_1, editorDom_1, mouseEvent_1, editorZoom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Merges mouse events when mouse move events are throttled
     */
    function createMouseMoveEventMerger(mouseTargetFactory) {
        return function (lastEvent, currentEvent) {
            var targetIsWidget = false;
            if (mouseTargetFactory) {
                targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);
            }
            if (!targetIsWidget) {
                currentEvent.preventDefault();
            }
            return currentEvent;
        };
    }
    var EventGateKeeper = (function (_super) {
        __extends(EventGateKeeper, _super);
        function EventGateKeeper(destination, condition) {
            var _this = _super.call(this) || this;
            _this._destination = destination;
            _this._condition = condition;
            _this._retryTimer = _this._register(new async_1.TimeoutTimer());
            _this.handler = function (value) { return _this._handle(value); };
            return _this;
        }
        EventGateKeeper.prototype.dispose = function () {
            this._retryValue = null;
            _super.prototype.dispose.call(this);
        };
        EventGateKeeper.prototype._handle = function (value) {
            var _this = this;
            if (this._condition()) {
                this._retryTimer.cancel();
                this._retryValue = null;
                this._destination(value);
            }
            else {
                this._retryValue = value;
                this._retryTimer.setIfNotSet(function () {
                    var tmp = _this._retryValue;
                    _this._retryValue = null;
                    _this._handle(tmp);
                }, 10);
            }
        };
        return EventGateKeeper;
    }(lifecycle_1.Disposable));
    var MousePosition = (function () {
        function MousePosition(position, mouseColumn) {
            this.position = position;
            this.mouseColumn = mouseColumn;
        }
        return MousePosition;
    }());
    var MouseHandler = (function (_super) {
        __extends(MouseHandler, _super);
        function MouseHandler(context, viewController, viewHelper) {
            var _this = _super.call(this) || this;
            _this._isFocused = false;
            _this._context = context;
            _this.viewController = viewController;
            _this.viewHelper = viewHelper;
            _this.mouseTargetFactory = new mouseTarget_1.MouseTargetFactory(_this._context, viewHelper);
            _this.listenersToRemove = [];
            _this._mouseDownOperation = new MouseDownOperation(_this._context, _this.viewController, _this.viewHelper, function (e, testEventTarget) { return _this._createMouseTarget(e, testEventTarget); }, function (e) { return _this._getMouseColumn(e); });
            _this.toDispose = [];
            _this._asyncFocus = new async_1.RunOnceScheduler(function () { return _this.viewHelper.focusTextArea(); }, 0);
            _this.toDispose.push(_this._asyncFocus);
            _this.lastMouseLeaveTime = -1;
            var mouseEvents = new editorDom_1.EditorMouseEventFactory(_this.viewHelper.viewDomNode);
            _this.listenersToRemove.push(mouseEvents.onContextMenu(_this.viewHelper.viewDomNode, function (e) { return _this._onContextMenu(e, true); }));
            _this._mouseMoveEventHandler = new EventGateKeeper(function (e) { return _this._onMouseMove(e); }, function () { return !_this.viewHelper.isDirty(); });
            _this.toDispose.push(_this._mouseMoveEventHandler);
            _this.listenersToRemove.push(mouseEvents.onMouseMoveThrottled(_this.viewHelper.viewDomNode, _this._mouseMoveEventHandler.handler, createMouseMoveEventMerger(_this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
            _this.listenersToRemove.push(mouseEvents.onMouseUp(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseUp(e); }));
            _this.listenersToRemove.push(mouseEvents.onMouseLeave(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseLeave(e); }));
            _this.listenersToRemove.push(mouseEvents.onMouseDown(_this.viewHelper.viewDomNode, function (e) { return _this._onMouseDown(e); }));
            var onMouseWheel = function (browserEvent) {
                if (!_this._context.configuration.editor.viewInfo.mouseWheelZoom) {
                    return;
                }
                var e = new mouseEvent_1.StandardMouseWheelEvent(browserEvent);
                if (e.browserEvent.ctrlKey || e.browserEvent.metaKey) {
                    var zoomLevel = editorZoom_1.EditorZoom.getZoomLevel();
                    var delta = e.deltaY > 0 ? 1 : -1;
                    editorZoom_1.EditorZoom.setZoomLevel(zoomLevel + delta);
                    e.preventDefault();
                    e.stopPropagation();
                }
            };
            _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.viewDomNode, 'mousewheel', onMouseWheel, true));
            _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.viewDomNode, 'DOMMouseScroll', onMouseWheel, true));
            _this._context.addEventHandler(_this);
            return _this;
        }
        MouseHandler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this._mouseDownOperation.dispose();
        };
        // --- begin event handlers
        MouseHandler.prototype.onLayoutChanged = function (layoutInfo) {
            return false;
        };
        MouseHandler.prototype.onScrollChanged = function (e) {
            this._mouseDownOperation.onScrollChanged();
            return false;
        };
        MouseHandler.prototype.onCursorSelectionChanged = function (e) {
            this._mouseDownOperation.onCursorSelectionChanged(e);
            return false;
        };
        MouseHandler.prototype.onViewFocusChanged = function (isFocused) {
            this._isFocused = isFocused;
            return false;
        };
        // --- end event handlers
        MouseHandler.prototype.getTargetAtClientPoint = function (clientX, clientY) {
            var clientPos = new editorDom_1.ClientCoordinates(clientX, clientY);
            var pos = clientPos.toPageCoordinates();
            var editorPos = editorDom_1.createEditorPagePosition(this.viewHelper.viewDomNode);
            if (pos.y < editorPos.y || pos.y > editorPos.y + editorPos.height || pos.x < editorPos.x || pos.x > editorPos.x + editorPos.width) {
                return null;
            }
            var lastViewCursorsRenderData = this.viewHelper.getLastViewCursorsRenderData();
            return this.mouseTargetFactory.createMouseTarget(lastViewCursorsRenderData, editorPos, pos, null);
        };
        MouseHandler.prototype._createMouseTarget = function (e, testEventTarget) {
            var lastViewCursorsRenderData = this.viewHelper.getLastViewCursorsRenderData();
            return this.mouseTargetFactory.createMouseTarget(lastViewCursorsRenderData, e.editorPos, e.pos, testEventTarget ? e.target : null);
        };
        MouseHandler.prototype._getMouseColumn = function (e) {
            return this.mouseTargetFactory.getMouseColumn(e.editorPos, e.pos);
        };
        MouseHandler.prototype._onContextMenu = function (e, testEventTarget) {
            this.viewController.emitContextMenu({
                event: e,
                target: this._createMouseTarget(e, testEventTarget)
            });
        };
        MouseHandler.prototype._onMouseMove = function (e) {
            if (this._mouseDownOperation.isActive()) {
                // In selection/drag operation
                return;
            }
            var actualMouseMoveTime = e.timestamp;
            if (actualMouseMoveTime < this.lastMouseLeaveTime) {
                // Due to throttling, this event occured before the mouse left the editor, therefore ignore it.
                return;
            }
            this.viewController.emitMouseMove({
                event: e,
                target: this._createMouseTarget(e, true)
            });
        };
        MouseHandler.prototype._onMouseLeave = function (e) {
            this.lastMouseLeaveTime = (new Date()).getTime();
            this.viewController.emitMouseLeave({
                event: e,
                target: null
            });
        };
        MouseHandler.prototype._onMouseUp = function (e) {
            this.viewController.emitMouseUp({
                event: e,
                target: this._createMouseTarget(e, true)
            });
        };
        MouseHandler.prototype._onMouseDown = function (e) {
            var _this = this;
            var t = this._createMouseTarget(e, true);
            var targetIsContent = (t.type === editorCommon.MouseTargetType.CONTENT_TEXT || t.type === editorCommon.MouseTargetType.CONTENT_EMPTY);
            var targetIsGutter = (t.type === editorCommon.MouseTargetType.GUTTER_GLYPH_MARGIN || t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS || t.type === editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS);
            var targetIsLineNumbers = (t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
            var selectOnLineNumbers = this._context.configuration.editor.viewInfo.selectOnLineNumbers;
            var targetIsViewZone = (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE);
            var targetIsWidget = (t.type === editorCommon.MouseTargetType.CONTENT_WIDGET);
            var shouldHandle = e.leftButton;
            if (platform.isMacintosh && e.ctrlKey) {
                shouldHandle = false;
            }
            var focus = function () {
                // In IE11, if the focus is in the browser's address bar and
                // then you click in the editor, calling preventDefault()
                // will not move focus properly (focus remains the address bar)
                if (browser.isIE && !_this._isFocused) {
                    _this._asyncFocus.schedule();
                }
                else {
                    e.preventDefault();
                    _this.viewHelper.focusTextArea();
                }
            };
            if (shouldHandle && (targetIsContent || (targetIsLineNumbers && selectOnLineNumbers))) {
                focus();
                this._mouseDownOperation.start(t.type, e);
            }
            else if (targetIsGutter) {
                // Do not steal focus
                e.preventDefault();
            }
            else if (targetIsViewZone) {
                var viewZoneData = t.detail;
                if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {
                    focus();
                    this._mouseDownOperation.start(t.type, e);
                    e.preventDefault();
                }
            }
            else if (targetIsWidget && this.viewHelper.shouldSuppressMouseDownOnWidget(t.detail)) {
                focus();
                e.preventDefault();
            }
            this.viewController.emitMouseDown({
                event: e,
                target: t
            });
        };
        return MouseHandler;
    }(viewEventHandler_1.ViewEventHandler));
    MouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100; // ms
    exports.MouseHandler = MouseHandler;
    var MouseDownOperation = (function (_super) {
        __extends(MouseDownOperation, _super);
        function MouseDownOperation(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._viewController = viewController;
            _this._viewHelper = viewHelper;
            _this._createMouseTarget = createMouseTarget;
            _this._getMouseColumn = getMouseColumn;
            _this._currentSelection = new selection_1.Selection(1, 1, 1, 1);
            _this._mouseState = new MouseDownState();
            _this._onScrollTimeout = _this._register(new async_1.TimeoutTimer());
            _this._isActive = false;
            _this._lastMouseEvent = null;
            _this._mouseMoveMonitor = _this._register(new editorDom_1.GlobalEditorMouseMoveMonitor(_this._viewHelper.viewDomNode));
            _this._mouseDownThenMoveEventHandler = _this._register(new EventGateKeeper(function (e) { return _this._onMouseDownThenMove(e); }, function () { return !_this._viewHelper.isDirty(); }));
            return _this;
        }
        MouseDownOperation.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        MouseDownOperation.prototype.isActive = function () {
            return this._isActive;
        };
        MouseDownOperation.prototype._onMouseDownThenMove = function (e) {
            this._lastMouseEvent = e;
            this._mouseState.setModifiers(e);
            var position = this._findMousePosition(e, true);
            if (!position) {
                // Ignoring because position is unknown
                return;
            }
            this._dispatchMouse(position, true);
        };
        MouseDownOperation.prototype.start = function (targetType, e) {
            var _this = this;
            this._lastMouseEvent = e;
            this._mouseState.setStartedOnLineNumbers(targetType === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
            this._mouseState.setModifiers(e);
            var position = this._findMousePosition(e, true);
            if (!position) {
                // Ignoring because position is unknown
                return;
            }
            this._mouseState.trySetCount(e.detail, position.position);
            // Overwrite the detail of the MouseEvent, as it will be sent out in an event and contributions might rely on it.
            e.detail = this._mouseState.count;
            this._dispatchMouse(position, e.shiftKey);
            if (!this._isActive) {
                this._isActive = true;
                this._mouseMoveMonitor.startMonitoring(createMouseMoveEventMerger(null), this._mouseDownThenMoveEventHandler.handler, function () { return _this._stop(); });
            }
        };
        MouseDownOperation.prototype._stop = function () {
            this._isActive = false;
            this._onScrollTimeout.cancel();
        };
        MouseDownOperation.prototype.onScrollChanged = function () {
            var _this = this;
            if (!this._isActive) {
                return;
            }
            this._onScrollTimeout.setIfNotSet(function () {
                var position = _this._findMousePosition(_this._lastMouseEvent, false);
                if (!position) {
                    // Ignoring because position is unknown
                    return;
                }
                _this._dispatchMouse(position, true);
            }, 10);
        };
        MouseDownOperation.prototype.onCursorSelectionChanged = function (e) {
            this._currentSelection = e.selection;
        };
        MouseDownOperation.prototype._getPositionOutsideEditor = function (e) {
            var editorContent = e.editorPos;
            var mouseColumn = this._getMouseColumn(e);
            if (e.posy < editorContent.y) {
                var aboveLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(Math.max(this._viewHelper.getScrollTop() - (editorContent.y - e.posy), 0));
                return new MousePosition(new position_1.Position(aboveLineNumber, 1), mouseColumn);
            }
            if (e.posy > editorContent.y + editorContent.height) {
                var belowLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.y));
                return new MousePosition(new position_1.Position(belowLineNumber, this._context.model.getLineMaxColumn(belowLineNumber)), mouseColumn);
            }
            var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.y));
            if (e.posx < editorContent.x) {
                return new MousePosition(new position_1.Position(possibleLineNumber, 1), mouseColumn);
            }
            if (e.posx > editorContent.x + editorContent.width) {
                return new MousePosition(new position_1.Position(possibleLineNumber, this._context.model.getLineMaxColumn(possibleLineNumber)), mouseColumn);
            }
            return null;
        };
        MouseDownOperation.prototype._findMousePosition = function (e, testEventTarget) {
            var positionOutsideEditor = this._getPositionOutsideEditor(e);
            if (positionOutsideEditor) {
                return positionOutsideEditor;
            }
            var t = this._createMouseTarget(e, testEventTarget);
            var hintedPosition = t.position;
            if (!hintedPosition) {
                return null;
            }
            if (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE) {
                // Force position on view zones to go above or below depending on where selection started from
                var selectionStart = new position_1.Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);
                var viewZoneData = t.detail;
                var positionBefore = viewZoneData.positionBefore;
                var positionAfter = viewZoneData.positionAfter;
                if (positionBefore && positionAfter) {
                    if (positionBefore.isBefore(selectionStart)) {
                        return new MousePosition(positionBefore, t.mouseColumn);
                    }
                    else {
                        return new MousePosition(positionAfter, t.mouseColumn);
                    }
                }
            }
            return new MousePosition(hintedPosition, t.mouseColumn);
        };
        MouseDownOperation.prototype._dispatchMouse = function (position, inSelectionMode) {
            this._viewController.dispatchMouse({
                position: position.position,
                mouseColumn: position.mouseColumn,
                startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
                inSelectionMode: inSelectionMode,
                mouseDownCount: this._mouseState.count,
                altKey: this._mouseState.altKey,
                ctrlKey: this._mouseState.ctrlKey,
                metaKey: this._mouseState.metaKey,
                shiftKey: this._mouseState.shiftKey,
            });
        };
        return MouseDownOperation;
    }(lifecycle_1.Disposable));
    var MouseDownState = (function () {
        function MouseDownState() {
            this._altKey = false;
            this._ctrlKey = false;
            this._metaKey = false;
            this._shiftKey = false;
            this._startedOnLineNumbers = false;
            this._lastMouseDownPosition = null;
            this._lastMouseDownPositionEqualCount = 0;
            this._lastMouseDownCount = 0;
            this._lastSetMouseDownCountTime = 0;
        }
        Object.defineProperty(MouseDownState.prototype, "altKey", {
            get: function () { return this._altKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "ctrlKey", {
            get: function () { return this._ctrlKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "metaKey", {
            get: function () { return this._metaKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "shiftKey", {
            get: function () { return this._shiftKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "startedOnLineNumbers", {
            get: function () { return this._startedOnLineNumbers; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "count", {
            get: function () {
                return this._lastMouseDownCount;
            },
            enumerable: true,
            configurable: true
        });
        MouseDownState.prototype.setModifiers = function (source) {
            this._altKey = source.altKey;
            this._ctrlKey = source.ctrlKey;
            this._metaKey = source.metaKey;
            this._shiftKey = source.shiftKey;
        };
        MouseDownState.prototype.setStartedOnLineNumbers = function (startedOnLineNumbers) {
            this._startedOnLineNumbers = startedOnLineNumbers;
        };
        MouseDownState.prototype.trySetCount = function (setMouseDownCount, newMouseDownPosition) {
            // a. Invalidate multiple clicking if too much time has passed (will be hit by IE because the detail field of mouse events contains garbage in IE10)
            var currentTime = (new Date()).getTime();
            if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
                setMouseDownCount = 1;
            }
            this._lastSetMouseDownCountTime = currentTime;
            // b. Ensure that we don't jump from single click to triple click in one go (will be hit by IE because the detail field of mouse events contains garbage in IE10)
            if (setMouseDownCount > this._lastMouseDownCount + 1) {
                setMouseDownCount = this._lastMouseDownCount + 1;
            }
            // c. Invalidate multiple clicking if the logical position is different
            if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {
                this._lastMouseDownPositionEqualCount++;
            }
            else {
                this._lastMouseDownPositionEqualCount = 1;
            }
            this._lastMouseDownPosition = newMouseDownPosition;
            // Finally set the lastMouseDownCount
            this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
        };
        return MouseDownState;
    }());
    MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400; // ms
});






define(__m[372/*vs/editor/browser/controller/pointerHandler*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,61/*vs/base/browser/touch*/,371/*vs/editor/browser/controller/mouseHandler*/,104/*vs/editor/browser/editorDom*/]), function (require, exports, dom, touch_1, mouseHandler_1, editorDom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function gestureChangeEventMerger(lastEvent, currentEvent) {
        var r = {
            translationY: currentEvent.translationY,
            translationX: currentEvent.translationX
        };
        if (lastEvent) {
            r.translationY += lastEvent.translationY;
            r.translationX += lastEvent.translationX;
        }
        return r;
    }
    ;
    /**
     * Basically IE10 and IE11
     */
    var MsPointerHandler = (function (_super) {
        __extends(MsPointerHandler, _super);
        function MsPointerHandler(context, viewController, viewHelper) {
            var _this = _super.call(this, context, viewController, viewHelper) || this;
            _this.viewHelper.linesContentDomNode.style.msTouchAction = 'none';
            _this.viewHelper.linesContentDomNode.style.msContentZooming = 'none';
            // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
            // This handler should be added when the dom node is in the dom tree
            _this._installGestureHandlerTimeout = window.setTimeout(function () {
                _this._installGestureHandlerTimeout = -1;
                if (window.MSGesture) {
                    var touchGesture_1 = new MSGesture();
                    var penGesture_1 = new MSGesture();
                    touchGesture_1.target = _this.viewHelper.linesContentDomNode;
                    penGesture_1.target = _this.viewHelper.linesContentDomNode;
                    _this.viewHelper.linesContentDomNode.addEventListener('MSPointerDown', function (e) {
                        // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
                        var pointerType = e.pointerType;
                        if (pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {
                            _this._lastPointerType = 'mouse';
                            return;
                        }
                        else if (pointerType === (e.MSPOINTER_TYPE_TOUCH || 'touch')) {
                            _this._lastPointerType = 'touch';
                            touchGesture_1.addPointer(e.pointerId);
                        }
                        else {
                            _this._lastPointerType = 'pen';
                            penGesture_1.addPointer(e.pointerId);
                        }
                    });
                    _this.listenersToRemove.push(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                    _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
                }
            }, 100);
            _this._lastPointerType = 'mouse';
            return _this;
        }
        MsPointerHandler.prototype._onMouseDown = function (e) {
            if (this._lastPointerType === 'mouse') {
                _super.prototype._onMouseDown.call(this, e);
            }
        };
        MsPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
            var _this = this;
            var e = new editorDom_1.EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
            var t = this._createMouseTarget(e, false);
            if (t.position) {
                this.viewController.moveTo('mouse', t.position);
            }
            // IE does not want to focus when coming in from the browser's address bar
            if (e.browserEvent.fromElement) {
                e.preventDefault();
                this.viewHelper.focusTextArea();
            }
            else {
                // TODO@Alex -> cancel this is focus is lost
                setTimeout(function () {
                    _this.viewHelper.focusTextArea();
                });
            }
        };
        MsPointerHandler.prototype._onGestureChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        MsPointerHandler.prototype.dispose = function () {
            window.clearTimeout(this._installGestureHandlerTimeout);
            _super.prototype.dispose.call(this);
        };
        return MsPointerHandler;
    }(mouseHandler_1.MouseHandler));
    /**
     * Basically Edge but should be modified to handle any pointerEnabled, even without support of MSGesture
     */
    var StandardPointerHandler = (function (_super) {
        __extends(StandardPointerHandler, _super);
        function StandardPointerHandler(context, viewController, viewHelper) {
            var _this = _super.call(this, context, viewController, viewHelper) || this;
            _this.viewHelper.linesContentDomNode.style.touchAction = 'none';
            // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
            // This handler should be added when the dom node is in the dom tree
            _this._installGestureHandlerTimeout = window.setTimeout(function () {
                _this._installGestureHandlerTimeout = -1;
                // TODO@Alex: replace the usage of MSGesture here with something that works across all browsers
                if (window.MSGesture) {
                    var touchGesture_2 = new MSGesture();
                    var penGesture_2 = new MSGesture();
                    touchGesture_2.target = _this.viewHelper.linesContentDomNode;
                    penGesture_2.target = _this.viewHelper.linesContentDomNode;
                    _this.viewHelper.linesContentDomNode.addEventListener('pointerdown', function (e) {
                        var pointerType = e.pointerType;
                        if (pointerType === 'mouse') {
                            _this._lastPointerType = 'mouse';
                            return;
                        }
                        else if (pointerType === 'touch') {
                            _this._lastPointerType = 'touch';
                            touchGesture_2.addPointer(e.pointerId);
                        }
                        else {
                            _this._lastPointerType = 'pen';
                            penGesture_2.addPointer(e.pointerId);
                        }
                    });
                    _this.listenersToRemove.push(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                    _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
                }
            }, 100);
            _this._lastPointerType = 'mouse';
            return _this;
        }
        StandardPointerHandler.prototype._onMouseDown = function (e) {
            if (this._lastPointerType === 'mouse') {
                _super.prototype._onMouseDown.call(this, e);
            }
        };
        StandardPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
            var _this = this;
            var e = new editorDom_1.EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
            var t = this._createMouseTarget(e, false);
            if (t.position) {
                this.viewController.moveTo('mouse', t.position);
            }
            // IE does not want to focus when coming in from the browser's address bar
            if (e.browserEvent.fromElement) {
                e.preventDefault();
                this.viewHelper.focusTextArea();
            }
            else {
                // TODO@Alex -> cancel this is focus is lost
                setTimeout(function () {
                    _this.viewHelper.focusTextArea();
                });
            }
        };
        StandardPointerHandler.prototype._onGestureChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        StandardPointerHandler.prototype.dispose = function () {
            window.clearTimeout(this._installGestureHandlerTimeout);
            _super.prototype.dispose.call(this);
        };
        return StandardPointerHandler;
    }(mouseHandler_1.MouseHandler));
    var TouchHandler = (function (_super) {
        __extends(TouchHandler, _super);
        function TouchHandler(context, viewController, viewHelper) {
            var _this = _super.call(this, context, viewController, viewHelper) || this;
            _this.gesture = new touch_1.Gesture(_this.viewHelper.linesContentDomNode);
            _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, touch_1.EventType.Tap, function (e) { return _this.onTap(e); }));
            _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, touch_1.EventType.Change, function (e) { return _this.onChange(e); }));
            _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, touch_1.EventType.Contextmenu, function (e) { return _this._onContextMenu(new editorDom_1.EditorMouseEvent(e, _this.viewHelper.viewDomNode), false); }));
            return _this;
        }
        TouchHandler.prototype.dispose = function () {
            this.gesture.dispose();
            _super.prototype.dispose.call(this);
        };
        TouchHandler.prototype.onTap = function (event) {
            event.preventDefault();
            this.viewHelper.focusTextArea();
            var target = this._createMouseTarget(new editorDom_1.EditorMouseEvent(event, this.viewHelper.viewDomNode), false);
            if (target.position) {
                this.viewController.moveTo('mouse', target.position);
            }
        };
        TouchHandler.prototype.onChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        return TouchHandler;
    }(mouseHandler_1.MouseHandler));
    var PointerHandler = (function () {
        function PointerHandler(context, viewController, viewHelper) {
            if (window.navigator.msPointerEnabled) {
                this.handler = new MsPointerHandler(context, viewController, viewHelper);
            }
            else if (window.TouchEvent) {
                this.handler = new TouchHandler(context, viewController, viewHelper);
            }
            else if (window.navigator.pointerEnabled) {
                this.handler = new StandardPointerHandler(context, viewController, viewHelper);
            }
            else {
                this.handler = new mouseHandler_1.MouseHandler(context, viewController, viewHelper);
            }
        }
        PointerHandler.prototype.getTargetAtClientPoint = function (clientX, clientY) {
            return this.handler.getTargetAtClientPoint(clientX, clientY);
        };
        PointerHandler.prototype.dispose = function () {
            this.handler.dispose();
        };
        return PointerHandler;
    }());
    exports.PointerHandler = PointerHandler;
});






define(__m[135/*vs/editor/browser/view/viewLayer*/], __M([1/*require*/,0/*exports*/,31/*vs/editor/browser/view/viewPart*/,29/*vs/base/browser/styleMutator*/]), function (require, exports, viewPart_1, styleMutator_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RenderedLinesCollection = (function () {
        function RenderedLinesCollection(createLine) {
            this._lines = [];
            this._rendLineNumberStart = 1;
            this._createLine = createLine;
        }
        RenderedLinesCollection.prototype._set = function (rendLineNumberStart, lines) {
            this._lines = lines;
            this._rendLineNumberStart = rendLineNumberStart;
        };
        RenderedLinesCollection.prototype._get = function () {
            return {
                rendLineNumberStart: this._rendLineNumberStart,
                lines: this._lines
            };
        };
        /**
         * @returns Inclusive line number that is inside this collection
         */
        RenderedLinesCollection.prototype.getStartLineNumber = function () {
            return this._rendLineNumberStart;
        };
        /**
         * @returns Inclusive line number that is inside this collection
         */
        RenderedLinesCollection.prototype.getEndLineNumber = function () {
            return this._rendLineNumberStart + this._lines.length - 1;
        };
        RenderedLinesCollection.prototype.getCount = function () {
            return this._lines.length;
        };
        RenderedLinesCollection.prototype.getLine = function (lineNumber) {
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (lineIndex < 0 || lineIndex >= this._lines.length) {
                throw new Error('Illegal value for lineNumber: ' + lineNumber);
            }
            return this._lines[lineIndex];
        };
        /**
         * @returns Lines that were removed from this collection
         */
        RenderedLinesCollection.prototype.onModelLinesDeleted = function (deleteFromLineNumber, deleteToLineNumber) {
            if (this.getCount() === 0) {
                // no lines
                return null;
            }
            var startLineNumber = this.getStartLineNumber();
            var endLineNumber = this.getEndLineNumber();
            // Record what needs to be deleted, notify lines that survive after deletion
            var deleteStartIndex = 0;
            var deleteCount = 0;
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                if (deleteFromLineNumber <= lineNumber && lineNumber <= deleteToLineNumber) {
                    // this is a line to be deleted
                    if (deleteCount === 0) {
                        // this is the first line to be deleted
                        deleteStartIndex = lineIndex;
                        deleteCount = 1;
                    }
                    else {
                        deleteCount++;
                    }
                }
            }
            // Adjust this._rendLineNumberStart for lines deleted above
            if (deleteFromLineNumber < startLineNumber) {
                // Something was deleted above
                var deleteAboveCount = 0;
                if (deleteToLineNumber < startLineNumber) {
                    // the entire deleted lines are above
                    deleteAboveCount = deleteToLineNumber - deleteFromLineNumber + 1;
                }
                else {
                    deleteAboveCount = startLineNumber - deleteFromLineNumber;
                }
                this._rendLineNumberStart -= deleteAboveCount;
            }
            var deleted = this._lines.splice(deleteStartIndex, deleteCount);
            return deleted;
        };
        RenderedLinesCollection.prototype.onModelLineChanged = function (changedLineNumber) {
            if (this.getCount() === 0) {
                // no lines
                return false;
            }
            var startLineNumber = this.getStartLineNumber();
            var endLineNumber = this.getEndLineNumber();
            // Notify lines after the change
            var notifiedSomeone = false;
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                if (lineNumber === changedLineNumber) {
                    this._lines[lineIndex].onContentChanged();
                    notifiedSomeone = true;
                }
            }
            return notifiedSomeone;
        };
        RenderedLinesCollection.prototype.onModelLinesInserted = function (insertFromLineNumber, insertToLineNumber) {
            if (this.getCount() === 0) {
                // no lines
                return null;
            }
            var insertCnt = insertToLineNumber - insertFromLineNumber + 1;
            var startLineNumber = this.getStartLineNumber();
            var endLineNumber = this.getEndLineNumber();
            if (insertFromLineNumber <= startLineNumber) {
                // inserting above the viewport
                this._rendLineNumberStart += insertCnt;
                return null;
            }
            if (insertFromLineNumber > endLineNumber) {
                // inserting below the viewport
                return null;
            }
            if (insertCnt + insertFromLineNumber > endLineNumber) {
                // insert inside the viewport in such a way that all remaining lines are pushed outside
                var deleted = this._lines.splice(insertFromLineNumber - this._rendLineNumberStart, endLineNumber - insertFromLineNumber + 1);
                return deleted;
            }
            // insert inside the viewport, push out some lines, but not all remaining lines
            var newLines = [];
            for (var i = 0; i < insertCnt; i++) {
                newLines[i] = this._createLine();
            }
            var insertIndex = insertFromLineNumber - this._rendLineNumberStart;
            var beforeLines = this._lines.slice(0, insertIndex);
            var afterLines = this._lines.slice(insertIndex, this._lines.length - insertCnt);
            var deletedLines = this._lines.slice(this._lines.length - insertCnt, this._lines.length);
            this._lines = beforeLines.concat(newLines).concat(afterLines);
            return deletedLines;
        };
        RenderedLinesCollection.prototype.onModelTokensChanged = function (ranges) {
            if (this.getCount() === 0) {
                // no lines
                return false;
            }
            var startLineNumber = this.getStartLineNumber();
            var endLineNumber = this.getEndLineNumber();
            var notifiedSomeone = false;
            for (var i = 0, len = ranges.length; i < len; i++) {
                var rng = ranges[i];
                if (rng.toLineNumber < startLineNumber || rng.fromLineNumber > endLineNumber) {
                    // range outside viewport
                    continue;
                }
                var from = Math.max(startLineNumber, rng.fromLineNumber);
                var to = Math.min(endLineNumber, rng.toLineNumber);
                for (var lineNumber = from; lineNumber <= to; lineNumber++) {
                    var lineIndex = lineNumber - this._rendLineNumberStart;
                    this._lines[lineIndex].onTokensChanged();
                    notifiedSomeone = true;
                }
            }
            return notifiedSomeone;
        };
        return RenderedLinesCollection;
    }());
    exports.RenderedLinesCollection = RenderedLinesCollection;
    var ViewLayer = (function (_super) {
        __extends(ViewLayer, _super);
        function ViewLayer(context) {
            var _this = _super.call(this, context) || this;
            _this.domNode = _this._createDomNode();
            _this._linesCollection = new RenderedLinesCollection(function () { return _this._createLine(); });
            _this._scrollDomNode = null;
            _this._scrollDomNodeIsAbove = false;
            _this._renderer = new ViewLayerRenderer(function () { return _this._createLine(); });
            return _this;
        }
        ViewLayer.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._linesCollection = null;
        };
        // ---- begin view event handlers
        ViewLayer.prototype.onConfigurationChanged = function (e) {
            var startLineNumber = this._linesCollection.getStartLineNumber();
            var endLineNumber = this._linesCollection.getEndLineNumber();
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                var line = this._linesCollection.getLine(lineNumber);
                line.onConfigurationChanged(e);
            }
            return true;
        };
        ViewLayer.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewLayer.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        ViewLayer.prototype.onZonesChanged = function () {
            return true;
        };
        ViewLayer.prototype.onModelFlushed = function () {
            var _this = this;
            this._linesCollection = new RenderedLinesCollection(function () { return _this._createLine(); });
            this._scrollDomNode = null;
            // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render
            return true;
        };
        ViewLayer.prototype.onModelLinesDeleted = function (e) {
            var deleted = this._linesCollection.onModelLinesDeleted(e.fromLineNumber, e.toLineNumber);
            if (deleted) {
                // Remove from DOM
                for (var i = 0, len = deleted.length; i < len; i++) {
                    var lineDomNode = deleted[i].getDomNode();
                    if (lineDomNode) {
                        this.domNode.domNode.removeChild(lineDomNode);
                    }
                }
            }
            return true;
        };
        ViewLayer.prototype.onModelLineChanged = function (e) {
            return this._linesCollection.onModelLineChanged(e.lineNumber);
        };
        ViewLayer.prototype.onModelLinesInserted = function (e) {
            var deleted = this._linesCollection.onModelLinesInserted(e.fromLineNumber, e.toLineNumber);
            if (deleted) {
                // Remove from DOM
                for (var i = 0, len = deleted.length; i < len; i++) {
                    var lineDomNode = deleted[i].getDomNode();
                    if (lineDomNode) {
                        this.domNode.domNode.removeChild(lineDomNode);
                    }
                }
            }
            return true;
        };
        ViewLayer.prototype.onModelTokensChanged = function (e) {
            return this._linesCollection.onModelTokensChanged(e.ranges);
        };
        // ---- end view event handlers
        ViewLayer.prototype._renderLines = function (linesViewportData) {
            var inp = this._linesCollection._get();
            var ctx = {
                domNode: this.domNode.domNode,
                rendLineNumberStart: inp.rendLineNumberStart,
                lines: inp.lines,
                linesLength: inp.lines.length,
                getInlineDecorationsForLineInViewport: function (lineNumber) { return linesViewportData.getInlineDecorationsForLineInViewport(lineNumber); },
                viewportTop: linesViewportData.viewportTop,
                viewportHeight: linesViewportData.viewportHeight,
                scrollDomNode: this._scrollDomNode,
                scrollDomNodeIsAbove: this._scrollDomNodeIsAbove
            };
            // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)
            var resCtx = this._renderer.renderWithManyUpdates(ctx, linesViewportData.startLineNumber, linesViewportData.endLineNumber, linesViewportData.relativeVerticalOffset);
            this._linesCollection._set(resCtx.rendLineNumberStart, resCtx.lines);
            this._scrollDomNode = resCtx.scrollDomNode;
            this._scrollDomNodeIsAbove = resCtx.scrollDomNodeIsAbove;
        };
        ViewLayer.prototype._createDomNode = function () {
            var domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            domNode.setClassName('view-layer');
            domNode.setPosition('absolute');
            domNode.domNode.setAttribute('role', 'presentation');
            domNode.domNode.setAttribute('aria-hidden', 'true');
            return domNode;
        };
        return ViewLayer;
    }(viewPart_1.ViewPart));
    exports.ViewLayer = ViewLayer;
    var ViewLayerRenderer = (function () {
        function ViewLayerRenderer(createLine) {
            this._createLine = createLine;
        }
        ViewLayerRenderer.prototype.renderWithManyUpdates = function (ctx, startLineNumber, stopLineNumber, deltaTop) {
            return this._render(ctx, startLineNumber, stopLineNumber, deltaTop);
        };
        ViewLayerRenderer.prototype._render = function (inContext, startLineNumber, stopLineNumber, deltaTop) {
            var ctx = {
                domNode: inContext.domNode,
                rendLineNumberStart: inContext.rendLineNumberStart,
                lines: inContext.lines.slice(0),
                linesLength: inContext.linesLength,
                getInlineDecorationsForLineInViewport: inContext.getInlineDecorationsForLineInViewport,
                viewportTop: inContext.viewportTop,
                viewportHeight: inContext.viewportHeight,
                scrollDomNode: inContext.scrollDomNode,
                scrollDomNodeIsAbove: inContext.scrollDomNodeIsAbove
            };
            var canRemoveScrollDomNode = true;
            if (ctx.scrollDomNode) {
                var time = this._getScrollDomNodeTime(ctx.scrollDomNode);
                if ((new Date()).getTime() - time < 1000) {
                    canRemoveScrollDomNode = false;
                }
            }
            if (canRemoveScrollDomNode && ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart))) {
                // There is no overlap whatsoever
                ctx.rendLineNumberStart = startLineNumber;
                ctx.linesLength = stopLineNumber - startLineNumber + 1;
                ctx.lines = [];
                for (var x = startLineNumber; x <= stopLineNumber; x++) {
                    ctx.lines[x - startLineNumber] = this._createLine();
                }
                this._finishRendering(ctx, true, deltaTop);
                ctx.scrollDomNode = null;
                return ctx;
            }
            // Update lines which will remain untouched
            this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);
            if (ctx.rendLineNumberStart > startLineNumber) {
                // Insert lines before
                var fromLineNumber = startLineNumber;
                var toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);
                if (fromLineNumber <= toLineNumber) {
                    this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                    ctx.linesLength += toLineNumber - fromLineNumber + 1;
                    // Clean garbage above
                    if (ctx.scrollDomNode && ctx.scrollDomNodeIsAbove) {
                        if (ctx.scrollDomNode.parentNode) {
                            ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                        }
                        ctx.scrollDomNode = null;
                    }
                }
            }
            else if (ctx.rendLineNumberStart < startLineNumber) {
                // Remove lines before
                var removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);
                if (removeCnt > 0) {
                    this._removeLinesBefore(ctx, removeCnt);
                    ctx.linesLength -= removeCnt;
                }
            }
            ctx.rendLineNumberStart = startLineNumber;
            if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {
                // Insert lines after
                var fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;
                var toLineNumber = stopLineNumber;
                if (fromLineNumber <= toLineNumber) {
                    this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                    ctx.linesLength += toLineNumber - fromLineNumber + 1;
                    // Clean garbage below
                    if (ctx.scrollDomNode && !ctx.scrollDomNodeIsAbove) {
                        if (ctx.scrollDomNode.parentNode) {
                            ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                        }
                        ctx.scrollDomNode = null;
                    }
                }
            }
            else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {
                // Remove lines after
                var fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);
                var toLineNumber = ctx.linesLength - 1;
                var removeCnt = toLineNumber - fromLineNumber + 1;
                if (removeCnt > 0) {
                    this._removeLinesAfter(ctx, removeCnt);
                    ctx.linesLength -= removeCnt;
                }
            }
            this._finishRendering(ctx, false, deltaTop);
            return ctx;
        };
        ViewLayerRenderer.prototype._renderUntouchedLines = function (ctx, startIndex, endIndex, deltaTop, deltaLN) {
            for (var i = startIndex; i <= endIndex; i++) {
                var lineNumber = ctx.rendLineNumberStart + i;
                var lineDomNode = ctx.lines[i].getDomNode();
                if (lineDomNode) {
                    ctx.lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
                }
            }
        };
        ViewLayerRenderer.prototype._insertLinesBefore = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
            var newLines = [];
            var newLinesLen = 0;
            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                newLines[newLinesLen++] = this._createLine();
            }
            ctx.lines = newLines.concat(ctx.lines);
        };
        ViewLayerRenderer.prototype._getScrollDomNodeTime = function (domNode) {
            var lastScrollTime = domNode.getAttribute('last-scroll-time');
            if (lastScrollTime) {
                return parseInt(lastScrollTime, 10);
            }
            return 0;
        };
        ViewLayerRenderer.prototype._removeIfNotScrollDomNode = function (ctx, domNode, isAbove) {
            var time = this._getScrollDomNodeTime(domNode);
            if (!time) {
                ctx.domNode.removeChild(domNode);
                return;
            }
            if (ctx.scrollDomNode) {
                var otherTime = this._getScrollDomNodeTime(ctx.scrollDomNode);
                if (otherTime > time) {
                    // The other is the real scroll dom node
                    ctx.domNode.removeChild(domNode);
                    return;
                }
                if (ctx.scrollDomNode.parentNode) {
                    ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                }
                ctx.scrollDomNode = null;
            }
            ctx.scrollDomNode = domNode;
            ctx.scrollDomNodeIsAbove = isAbove;
        };
        ViewLayerRenderer.prototype._removeLinesBefore = function (ctx, removeCount) {
            for (var i = 0; i < removeCount; i++) {
                var lineDomNode = ctx.lines[i].getDomNode();
                if (lineDomNode) {
                    this._removeIfNotScrollDomNode(ctx, lineDomNode, true);
                }
            }
            ctx.lines.splice(0, removeCount);
        };
        ViewLayerRenderer.prototype._insertLinesAfter = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
            var newLines = [];
            var newLinesLen = 0;
            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                newLines[newLinesLen++] = this._createLine();
            }
            ctx.lines = ctx.lines.concat(newLines);
        };
        ViewLayerRenderer.prototype._removeLinesAfter = function (ctx, removeCount) {
            var removeIndex = ctx.linesLength - removeCount;
            for (var i = 0; i < removeCount; i++) {
                var lineDomNode = ctx.lines[removeIndex + i].getDomNode();
                if (lineDomNode) {
                    this._removeIfNotScrollDomNode(ctx, lineDomNode, false);
                }
            }
            ctx.lines.splice(removeIndex, removeCount);
        };
        ViewLayerRenderer._resolveInlineDecorations = function (ctx) {
            var result = [];
            for (var i = 0, len = ctx.linesLength; i < len; i++) {
                var lineNumber = i + ctx.rendLineNumberStart;
                result[i] = ctx.getInlineDecorationsForLineInViewport(lineNumber);
            }
            return result;
        };
        ViewLayerRenderer.prototype._finishRenderingNewLines = function (ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
            var lastChild = ctx.domNode.lastChild;
            if (domNodeIsEmpty || !lastChild) {
                ctx.domNode.innerHTML = newLinesHTML.join('');
            }
            else {
                lastChild.insertAdjacentHTML('afterend', newLinesHTML.join(''));
            }
            var currChild = ctx.domNode.lastChild;
            for (var i = ctx.linesLength - 1; i >= 0; i--) {
                var line = ctx.lines[i];
                if (wasNew[i]) {
                    line.setDomNode(currChild);
                    currChild = currChild.previousSibling;
                }
            }
        };
        ViewLayerRenderer.prototype._finishRenderingInvalidLines = function (ctx, invalidLinesHTML, wasInvalid) {
            var hugeDomNode = document.createElement('div');
            hugeDomNode.innerHTML = invalidLinesHTML.join('');
            for (var i = 0; i < ctx.linesLength; i++) {
                var line = ctx.lines[i];
                if (wasInvalid[i]) {
                    var source = hugeDomNode.firstChild;
                    var lineDomNode = line.getDomNode();
                    lineDomNode.parentNode.replaceChild(source, lineDomNode);
                    line.setDomNode(source);
                }
            }
        };
        ViewLayerRenderer.prototype._finishRendering = function (ctx, domNodeIsEmpty, deltaTop) {
            var inlineDecorations = ViewLayerRenderer._resolveInlineDecorations(ctx);
            var hadNewLine = false;
            var wasNew = [];
            var newLinesHTML = [];
            var hadInvalidLine = false;
            var wasInvalid = [];
            var invalidLinesHTML = [];
            for (var i = 0, len = ctx.linesLength; i < len; i++) {
                var line = ctx.lines[i];
                var lineNumber = i + ctx.rendLineNumberStart;
                if (line.shouldUpdateHTML(ctx.rendLineNumberStart, lineNumber, inlineDecorations[i])) {
                    var lineDomNode = line.getDomNode();
                    if (!lineDomNode) {
                        // Line is new
                        line.getLineOuterHTML(newLinesHTML, lineNumber, deltaTop[i]);
                        wasNew[i] = true;
                        hadNewLine = true;
                    }
                    else {
                        // Line is invalid
                        line.getLineOuterHTML(invalidLinesHTML, lineNumber, deltaTop[i]);
                        wasInvalid[i] = true;
                        hadInvalidLine = true;
                    }
                }
            }
            if (hadNewLine) {
                this._finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew);
            }
            if (hadInvalidLine) {
                this._finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid);
            }
        };
        return ViewLayerRenderer;
    }());
});






define(__m[374/*vs/editor/browser/view/viewOutgoingEvents*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,2/*vs/editor/common/editorCommon*/,134/*vs/editor/browser/controller/mouseTarget*/]), function (require, exports, eventEmitter_1, lifecycle_1, editorCommon_1, mouseTarget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewOutgoingEvents = (function (_super) {
        __extends(ViewOutgoingEvents, _super);
        function ViewOutgoingEvents(viewModel) {
            var _this = _super.call(this) || this;
            _this._viewModel = viewModel;
            _this._actual = _this._register(new eventEmitter_1.EventEmitter());
            return _this;
        }
        ViewOutgoingEvents.prototype.getInternalEventBus = function () {
            return this._actual;
        };
        ViewOutgoingEvents.prototype.deferredEmit = function (callback) {
            return this._actual.deferredEmit(callback);
        };
        ViewOutgoingEvents.prototype.emitViewLayoutChanged = function (layoutInfo) {
            this._actual.emit(editorCommon_1.EventType.ViewLayoutChanged, layoutInfo);
        };
        ViewOutgoingEvents.prototype.emitScrollChanged = function (e) {
            this._actual.emit('scroll', e);
        };
        ViewOutgoingEvents.prototype.emitViewFocusGained = function () {
            this._actual.emit(editorCommon_1.EventType.ViewFocusGained, {});
        };
        ViewOutgoingEvents.prototype.emitViewFocusLost = function () {
            this._actual.emit(editorCommon_1.EventType.ViewFocusLost, {});
        };
        ViewOutgoingEvents.prototype.emitKeyDown = function (e) {
            this._actual.emit(editorCommon_1.EventType.KeyDown, e);
        };
        ViewOutgoingEvents.prototype.emitKeyUp = function (e) {
            this._actual.emit(editorCommon_1.EventType.KeyUp, e);
        };
        ViewOutgoingEvents.prototype.emitContextMenu = function (e) {
            this._actual.emit(editorCommon_1.EventType.ContextMenu, this._convertViewToModelMouseEvent(e));
        };
        ViewOutgoingEvents.prototype.emitMouseMove = function (e) {
            this._actual.emit(editorCommon_1.EventType.MouseMove, this._convertViewToModelMouseEvent(e));
        };
        ViewOutgoingEvents.prototype.emitMouseLeave = function (e) {
            this._actual.emit(editorCommon_1.EventType.MouseLeave, this._convertViewToModelMouseEvent(e));
        };
        ViewOutgoingEvents.prototype.emitMouseUp = function (e) {
            this._actual.emit(editorCommon_1.EventType.MouseUp, this._convertViewToModelMouseEvent(e));
        };
        ViewOutgoingEvents.prototype.emitMouseDown = function (e) {
            this._actual.emit(editorCommon_1.EventType.MouseDown, this._convertViewToModelMouseEvent(e));
        };
        ViewOutgoingEvents.prototype._convertViewToModelMouseEvent = function (e) {
            if (e.target) {
                return {
                    event: e.event,
                    target: this._convertViewToModelMouseTarget(e.target)
                };
            }
            return e;
        };
        ViewOutgoingEvents.prototype._convertViewToModelMouseTarget = function (target) {
            return new ExternalMouseTarget(target.element, target.type, target.mouseColumn, target.position ? this._convertViewToModelPosition(target.position) : null, target.range ? this._convertViewToModelRange(target.range) : null, target.detail);
        };
        ViewOutgoingEvents.prototype._convertViewToModelPosition = function (viewPosition) {
            return this._viewModel.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
        };
        ViewOutgoingEvents.prototype._convertViewToModelRange = function (viewRange) {
            return this._viewModel.convertViewRangeToModelRange(viewRange);
        };
        return ViewOutgoingEvents;
    }(lifecycle_1.Disposable));
    exports.ViewOutgoingEvents = ViewOutgoingEvents;
    var ExternalMouseTarget = (function () {
        function ExternalMouseTarget(element, type, mouseColumn, position, range, detail) {
            this.element = element;
            this.type = type;
            this.mouseColumn = mouseColumn;
            this.position = position;
            this.range = range;
            this.detail = detail;
        }
        ExternalMouseTarget.prototype.toString = function () {
            return mouseTarget_1.MouseTarget.toString(this);
        };
        return ExternalMouseTarget;
    }());
});

define(__m[375/*vs/editor/browser/viewLayout/scrollManager*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,2/*vs/editor/common/editorCommon*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/]), function (require, exports, lifecycle_1, dom, scrollableElement_1, editorCommon_1, editorBrowser_1, viewPart_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function addPropertyIfPresent(src, dst, prop) {
        if (src.hasOwnProperty(prop)) {
            dst[prop] = src[prop];
        }
    }
    var ScrollManager = (function () {
        function ScrollManager(configuration, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode) {
            var _this = this;
            this.toDispose = [];
            this.configuration = configuration;
            this.privateViewEventBus = privateViewEventBus;
            this.linesContent = linesContent;
            var configScrollbarOpts = this.configuration.editor.viewInfo.scrollbar;
            var scrollbarOptions = {
                canUseTranslate3d: this.configuration.editor.viewInfo.canUseTranslate3d,
                listenOnDomNode: viewDomNode,
                vertical: configScrollbarOpts.vertical,
                horizontal: configScrollbarOpts.horizontal,
                className: editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + this.configuration.editor.viewInfo.theme,
                useShadows: false,
                lazyRender: true,
                saveLastScrollTimeOnClassName: editorBrowser_1.ClassNames.VIEW_LINE
            };
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalHasArrows');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalHasArrows');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalScrollbarSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalSliderSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalScrollbarSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalSliderSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'handleMouseWheel');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'arrowSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'mouseWheelScrollSensitivity');
            this.scrollbar = new scrollableElement_1.ScrollableElement(linesContent, scrollbarOptions);
            viewPart_1.PartFingerprints.write(this.scrollbar.getDomNode(), 5 /* ScrollableElement */);
            this.onLayoutInfoChanged();
            this.toDispose.push(this.scrollbar);
            this.toDispose.push(this.scrollbar.onScroll(function (e) {
                _this.privateViewEventBus.emit(editorCommon_1.EventType.ViewScrollChanged, e);
            }));
            this.toDispose.push(this.configuration.onDidChange(function (e) {
                _this.scrollbar.updateClassName(editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + _this.configuration.editor.viewInfo.theme);
                if (e.viewInfo.scrollbar || e.viewInfo.canUseTranslate3d) {
                    var newOpts = {
                        canUseTranslate3d: _this.configuration.editor.viewInfo.canUseTranslate3d,
                        handleMouseWheel: _this.configuration.editor.viewInfo.scrollbar.handleMouseWheel,
                        mouseWheelScrollSensitivity: _this.configuration.editor.viewInfo.scrollbar.mouseWheelScrollSensitivity
                    };
                    _this.scrollbar.updateOptions(newOpts);
                }
            }));
            // When having a zone widget that calls .focus() on one of its dom elements,
            // the browser will try desperately to reveal that dom node, unexpectedly
            // changing the .scrollTop of this.linesContent
            var onBrowserDesperateReveal = function (domNode, lookAtScrollTop, lookAtScrollLeft) {
                var newScrollPosition = {};
                if (lookAtScrollTop) {
                    var deltaTop = domNode.scrollTop;
                    if (deltaTop) {
                        newScrollPosition.scrollTop = _this.getScrollTop() + deltaTop;
                        domNode.scrollTop = 0;
                    }
                }
                if (lookAtScrollLeft) {
                    var deltaLeft = domNode.scrollLeft;
                    if (deltaLeft) {
                        newScrollPosition.scrollLeft = _this.getScrollLeft() + deltaLeft;
                        domNode.scrollLeft = 0;
                    }
                }
                _this.setScrollPosition(newScrollPosition);
            };
            // I've seen this happen both on the view dom node & on the lines content dom node.
            this.toDispose.push(dom.addDisposableListener(viewDomNode, 'scroll', function (e) { return onBrowserDesperateReveal(viewDomNode, true, true); }));
            this.toDispose.push(dom.addDisposableListener(linesContent, 'scroll', function (e) { return onBrowserDesperateReveal(linesContent, true, false); }));
            this.toDispose.push(dom.addDisposableListener(overflowGuardDomNode, 'scroll', function (e) { return onBrowserDesperateReveal(overflowGuardDomNode, true, false); }));
        }
        ScrollManager.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        ScrollManager.prototype.renderScrollbar = function () {
            this.scrollbar.renderNow();
        };
        ScrollManager.prototype.onLayoutInfoChanged = function () {
            this.scrollbar.updateState({
                width: this.configuration.editor.layoutInfo.contentWidth,
                height: this.configuration.editor.layoutInfo.contentHeight
            });
        };
        ScrollManager.prototype.getOverviewRulerLayoutInfo = function () {
            return this.scrollbar.getOverviewRulerLayoutInfo();
        };
        ScrollManager.prototype.getScrollbarContainerDomNode = function () {
            return this.scrollbar.getDomNode();
        };
        ScrollManager.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
        };
        ScrollManager.prototype.getWidth = function () {
            return this.scrollbar.getWidth();
        };
        ScrollManager.prototype.getScrollWidth = function () {
            return this.scrollbar.getScrollWidth();
        };
        ScrollManager.prototype.getScrollLeft = function () {
            return this.scrollbar.getScrollLeft();
        };
        ScrollManager.prototype.getHeight = function () {
            return this.scrollbar.getHeight();
        };
        ScrollManager.prototype.getScrollHeight = function () {
            return this.scrollbar.getScrollHeight();
        };
        ScrollManager.prototype.getScrollTop = function () {
            return this.scrollbar.getScrollTop();
        };
        ScrollManager.prototype.setScrollPosition = function (position) {
            this.scrollbar.updateState(position);
        };
        ScrollManager.prototype.setScrollHeight = function (scrollHeight) {
            this.scrollbar.updateState({
                scrollHeight: scrollHeight
            });
        };
        ScrollManager.prototype.setScrollWidth = function (scrollWidth) {
            this.scrollbar.updateState({
                scrollWidth: scrollWidth
            });
        };
        return ScrollManager;
    }());
    exports.ScrollManager = ScrollManager;
});






define(__m[376/*vs/editor/browser/viewLayout/layoutProvider*/], __M([1/*require*/,0/*exports*/,38/*vs/base/common/scrollable*/,2/*vs/editor/common/editorCommon*/,210/*vs/editor/common/viewLayout/linesLayout*/,47/*vs/editor/common/viewModel/viewEventHandler*/,375/*vs/editor/browser/viewLayout/scrollManager*/]), function (require, exports, scrollable_1, editorCommon, linesLayout_1, viewEventHandler_1, scrollManager_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LayoutProvider = (function (_super) {
        __extends(LayoutProvider, _super);
        function LayoutProvider(configuration, model, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode) {
            var _this = _super.call(this) || this;
            _this.configuration = configuration;
            _this.privateViewEventBus = privateViewEventBus;
            _this.model = model;
            _this.scrollManager = new scrollManager_1.ScrollManager(configuration, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode);
            _this.configuration.setMaxLineNumber(_this.model.getMaxLineNumber());
            _this.linesLayout = new linesLayout_1.LinesLayout(configuration, model);
            _this._updateHeight();
            return _this;
        }
        LayoutProvider.prototype.dispose = function () {
            this.scrollManager.dispose();
        };
        LayoutProvider.prototype.updateLineCount = function () {
            this.configuration.setMaxLineNumber(this.model.getMaxLineNumber());
        };
        // ---- begin view event handlers
        LayoutProvider.prototype.onZonesChanged = function () {
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelFlushed = function () {
            this.linesLayout.onModelFlushed();
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelLinesDeleted = function (e) {
            this.linesLayout.onModelLinesDeleted(e);
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelLinesInserted = function (e) {
            this.linesLayout.onModelLinesInserted(e);
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onConfigurationChanged = function (e) {
            this.linesLayout.onConfigurationChanged(e);
            if (e.layoutInfo) {
                this.scrollManager.onLayoutInfoChanged();
                this._emitLayoutChangedEvent();
            }
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype._updateHeight = function () {
            this.scrollManager.setScrollHeight(this.getTotalHeight());
        };
        // ---- end view event handlers
        // ---- Layouting logic
        LayoutProvider.prototype.getCurrentViewport = function () {
            return new editorCommon.Viewport(this.scrollManager.getScrollTop(), this.scrollManager.getScrollLeft(), this.scrollManager.getWidth(), this.scrollManager.getHeight());
        };
        LayoutProvider.prototype.getCenteredViewLineNumberInViewport = function () {
            return this.linesLayout.getCenteredLineInViewport(this.getCurrentViewport());
        };
        LayoutProvider.prototype._emitLayoutChangedEvent = function () {
            this.privateViewEventBus.emit(editorCommon.EventType.ViewLayoutChanged, this.configuration.editor.layoutInfo);
        };
        LayoutProvider.prototype.emitLayoutChangedEvent = function () {
            this._emitLayoutChangedEvent();
        };
        LayoutProvider.prototype._computeScrollWidth = function (maxLineWidth, viewportWidth) {
            var isViewportWrapping = this.configuration.editor.wrappingInfo.isViewportWrapping;
            if (!isViewportWrapping) {
                return Math.max(maxLineWidth + LayoutProvider.LINES_HORIZONTAL_EXTRA_PX, viewportWidth);
            }
            return Math.max(maxLineWidth, viewportWidth);
        };
        LayoutProvider.prototype.onMaxLineWidthChanged = function (maxLineWidth) {
            var newScrollWidth = this._computeScrollWidth(maxLineWidth, this.getCurrentViewport().width);
            this.scrollManager.setScrollWidth(newScrollWidth);
            // The height might depend on the fact that there is a horizontal scrollbar or not
            this._updateHeight();
        };
        // ---- view state
        LayoutProvider.prototype.saveState = function () {
            var scrollTop = this.scrollManager.getScrollTop();
            var firstLineNumberInViewport = this.linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);
            var whitespaceAboveFirstLine = this.linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);
            return {
                scrollTop: scrollTop,
                scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,
                scrollLeft: this.scrollManager.getScrollLeft()
            };
        };
        LayoutProvider.prototype.restoreState = function (state) {
            var restoreScrollTop = state.scrollTop;
            if (typeof state.scrollTopWithoutViewZones === 'number' && !this.linesLayout.hasWhitespace()) {
                restoreScrollTop = state.scrollTopWithoutViewZones;
            }
            this.scrollManager.setScrollPosition({
                scrollLeft: state.scrollLeft,
                scrollTop: restoreScrollTop
            });
        };
        // ---- IVerticalLayoutProvider
        LayoutProvider.prototype.addWhitespace = function (afterLineNumber, ordinal, height) {
            return this.linesLayout.insertWhitespace(afterLineNumber, ordinal, height);
        };
        LayoutProvider.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.linesLayout.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        LayoutProvider.prototype.removeWhitespace = function (id) {
            return this.linesLayout.removeWhitespace(id);
        };
        LayoutProvider.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
            return this.linesLayout.getVerticalOffsetForLineNumber(lineNumber);
        };
        LayoutProvider.prototype.heightInPxForLine = function (lineNumber) {
            return this.linesLayout.getHeightForLineNumber(lineNumber);
        };
        LayoutProvider.prototype.isAfterLines = function (verticalOffset) {
            return this.linesLayout.isAfterLines(verticalOffset);
        };
        LayoutProvider.prototype.getLineNumberAtVerticalOffset = function (verticalOffset) {
            return this.linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);
        };
        LayoutProvider.prototype.getTotalHeight = function () {
            var reserveHorizontalScrollbarHeight = 0;
            if (this.scrollManager.getScrollWidth() > this.scrollManager.getWidth()) {
                if (this.configuration.editor.viewInfo.scrollbar.horizontal !== scrollable_1.ScrollbarVisibility.Hidden) {
                    reserveHorizontalScrollbarHeight = this.configuration.editor.viewInfo.scrollbar.horizontalScrollbarSize;
                }
            }
            return this.linesLayout.getTotalHeight(this.getCurrentViewport(), reserveHorizontalScrollbarHeight);
        };
        LayoutProvider.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
            return this.linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);
        };
        LayoutProvider.prototype.getLinesViewportData = function () {
            return this.linesLayout.getLinesViewportData(this.getCurrentViewport());
        };
        LayoutProvider.prototype.getWhitespaceViewportData = function () {
            return this.linesLayout.getWhitespaceViewportData(this.getCurrentViewport());
        };
        LayoutProvider.prototype.getWhitespaces = function () {
            return this.linesLayout.getWhitespaces();
        };
        // ---- IScrollingProvider
        LayoutProvider.prototype.getOverviewRulerInsertData = function () {
            var layoutInfo = this.scrollManager.getOverviewRulerLayoutInfo();
            return {
                parent: layoutInfo.parent,
                insertBefore: layoutInfo.insertBefore
            };
        };
        LayoutProvider.prototype.getScrollbarContainerDomNode = function () {
            return this.scrollManager.getScrollbarContainerDomNode();
        };
        LayoutProvider.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this.scrollManager.delegateVerticalScrollbarMouseDown(browserEvent);
        };
        LayoutProvider.prototype.getScrollWidth = function () {
            return this.scrollManager.getScrollWidth();
        };
        LayoutProvider.prototype.getScrollLeft = function () {
            return this.scrollManager.getScrollLeft();
        };
        LayoutProvider.prototype.getScrollHeight = function () {
            return this.scrollManager.getScrollHeight();
        };
        LayoutProvider.prototype.getScrollTop = function () {
            return this.scrollManager.getScrollTop();
        };
        LayoutProvider.prototype.setScrollPosition = function (position) {
            this.scrollManager.setScrollPosition(position);
        };
        LayoutProvider.prototype.getScrolledTopFromAbsoluteTop = function (top) {
            return top - this.scrollManager.getScrollTop();
        };
        LayoutProvider.prototype.renderScrollbar = function () {
            this.scrollManager.renderScrollbar();
        };
        return LayoutProvider;
    }(viewEventHandler_1.ViewEventHandler));
    LayoutProvider.LINES_HORIZONTAL_EXTRA_PX = 30;
    exports.LayoutProvider = LayoutProvider;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[377/*vs/editor/browser/viewParts/contentWidgets/contentWidgets*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/]), function (require, exports, dom, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ViewContentWidgets = (function (_super) {
        __extends(ViewContentWidgets, _super);
        function ViewContentWidgets(context, viewDomNode) {
            var _this = _super.call(this, context) || this;
            _this._viewDomNode = viewDomNode;
            _this._widgets = {};
            _this._contentWidth = 0;
            _this._contentLeft = 0;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._renderData = {};
            _this.domNode = document.createElement('div');
            viewPart_1.PartFingerprints.write(_this.domNode, 1 /* ContentWidgets */);
            _this.domNode.className = editorBrowser_1.ClassNames.CONTENT_WIDGETS;
            _this.domNode.style.position = 'absolute';
            _this.domNode.style.top = '0';
            _this.overflowingContentWidgetsDomNode = document.createElement('div');
            viewPart_1.PartFingerprints.write(_this.overflowingContentWidgetsDomNode, 2 /* OverflowingContentWidgets */);
            _this.overflowingContentWidgetsDomNode.className = editorBrowser_1.ClassNames.OVERFLOWING_CONTENT_WIDGETS;
            return _this;
        }
        ViewContentWidgets.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._widgets = null;
            this.domNode = null;
        };
        // --- begin event handlers
        ViewContentWidgets.prototype.onModelFlushed = function () {
            return true;
        };
        ViewContentWidgets.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return true; //e.inlineDecorationsChanged;
        };
        ViewContentWidgets.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onModelLineChanged = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            return true;
        };
        ViewContentWidgets.prototype.onLayoutChanged = function (layoutInfo) {
            this._contentLeft = layoutInfo.contentLeft;
            if (this._contentWidth !== layoutInfo.contentWidth) {
                this._contentWidth = layoutInfo.contentWidth;
                // update the maxWidth on widgets nodes, such that `onReadAfterForcedLayout`
                // below can read out the adjusted width/height of widgets
                var keys = Object.keys(this._widgets);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var widgetId = keys[i];
                    var widgetData = this._widgets[widgetId];
                    var widget = widgetData.widget;
                    var maxWidth = widgetData.allowEditorOverflow
                        ? window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth
                        : this._contentWidth;
                    styleMutator_1.StyleMutator.setMaxWidth(widget.getDomNode(), maxWidth);
                }
            }
            return true;
        };
        ViewContentWidgets.prototype.onScrollChanged = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onZonesChanged = function () {
            return true;
        };
        // ---- end view event handlers
        ViewContentWidgets.prototype.addWidget = function (widget) {
            var widgetData = {
                allowEditorOverflow: widget.allowEditorOverflow || false,
                widget: widget,
                position: null,
                preference: null,
                isVisible: false
            };
            this._widgets[widget.getId()] = widgetData;
            var domNode = widget.getDomNode();
            domNode.style.position = (this._context.configuration.editor.viewInfo.fixedOverflowWidgets && widget.allowEditorOverflow) ? 'fixed' : 'absolute';
            styleMutator_1.StyleMutator.setMaxWidth(domNode, this._contentWidth);
            styleMutator_1.StyleMutator.setVisibility(domNode, 'hidden');
            domNode.setAttribute('widgetId', widget.getId());
            if (widgetData.allowEditorOverflow) {
                this.overflowingContentWidgetsDomNode.appendChild(domNode);
            }
            else {
                this.domNode.appendChild(domNode);
            }
            this.setShouldRender();
        };
        ViewContentWidgets.prototype.setWidgetPosition = function (widget, position, preference) {
            var widgetData = this._widgets[widget.getId()];
            widgetData.position = position;
            widgetData.preference = preference;
            this.setShouldRender();
        };
        ViewContentWidgets.prototype.removeWidget = function (widget) {
            var widgetId = widget.getId();
            if (this._widgets.hasOwnProperty(widgetId)) {
                var widgetData = this._widgets[widgetId];
                delete this._widgets[widgetId];
                var domNode = widgetData.widget.getDomNode();
                domNode.parentNode.removeChild(domNode);
                domNode.removeAttribute('monaco-visible-content-widget');
                this.setShouldRender();
            }
        };
        ViewContentWidgets.prototype.shouldSuppressMouseDownOnWidget = function (widgetId) {
            if (this._widgets.hasOwnProperty(widgetId)) {
                var widgetData = this._widgets[widgetId];
                return widgetData.widget.suppressMouseDown;
            }
            return false;
        };
        ViewContentWidgets.prototype._layoutBoxInViewport = function (position, domNode, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            var width = domNode.clientWidth;
            var height = domNode.clientHeight;
            // Our visible box is split horizontally by the current line => 2 boxes
            // a) the box above the line
            var aboveLineTop = visibleRange.top;
            var heightAboveLine = aboveLineTop;
            // b) the box under the line
            var underLineTop = visibleRange.top + this._lineHeight;
            var heightUnderLine = ctx.viewportHeight - underLineTop;
            var aboveTop = aboveLineTop - height;
            var fitsAbove = (heightAboveLine >= height);
            var belowTop = underLineTop;
            var fitsBelow = (heightUnderLine >= height);
            // And its left
            var actualLeft = visibleRange.left;
            if (actualLeft + width > ctx.viewportLeft + ctx.viewportWidth) {
                actualLeft = ctx.viewportLeft + ctx.viewportWidth - width;
            }
            if (actualLeft < ctx.viewportLeft) {
                actualLeft = ctx.viewportLeft;
            }
            return {
                aboveTop: aboveTop,
                fitsAbove: fitsAbove,
                belowTop: belowTop,
                fitsBelow: fitsBelow,
                left: actualLeft
            };
        };
        ViewContentWidgets.prototype._layoutBoxInPage = function (position, domNode, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            var left0 = visibleRange.left - ctx.viewportLeft;
            var width = domNode.clientWidth, height = domNode.clientHeight;
            if (left0 + width < 0 || left0 > this._contentWidth) {
                return null;
            }
            var aboveTop = visibleRange.top - height;
            var belowTop = visibleRange.top + this._lineHeight;
            var left = left0 + this._contentLeft;
            var domNodePosition = dom.getDomNodePagePosition(this._viewDomNode);
            var absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;
            var absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;
            var absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;
            var INNER_WIDTH = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            var INNER_HEIGHT = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            // Leave some clearance to the bottom
            var TOP_PADDING = 22;
            var BOTTOM_PADDING = 22;
            var fitsAbove = (absoluteAboveTop >= TOP_PADDING), fitsBelow = (absoluteBelowTop + height <= INNER_HEIGHT - BOTTOM_PADDING);
            if (absoluteLeft + width + 20 > INNER_WIDTH) {
                var delta = absoluteLeft - (INNER_WIDTH - width - 20);
                absoluteLeft -= delta;
                left -= delta;
            }
            if (absoluteLeft < 0) {
                var delta = absoluteLeft;
                absoluteLeft -= delta;
                left -= delta;
            }
            if (this._context.configuration.editor.viewInfo.fixedOverflowWidgets) {
                aboveTop = absoluteAboveTop;
                belowTop = absoluteBelowTop;
                left = absoluteLeft;
            }
            return { aboveTop: aboveTop, fitsAbove: fitsAbove, belowTop: belowTop, fitsBelow: fitsBelow, left: left };
        };
        ViewContentWidgets.prototype._prepareRenderWidgetAtExactPosition = function (position, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            return {
                top: visibleRange.top,
                left: visibleRange.left
            };
        };
        ViewContentWidgets.prototype._prepareRenderWidgetAtExactPositionOverflowing = function (position, ctx) {
            var r = this._prepareRenderWidgetAtExactPosition(position, ctx);
            r.left += this._contentLeft;
            return r;
        };
        ViewContentWidgets.prototype._prepareRenderWidget = function (widgetData, ctx) {
            var _this = this;
            if (!widgetData.position || !widgetData.preference) {
                return null;
            }
            // Do not trust that widgets have a valid position
            var validModelPosition = this._context.model.validateModelPosition(widgetData.position);
            if (!this._context.model.modelPositionIsVisible(validModelPosition)) {
                // this position is hidden by the view model
                return null;
            }
            var position = this._context.model.convertModelPositionToViewPosition(validModelPosition.lineNumber, validModelPosition.column);
            var placement = null;
            var fetchPlacement = function () {
                if (placement) {
                    return;
                }
                var domNode = widgetData.widget.getDomNode();
                if (widgetData.allowEditorOverflow) {
                    placement = _this._layoutBoxInPage(position, domNode, ctx);
                }
                else {
                    placement = _this._layoutBoxInViewport(position, domNode, ctx);
                }
            };
            // Do two passes, first for perfect fit, second picks first option
            for (var pass = 1; pass <= 2; pass++) {
                for (var i = 0; i < widgetData.preference.length; i++) {
                    var pref = widgetData.preference[i];
                    if (pref === editorBrowser_1.ContentWidgetPositionPreference.ABOVE) {
                        fetchPlacement();
                        if (!placement) {
                            // Widget outside of viewport
                            return null;
                        }
                        if (pass === 2 || placement.fitsAbove) {
                            return {
                                top: placement.aboveTop,
                                left: placement.left
                            };
                        }
                    }
                    else if (pref === editorBrowser_1.ContentWidgetPositionPreference.BELOW) {
                        fetchPlacement();
                        if (!placement) {
                            // Widget outside of viewport
                            return null;
                        }
                        if (pass === 2 || placement.fitsBelow) {
                            return {
                                top: placement.belowTop,
                                left: placement.left
                            };
                        }
                    }
                    else {
                        if (widgetData.allowEditorOverflow) {
                            return this._prepareRenderWidgetAtExactPositionOverflowing(position, ctx);
                        }
                        else {
                            return this._prepareRenderWidgetAtExactPosition(position, ctx);
                        }
                    }
                }
            }
        };
        ViewContentWidgets.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var data = {};
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                var renderData = this._prepareRenderWidget(this._widgets[widgetId], ctx);
                if (renderData) {
                    data[widgetId] = renderData;
                }
            }
            this._renderData = data;
        };
        ViewContentWidgets.prototype.render = function (ctx) {
            var data = this._renderData;
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                var widget = this._widgets[widgetId];
                var domNode = this._widgets[widgetId].widget.getDomNode();
                if (data.hasOwnProperty(widgetId)) {
                    if (widget.allowEditorOverflow) {
                        styleMutator_1.StyleMutator.setTop(domNode, data[widgetId].top);
                        styleMutator_1.StyleMutator.setLeft(domNode, data[widgetId].left);
                    }
                    else {
                        styleMutator_1.StyleMutator.setTop(domNode, data[widgetId].top + ctx.viewportTop - ctx.bigNumbersDelta);
                        styleMutator_1.StyleMutator.setLeft(domNode, data[widgetId].left);
                    }
                    if (!widget.isVisible) {
                        styleMutator_1.StyleMutator.setVisibility(domNode, 'inherit');
                        domNode.setAttribute('monaco-visible-content-widget', 'true');
                        widget.isVisible = true;
                    }
                }
                else {
                    if (widget.isVisible) {
                        domNode.removeAttribute('monaco-visible-content-widget');
                        widget.isVisible = false;
                        styleMutator_1.StyleMutator.setVisibility(domNode, 'hidden');
                    }
                }
            }
        };
        return ViewContentWidgets;
    }(viewPart_1.ViewPart));
    exports.ViewContentWidgets = ViewContentWidgets;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[378/*vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,324/*vs/css!vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight*/]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var CurrentLineHighlightOverlay = (function (_super) {
        __extends(CurrentLineHighlightOverlay, _super);
        function CurrentLineHighlightOverlay(context, layoutProvider) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._readOnly = _this._context.configuration.editor.readOnly;
            _this._renderLineHighlight = _this._context.configuration.editor.viewInfo.renderLineHighlight;
            _this._layoutProvider = layoutProvider;
            _this._selectionIsEmpty = true;
            _this._primaryCursorIsInEditableRange = true;
            _this._primaryCursorLineNumber = 1;
            _this._scrollWidth = _this._layoutProvider.getScrollWidth();
            _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
            _this._context.addEventHandler(_this);
            return _this;
        }
        CurrentLineHighlightOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
        };
        // --- begin event handlers
        CurrentLineHighlightOverlay.prototype.onModelFlushed = function () {
            this._primaryCursorIsInEditableRange = true;
            this._selectionIsEmpty = true;
            this._primaryCursorLineNumber = 1;
            this._scrollWidth = this._layoutProvider.getScrollWidth();
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onCursorPositionChanged = function (e) {
            var hasChanged = false;
            if (this._primaryCursorIsInEditableRange !== e.isInEditableRange) {
                this._primaryCursorIsInEditableRange = e.isInEditableRange;
                hasChanged = true;
            }
            if (this._primaryCursorLineNumber !== e.position.lineNumber) {
                this._primaryCursorLineNumber = e.position.lineNumber;
                hasChanged = true;
            }
            return hasChanged;
        };
        CurrentLineHighlightOverlay.prototype.onCursorSelectionChanged = function (e) {
            var isEmpty = e.selection.isEmpty();
            if (this._selectionIsEmpty !== isEmpty) {
                this._selectionIsEmpty = isEmpty;
                return true;
            }
            return false;
        };
        CurrentLineHighlightOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.readOnly) {
                this._readOnly = this._context.configuration.editor.readOnly;
            }
            if (e.viewInfo.renderLineHighlight) {
                this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight;
            }
            if (e.layoutInfo) {
                this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
            }
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onScrollChanged = function (e) {
            this._scrollWidth = e.scrollWidth;
            return e.scrollWidthChanged;
        };
        CurrentLineHighlightOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        CurrentLineHighlightOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            this._scrollWidth = ctx.scrollWidth;
        };
        CurrentLineHighlightOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (lineNumber === this._primaryCursorLineNumber) {
                if (this._shouldShowCurrentLine()) {
                    return ('<div class="current-line" style="width:'
                        + String(Math.max(this._scrollWidth, this._contentWidth))
                        + 'px; height:'
                        + String(this._lineHeight)
                        + 'px;"></div>');
                }
                else {
                    return '';
                }
            }
            return '';
        };
        CurrentLineHighlightOverlay.prototype._shouldShowCurrentLine = function () {
            return (this._renderLineHighlight === 'line' || this._renderLineHighlight === 'all') &&
                this._selectionIsEmpty &&
                this._primaryCursorIsInEditableRange;
        };
        return CurrentLineHighlightOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.CurrentLineHighlightOverlay = CurrentLineHighlightOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[379/*vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,325/*vs/css!vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight*/]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var CurrentLineMarginHighlightOverlay = (function (_super) {
        __extends(CurrentLineMarginHighlightOverlay, _super);
        function CurrentLineMarginHighlightOverlay(context, layoutProvider) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._renderLineHighlight = _this._context.configuration.editor.viewInfo.renderLineHighlight;
            _this._layoutProvider = layoutProvider;
            _this._primaryCursorIsInEditableRange = true;
            _this._primaryCursorLineNumber = 1;
            _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
            _this._context.addEventHandler(_this);
            return _this;
        }
        CurrentLineMarginHighlightOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
        };
        // --- begin event handlers
        CurrentLineMarginHighlightOverlay.prototype.onModelFlushed = function () {
            this._primaryCursorIsInEditableRange = true;
            this._primaryCursorLineNumber = 1;
            return true;
        };
        CurrentLineMarginHighlightOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        CurrentLineMarginHighlightOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        CurrentLineMarginHighlightOverlay.prototype.onCursorPositionChanged = function (e) {
            var hasChanged = false;
            if (this._primaryCursorIsInEditableRange !== e.isInEditableRange) {
                this._primaryCursorIsInEditableRange = e.isInEditableRange;
                hasChanged = true;
            }
            if (this._primaryCursorLineNumber !== e.position.lineNumber) {
                this._primaryCursorLineNumber = e.position.lineNumber;
                hasChanged = true;
            }
            return hasChanged;
        };
        CurrentLineMarginHighlightOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.renderLineHighlight) {
                this._renderLineHighlight = this._context.configuration.editor.viewInfo.renderLineHighlight;
            }
            if (e.layoutInfo) {
                this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
            }
            return true;
        };
        CurrentLineMarginHighlightOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        CurrentLineMarginHighlightOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        CurrentLineMarginHighlightOverlay.prototype.prepareRender = function (ctx) {
        };
        CurrentLineMarginHighlightOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (lineNumber === this._primaryCursorLineNumber) {
                if (this._shouldShowCurrentLine()) {
                    return ('<div class="current-line-margin" style="width:'
                        + String(this._contentLeft)
                        + 'px; height:'
                        + String(this._lineHeight)
                        + 'px;"></div>');
                }
                else {
                    return '';
                }
            }
            return '';
        };
        CurrentLineMarginHighlightOverlay.prototype._shouldShowCurrentLine = function () {
            return (this._renderLineHighlight === 'gutter' || this._renderLineHighlight === 'all') && this._primaryCursorIsInEditableRange;
        };
        return CurrentLineMarginHighlightOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.CurrentLineMarginHighlightOverlay = CurrentLineMarginHighlightOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[380/*vs/editor/browser/viewParts/decorations/decorations*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,4/*vs/editor/common/core/range*/,326/*vs/css!vs/editor/browser/viewParts/decorations/decorations*/]), function (require, exports, dynamicViewOverlay_1, range_1) {
    'use strict';
    var DecorationsOverlay = (function (_super) {
        __extends(DecorationsOverlay, _super);
        function DecorationsOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        DecorationsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        DecorationsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        DecorationsOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            return true;
        };
        DecorationsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        DecorationsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged || e.scrollWidthChanged;
        };
        DecorationsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        DecorationsOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var _decorations = ctx.getDecorationsInViewport();
            // Keep only decorations with `className`
            var decorations = [], decorationsLen = 0;
            for (var i = 0, len = _decorations.length; i < len; i++) {
                var d = _decorations[i];
                if (d.source.options.className) {
                    decorations[decorationsLen++] = d;
                }
            }
            // Sort decorations for consistent render output
            decorations = decorations.sort(function (a, b) {
                var aClassName = a.source.options.className;
                var bClassName = b.source.options.className;
                if (aClassName < bClassName) {
                    return -1;
                }
                if (aClassName > bClassName) {
                    return 1;
                }
                return range_1.Range.compareRangesUsingStarts(a.range, b.range);
            });
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = '';
            }
            // Render first whole line decorations and then regular decorations
            this._renderWholeLineDecorations(ctx, decorations, output);
            this._renderNormalDecorations(ctx, decorations, output);
            this._renderResult = output;
        };
        DecorationsOverlay.prototype._renderWholeLineDecorations = function (ctx, decorations, output) {
            var lineHeight = String(this._lineHeight);
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            for (var i = 0, lenI = decorations.length; i < lenI; i++) {
                var d = decorations[i];
                if (!d.source.options.isWholeLine) {
                    continue;
                }
                var decorationOutput = ('<div class="cdr '
                    + d.source.options.className
                    + '" style="left:0;width:100%;height:'
                    + lineHeight
                    + 'px;"></div>');
                var startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
                var endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);
                for (var j = startLineNumber; j <= endLineNumber; j++) {
                    var lineIndex = j - visibleStartLineNumber;
                    output[lineIndex] += decorationOutput;
                }
            }
        };
        DecorationsOverlay.prototype._renderNormalDecorations = function (ctx, decorations, output) {
            var lineHeight = String(this._lineHeight);
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            for (var i = 0, lenI = decorations.length; i < lenI; i++) {
                var d = decorations[i];
                if (d.source.options.isWholeLine) {
                    continue;
                }
                var className = d.source.options.className;
                var linesVisibleRanges = ctx.linesVisibleRangesForRange(d.range, /*TODO@Alex*/ className === 'findMatch');
                if (!linesVisibleRanges) {
                    continue;
                }
                for (var j = 0, lenJ = linesVisibleRanges.length; j < lenJ; j++) {
                    var lineVisibleRanges = linesVisibleRanges[j];
                    var lineIndex = lineVisibleRanges.lineNumber - visibleStartLineNumber;
                    for (var k = 0, lenK = lineVisibleRanges.ranges.length; k < lenK; k++) {
                        var visibleRange = lineVisibleRanges.ranges[k];
                        var decorationOutput = ('<div class="cdr '
                            + className
                            + '" style="left:'
                            + String(visibleRange.left)
                            + 'px;width:'
                            + String(visibleRange.width)
                            + 'px;height:'
                            + lineHeight
                            + 'px;"></div>');
                        output[lineIndex] += decorationOutput;
                    }
                }
            }
        };
        DecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return DecorationsOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.DecorationsOverlay = DecorationsOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[101/*vs/editor/browser/viewParts/glyphMargin/glyphMargin*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,327/*vs/css!vs/editor/browser/viewParts/glyphMargin/glyphMargin*/]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var DecorationToRender = (function () {
        function DecorationToRender(startLineNumber, endLineNumber, className) {
            this.startLineNumber = +startLineNumber;
            this.endLineNumber = +endLineNumber;
            this.className = String(className);
        }
        return DecorationToRender;
    }());
    exports.DecorationToRender = DecorationToRender;
    var DedupOverlay = (function (_super) {
        __extends(DedupOverlay, _super);
        function DedupOverlay() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DedupOverlay.prototype._render = function (visibleStartLineNumber, visibleEndLineNumber, decorations) {
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = [];
            }
            if (decorations.length === 0) {
                return output;
            }
            decorations.sort(function (a, b) {
                if (a.className === b.className) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.endLineNumber - b.endLineNumber;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return (a.className < b.className ? -1 : 1);
            });
            var prevClassName = null;
            var prevEndLineIndex = 0;
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                var className = d.className;
                var startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;
                var endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;
                if (prevClassName === className) {
                    startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);
                    prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);
                }
                else {
                    prevClassName = className;
                    prevEndLineIndex = endLineIndex;
                }
                for (var i_1 = startLineIndex; i_1 <= prevEndLineIndex; i_1++) {
                    output[i_1].push(prevClassName);
                }
            }
            return output;
        };
        return DedupOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.DedupOverlay = DedupOverlay;
    var GlyphMarginOverlay = (function (_super) {
        __extends(GlyphMarginOverlay, _super);
        function GlyphMarginOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._glyphMargin = _this._context.configuration.editor.viewInfo.glyphMargin;
            _this._glyphMarginLeft = 0;
            _this._glyphMarginWidth = 0;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        GlyphMarginOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        GlyphMarginOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.glyphMargin) {
                this._glyphMargin = this._context.configuration.editor.viewInfo.glyphMargin;
            }
            return true;
        };
        GlyphMarginOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
            return true;
        };
        GlyphMarginOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        GlyphMarginOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        GlyphMarginOverlay.prototype._getDecorations = function (ctx) {
            var decorations = ctx.getDecorationsInViewport();
            var r = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                var glyphMarginClassName = d.source.options.glyphMarginClassName;
                if (glyphMarginClassName) {
                    r.push(new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, glyphMarginClassName));
                }
            }
            return r;
        };
        GlyphMarginOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            if (!this._glyphMargin) {
                this._renderResult = null;
                return;
            }
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
            var lineHeight = this._lineHeight.toString();
            var left = this._glyphMarginLeft.toString();
            var width = this._glyphMarginWidth.toString();
            var common = '" style="left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;"></div>';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var classNames = toRender[lineIndex];
                if (classNames.length === 0) {
                    output[lineIndex] = '';
                }
                else {
                    output[lineIndex] = ('<div class="cgmr '
                        + classNames.join(' ')
                        + common);
                }
            }
            this._renderResult = output;
        };
        GlyphMarginOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return GlyphMarginOverlay;
    }(DedupOverlay));
    exports.GlyphMarginOverlay = GlyphMarginOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[382/*vs/editor/browser/viewParts/indentGuides/indentGuides*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,329/*vs/css!vs/editor/browser/viewParts/indentGuides/indentGuides*/]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var IndentGuidesOverlay = (function (_super) {
        __extends(IndentGuidesOverlay, _super);
        function IndentGuidesOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._spaceWidth = _this._context.configuration.editor.fontInfo.spaceWidth;
            _this._enabled = _this._context.configuration.editor.viewInfo.renderIndentGuides;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        IndentGuidesOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        IndentGuidesOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        IndentGuidesOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        IndentGuidesOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        IndentGuidesOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        IndentGuidesOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.fontInfo) {
                this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
            }
            if (e.viewInfo.renderIndentGuides) {
                this._enabled = this._context.configuration.editor.viewInfo.renderIndentGuides;
            }
            return true;
        };
        IndentGuidesOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        IndentGuidesOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged; // || e.scrollWidthChanged;
        };
        IndentGuidesOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        IndentGuidesOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            if (!this._enabled) {
                this._renderResult = null;
                return;
            }
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var tabSize = this._context.model.getTabSize();
            var tabWidth = tabSize * this._spaceWidth;
            var lineHeight = this._lineHeight;
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var indent = this._context.model.getLineIndentGuide(lineNumber);
                var result = '';
                var left = 0;
                for (var i = 0; i < indent; i++) {
                    result += "<div class=\"cigr\" style=\"left:" + left + "px;height:" + lineHeight + "px;\"></div>";
                    left += tabWidth;
                }
                output[lineIndex] = result;
            }
            this._renderResult = output;
        };
        IndentGuidesOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return IndentGuidesOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.IndentGuidesOverlay = IndentGuidesOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[383/*vs/editor/browser/viewParts/lineNumbers/lineNumbers*/], __M([1/*require*/,0/*exports*/,19/*vs/base/common/platform*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,21/*vs/editor/browser/editorBrowser*/,331/*vs/css!vs/editor/browser/viewParts/lineNumbers/lineNumbers*/]), function (require, exports, platform, dynamicViewOverlay_1, editorBrowser_1) {
    'use strict';
    var LineNumbersOverlay = (function (_super) {
        __extends(LineNumbersOverlay, _super);
        function LineNumbersOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._renderLineNumbers = _this._context.configuration.editor.viewInfo.renderLineNumbers;
            _this._renderRelativeLineNumbers = _this._context.configuration.editor.viewInfo.renderRelativeLineNumbers;
            _this._lineNumbersLeft = 0;
            _this._lineNumbersWidth = 0;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        LineNumbersOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        LineNumbersOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        LineNumbersOverlay.prototype.onModelDecorationsChanged = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onCursorPositionChanged = function (e) {
            if (this._renderRelativeLineNumbers) {
                return true;
            }
            return false;
        };
        LineNumbersOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.renderLineNumbers) {
                this._renderLineNumbers = this._context.configuration.editor.viewInfo.renderLineNumbers;
            }
            if (e.viewInfo.renderRelativeLineNumbers) {
                this._renderRelativeLineNumbers = this._context.configuration.editor.viewInfo.renderRelativeLineNumbers;
            }
            return true;
        };
        LineNumbersOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._lineNumbersLeft = layoutInfo.lineNumbersLeft;
            this._lineNumbersWidth = layoutInfo.lineNumbersWidth;
            return true;
        };
        LineNumbersOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        LineNumbersOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        LineNumbersOverlay.prototype.prepareRender = function (ctx) {
            if (!this._renderLineNumbers) {
                this._renderResult = null;
                return;
            }
            var lineHeightClassName = (platform.isLinux ? (this._lineHeight % 2 === 0 ? ' lh-even' : ' lh-odd') : '');
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var common = '<div class="' + editorBrowser_1.ClassNames.LINE_NUMBERS + lineHeightClassName + '" style="left:' + this._lineNumbersLeft.toString() + 'px;width:' + this._lineNumbersWidth.toString() + 'px;">';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var renderLineNumber = this._context.model.getLineRenderLineNumber(lineNumber);
                if (renderLineNumber) {
                    output[lineIndex] = (common
                        + renderLineNumber
                        + '</div>');
                }
                else {
                    output[lineIndex] = '';
                }
            }
            this._renderResult = output;
        };
        LineNumbersOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return LineNumbersOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.LineNumbersOverlay = LineNumbersOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[384/*vs/editor/browser/viewParts/linesDecorations/linesDecorations*/], __M([1/*require*/,0/*exports*/,101/*vs/editor/browser/viewParts/glyphMargin/glyphMargin*/,333/*vs/css!vs/editor/browser/viewParts/linesDecorations/linesDecorations*/]), function (require, exports, glyphMargin_1) {
    'use strict';
    var LinesDecorationsOverlay = (function (_super) {
        __extends(LinesDecorationsOverlay, _super);
        function LinesDecorationsOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._decorationsLeft = 0;
            _this._decorationsWidth = 0;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        LinesDecorationsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        LinesDecorationsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onConfigurationChanged = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._decorationsLeft = layoutInfo.decorationsLeft;
            this._decorationsWidth = layoutInfo.decorationsWidth;
            return true;
        };
        LinesDecorationsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        LinesDecorationsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        LinesDecorationsOverlay.prototype._getDecorations = function (ctx) {
            var decorations = ctx.getDecorationsInViewport();
            var r = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                var linesDecorationsClassName = d.source.options.linesDecorationsClassName;
                if (linesDecorationsClassName) {
                    r.push(new glyphMargin_1.DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, linesDecorationsClassName));
                }
            }
            return r;
        };
        LinesDecorationsOverlay.prototype.prepareRender = function (ctx) {
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
            var left = this._decorationsLeft.toString();
            var width = this._decorationsWidth.toString();
            var common = '" style="left:' + left + 'px;width:' + width + 'px;"></div>';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var classNames = toRender[lineIndex];
                var lineOutput = '';
                for (var i = 0, len = classNames.length; i < len; i++) {
                    lineOutput += '<div class="cldr ' + classNames[i] + common;
                }
                output[lineIndex] = lineOutput;
            }
            this._renderResult = output;
        };
        LinesDecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            return this._renderResult[lineNumber - startLineNumber];
        };
        return LinesDecorationsOverlay;
    }(glyphMargin_1.DedupOverlay));
    exports.LinesDecorationsOverlay = LinesDecorationsOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[385/*vs/editor/browser/viewParts/margin/margin*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/]), function (require, exports, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var Margin = (function (_super) {
        __extends(Margin, _super);
        function Margin(context, layoutProvider) {
            var _this = _super.call(this, context) || this;
            _this._layoutProvider = layoutProvider;
            _this._canUseTranslate3d = _this._context.configuration.editor.viewInfo.canUseTranslate3d;
            _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
            _this._glyphMarginLeft = _this._context.configuration.editor.layoutInfo.glyphMarginLeft;
            _this._glyphMarginWidth = _this._context.configuration.editor.layoutInfo.glyphMarginWidth;
            _this.domNode = _this._createDomNode();
            return _this;
        }
        Margin.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        Margin.prototype._createDomNode = function () {
            var domNode = document.createElement('div');
            domNode.className = editorBrowser_1.ClassNames.MARGIN + ' monaco-editor-background';
            domNode.style.position = 'absolute';
            domNode.setAttribute('role', 'presentation');
            domNode.setAttribute('aria-hidden', 'true');
            this._glyphMarginBackgroundDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            this._glyphMarginBackgroundDomNode.setClassName(editorBrowser_1.ClassNames.GLYPH_MARGIN);
            domNode.appendChild(this._glyphMarginBackgroundDomNode.domNode);
            return domNode;
        };
        // --- begin event handlers
        Margin.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            return _super.prototype.onConfigurationChanged.call(this, e);
        };
        Margin.prototype.onScrollChanged = function (e) {
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollTopChanged;
        };
        Margin.prototype.onLayoutChanged = function (layoutInfo) {
            this._contentLeft = layoutInfo.contentLeft;
            this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
            return _super.prototype.onLayoutChanged.call(this, layoutInfo) || true;
        };
        // --- end event handlers
        Margin.prototype.prepareRender = function (ctx) {
            // Nothing to read
        };
        Margin.prototype.render = function (ctx) {
            if (this._canUseTranslate3d) {
                var transform = 'translate3d(0px, ' + ctx.linesViewportData.visibleRangesDeltaTop + 'px, 0px)';
                styleMutator_1.StyleMutator.setTransform(this.domNode, transform);
                styleMutator_1.StyleMutator.setTop(this.domNode, 0);
            }
            else {
                styleMutator_1.StyleMutator.setTransform(this.domNode, '');
                styleMutator_1.StyleMutator.setTop(this.domNode, ctx.linesViewportData.visibleRangesDeltaTop);
            }
            var height = Math.min(this._layoutProvider.getTotalHeight(), 1000000);
            styleMutator_1.StyleMutator.setHeight(this.domNode, height);
            styleMutator_1.StyleMutator.setWidth(this.domNode, this._contentLeft);
            this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft);
            this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth);
            this._glyphMarginBackgroundDomNode.setHeight(height);
        };
        return Margin;
    }(viewPart_1.ViewPart));
    exports.Margin = Margin;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[386/*vs/editor/browser/viewParts/marginDecorations/marginDecorations*/], __M([1/*require*/,0/*exports*/,101/*vs/editor/browser/viewParts/glyphMargin/glyphMargin*/,334/*vs/css!vs/editor/browser/viewParts/marginDecorations/marginDecorations*/]), function (require, exports, glyphMargin_1) {
    'use strict';
    var MarginViewLineDecorationsOverlay = (function (_super) {
        __extends(MarginViewLineDecorationsOverlay, _super);
        function MarginViewLineDecorationsOverlay(context) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        MarginViewLineDecorationsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        MarginViewLineDecorationsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        MarginViewLineDecorationsOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        MarginViewLineDecorationsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        MarginViewLineDecorationsOverlay.prototype.onConfigurationChanged = function (e) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        MarginViewLineDecorationsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        MarginViewLineDecorationsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        MarginViewLineDecorationsOverlay.prototype._getDecorations = function (ctx) {
            var decorations = ctx.getDecorationsInViewport();
            var r = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                var marginClassName = d.source.options.marginClassName;
                if (marginClassName) {
                    r.push(new glyphMargin_1.DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, marginClassName));
                }
            }
            return r;
        };
        MarginViewLineDecorationsOverlay.prototype.prepareRender = function (ctx) {
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var classNames = toRender[lineIndex];
                var lineOutput = '';
                for (var i = 0, len = classNames.length; i < len; i++) {
                    lineOutput += '<div class="cmdr ' + classNames[i] + '" style=""></div>';
                }
                output[lineIndex] = lineOutput;
            }
            this._renderResult = output;
        };
        MarginViewLineDecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            return this._renderResult[lineNumber - startLineNumber];
        };
        return MarginViewLineDecorationsOverlay;
    }(glyphMargin_1.DedupOverlay));
    exports.MarginViewLineDecorationsOverlay = MarginViewLineDecorationsOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[387/*vs/editor/browser/viewParts/overlayWidgets/overlayWidgets*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/,335/*vs/css!vs/editor/browser/viewParts/overlayWidgets/overlayWidgets*/]), function (require, exports, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ViewOverlayWidgets = (function (_super) {
        __extends(ViewOverlayWidgets, _super);
        function ViewOverlayWidgets(context) {
            var _this = _super.call(this, context) || this;
            _this._widgets = {};
            _this._verticalScrollbarWidth = 0;
            _this._horizontalScrollbarHeight = 0;
            _this._editorHeight = 0;
            _this._editorWidth = 0;
            _this.domNode = document.createElement('div');
            viewPart_1.PartFingerprints.write(_this.domNode, 4 /* OverlayWidgets */);
            _this.domNode.className = editorBrowser_1.ClassNames.OVERLAY_WIDGETS;
            return _this;
        }
        ViewOverlayWidgets.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._widgets = null;
        };
        // ---- begin view event handlers
        ViewOverlayWidgets.prototype.onLayoutChanged = function (layoutInfo) {
            this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;
            this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;
            this._editorHeight = layoutInfo.height;
            this._editorWidth = layoutInfo.width;
            return true;
        };
        // ---- end view event handlers
        ViewOverlayWidgets.prototype.addWidget = function (widget) {
            this._widgets[widget.getId()] = {
                widget: widget,
                preference: null
            };
            // This is sync because a widget wants to be in the dom
            var domNode = widget.getDomNode();
            domNode.style.position = 'absolute';
            domNode.setAttribute('widgetId', widget.getId());
            this.domNode.appendChild(domNode);
            this.setShouldRender();
        };
        ViewOverlayWidgets.prototype.setWidgetPosition = function (widget, preference) {
            var widgetData = this._widgets[widget.getId()];
            if (widgetData.preference === preference) {
                return false;
            }
            widgetData.preference = preference;
            this.setShouldRender();
            return true;
        };
        ViewOverlayWidgets.prototype.removeWidget = function (widget) {
            var widgetId = widget.getId();
            if (this._widgets.hasOwnProperty(widgetId)) {
                var widgetData = this._widgets[widgetId];
                var domNode = widgetData.widget.getDomNode();
                delete this._widgets[widgetId];
                domNode.parentNode.removeChild(domNode);
                this.setShouldRender();
            }
        };
        ViewOverlayWidgets.prototype._renderWidget = function (widgetData) {
            var _RESTORE_STYLE_TOP = 'data-editor-restoreStyleTop';
            var domNode = widgetData.widget.getDomNode();
            if (widgetData.preference === null) {
                if (domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    var previousTop = domNode.getAttribute(_RESTORE_STYLE_TOP);
                    domNode.removeAttribute(_RESTORE_STYLE_TOP);
                    domNode.style.top = previousTop;
                }
                return;
            }
            if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.TOP_RIGHT_CORNER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                styleMutator_1.StyleMutator.setTop(domNode, 0);
                styleMutator_1.StyleMutator.setRight(domNode, (2 * this._verticalScrollbarWidth));
            }
            else if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                var widgetHeight = domNode.clientHeight;
                styleMutator_1.StyleMutator.setTop(domNode, (this._editorHeight - widgetHeight - 2 * this._horizontalScrollbarHeight));
                styleMutator_1.StyleMutator.setRight(domNode, (2 * this._verticalScrollbarWidth));
            }
            else if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.TOP_CENTER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                styleMutator_1.StyleMutator.setTop(domNode, 0);
                domNode.style.right = '50%';
            }
        };
        ViewOverlayWidgets.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ViewOverlayWidgets.prototype.render = function (ctx) {
            styleMutator_1.StyleMutator.setWidth(this.domNode, this._editorWidth);
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                this._renderWidget(this._widgets[widgetId]);
            }
        };
        return ViewOverlayWidgets;
    }(viewPart_1.ViewPart));
    exports.ViewOverlayWidgets = ViewOverlayWidgets;
});






define(__m[388/*vs/editor/browser/viewParts/overviewRuler/overviewRuler*/], __M([1/*require*/,0/*exports*/,47/*vs/editor/common/viewModel/viewEventHandler*/,129/*vs/editor/browser/viewParts/overviewRuler/overviewRulerImpl*/]), function (require, exports, viewEventHandler_1, overviewRulerImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewRuler = (function (_super) {
        __extends(OverviewRuler, _super);
        function OverviewRuler(context, cssClassName, scrollHeight, minimumHeight, maximumHeight, getVerticalOffsetForLine) {
            var _this = _super.call(this) || this;
            _this._context = context;
            _this._overviewRuler = new overviewRulerImpl_1.OverviewRulerImpl(0, cssClassName, scrollHeight, _this._context.configuration.editor.lineHeight, _this._context.configuration.editor.viewInfo.canUseTranslate3d, minimumHeight, maximumHeight, getVerticalOffsetForLine);
            _this._context.addEventHandler(_this);
            return _this;
        }
        OverviewRuler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._overviewRuler.dispose();
        };
        OverviewRuler.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._overviewRuler.setLineHeight(this._context.configuration.editor.lineHeight, true);
                return true;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._overviewRuler.setCanUseTranslate3d(this._context.configuration.editor.viewInfo.canUseTranslate3d, true);
                return true;
            }
            return false;
        };
        OverviewRuler.prototype.onZonesChanged = function () {
            return true;
        };
        OverviewRuler.prototype.onModelFlushed = function () {
            return true;
        };
        OverviewRuler.prototype.onScrollChanged = function (e) {
            this._overviewRuler.setScrollHeight(e.scrollHeight, true);
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        OverviewRuler.prototype.getDomNode = function () {
            return this._overviewRuler.getDomNode();
        };
        OverviewRuler.prototype.setLayout = function (position) {
            this._overviewRuler.setLayout(position, true);
        };
        OverviewRuler.prototype.setZones = function (zones) {
            this._overviewRuler.setZones(zones, true);
        };
        return OverviewRuler;
    }(viewEventHandler_1.ViewEventHandler));
    exports.OverviewRuler = OverviewRuler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[389/*vs/editor/browser/viewParts/rulers/rulers*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,31/*vs/editor/browser/view/viewPart*/,338/*vs/css!vs/editor/browser/viewParts/rulers/rulers*/]), function (require, exports, styleMutator_1, viewPart_1) {
    'use strict';
    var Rulers = (function (_super) {
        __extends(Rulers, _super);
        function Rulers(context, layoutProvider) {
            var _this = _super.call(this, context) || this;
            _this._layoutProvider = layoutProvider;
            _this.domNode = document.createElement('div');
            _this.domNode.className = 'view-rulers';
            _this._rulers = _this._context.configuration.editor.viewInfo.rulers;
            _this._height = _this._context.configuration.editor.layoutInfo.contentHeight;
            _this._typicalHalfwidthCharacterWidth = _this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            return _this;
        }
        Rulers.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        // --- begin event handlers
        Rulers.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.rulers || e.layoutInfo || e.fontInfo) {
                this._rulers = this._context.configuration.editor.viewInfo.rulers;
                this._height = this._context.configuration.editor.layoutInfo.contentHeight;
                this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
                return true;
            }
            return false;
        };
        Rulers.prototype.onScrollChanged = function (e) {
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        // --- end event handlers
        Rulers.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        Rulers.prototype.render = function (ctx) {
            var existingRulersLength = this.domNode.children.length;
            var max = Math.max(existingRulersLength, this._rulers.length);
            for (var i = 0; i < max; i++) {
                if (i >= this._rulers.length) {
                    this.domNode.removeChild(this.domNode.lastChild);
                    continue;
                }
                var node = void 0;
                if (i < existingRulersLength) {
                    node = this.domNode.children[i];
                }
                else {
                    node = document.createElement('div');
                    node.className = 'view-ruler';
                    this.domNode.appendChild(node);
                }
                styleMutator_1.StyleMutator.setHeight(node, Math.min(this._layoutProvider.getTotalHeight(), 1000000));
                styleMutator_1.StyleMutator.setLeft(node, this._rulers[i] * this._typicalHalfwidthCharacterWidth);
            }
        };
        return Rulers;
    }(viewPart_1.ViewPart));
    exports.Rulers = Rulers;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[390/*vs/editor/browser/viewParts/scrollDecoration/scrollDecoration*/], __M([1/*require*/,0/*exports*/,11/*vs/base/browser/dom*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/,342/*vs/css!vs/editor/browser/viewParts/scrollDecoration/scrollDecoration*/]), function (require, exports, dom, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ScrollDecorationViewPart = (function (_super) {
        __extends(ScrollDecorationViewPart, _super);
        function ScrollDecorationViewPart(context) {
            var _this = _super.call(this, context) || this;
            _this._scrollTop = 0;
            _this._width = 0;
            _this._shouldShow = false;
            _this._useShadows = _this._context.configuration.editor.viewInfo.scrollbar.useShadows;
            _this._domNode = document.createElement('div');
            return _this;
        }
        ScrollDecorationViewPart.prototype._updateShouldShow = function () {
            var newShouldShow = (this._useShadows && this._scrollTop > 0);
            if (this._shouldShow !== newShouldShow) {
                this._shouldShow = newShouldShow;
                return true;
            }
            return false;
        };
        ScrollDecorationViewPart.prototype.getDomNode = function () {
            return this._domNode;
        };
        // --- begin event handlers
        ScrollDecorationViewPart.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.scrollbar) {
                this._useShadows = this._context.configuration.editor.viewInfo.scrollbar.useShadows;
            }
            return this._updateShouldShow();
        };
        ScrollDecorationViewPart.prototype.onLayoutChanged = function (layoutInfo) {
            if (this._width !== layoutInfo.width) {
                this._width = layoutInfo.width;
                return true;
            }
            return false;
        };
        ScrollDecorationViewPart.prototype.onScrollChanged = function (e) {
            this._scrollTop = e.scrollTop;
            return this._updateShouldShow();
        };
        // --- end event handlers
        ScrollDecorationViewPart.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ScrollDecorationViewPart.prototype.render = function (ctx) {
            styleMutator_1.StyleMutator.setWidth(this._domNode, this._width);
            dom.toggleClass(this._domNode, editorBrowser_1.ClassNames.SCROLL_DECORATION, this._shouldShow);
        };
        return ScrollDecorationViewPart;
    }(viewPart_1.ViewPart));
    exports.ScrollDecorationViewPart = ScrollDecorationViewPart;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[391/*vs/editor/browser/viewParts/selections/selections*/], __M([1/*require*/,0/*exports*/,48/*vs/editor/browser/view/dynamicViewOverlay*/,23/*vs/base/browser/browser*/,343/*vs/css!vs/editor/browser/viewParts/selections/selections*/]), function (require, exports, dynamicViewOverlay_1, browser) {
    'use strict';
    var CornerStyle;
    (function (CornerStyle) {
        CornerStyle[CornerStyle["EXTERN"] = 0] = "EXTERN";
        CornerStyle[CornerStyle["INTERN"] = 1] = "INTERN";
        CornerStyle[CornerStyle["FLAT"] = 2] = "FLAT";
    })(CornerStyle || (CornerStyle = {}));
    var HorizontalRangeWithStyle = (function () {
        function HorizontalRangeWithStyle(other) {
            this.left = other.left;
            this.width = other.width;
            this.startStyle = null;
            this.endStyle = null;
        }
        return HorizontalRangeWithStyle;
    }());
    var LineVisibleRangesWithStyle = (function () {
        function LineVisibleRangesWithStyle(lineNumber, ranges) {
            this.lineNumber = lineNumber;
            this.ranges = ranges;
        }
        return LineVisibleRangesWithStyle;
    }());
    function toStyledRange(item) {
        return new HorizontalRangeWithStyle(item);
    }
    function toStyled(item) {
        return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));
    }
    // TODO@Alex: Remove this once IE11 fixes Bug #524217
    // The problem in IE11 is that it does some sort of auto-zooming to accomodate for displays with different pixel density.
    // Unfortunately, this auto-zooming is buggy around dealing with rounded borders
    var isIEWithZoomingIssuesNearRoundedBorders = browser.isEdgeOrIE;
    var SelectionsOverlay = (function (_super) {
        __extends(SelectionsOverlay, _super);
        function SelectionsOverlay(context) {
            var _this = _super.call(this) || this;
            _this._previousFrameVisibleRangesWithStyle = [];
            _this._context = context;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._roundedSelection = _this._context.configuration.editor.viewInfo.roundedSelection;
            _this._selections = [];
            _this._renderResult = null;
            _this._context.addEventHandler(_this);
            return _this;
        }
        SelectionsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._selections = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        SelectionsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        SelectionsOverlay.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return true; //e.inlineDecorationsChanged;
        };
        SelectionsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        SelectionsOverlay.prototype.onCursorSelectionChanged = function (e) {
            this._selections = [e.selection];
            this._selections = this._selections.concat(e.secondarySelections);
            return true;
        };
        SelectionsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        SelectionsOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.roundedSelection) {
                this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection;
            }
            return true;
        };
        SelectionsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        SelectionsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        SelectionsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        SelectionsOverlay.prototype._visibleRangesHaveGaps = function (linesVisibleRanges) {
            for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {
                var lineVisibleRanges = linesVisibleRanges[i];
                if (lineVisibleRanges.ranges.length > 1) {
                    // There are two ranges on the same line
                    return true;
                }
            }
            return false;
        };
        SelectionsOverlay.prototype._enrichVisibleRangesWithStyle = function (linesVisibleRanges, previousFrame) {
            var previousFrameTop = null;
            var previousFrameBottom = null;
            if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {
                var topLineNumber = linesVisibleRanges[0].lineNumber;
                for (var i = 0; !previousFrameTop && i < previousFrame.length; i++) {
                    if (previousFrame[i].lineNumber === topLineNumber) {
                        previousFrameTop = previousFrame[i].ranges[0];
                    }
                }
                var bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;
                for (var i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {
                    if (previousFrame[i].lineNumber === bottomLineNumber) {
                        previousFrameBottom = previousFrame[i].ranges[0];
                    }
                }
                if (previousFrameTop && !previousFrameTop.startStyle) {
                    previousFrameTop = null;
                }
                if (previousFrameBottom && !previousFrameBottom.startStyle) {
                    previousFrameBottom = null;
                }
            }
            for (var i = 0, len = linesVisibleRanges.length; i < len; i++) {
                // We know for a fact that there is precisely one range on each line
                var curLineRange = linesVisibleRanges[i].ranges[0];
                var curLeft = curLineRange.left;
                var curRight = curLineRange.left + curLineRange.width;
                var startStyle = {
                    top: 0 /* EXTERN */,
                    bottom: 0 /* EXTERN */
                };
                var endStyle = {
                    top: 0 /* EXTERN */,
                    bottom: 0 /* EXTERN */
                };
                if (i > 0) {
                    // Look above
                    var prevLeft = linesVisibleRanges[i - 1].ranges[0].left;
                    var prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;
                    if (curLeft === prevLeft) {
                        startStyle.top = 2 /* FLAT */;
                    }
                    else if (curLeft > prevLeft) {
                        startStyle.top = 1 /* INTERN */;
                    }
                    if (curRight === prevRight) {
                        endStyle.top = 2 /* FLAT */;
                    }
                    else if (prevLeft < curRight && curRight < prevRight) {
                        endStyle.top = 1 /* INTERN */;
                    }
                }
                else if (previousFrameTop) {
                    // Accept some hick-ups near the viewport edges to save on repaints
                    startStyle.top = previousFrameTop.startStyle.top;
                    endStyle.top = previousFrameTop.endStyle.top;
                }
                if (i + 1 < len) {
                    // Look below
                    var nextLeft = linesVisibleRanges[i + 1].ranges[0].left;
                    var nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;
                    if (curLeft === nextLeft) {
                        startStyle.bottom = 2 /* FLAT */;
                    }
                    else if (nextLeft < curLeft && curLeft < nextRight) {
                        startStyle.bottom = 1 /* INTERN */;
                    }
                    if (curRight === nextRight) {
                        endStyle.bottom = 2 /* FLAT */;
                    }
                    else if (curRight < nextRight) {
                        endStyle.bottom = 1 /* INTERN */;
                    }
                }
                else if (previousFrameBottom) {
                    // Accept some hick-ups near the viewport edges to save on repaints
                    startStyle.bottom = previousFrameBottom.startStyle.bottom;
                    endStyle.bottom = previousFrameBottom.endStyle.bottom;
                }
                curLineRange.startStyle = startStyle;
                curLineRange.endStyle = endStyle;
            }
        };
        SelectionsOverlay.prototype._getVisibleRangesWithStyle = function (selection, ctx, previousFrame) {
            var _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];
            var linesVisibleRanges = _linesVisibleRanges.map(toStyled);
            var visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);
            if (!isIEWithZoomingIssuesNearRoundedBorders && !visibleRangesHaveGaps && this._roundedSelection) {
                this._enrichVisibleRangesWithStyle(linesVisibleRanges, previousFrame);
            }
            // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT
            return linesVisibleRanges;
        };
        SelectionsOverlay.prototype._createSelectionPiece = function (top, height, className, left, width) {
            return ('<div class="cslr '
                + className
                + '" style="top:'
                + top.toString()
                + 'px;left:'
                + left.toString()
                + 'px;width:'
                + width.toString()
                + 'px;height:'
                + height
                + 'px;"></div>');
        };
        SelectionsOverlay.prototype._actualRenderOneSelection = function (output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {
            var visibleRangesHaveStyle = (visibleRanges.length > 0 && visibleRanges[0].ranges[0].startStyle);
            var fullLineHeight = (this._lineHeight).toString();
            var reducedLineHeight = (this._lineHeight - 1).toString();
            var firstLineNumber = (visibleRanges.length > 0 ? visibleRanges[0].lineNumber : 0);
            var lastLineNumber = (visibleRanges.length > 0 ? visibleRanges[visibleRanges.length - 1].lineNumber : 0);
            for (var i = 0, len = visibleRanges.length; i < len; i++) {
                var lineVisibleRanges = visibleRanges[i];
                var lineNumber = lineVisibleRanges.lineNumber;
                var lineIndex = lineNumber - visibleStartLineNumber;
                var lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;
                var top_1 = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;
                var lineOutput = '';
                for (var j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {
                    var visibleRange = lineVisibleRanges.ranges[j];
                    if (visibleRangesHaveStyle) {
                        if (visibleRange.startStyle.top === 1 /* INTERN */ || visibleRange.startStyle.bottom === 1 /* INTERN */) {
                            // Reverse rounded corner to the left
                            // First comes the selection (blue layer)
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                            // Second comes the background (white layer) with inverse border radius
                            var className_1 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                            if (visibleRange.startStyle.top === 1 /* INTERN */) {
                                className_1 += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                            }
                            if (visibleRange.startStyle.bottom === 1 /* INTERN */) {
                                className_1 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                            }
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, className_1, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        }
                        if (visibleRange.endStyle.top === 1 /* INTERN */ || visibleRange.endStyle.bottom === 1 /* INTERN */) {
                            // Reverse rounded corner to the right
                            // First comes the selection (blue layer)
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                            // Second comes the background (white layer) with inverse border radius
                            var className_2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                            if (visibleRange.endStyle.top === 1 /* INTERN */) {
                                className_2 += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                            }
                            if (visibleRange.endStyle.bottom === 1 /* INTERN */) {
                                className_2 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                            }
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, className_2, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        }
                    }
                    var className = SelectionsOverlay.SELECTION_CLASS_NAME;
                    if (visibleRangesHaveStyle) {
                        if (visibleRange.startStyle.top === 0 /* EXTERN */) {
                            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                        }
                        if (visibleRange.startStyle.bottom === 0 /* EXTERN */) {
                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                        }
                        if (visibleRange.endStyle.top === 0 /* EXTERN */) {
                            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                        }
                        if (visibleRange.endStyle.bottom === 0 /* EXTERN */) {
                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                        }
                    }
                    lineOutput += this._createSelectionPiece(top_1, lineHeight, className, visibleRange.left, visibleRange.width);
                }
                output2[lineIndex] += lineOutput;
            }
        };
        SelectionsOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var output = [];
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = '';
            }
            var thisFrameVisibleRangesWithStyle = [];
            for (var i = 0, len = this._selections.length; i < len; i++) {
                var selection = this._selections[i];
                if (selection.isEmpty()) {
                    thisFrameVisibleRangesWithStyle.push(null);
                    continue;
                }
                var visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);
                thisFrameVisibleRangesWithStyle.push(visibleRangesWithStyle);
                this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);
            }
            this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;
            this._renderResult = output;
        };
        SelectionsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return SelectionsOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    SelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';
    SelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';
    SelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';
    SelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';
    SelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';
    SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';
    SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;
    exports.SelectionsOverlay = SelectionsOverlay;
});






define(__m[392/*vs/editor/browser/viewParts/viewZones/viewZones*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/,16/*vs/editor/common/core/position*/]), function (require, exports, errors_1, styleMutator_1, editorBrowser_1, viewPart_1, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewZones = (function (_super) {
        __extends(ViewZones, _super);
        function ViewZones(context, whitespaceManager) {
            var _this = _super.call(this, context) || this;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
            _this._contentLeft = _this._context.configuration.editor.layoutInfo.contentLeft;
            _this._whitespaceManager = whitespaceManager;
            _this.domNode = document.createElement('div');
            _this.domNode.className = editorBrowser_1.ClassNames.VIEW_ZONES;
            _this.domNode.style.position = 'absolute';
            _this.domNode.setAttribute('role', 'presentation');
            _this.domNode.setAttribute('aria-hidden', 'true');
            _this.marginDomNode = document.createElement('div');
            _this.marginDomNode.className = 'margin-view-zones';
            _this.marginDomNode.style.position = 'absolute';
            _this.marginDomNode.setAttribute('role', 'presentation');
            _this.marginDomNode.setAttribute('aria-hidden', 'true');
            _this._zones = {};
            return _this;
        }
        ViewZones.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._whitespaceManager = null;
            this._zones = {};
        };
        // ---- begin view event handlers
        ViewZones.prototype._recomputeWhitespacesProps = function () {
            var hadAChange = false;
            var keys = Object.keys(this._zones);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var zone = this._zones[id];
                var props = this._computeWhitespaceProps(zone.delegate);
                if (this._whitespaceManager.changeWhitespace(parseInt(id, 10), props.afterViewLineNumber, props.heightInPx)) {
                    this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                    hadAChange = true;
                }
            }
            return hadAChange;
        };
        ViewZones.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
                return this._recomputeWhitespacesProps();
            }
            if (e.layoutInfo) {
                this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
                this._contentLeft = this._context.configuration.editor.layoutInfo.contentLeft;
            }
            return false;
        };
        ViewZones.prototype.onLineMappingChanged = function () {
            return this._recomputeWhitespacesProps();
        };
        ViewZones.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewZones.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged || e.scrollWidthChanged;
        };
        ViewZones.prototype.onZonesChanged = function () {
            return true;
        };
        ViewZones.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewZones.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        // ---- end view event handlers
        ViewZones.prototype._getZoneOrdinal = function (zone) {
            if (typeof zone.afterColumn !== 'undefined') {
                return zone.afterColumn;
            }
            return 10000;
        };
        ViewZones.prototype._computeWhitespaceProps = function (zone) {
            if (zone.afterLineNumber === 0) {
                return {
                    afterViewLineNumber: 0,
                    heightInPx: this._heightInPixels(zone)
                };
            }
            var zoneAfterModelPosition;
            if (typeof zone.afterColumn !== 'undefined') {
                zoneAfterModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zone.afterLineNumber,
                    column: zone.afterColumn
                });
            }
            else {
                var validAfterLineNumber = this._context.model.validateModelPosition({
                    lineNumber: zone.afterLineNumber,
                    column: 1
                }).lineNumber;
                zoneAfterModelPosition = new position_1.Position(validAfterLineNumber, this._context.model.getModelLineMaxColumn(validAfterLineNumber));
            }
            var zoneBeforeModelPosition;
            if (zoneAfterModelPosition.column === this._context.model.getModelLineMaxColumn(zoneAfterModelPosition.lineNumber)) {
                zoneBeforeModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zoneAfterModelPosition.lineNumber + 1,
                    column: 1
                });
            }
            else {
                zoneBeforeModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zoneAfterModelPosition.lineNumber,
                    column: zoneAfterModelPosition.column + 1
                });
            }
            var viewPosition = this._context.model.convertModelPositionToViewPosition(zoneAfterModelPosition.lineNumber, zoneAfterModelPosition.column);
            var isVisible = this._context.model.modelPositionIsVisible(zoneBeforeModelPosition);
            return {
                afterViewLineNumber: viewPosition.lineNumber,
                heightInPx: (isVisible ? this._heightInPixels(zone) : 0)
            };
        };
        ViewZones.prototype.addZone = function (zone) {
            var props = this._computeWhitespaceProps(zone);
            var whitespaceId = this._whitespaceManager.addWhitespace(props.afterViewLineNumber, this._getZoneOrdinal(zone), props.heightInPx);
            var myZone = {
                whitespaceId: whitespaceId,
                delegate: zone,
                isVisible: false
            };
            this._safeCallOnComputedHeight(myZone.delegate, props.heightInPx);
            myZone.delegate.domNode.style.position = 'absolute';
            myZone.delegate.domNode.style.width = '100%';
            styleMutator_1.StyleMutator.setDisplay(myZone.delegate.domNode, 'none');
            myZone.delegate.domNode.setAttribute('monaco-view-zone', myZone.whitespaceId.toString());
            this.domNode.appendChild(myZone.delegate.domNode);
            if (myZone.delegate.marginDomNode) {
                myZone.delegate.marginDomNode.style.position = 'absolute';
                myZone.delegate.marginDomNode.style.width = '100%';
                styleMutator_1.StyleMutator.setDisplay(myZone.delegate.marginDomNode, 'none');
                myZone.delegate.marginDomNode.setAttribute('monaco-view-zone', myZone.whitespaceId.toString());
                this.marginDomNode.appendChild(myZone.delegate.marginDomNode);
            }
            this._zones[myZone.whitespaceId.toString()] = myZone;
            this.setShouldRender();
            return myZone.whitespaceId;
        };
        ViewZones.prototype.removeZone = function (id) {
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                delete this._zones[id.toString()];
                this._whitespaceManager.removeWhitespace(zone.whitespaceId);
                zone.delegate.domNode.removeAttribute('monaco-visible-view-zone');
                zone.delegate.domNode.removeAttribute('monaco-view-zone');
                zone.delegate.domNode.parentNode.removeChild(zone.delegate.domNode);
                if (zone.delegate.marginDomNode) {
                    zone.delegate.marginDomNode.removeAttribute('monaco-visible-view-zone');
                    zone.delegate.marginDomNode.removeAttribute('monaco-view-zone');
                    zone.delegate.marginDomNode.parentNode.removeChild(zone.delegate.marginDomNode);
                }
                this.setShouldRender();
                return true;
            }
            return false;
        };
        ViewZones.prototype.layoutZone = function (id) {
            var changed = false;
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                var props = this._computeWhitespaceProps(zone.delegate);
                // let newOrdinal = this._getZoneOrdinal(zone.delegate);
                changed = this._whitespaceManager.changeWhitespace(zone.whitespaceId, props.afterViewLineNumber, props.heightInPx) || changed;
                // TODO@Alex: change `newOrdinal` too
                if (changed) {
                    this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                    this.setShouldRender();
                }
            }
            return changed;
        };
        ViewZones.prototype.shouldSuppressMouseDownOnViewZone = function (id) {
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                return zone.delegate.suppressMouseDown;
            }
            return false;
        };
        ViewZones.prototype._heightInPixels = function (zone) {
            if (typeof zone.heightInPx === 'number') {
                return zone.heightInPx;
            }
            if (typeof zone.heightInLines === 'number') {
                return this._lineHeight * zone.heightInLines;
            }
            return this._lineHeight;
        };
        ViewZones.prototype._safeCallOnComputedHeight = function (zone, height) {
            if (typeof zone.onComputedHeight === 'function') {
                try {
                    zone.onComputedHeight(height);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
        };
        ViewZones.prototype._safeCallOnDomNodeTop = function (zone, top) {
            if (typeof zone.onDomNodeTop === 'function') {
                try {
                    zone.onDomNodeTop(top);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
        };
        ViewZones.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ViewZones.prototype.render = function (ctx) {
            var visibleWhitespaces = this._whitespaceManager.getWhitespaceViewportData();
            var visibleZones = {};
            var hasVisibleZone = false;
            for (var i = 0, len = visibleWhitespaces.length; i < len; i++) {
                visibleZones[visibleWhitespaces[i].id.toString()] = visibleWhitespaces[i];
                hasVisibleZone = true;
            }
            var keys = Object.keys(this._zones);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var zone = this._zones[id];
                var newTop = 0;
                var newHeight = 0;
                var newDisplay = 'none';
                if (visibleZones.hasOwnProperty(id)) {
                    newTop = visibleZones[id].verticalOffset - ctx.bigNumbersDelta;
                    newHeight = visibleZones[id].height;
                    newDisplay = 'block';
                    // zone is visible
                    if (!zone.isVisible) {
                        zone.delegate.domNode.setAttribute('monaco-visible-view-zone', 'true');
                        zone.isVisible = true;
                    }
                    this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(visibleZones[id].verticalOffset));
                }
                else {
                    if (zone.isVisible) {
                        zone.delegate.domNode.removeAttribute('monaco-visible-view-zone');
                        zone.isVisible = false;
                    }
                    this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(-1000000));
                }
                styleMutator_1.StyleMutator.setTop(zone.delegate.domNode, newTop);
                styleMutator_1.StyleMutator.setHeight(zone.delegate.domNode, newHeight);
                styleMutator_1.StyleMutator.setDisplay(zone.delegate.domNode, newDisplay);
                if (zone.delegate.marginDomNode) {
                    styleMutator_1.StyleMutator.setTop(zone.delegate.marginDomNode, newTop);
                    styleMutator_1.StyleMutator.setHeight(zone.delegate.marginDomNode, newHeight);
                    styleMutator_1.StyleMutator.setDisplay(zone.delegate.marginDomNode, newDisplay);
                }
            }
            if (hasVisibleZone) {
                styleMutator_1.StyleMutator.setWidth(this.domNode, Math.max(ctx.scrollWidth, this._contentWidth));
                styleMutator_1.StyleMutator.setWidth(this.marginDomNode, this._contentLeft);
            }
        };
        return ViewZones;
    }(viewPart_1.ViewPart));
    exports.ViewZones = ViewZones;
});

define(__m[393/*vs/editor/common/viewModel/viewModelCursors*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,16/*vs/editor/common/core/position*/]), function (require, exports, range_1, selection_1, editorCommon, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModelCursors = (function () {
        function ViewModelCursors(configuration, converter) {
            this.configuration = configuration;
            this.converter = converter;
            this.lastCursorPositionChangedEvent = null;
            this.lastCursorSelectionChangedEvent = null;
        }
        ViewModelCursors.prototype.getSelections = function () {
            if (this.lastCursorSelectionChangedEvent) {
                var selections = [];
                selections.push(this.converter.convertModelSelectionToViewSelection(this.lastCursorSelectionChangedEvent.selection));
                for (var i = 0, len = this.lastCursorSelectionChangedEvent.secondarySelections.length; i < len; i++) {
                    selections.push(this.converter.convertModelSelectionToViewSelection(this.lastCursorSelectionChangedEvent.secondarySelections[i]));
                }
                return selections;
            }
            else {
                return [new selection_1.Selection(1, 1, 1, 1)];
            }
        };
        ViewModelCursors.prototype.onCursorPositionChanged = function (e, emit) {
            this.lastCursorPositionChangedEvent = e;
            var position = this.converter.validateViewPosition(e.viewPosition.lineNumber, e.viewPosition.column, e.position), stopRenderingLineAfter = this.configuration.editor.viewInfo.stopRenderingLineAfter;
            // Limit position to be somewhere where it can actually be rendered
            if (stopRenderingLineAfter !== -1 && position.column > stopRenderingLineAfter) {
                position = new position_1.Position(position.lineNumber, stopRenderingLineAfter);
            }
            var secondaryPositions = [];
            for (var i = 0, len = e.secondaryPositions.length; i < len; i++) {
                secondaryPositions[i] = this.converter.validateViewPosition(e.secondaryViewPositions[i].lineNumber, e.secondaryViewPositions[i].column, e.secondaryPositions[i]);
                // Limit position to be somewhere where it can actually be rendered
                if (stopRenderingLineAfter !== -1 && secondaryPositions[i].column > stopRenderingLineAfter) {
                    secondaryPositions[i] = new position_1.Position(secondaryPositions[i].lineNumber, stopRenderingLineAfter);
                }
            }
            var newEvent = {
                position: position,
                secondaryPositions: secondaryPositions,
                isInEditableRange: e.isInEditableRange
            };
            emit(editorCommon.ViewEventNames.CursorPositionChangedEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorSelectionChanged = function (e, emit) {
            this.lastCursorSelectionChangedEvent = e;
            var selection = this.converter.validateViewSelection(e.viewSelection, e.selection);
            var secondarySelections = [];
            for (var i = 0, len = e.secondarySelections.length; i < len; i++) {
                secondarySelections[i] = this.converter.validateViewSelection(e.secondaryViewSelections[i], e.secondarySelections[i]);
            }
            var newEvent = {
                selection: selection,
                secondarySelections: secondarySelections
            };
            emit(editorCommon.ViewEventNames.CursorSelectionChangedEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorRevealRange = function (e, emit) {
            var viewRange = null;
            if (e.viewRange) {
                var viewStartRange = this.converter.validateViewPosition(e.viewRange.startLineNumber, e.viewRange.startColumn, e.range.getStartPosition());
                var viewEndRange = this.converter.validateViewPosition(e.viewRange.endLineNumber, e.viewRange.endColumn, e.range.getEndPosition());
                viewRange = new range_1.Range(viewStartRange.lineNumber, viewStartRange.column, viewEndRange.lineNumber, viewEndRange.column);
            }
            else {
                viewRange = this.converter.convertModelRangeToViewRange(e.range);
            }
            var newEvent = {
                range: viewRange,
                verticalType: e.verticalType,
                revealHorizontal: e.revealHorizontal,
                revealCursor: e.revealCursor
            };
            emit(editorCommon.ViewEventNames.RevealRangeEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorScrollRequest = function (e, emit) {
            var newEvent = {
                deltaLines: e.deltaLines,
                revealCursor: e.revealCursor
            };
            emit(editorCommon.ViewEventNames.ScrollRequestEvent, newEvent);
        };
        ViewModelCursors.prototype.onLineMappingChanged = function (emit) {
            if (this.lastCursorPositionChangedEvent) {
                this.onCursorPositionChanged(this.lastCursorPositionChangedEvent, emit);
            }
            if (this.lastCursorSelectionChangedEvent) {
                this.onCursorSelectionChanged(this.lastCursorSelectionChangedEvent, emit);
            }
        };
        return ViewModelCursors;
    }());
    exports.ViewModelCursors = ViewModelCursors;
});

define(__m[394/*vs/editor/common/viewModel/viewModelDecorations*/], __M([1/*require*/,0/*exports*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,146/*vs/editor/common/viewModel/viewModel*/]), function (require, exports, range_1, editorCommon, viewModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModelDecorations = (function () {
        function ViewModelDecorations(editorId, model, configuration, converter) {
            this.editorId = editorId;
            this.model = model;
            this.configuration = configuration;
            this.converter = converter;
            this._decorationsCache = Object.create(null);
            this._clearCachedModelDecorationsResolver();
        }
        ViewModelDecorations.prototype._clearCachedModelDecorationsResolver = function () {
            this._cachedModelDecorationsResolver = null;
            this._cachedModelDecorationsResolverViewRange = null;
        };
        ViewModelDecorations.prototype.dispose = function () {
            this._decorationsCache = null;
            this._clearCachedModelDecorationsResolver();
        };
        ViewModelDecorations.prototype.reset = function () {
            this._decorationsCache = Object.create(null);
            this._clearCachedModelDecorationsResolver();
        };
        ViewModelDecorations.prototype.onModelDecorationsChanged = function (e, emit) {
            var changedDecorations = e.changedDecorations;
            for (var i = 0, len = changedDecorations.length; i < len; i++) {
                var changedDecoration = changedDecorations[i];
                var myDecoration = this._decorationsCache[changedDecoration];
                if (!myDecoration) {
                    continue;
                }
                myDecoration.range = null;
            }
            var removedDecorations = e.removedDecorations;
            for (var i = 0, len = removedDecorations.length; i < len; i++) {
                var removedDecoration = removedDecorations[i];
                delete this._decorationsCache[removedDecoration];
            }
            this._clearCachedModelDecorationsResolver();
            emit(editorCommon.ViewEventNames.DecorationsChangedEvent, {});
        };
        ViewModelDecorations.prototype.onLineMappingChanged = function (emit) {
            this._decorationsCache = Object.create(null);
            this._clearCachedModelDecorationsResolver();
            emit(editorCommon.ViewEventNames.DecorationsChangedEvent, {});
        };
        ViewModelDecorations.prototype._getOrCreateViewModelDecoration = function (modelDecoration) {
            var id = modelDecoration.id;
            var r = this._decorationsCache[id];
            if (!r) {
                r = new viewModel_1.ViewModelDecoration(modelDecoration);
                this._decorationsCache[id] = r;
            }
            if (r.range === null) {
                r.range = this.converter.convertModelRangeToViewRange(modelDecoration.range, modelDecoration.options.isWholeLine);
            }
            return r;
        };
        ViewModelDecorations.prototype.getAllOverviewRulerDecorations = function () {
            var modelDecorations = this.model.getAllDecorations(this.editorId, this.configuration.editor.readOnly);
            var result = [], resultLen = 0;
            for (var i = 0, len = modelDecorations.length; i < len; i++) {
                var modelDecoration = modelDecorations[i];
                var decorationOptions = modelDecoration.options;
                if (!decorationOptions.overviewRuler.color) {
                    continue;
                }
                var viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
                result[resultLen++] = viewModelDecoration;
            }
            return result;
        };
        ViewModelDecorations.prototype.getDecorationsViewportData = function (viewRange) {
            var cacheIsValid = true;
            cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolver !== null);
            cacheIsValid = cacheIsValid && (viewRange.equalsRange(this._cachedModelDecorationsResolverViewRange));
            if (!cacheIsValid) {
                this._cachedModelDecorationsResolver = this._getDecorationsViewportData(viewRange);
                this._cachedModelDecorationsResolverViewRange = viewRange;
            }
            return this._cachedModelDecorationsResolver;
        };
        ViewModelDecorations.prototype._getDecorationsViewportData = function (viewportRange) {
            var viewportModelRange = this.converter.convertViewRangeToModelRange(viewportRange);
            var startLineNumber = viewportRange.startLineNumber;
            var endLineNumber = viewportRange.endLineNumber;
            var modelDecorations = this.model.getDecorationsInRange(viewportModelRange, this.editorId, this.configuration.editor.readOnly);
            var decorationsInViewport = [], decorationsInViewportLen = 0;
            var inlineDecorations = [];
            for (var j = startLineNumber; j <= endLineNumber; j++) {
                inlineDecorations[j - startLineNumber] = [];
            }
            for (var i = 0, len = modelDecorations.length; i < len; i++) {
                var modelDecoration = modelDecorations[i];
                var decorationOptions = modelDecoration.options;
                var viewModelDecoration = this._getOrCreateViewModelDecoration(modelDecoration);
                var viewRange = viewModelDecoration.range;
                decorationsInViewport[decorationsInViewportLen++] = viewModelDecoration;
                if (decorationOptions.inlineClassName) {
                    var inlineDecoration = new viewModel_1.InlineDecoration(viewRange, decorationOptions.inlineClassName, false);
                    var intersectedStartLineNumber = Math.max(startLineNumber, viewRange.startLineNumber);
                    var intersectedEndLineNumber = Math.min(endLineNumber, viewRange.endLineNumber);
                    for (var j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {
                        inlineDecorations[j - startLineNumber].push(inlineDecoration);
                    }
                }
                if (decorationOptions.beforeContentClassName) {
                    if (startLineNumber <= viewRange.startLineNumber && viewRange.startLineNumber <= endLineNumber) {
                        // TODO: What happens if the startLineNumber and startColumn is at the end of a line?
                        var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.startLineNumber, viewRange.startColumn, viewRange.startLineNumber, viewRange.startColumn + 1), decorationOptions.beforeContentClassName, true);
                        inlineDecorations[viewRange.startLineNumber - startLineNumber].push(inlineDecoration);
                    }
                }
                if (decorationOptions.afterContentClassName) {
                    if (startLineNumber <= viewRange.endLineNumber && viewRange.endLineNumber <= endLineNumber && viewRange.endColumn > 1) {
                        var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(viewRange.endLineNumber, viewRange.endColumn - 1, viewRange.endLineNumber, viewRange.endColumn), decorationOptions.afterContentClassName, true);
                        inlineDecorations[viewRange.endLineNumber - startLineNumber].push(inlineDecoration);
                    }
                }
            }
            return {
                decorations: decorationsInViewport,
                inlineDecorations: inlineDecorations
            };
        };
        return ViewModelDecorations;
    }());
    exports.ViewModelDecorations = ViewModelDecorations;
});






define(__m[395/*vs/editor/common/viewModel/viewModelImpl*/], __M([1/*require*/,0/*exports*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,9/*vs/base/common/strings*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,393/*vs/editor/common/viewModel/viewModelCursors*/,394/*vs/editor/common/viewModel/viewModelDecorations*/]), function (require, exports, eventEmitter_1, lifecycle_1, strings, position_1, range_1, selection_1, editorCommon, viewModelCursors_1, viewModelDecorations_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModel = (function (_super) {
        __extends(ViewModel, _super);
        function ViewModel(lines, editorId, configuration, model, getCurrentCenteredModelRange) {
            var _this = _super.call(this) || this;
            _this.lines = lines;
            _this.editorId = editorId;
            _this.configuration = configuration;
            _this.model = model;
            _this._lastCursorPosition = new position_1.Position(1, 1);
            _this._renderCustomLineNumbers = _this.configuration.editor.viewInfo.renderCustomLineNumbers;
            _this._renderRelativeLineNumbers = _this.configuration.editor.viewInfo.renderRelativeLineNumbers;
            _this.getCurrentCenteredModelRange = getCurrentCenteredModelRange;
            _this.decorations = new viewModelDecorations_1.ViewModelDecorations(_this.editorId, _this.model, _this.configuration, {
                convertModelRangeToViewRange: function (modelRange, isWholeLine) {
                    if (isWholeLine) {
                        return _this.convertWholeLineModelRangeToViewRange(modelRange);
                    }
                    return _this.convertModelRangeToViewRange(modelRange);
                },
                convertViewRangeToModelRange: function (viewRange) {
                    return _this.convertViewRangeToModelRange(viewRange);
                }
            });
            _this.decorations.reset();
            _this.cursors = new viewModelCursors_1.ViewModelCursors(_this.configuration, _this);
            _this.listenersToRemove = [];
            _this._toDispose = [];
            _this.listenersToRemove.push(_this.model.addBulkListener(function (events) { return _this.onEvents(events); }));
            _this._toDispose.push(_this.configuration.onDidChange(function (e) {
                _this.onEvents([new eventEmitter_1.EmitterEvent(editorCommon.EventType.ConfigurationChanged, e)]);
            }));
            return _this;
        }
        ViewModel.prototype.setHiddenAreas = function (ranges) {
            try {
                this._beginDeferredEmit();
                this._setHiddenAreas(ranges);
            }
            finally {
                this._endDeferredEmit();
            }
        };
        ViewModel.prototype._setHiddenAreas = function (ranges) {
            var _this = this;
            var lineMappingChanged = this.lines.setHiddenAreas(ranges, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
        };
        ViewModel.prototype.dispose = function () {
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
            this.decorations.dispose();
            this.decorations = null;
            this.lines.dispose();
            this.lines = null;
            this.configuration = null;
            this.model = null;
        };
        ViewModel.prototype._onTabSizeChange = function (newTabSize) {
            var _this = this;
            var lineMappingChanged = this.lines.setTabSize(newTabSize, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype._onWrappingIndentChange = function (newWrappingIndent) {
            var _this = this;
            var lineMappingChanged = this.lines.setWrappingIndent(newWrappingIndent, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype._restoreCenteredModelRange = function (range) {
            // modelLine -> viewLine
            var newCenteredViewRange = this.convertModelRangeToViewRange(range);
            // Send a reveal event to restore the centered content
            var restoreRevealEvent = {
                range: newCenteredViewRange,
                verticalType: 1 /* Center */,
                revealHorizontal: false,
                revealCursor: false
            };
            this.emit(editorCommon.ViewEventNames.RevealRangeEvent, restoreRevealEvent);
        };
        ViewModel.prototype._onWrappingColumnChange = function (newWrappingColumn, columnsForFullWidthChar) {
            var _this = this;
            var lineMappingChanged = this.lines.setWrappingColumn(newWrappingColumn, columnsForFullWidthChar, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype.addEventSource = function (eventSource) {
            var _this = this;
            this.listenersToRemove.push(eventSource.addBulkListener2(function (events) { return _this.onEvents(events); }));
        };
        ViewModel.prototype.onEvents = function (events) {
            try {
                this._beginDeferredEmit();
                this._onEvents(events);
            }
            finally {
                this._endDeferredEmit();
            }
        };
        ViewModel.prototype._onEvents = function (events) {
            var _this = this;
            var hasContentChange = events.some(function (e) { return e.getType() === editorCommon.EventType.ModelRawContentChanged; }), previousCenteredModelRange;
            if (!hasContentChange) {
                // We can only convert the current centered view range to the current centered model range if the model has no changes.
                previousCenteredModelRange = this.getCurrentCenteredModelRange();
            }
            var i, len, e, data, modelContentChangedEvent, hadOtherModelChange = false, hadModelLineChangeThatChangedLineMapping = false, revealPreviousCenteredModelRange = false;
            for (i = 0, len = events.length; i < len; i++) {
                e = events[i];
                data = e.getData();
                switch (e.getType()) {
                    case editorCommon.EventType.ModelRawContentChanged:
                        modelContentChangedEvent = data;
                        switch (modelContentChangedEvent.changeType) {
                            case editorCommon.EventType.ModelRawContentChangedFlush:
                                this.onModelFlushed(modelContentChangedEvent);
                                hadOtherModelChange = true;
                                break;
                            case editorCommon.EventType.ModelRawContentChangedLinesDeleted:
                                this.onModelLinesDeleted(modelContentChangedEvent);
                                hadOtherModelChange = true;
                                break;
                            case editorCommon.EventType.ModelRawContentChangedLinesInserted:
                                this.onModelLinesInserted(modelContentChangedEvent);
                                hadOtherModelChange = true;
                                break;
                            case editorCommon.EventType.ModelRawContentChangedLineChanged:
                                hadModelLineChangeThatChangedLineMapping = this.onModelLineChanged(modelContentChangedEvent);
                                break;
                            default:
                                console.info('ViewModel received unknown event: ');
                                console.info(e);
                        }
                        break;
                    case editorCommon.EventType.ModelTokensChanged:
                        this.onModelTokensChanged(data);
                        break;
                    case editorCommon.EventType.ModelLanguageChanged:
                        // That's ok, a model tokens changed event will follow shortly
                        break;
                    case editorCommon.EventType.ModelContentChanged2:
                        // Ignore
                        break;
                    case editorCommon.EventType.ModelOptionsChanged:
                        // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here
                        var prevLineCount = this.lines.getOutputLineCount();
                        var tabSizeChanged = this._onTabSizeChange(this.model.getOptions().tabSize);
                        var newLineCount = this.lines.getOutputLineCount();
                        if (tabSizeChanged && prevLineCount !== newLineCount) {
                            revealPreviousCenteredModelRange = true;
                        }
                        break;
                    case editorCommon.EventType.ModelDecorationsChanged:
                        this.onModelDecorationsChanged(data);
                        break;
                    case editorCommon.EventType.ModelDispose:
                        // Ignore, since the editor will take care of this and destroy the view shortly
                        break;
                    case editorCommon.EventType.CursorPositionChanged:
                        this.onCursorPositionChanged(data);
                        this._lastCursorPosition = data.position;
                        break;
                    case editorCommon.EventType.CursorSelectionChanged:
                        this.onCursorSelectionChanged(data);
                        break;
                    case editorCommon.EventType.CursorRevealRange:
                        this.onCursorRevealRange(data);
                        break;
                    case editorCommon.EventType.CursorScrollRequest:
                        this.onCursorScrollRequest(data);
                        break;
                    case editorCommon.EventType.ConfigurationChanged:
                        revealPreviousCenteredModelRange = this._onWrappingIndentChange(this.configuration.editor.wrappingInfo.wrappingIndent) || revealPreviousCenteredModelRange;
                        revealPreviousCenteredModelRange = this._onWrappingColumnChange(this.configuration.editor.wrappingInfo.wrappingColumn, this.configuration.editor.fontInfo.typicalFullwidthCharacterWidth / this.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth) || revealPreviousCenteredModelRange;
                        this._renderCustomLineNumbers = this.configuration.editor.viewInfo.renderCustomLineNumbers;
                        this._renderRelativeLineNumbers = this.configuration.editor.viewInfo.renderRelativeLineNumbers;
                        if (data.readOnly) {
                            // Must read again all decorations due to readOnly filtering
                            this.decorations.reset();
                            this.emit(editorCommon.ViewEventNames.DecorationsChangedEvent, {});
                        }
                        this.emit(e.getType(), data);
                        break;
                    default:
                        console.info('View received unknown event: ');
                        console.info(e);
                }
            }
            if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            if (revealPreviousCenteredModelRange && previousCenteredModelRange) {
                this._restoreCenteredModelRange(previousCenteredModelRange);
            }
        };
        // --- begin inbound event conversion
        ViewModel.prototype.onModelFlushed = function (e) {
            var _this = this;
            this.lines.onModelFlushed(e.versionId, function (eventType, payload) { return _this.emit(eventType, payload); });
            this.decorations.reset();
        };
        ViewModel.prototype.onModelDecorationsChanged = function (e) {
            var _this = this;
            this.decorations.onModelDecorationsChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onModelLinesDeleted = function (e) {
            var _this = this;
            this.lines.onModelLinesDeleted(e.versionId, e.fromLineNumber, e.toLineNumber, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onModelTokensChanged = function (e) {
            var viewRanges = [];
            for (var i = 0, len = e.ranges.length; i < len; i++) {
                var modelRange = e.ranges[i];
                var viewStartLineNumber = this.convertModelPositionToViewPosition(modelRange.fromLineNumber, 1).lineNumber;
                var viewEndLineNumber = this.convertModelPositionToViewPosition(modelRange.toLineNumber, this.model.getLineMaxColumn(modelRange.toLineNumber)).lineNumber;
                viewRanges[i] = {
                    fromLineNumber: viewStartLineNumber,
                    toLineNumber: viewEndLineNumber
                };
            }
            var e = {
                ranges: viewRanges
            };
            this.emit(editorCommon.ViewEventNames.TokensChangedEvent, e);
        };
        ViewModel.prototype.onModelLineChanged = function (e) {
            var _this = this;
            var lineMappingChanged = this.lines.onModelLineChanged(e.versionId, e.lineNumber, e.detail, function (eventType, payload) { return _this.emit(eventType, payload); });
            return lineMappingChanged;
        };
        ViewModel.prototype.onModelLinesInserted = function (e) {
            var _this = this;
            this.lines.onModelLinesInserted(e.versionId, e.fromLineNumber, e.toLineNumber, e.detail.split('\n'), function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.validateViewRange = function (viewStartLineNumber, viewStartColumn, viewEndLineNumber, viewEndColumn, modelRange) {
            var validViewStart = this.validateViewPosition(viewStartLineNumber, viewStartColumn, modelRange.getStartPosition());
            var validViewEnd = this.validateViewPosition(viewEndLineNumber, viewEndColumn, modelRange.getEndPosition());
            return new range_1.Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);
        };
        ViewModel.prototype.validateViewPosition = function (viewLineNumber, viewColumn, modelPosition) {
            if (viewLineNumber < 1) {
                viewLineNumber = 1;
            }
            var lineCount = this.getLineCount();
            if (viewLineNumber > lineCount) {
                viewLineNumber = lineCount;
            }
            var viewMinColumn = this.getLineMinColumn(viewLineNumber);
            var viewMaxColumn = this.getLineMaxColumn(viewLineNumber);
            if (viewColumn < viewMinColumn) {
                viewColumn = viewMinColumn;
            }
            if (viewColumn > viewMaxColumn) {
                viewColumn = viewMaxColumn;
            }
            var computedModelPosition = this.convertViewPositionToModelPosition(viewLineNumber, viewColumn);
            if (computedModelPosition.equals(modelPosition)) {
                return new position_1.Position(viewLineNumber, viewColumn);
            }
            return this.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
        };
        ViewModel.prototype.validateViewSelection = function (viewSelection, modelSelection) {
            var modelSelectionStart = new position_1.Position(modelSelection.selectionStartLineNumber, modelSelection.selectionStartColumn);
            var modelPosition = new position_1.Position(modelSelection.positionLineNumber, modelSelection.positionColumn);
            var viewSelectionStart = this.validateViewPosition(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn, modelSelectionStart);
            var viewPosition = this.validateViewPosition(viewSelection.positionLineNumber, viewSelection.positionColumn, modelPosition);
            return new selection_1.Selection(viewSelectionStart.lineNumber, viewSelectionStart.column, viewPosition.lineNumber, viewPosition.column);
        };
        ViewModel.prototype.onCursorPositionChanged = function (e) {
            var _this = this;
            this.cursors.onCursorPositionChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorSelectionChanged = function (e) {
            var _this = this;
            this.cursors.onCursorSelectionChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorRevealRange = function (e) {
            var _this = this;
            this.cursors.onCursorRevealRange(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorScrollRequest = function (e) {
            var _this = this;
            this.cursors.onCursorScrollRequest(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        // --- end inbound event conversion
        ViewModel.prototype.getTabSize = function () {
            return this.model.getOptions().tabSize;
        };
        ViewModel.prototype.getLineCount = function () {
            return this.lines.getOutputLineCount();
        };
        ViewModel.prototype.mightContainRTL = function () {
            return this.model.mightContainRTL();
        };
        ViewModel.prototype.mightContainNonBasicASCII = function () {
            return this.model.mightContainNonBasicASCII();
        };
        ViewModel.prototype.getLineContent = function (lineNumber) {
            return this.lines.getOutputLineContent(lineNumber);
        };
        ViewModel.prototype.getLineIndentGuide = function (lineNumber) {
            return this.lines.getOutputIndentGuide(lineNumber);
        };
        ViewModel.prototype.getLineMinColumn = function (lineNumber) {
            return this.lines.getOutputLineMinColumn(lineNumber);
        };
        ViewModel.prototype.getLineMaxColumn = function (lineNumber) {
            return this.lines.getOutputLineMaxColumn(lineNumber);
        };
        ViewModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        ViewModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        ViewModel.prototype.getLineTokens = function (lineNumber) {
            return this.lines.getOutputLineTokens(lineNumber);
        };
        ViewModel.prototype.getLineRenderLineNumber = function (viewLineNumber) {
            var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, 1);
            if (modelPosition.column !== 1) {
                return '';
            }
            var modelLineNumber = modelPosition.lineNumber;
            if (this._renderCustomLineNumbers) {
                return this._renderCustomLineNumbers(modelLineNumber);
            }
            if (this._renderRelativeLineNumbers) {
                var diff = Math.abs(this._lastCursorPosition.lineNumber - modelLineNumber);
                if (diff === 0) {
                    return '<span class="relative-current-line-number">' + modelLineNumber + '</span>';
                }
                return String(diff);
            }
            return String(modelLineNumber);
        };
        ViewModel.prototype.getMaxLineNumber = function () {
            // The largest value for a line number will be that of the model line count
            return this.model.getLineCount();
        };
        ViewModel.prototype.getDecorationsViewportData = function (startLineNumber, endLineNumber) {
            var viewRange = new range_1.Range(startLineNumber, this.getLineMinColumn(startLineNumber), endLineNumber, this.getLineMaxColumn(endLineNumber));
            return this.decorations.getDecorationsViewportData(viewRange);
        };
        ViewModel.prototype.getAllOverviewRulerDecorations = function () {
            return this.decorations.getAllOverviewRulerDecorations();
        };
        ViewModel.prototype.getEOL = function () {
            return this.model.getEOL();
        };
        ViewModel.prototype.getValueInRange = function (range, eol) {
            var modelRange = this.convertViewRangeToModelRange(range);
            return this.model.getValueInRange(modelRange, eol);
        };
        ViewModel.prototype.getSelections = function () {
            return this.cursors.getSelections();
        };
        // View -> Model conversion and related methods
        ViewModel.prototype.convertViewPositionToModelPosition = function (viewLineNumber, viewColumn) {
            return this.lines.convertOutputPositionToInputPosition(viewLineNumber, viewColumn);
        };
        ViewModel.prototype.convertViewRangeToModelRange = function (viewRange) {
            var start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
            var end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertViewSelectionToModelSelection = function (viewSelection) {
            var selectionStart = this.convertViewPositionToModelPosition(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn);
            var position = this.convertViewPositionToModelPosition(viewSelection.positionLineNumber, viewSelection.positionColumn);
            return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
        };
        // Model -> View conversion and related methods
        ViewModel.prototype.getModelLineContent = function (modelLineNumber) {
            return this.model.getLineContent(modelLineNumber);
        };
        ViewModel.prototype.getModelLineMaxColumn = function (modelLineNumber) {
            return this.model.getLineMaxColumn(modelLineNumber);
        };
        ViewModel.prototype.validateModelPosition = function (position) {
            return this.model.validatePosition(position);
        };
        ViewModel.prototype.convertModelPositionToViewPosition = function (modelLineNumber, modelColumn) {
            return this.lines.convertInputPositionToOutputPosition(modelLineNumber, modelColumn);
        };
        ViewModel.prototype.convertModelRangeToViewRange = function (modelRange) {
            var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);
            var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertWholeLineModelRangeToViewRange = function (modelRange) {
            var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, 1);
            var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber));
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertModelSelectionToViewSelection = function (modelSelection) {
            var selectionStart = this.convertModelPositionToViewPosition(modelSelection.selectionStartLineNumber, modelSelection.selectionStartColumn);
            var position = this.convertModelPositionToViewPosition(modelSelection.positionLineNumber, modelSelection.positionColumn);
            return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
        };
        ViewModel.prototype.modelPositionIsVisible = function (position) {
            return this.lines.inputPositionIsVisible(position.lineNumber, position.column);
        };
        return ViewModel;
    }(eventEmitter_1.EventEmitter));
    exports.ViewModel = ViewModel;
});

define(__m[396/*vs/editor/contrib/find/common/findDecorations*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/]), function (require, exports, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindDecorations = (function () {
        function FindDecorations(editor) {
            this._editor = editor;
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._rangeHighlightDecorationId = null;
            this._highlightedDecorationId = null;
            this._startPosition = this._editor.getPosition();
        }
        FindDecorations.prototype.dispose = function () {
            this._editor.deltaDecorations(this._allDecorations(), []);
            this._editor = null;
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._rangeHighlightDecorationId = null;
            this._highlightedDecorationId = null;
            this._startPosition = null;
        };
        FindDecorations.prototype.reset = function () {
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._rangeHighlightDecorationId = null;
            this._highlightedDecorationId = null;
        };
        FindDecorations.prototype.getCount = function () {
            return this._decorations.length;
        };
        FindDecorations.prototype.getFindScope = function () {
            if (this._findScopeDecorationId) {
                return this._editor.getModel().getDecorationRange(this._findScopeDecorationId);
            }
            return null;
        };
        FindDecorations.prototype.getStartPosition = function () {
            return this._startPosition;
        };
        FindDecorations.prototype.setStartPosition = function (newStartPosition) {
            this._startPosition = newStartPosition;
            this.setCurrentFindMatch(null);
        };
        FindDecorations.prototype.getCurrentMatchesPosition = function (desiredRange) {
            for (var i = 0, len = this._decorations.length; i < len; i++) {
                var range = this._editor.getModel().getDecorationRange(this._decorations[i]);
                if (desiredRange.equalsRange(range)) {
                    return (i + 1);
                }
            }
            return 1;
        };
        FindDecorations.prototype.setCurrentFindMatch = function (nextMatch) {
            var _this = this;
            var newCurrentDecorationId = null;
            var matchPosition = 0;
            if (nextMatch) {
                for (var i = 0, len = this._decorations.length; i < len; i++) {
                    var range = this._editor.getModel().getDecorationRange(this._decorations[i]);
                    if (nextMatch.equalsRange(range)) {
                        newCurrentDecorationId = this._decorations[i];
                        matchPosition = (i + 1);
                        break;
                    }
                }
            }
            if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
                this._editor.changeDecorations(function (changeAccessor) {
                    if (_this._highlightedDecorationId !== null) {
                        changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations.createFindMatchDecorationOptions(false));
                        _this._highlightedDecorationId = null;
                    }
                    if (newCurrentDecorationId !== null) {
                        _this._highlightedDecorationId = newCurrentDecorationId;
                        changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations.createFindMatchDecorationOptions(true));
                    }
                    if (_this._rangeHighlightDecorationId !== null) {
                        changeAccessor.removeDecoration(_this._rangeHighlightDecorationId);
                        _this._rangeHighlightDecorationId = null;
                    }
                    if (newCurrentDecorationId !== null) {
                        var rng = _this._editor.getModel().getDecorationRange(newCurrentDecorationId);
                        _this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations.createRangeHighlightDecoration());
                    }
                });
            }
            return matchPosition;
        };
        FindDecorations.prototype.set = function (matches, findScope) {
            var newDecorations = matches.map(function (match) {
                return {
                    range: match,
                    options: FindDecorations.createFindMatchDecorationOptions(false)
                };
            });
            if (findScope) {
                newDecorations.unshift({
                    range: findScope,
                    options: FindDecorations.createFindScopeDecorationOptions()
                });
            }
            var tmpDecorations = this._editor.deltaDecorations(this._allDecorations(), newDecorations);
            if (findScope) {
                this._findScopeDecorationId = tmpDecorations.shift();
            }
            else {
                this._findScopeDecorationId = null;
            }
            this._decorations = tmpDecorations;
            this._rangeHighlightDecorationId = null;
            this._highlightedDecorationId = null;
        };
        FindDecorations.prototype._allDecorations = function () {
            var result = [];
            result = result.concat(this._decorations);
            if (this._findScopeDecorationId) {
                result.push(this._findScopeDecorationId);
            }
            if (this._rangeHighlightDecorationId) {
                result.push(this._rangeHighlightDecorationId);
            }
            return result;
        };
        FindDecorations.createFindMatchDecorationOptions = function (isCurrent) {
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                className: isCurrent ? 'currentFindMatch' : 'findMatch',
                overviewRuler: {
                    color: 'rgba(246, 185, 77, 0.7)',
                    darkColor: 'rgba(246, 185, 77, 0.7)',
                    position: editorCommon.OverviewRulerLane.Center
                }
            };
        };
        FindDecorations.createRangeHighlightDecoration = function () {
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                className: 'rangeHighlight',
                isWholeLine: true
            };
        };
        FindDecorations.createFindScopeDecorationOptions = function () {
            return {
                className: 'findScope',
                isWholeLine: true
            };
        };
        return FindDecorations;
    }());
    exports.FindDecorations = FindDecorations;
});

define(__m[137/*vs/editor/contrib/find/common/findModel*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,3/*vs/base/common/lifecycle*/,221/*vs/editor/contrib/find/common/replacePattern*/,62/*vs/editor/common/commands/replaceCommand*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,396/*vs/editor/contrib/find/common/findDecorations*/,220/*vs/editor/contrib/find/common/replaceAllCommand*/,20/*vs/editor/common/core/selection*/]), function (require, exports, async_1, lifecycle_1, replacePattern_1, replaceCommand_1, position_1, range_1, editorCommon, findDecorations_1, replaceAllCommand_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ToggleCaseSensitiveKeybinding = {
        primary: 512 /* Alt */ | 33 /* KEY_C */,
        mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 33 /* KEY_C */ }
    };
    exports.ToggleWholeWordKeybinding = {
        primary: 512 /* Alt */ | 53 /* KEY_W */,
        mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 53 /* KEY_W */ }
    };
    exports.ToggleRegexKeybinding = {
        primary: 512 /* Alt */ | 48 /* KEY_R */,
        mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 48 /* KEY_R */ }
    };
    exports.ShowPreviousFindTermKeybinding = {
        primary: 512 /* Alt */ | 16 /* UpArrow */
    };
    exports.ShowNextFindTermKeybinding = {
        primary: 512 /* Alt */ | 18 /* DownArrow */
    };
    exports.FIND_IDS = {
        StartFindAction: 'actions.find',
        NextMatchFindAction: 'editor.action.nextMatchFindAction',
        PreviousMatchFindAction: 'editor.action.previousMatchFindAction',
        NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',
        PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',
        AddSelectionToNextFindMatchAction: 'editor.action.addSelectionToNextFindMatch',
        AddSelectionToPreviousFindMatchAction: 'editor.action.addSelectionToPreviousFindMatch',
        MoveSelectionToNextFindMatchAction: 'editor.action.moveSelectionToNextFindMatch',
        MoveSelectionToPreviousFindMatchAction: 'editor.action.moveSelectionToPreviousFindMatch',
        StartFindReplaceAction: 'editor.action.startFindReplaceAction',
        CloseFindWidgetCommand: 'closeFindWidget',
        ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',
        ToggleWholeWordCommand: 'toggleFindWholeWord',
        ToggleRegexCommand: 'toggleFindRegex',
        ReplaceOneAction: 'editor.action.replaceOne',
        ReplaceAllAction: 'editor.action.replaceAll',
        SelectAllMatchesAction: 'editor.action.selectAllMatches',
        ShowPreviousFindTermAction: 'find.history.showPrevious',
        ShowNextFindTermAction: 'find.history.showNext'
    };
    exports.MATCHES_LIMIT = 999;
    var FindModelBoundToEditorModel = (function () {
        function FindModelBoundToEditorModel(editor, state) {
            var _this = this;
            this._editor = editor;
            this._state = state;
            this._toDispose = [];
            this._isDisposed = false;
            this._decorations = new findDecorations_1.FindDecorations(editor);
            this._toDispose.push(this._decorations);
            this._updateDecorationsScheduler = new async_1.RunOnceScheduler(function () { return _this.research(false); }, 100);
            this._toDispose.push(this._updateDecorationsScheduler);
            this._toDispose.push(this._editor.onDidChangeCursorPosition(function (e) {
                if (e.reason === editorCommon.CursorChangeReason.Explicit
                    || e.reason === editorCommon.CursorChangeReason.Undo
                    || e.reason === editorCommon.CursorChangeReason.Redo) {
                    _this._decorations.setStartPosition(_this._editor.getPosition());
                }
            }));
            this._ignoreModelContentChanged = false;
            this._toDispose.push(this._editor.onDidChangeModelRawContent(function (e) {
                if (_this._ignoreModelContentChanged) {
                    return;
                }
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    _this._decorations.reset();
                }
                _this._decorations.setStartPosition(_this._editor.getPosition());
                _this._updateDecorationsScheduler.schedule();
            }));
            this._toDispose.push(this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            this.research(false, this._state.searchScope);
        }
        FindModelBoundToEditorModel.prototype.dispose = function () {
            this._isDisposed = true;
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        FindModelBoundToEditorModel.prototype._onStateChanged = function (e) {
            if (this._isDisposed) {
                // The find model is disposed during a find state changed event
                return;
            }
            if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
                if (e.searchScope) {
                    this.research(e.moveCursor, this._state.searchScope);
                }
                else {
                    this.research(e.moveCursor);
                }
            }
        };
        FindModelBoundToEditorModel._getSearchRange = function (model, searchOnlyEditableRange, findScope) {
            var searchRange;
            if (searchOnlyEditableRange) {
                searchRange = model.getEditableRange();
            }
            else {
                searchRange = model.getFullModelRange();
            }
            // If we have set now or before a find scope, use it for computing the search range
            if (findScope) {
                searchRange = searchRange.intersectRanges(findScope);
            }
            return searchRange;
        };
        FindModelBoundToEditorModel.prototype.research = function (moveCursor, newFindScope) {
            var findScope = null;
            if (typeof newFindScope !== 'undefined') {
                findScope = newFindScope;
            }
            else {
                findScope = this._decorations.getFindScope();
            }
            if (findScope !== null) {
                findScope = new range_1.Range(findScope.startLineNumber, 1, findScope.endLineNumber, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber));
            }
            var findMatches = this._findMatches(findScope, false, exports.MATCHES_LIMIT);
            this._decorations.set(findMatches.map(function (match) { return match.range; }), findScope);
            this._state.changeMatchInfo(this._decorations.getCurrentMatchesPosition(this._editor.getSelection()), this._decorations.getCount(), undefined);
            if (moveCursor) {
                this._moveToNextMatch(this._decorations.getStartPosition());
            }
        };
        FindModelBoundToEditorModel.prototype._hasMatches = function () {
            return (this._state.matchesCount > 0);
        };
        FindModelBoundToEditorModel.prototype._cannotFind = function () {
            if (!this._hasMatches()) {
                var findScope = this._decorations.getFindScope();
                if (findScope) {
                    // Reveal the selection so user is reminded that 'selection find' is on.
                    this._editor.revealRangeInCenterIfOutsideViewport(findScope);
                }
                return true;
            }
            return false;
        };
        FindModelBoundToEditorModel.prototype._setCurrentFindMatch = function (match) {
            var matchesPosition = this._decorations.setCurrentFindMatch(match);
            this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
            this._editor.setSelection(match);
            this._editor.revealRangeInCenterIfOutsideViewport(match);
        };
        FindModelBoundToEditorModel.prototype._moveToPrevMatch = function (before, isRecursed) {
            if (isRecursed === void 0) { isRecursed = false; }
            if (this._cannotFind()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            // ...(----)...|...
            if (searchRange.getEndPosition().isBefore(before)) {
                before = searchRange.getEndPosition();
            }
            // ...|...(----)...
            if (before.isBefore(searchRange.getStartPosition())) {
                before = searchRange.getEndPosition();
            }
            var lineNumber = before.lineNumber, column = before.column;
            var model = this._editor.getModel();
            var position = new position_1.Position(lineNumber, column);
            var prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord, false);
            if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
                // Looks like we're stuck at this position, unacceptable!
                var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0
                    || this._state.searchString.indexOf('$') >= 0);
                if (isUsingLineStops || column === 1) {
                    if (lineNumber === 1) {
                        lineNumber = model.getLineCount();
                    }
                    else {
                        lineNumber--;
                    }
                    column = model.getLineMaxColumn(lineNumber);
                }
                else {
                    column--;
                }
                position = new position_1.Position(lineNumber, column);
                prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord, false);
            }
            if (!prevMatch) {
                // there is precisely one match and selection is on top of it
                return null;
            }
            if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
                return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
            }
            this._setCurrentFindMatch(prevMatch.range);
        };
        FindModelBoundToEditorModel.prototype.moveToPrevMatch = function () {
            this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
        };
        FindModelBoundToEditorModel.prototype._moveToNextMatch = function (after) {
            var nextMatch = this._getNextMatch(after, false);
            if (nextMatch) {
                this._setCurrentFindMatch(nextMatch.range);
            }
        };
        FindModelBoundToEditorModel.prototype._getNextMatch = function (after, captureMatches, isRecursed) {
            if (isRecursed === void 0) { isRecursed = false; }
            if (this._cannotFind()) {
                return null;
            }
            var findScope = this._decorations.getFindScope();
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            // ...(----)...|...
            if (searchRange.getEndPosition().isBefore(after)) {
                after = searchRange.getStartPosition();
            }
            // ...|...(----)...
            if (after.isBefore(searchRange.getStartPosition())) {
                after = searchRange.getStartPosition();
            }
            var lineNumber = after.lineNumber, column = after.column;
            var model = this._editor.getModel();
            var position = new position_1.Position(lineNumber, column);
            var nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord, captureMatches);
            if (nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
                // Looks like we're stuck at this position, unacceptable!
                var isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf('^') >= 0
                    || this._state.searchString.indexOf('$') >= 0);
                if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
                    if (lineNumber === model.getLineCount()) {
                        lineNumber = 1;
                    }
                    else {
                        lineNumber++;
                    }
                    column = 1;
                }
                else {
                    column++;
                }
                position = new position_1.Position(lineNumber, column);
                nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord, captureMatches);
            }
            if (!nextMatch) {
                // there is precisely one match and selection is on top of it
                return null;
            }
            if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
                return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, true);
            }
            return nextMatch;
        };
        FindModelBoundToEditorModel.prototype.moveToNextMatch = function () {
            this._moveToNextMatch(this._editor.getSelection().getEndPosition());
        };
        FindModelBoundToEditorModel.prototype._getReplacePattern = function () {
            if (this._state.isRegex) {
                return replacePattern_1.parseReplaceString(this._state.replaceString);
            }
            return replacePattern_1.ReplacePattern.fromStaticValue(this._state.replaceString);
        };
        FindModelBoundToEditorModel.prototype.replace = function () {
            if (!this._hasMatches()) {
                return;
            }
            var replacePattern = this._getReplacePattern();
            var selection = this._editor.getSelection();
            var nextMatch = this._getNextMatch(selection.getStartPosition(), replacePattern.hasReplacementPatterns);
            if (nextMatch) {
                if (selection.equalsRange(nextMatch.range)) {
                    // selection sits on a find match => replace it!
                    var replaceString = replacePattern.buildReplaceString(nextMatch.matches);
                    var command = new replaceCommand_1.ReplaceCommand(selection, replaceString);
                    this._executeEditorCommand('replace', command);
                    this._decorations.setStartPosition(new position_1.Position(selection.startLineNumber, selection.startColumn + replaceString.length));
                    this.research(true);
                }
                else {
                    this._decorations.setStartPosition(this._editor.getPosition());
                    this._setCurrentFindMatch(nextMatch.range);
                }
            }
        };
        FindModelBoundToEditorModel.prototype._findMatches = function (findScope, captureMatches, limitResultCount) {
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            return this._editor.getModel().findMatches(this._state.searchString, searchRange, this._state.isRegex, this._state.matchCase, this._state.wholeWord, captureMatches, limitResultCount);
        };
        FindModelBoundToEditorModel.prototype.replaceAll = function () {
            if (!this._hasMatches()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            var replacePattern = this._getReplacePattern();
            // Get all the ranges (even more than the highlighted ones)
            var matches = this._findMatches(findScope, replacePattern.hasReplacementPatterns, Number.MAX_VALUE);
            var replaceStrings = [];
            for (var i = 0, len = matches.length; i < len; i++) {
                replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches);
            }
            var command = new replaceAllCommand_1.ReplaceAllCommand(this._editor.getSelection(), matches.map(function (m) { return m.range; }), replaceStrings);
            this._executeEditorCommand('replaceAll', command);
            this.research(false);
        };
        FindModelBoundToEditorModel.prototype.selectAllMatches = function () {
            if (!this._hasMatches()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            // Get all the ranges (even more than the highlighted ones)
            var matches = this._findMatches(findScope, false, Number.MAX_VALUE);
            var selections = matches.map(function (m) { return new selection_1.Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn); });
            // If one of the ranges is the editor selection, then maintain it as primary
            var editorSelection = this._editor.getSelection();
            for (var i = 0, len = selections.length; i < len; i++) {
                var sel = selections[i];
                if (sel.equalsRange(editorSelection)) {
                    selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
                    break;
                }
            }
            this._editor.setSelections(selections);
        };
        FindModelBoundToEditorModel.prototype._executeEditorCommand = function (source, command) {
            try {
                this._ignoreModelContentChanged = true;
                this._editor.executeCommand(source, command);
            }
            finally {
                this._ignoreModelContentChanged = false;
            }
        };
        return FindModelBoundToEditorModel;
    }());
    exports.FindModelBoundToEditorModel = FindModelBoundToEditorModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[398/*vs/editor/contrib/folding/common/foldingModel*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/,4/*vs/editor/common/core/range*/]), function (require, exports, editorCommon, range_1) {
    "use strict";
    function toString(range) {
        return (range ? range.startLineNumber + '/' + range.endLineNumber : 'null') + (range.isCollapsed ? ' (collapsed)' : '') + ' - ' + range.indent;
    }
    exports.toString = toString;
    var CollapsibleRegion = (function () {
        function CollapsibleRegion(range, model, changeAccessor) {
            this.decorationIds = [];
            this.update(range, model, changeAccessor);
        }
        Object.defineProperty(CollapsibleRegion.prototype, "isCollapsed", {
            get: function () {
                return this._isCollapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "isExpanded", {
            get: function () {
                return !this._isCollapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "indent", {
            get: function () {
                return this._indent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "foldingRange", {
            get: function () {
                return this._lastRange;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "startLineNumber", {
            get: function () {
                return this._lastRange ? this._lastRange.startLineNumber : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "endLineNumber", {
            get: function () {
                return this._lastRange ? this._lastRange.endLineNumber : void 0;
            },
            enumerable: true,
            configurable: true
        });
        CollapsibleRegion.prototype.setCollapsed = function (isCollaped, changeAccessor) {
            this._isCollapsed = isCollaped;
            if (this.decorationIds.length > 0) {
                changeAccessor.changeDecorationOptions(this.decorationIds[0], this.getVisualDecorationOptions());
            }
        };
        CollapsibleRegion.prototype.getDecorationRange = function (model) {
            if (this.decorationIds.length > 0) {
                return model.getDecorationRange(this.decorationIds[1]);
            }
            return null;
        };
        CollapsibleRegion.prototype.getVisualDecorationOptions = function () {
            if (this._isCollapsed) {
                return {
                    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    inlineClassName: 'inline-folded',
                    linesDecorationsClassName: 'folding collapsed'
                };
            }
            else {
                return {
                    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    linesDecorationsClassName: 'folding'
                };
            }
        };
        CollapsibleRegion.prototype.getRangeDecorationOptions = function () {
            return {
                stickiness: editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
            };
        };
        CollapsibleRegion.prototype.update = function (newRange, model, changeAccessor) {
            this._lastRange = newRange;
            this._isCollapsed = !!newRange.isCollapsed;
            this._indent = newRange.indent;
            var newDecorations = [];
            var maxColumn = model.getLineMaxColumn(newRange.startLineNumber);
            var visualRng = {
                startLineNumber: newRange.startLineNumber,
                startColumn: maxColumn - 1,
                endLineNumber: newRange.startLineNumber,
                endColumn: maxColumn
            };
            newDecorations.push({ range: visualRng, options: this.getVisualDecorationOptions() });
            var colRng = {
                startLineNumber: newRange.startLineNumber,
                startColumn: 1,
                endLineNumber: newRange.endLineNumber,
                endColumn: model.getLineMaxColumn(newRange.endLineNumber)
            };
            newDecorations.push({ range: colRng, options: this.getRangeDecorationOptions() });
            this.decorationIds = changeAccessor.deltaDecorations(this.decorationIds, newDecorations);
        };
        CollapsibleRegion.prototype.dispose = function (changeAccessor) {
            this._lastRange = null;
            this.decorationIds = changeAccessor.deltaDecorations(this.decorationIds, []);
        };
        CollapsibleRegion.prototype.toString = function () {
            var str = this.isCollapsed ? 'collapsed ' : 'expanded ';
            if (this._lastRange) {
                str += (this._lastRange.startLineNumber + '/' + this._lastRange.endLineNumber);
            }
            else {
                str += 'no range';
            }
            return str;
        };
        return CollapsibleRegion;
    }());
    exports.CollapsibleRegion = CollapsibleRegion;
    function getCollapsibleRegionsToFoldAtLine(allRegions, model, lineNumber, levels, up) {
        var surroundingRegion = getCollapsibleRegionAtLine(allRegions, model, lineNumber);
        if (!surroundingRegion) {
            return [];
        }
        if (levels === 1) {
            return [surroundingRegion];
        }
        var result = getCollapsibleRegionsFor(surroundingRegion, allRegions, model, levels, up);
        return result.filter(function (collapsibleRegion) { return !collapsibleRegion.isCollapsed; });
    }
    exports.getCollapsibleRegionsToFoldAtLine = getCollapsibleRegionsToFoldAtLine;
    function getCollapsibleRegionsToUnfoldAtLine(allRegions, model, lineNumber, levels) {
        var surroundingRegion = getCollapsibleRegionAtLine(allRegions, model, lineNumber);
        if (!surroundingRegion) {
            return [];
        }
        if (levels === 1) {
            var regionToUnfold = surroundingRegion.isCollapsed ? surroundingRegion : getFoldedCollapsibleRegionAfterLine(allRegions, model, surroundingRegion, lineNumber);
            return regionToUnfold ? [regionToUnfold] : [];
        }
        var result = getCollapsibleRegionsFor(surroundingRegion, allRegions, model, levels, false);
        return result.filter(function (collapsibleRegion) { return collapsibleRegion.isCollapsed; });
    }
    exports.getCollapsibleRegionsToUnfoldAtLine = getCollapsibleRegionsToUnfoldAtLine;
    function getCollapsibleRegionAtLine(allRegions, model, lineNumber) {
        var collapsibleRegion = null;
        for (var i = 0, len = allRegions.length; i < len; i++) {
            var dec = allRegions[i];
            var decRange = dec.getDecorationRange(model);
            if (decRange) {
                if (doesLineBelongsToCollapsibleRegion(decRange, lineNumber)) {
                    collapsibleRegion = dec;
                }
                if (doesCollapsibleRegionIsAfterLine(decRange, lineNumber)) {
                    break;
                }
            }
        }
        return collapsibleRegion;
    }
    function getFoldedCollapsibleRegionAfterLine(allRegions, model, surroundingRegion, lineNumber) {
        var index = allRegions.indexOf(surroundingRegion);
        for (var i = index + 1; i < allRegions.length; i++) {
            var dec = allRegions[i];
            var decRange = dec.getDecorationRange(model);
            if (decRange) {
                if (doesCollapsibleRegionIsAfterLine(decRange, lineNumber)) {
                    if (!doesCollapsibleRegionContains(surroundingRegion.foldingRange, decRange)) {
                        return null;
                    }
                    if (dec.isCollapsed) {
                        return dec;
                    }
                }
            }
        }
        return null;
    }
    function doesLineBelongsToCollapsibleRegion(range, lineNumber) {
        return lineNumber >= range.startLineNumber && lineNumber <= range.endLineNumber;
    }
    exports.doesLineBelongsToCollapsibleRegion = doesLineBelongsToCollapsibleRegion;
    function doesCollapsibleRegionIsAfterLine(range, lineNumber) {
        return lineNumber < range.startLineNumber;
    }
    function doesCollapsibleRegionIsBeforeLine(range, lineNumber) {
        return lineNumber > range.endLineNumber;
    }
    function doesCollapsibleRegionContains(range1, range2) {
        if (range1 instanceof range_1.Range && range2 instanceof range_1.Range) {
            return range1.containsRange(range2);
        }
        return range1.startLineNumber <= range2.startLineNumber && range1.endLineNumber >= range2.endLineNumber;
    }
    function getCollapsibleRegionsFor(surroundingRegion, allRegions, model, levels, up) {
        var collapsibleRegionsHierarchy = up ? new CollapsibleRegionsParentHierarchy(surroundingRegion, allRegions, model) : new CollapsibleRegionsChildrenHierarchy(surroundingRegion, allRegions, model);
        return collapsibleRegionsHierarchy.getRegionsTill(levels);
    }
    var CollapsibleRegionsChildrenHierarchy = (function () {
        function CollapsibleRegionsChildrenHierarchy(region, allRegions, model) {
            this.region = region;
            this.children = [];
            for (var index = allRegions.indexOf(region) + 1; index < allRegions.length; index++) {
                var dec = allRegions[index];
                var decRange = dec.getDecorationRange(model);
                if (decRange) {
                    if (doesCollapsibleRegionContains(region.foldingRange, decRange)) {
                        index = this.processChildRegion(dec, allRegions, model, index);
                    }
                    if (doesCollapsibleRegionIsAfterLine(decRange, region.foldingRange.endLineNumber)) {
                        break;
                    }
                }
            }
        }
        CollapsibleRegionsChildrenHierarchy.prototype.processChildRegion = function (dec, allRegions, model, index) {
            var childRegion = new CollapsibleRegionsChildrenHierarchy(dec, allRegions, model);
            this.children.push(childRegion);
            this.lastChildIndex = index;
            return childRegion.children.length > 0 ? childRegion.lastChildIndex : index;
        };
        CollapsibleRegionsChildrenHierarchy.prototype.getRegionsTill = function (level) {
            var result = [this.region];
            if (level > 1) {
                this.children.forEach(function (region) { return result = result.concat(region.getRegionsTill(level - 1)); });
            }
            return result;
        };
        return CollapsibleRegionsChildrenHierarchy;
    }());
    var CollapsibleRegionsParentHierarchy = (function () {
        function CollapsibleRegionsParentHierarchy(region, allRegions, model) {
            this.region = region;
            for (var index = allRegions.indexOf(region) - 1; index >= 0; index--) {
                var dec = allRegions[index];
                var decRange = dec.getDecorationRange(model);
                if (decRange) {
                    if (doesCollapsibleRegionContains(decRange, region.foldingRange)) {
                        this.parent = new CollapsibleRegionsParentHierarchy(dec, allRegions, model);
                        break;
                    }
                    if (doesCollapsibleRegionIsBeforeLine(decRange, region.foldingRange.endLineNumber)) {
                        break;
                    }
                }
            }
        }
        CollapsibleRegionsParentHierarchy.prototype.getRegionsTill = function (level) {
            var result = [this.region];
            if (this.parent && level > 1) {
                result = result.concat(this.parent.getRegionsTill(level - 1));
            }
            return result;
        };
        return CollapsibleRegionsParentHierarchy;
    }());
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[399/*vs/platform/actions/common/menu*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,18/*vs/platform/contextkey/common/contextkey*/,59/*vs/platform/actions/common/actions*/,22/*vs/platform/commands/common/commands*/]), function (require, exports, event_1, lifecycle_1, contextkey_1, actions_1, commands_1) {
    'use strict';
    var Menu = (function () {
        function Menu(id, startupSignal, _commandService, _contextKeyService) {
            var _this = this;
            this._commandService = _commandService;
            this._contextKeyService = _contextKeyService;
            this._menuGroups = [];
            this._disposables = [];
            this._onDidChange = new event_1.Emitter();
            startupSignal.then(function (_) {
                var menuItems = actions_1.MenuRegistry.getMenuItems(id);
                var keysFilter = new Set();
                var group;
                menuItems.sort(Menu._compareMenuItems);
                for (var _i = 0, menuItems_1 = menuItems; _i < menuItems_1.length; _i++) {
                    var item = menuItems_1[_i];
                    // group by groupId
                    var groupName = item.group;
                    if (!group || group[0] !== groupName) {
                        group = [groupName, []];
                        _this._menuGroups.push(group);
                    }
                    group[1].push(item);
                    // keep keys for eventing
                    Menu._fillInKbExprKeys(item.when, keysFilter);
                }
                // subscribe to context changes
                _this._disposables.push(_this._contextKeyService.onDidChangeContext(function (keys) {
                    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                        var k = keys_1[_i];
                        if (keysFilter.has(k)) {
                            _this._onDidChange.fire();
                            return;
                        }
                    }
                }));
                _this._onDidChange.fire(_this);
            });
        }
        Menu.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._onDidChange.dispose();
        };
        Object.defineProperty(Menu.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Menu.prototype.getActions = function (arg) {
            var result = [];
            for (var _i = 0, _a = this._menuGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                var id = group[0], items = group[1];
                var activeActions = [];
                for (var _b = 0, items_1 = items; _b < items_1.length; _b++) {
                    var item = items_1[_b];
                    if (this._contextKeyService.contextMatchesRules(item.when)) {
                        var action = new actions_1.MenuItemAction(item.command, item.alt, arg, this._commandService);
                        action.order = item.order; //TODO@Ben order is menu item property, not an action property
                        activeActions.push(action);
                    }
                }
                if (activeActions.length > 0) {
                    result.push([id, activeActions]);
                }
            }
            return result;
        };
        Menu._fillInKbExprKeys = function (exp, set) {
            if (exp) {
                for (var _i = 0, _a = exp.keys(); _i < _a.length; _i++) {
                    var key = _a[_i];
                    set.add(key);
                }
            }
        };
        Menu._compareMenuItems = function (a, b) {
            var aGroup = a.group;
            var bGroup = b.group;
            if (aGroup !== bGroup) {
                // Falsy groups come last
                if (!aGroup) {
                    return 1;
                }
                else if (!bGroup) {
                    return -1;
                }
                // 'navigation' group comes first
                if (aGroup === 'navigation') {
                    return -1;
                }
                else if (bGroup === 'navigation') {
                    return 1;
                }
                // lexical sort for groups
                var value = aGroup.localeCompare(bGroup);
                if (value !== 0) {
                    return value;
                }
            }
            // sort on priority - default is 0
            var aPrio = a.order || 0;
            var bPrio = b.order || 0;
            if (aPrio < bPrio) {
                return -1;
            }
            else if (aPrio > bPrio) {
                return 1;
            }
            // sort on titles
            return a.command.title.localeCompare(b.command.title);
        };
        return Menu;
    }());
    Menu = __decorate([
        __param(2, commands_1.ICommandService),
        __param(3, contextkey_1.IContextKeyService)
    ], Menu);
    exports.Menu = Menu;
});

define(__m[58/*vs/platform/contextview/browser/contextView*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IContextViewService = instantiation_1.createDecorator('contextViewService');
    exports.IContextMenuService = instantiation_1.createDecorator('contextMenuService');
    var ContextSubMenu = (function () {
        function ContextSubMenu(label, entries) {
            this.label = label;
            this.entries = entries;
            // noop
        }
        return ContextSubMenu;
    }());
    exports.ContextSubMenu = ContextSubMenu;
});

define(__m[57/*vs/platform/editor/common/editor*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    /**
     * Possible locations for opening an editor.
     */
    var Position;
    (function (Position) {
        /** Opens the editor in the first position replacing the input currently showing */
        Position[Position["ONE"] = 0] = "ONE";
        /** Opens the editor in the second position replacing the input currently showing */
        Position[Position["TWO"] = 1] = "TWO";
        /** Opens the editor in the third most position replacing the input currently showing */
        Position[Position["THREE"] = 2] = "THREE";
    })(Position = exports.Position || (exports.Position = {}));
    exports.POSITIONS = [Position.ONE, Position.TWO, Position.THREE];
    var Direction;
    (function (Direction) {
        Direction[Direction["LEFT"] = 0] = "LEFT";
        Direction[Direction["RIGHT"] = 1] = "RIGHT";
    })(Direction = exports.Direction || (exports.Direction = {}));
});






define(__m[402/*vs/platform/files/common/files*/], __M([1/*require*/,0/*exports*/,39/*vs/base/common/paths*/,67/*vs/base/common/events*/,19/*vs/base/common/platform*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, paths, events, platform_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IFileService = instantiation_1.createDecorator('fileService');
    var FileOperation;
    (function (FileOperation) {
        FileOperation[FileOperation["CREATE"] = 0] = "CREATE";
        FileOperation[FileOperation["DELETE"] = 1] = "DELETE";
        FileOperation[FileOperation["MOVE"] = 2] = "MOVE";
        FileOperation[FileOperation["COPY"] = 3] = "COPY";
        FileOperation[FileOperation["IMPORT"] = 4] = "IMPORT";
    })(FileOperation = exports.FileOperation || (exports.FileOperation = {}));
    var FileOperationEvent = (function () {
        function FileOperationEvent(_resource, _operation, _target) {
            this._resource = _resource;
            this._operation = _operation;
            this._target = _target;
        }
        Object.defineProperty(FileOperationEvent.prototype, "resource", {
            get: function () {
                return this._resource;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileOperationEvent.prototype, "operation", {
            get: function () {
                return this._operation;
            },
            enumerable: true,
            configurable: true
        });
        return FileOperationEvent;
    }());
    exports.FileOperationEvent = FileOperationEvent;
    /**
     * Possible changes that can occur to a file.
     */
    var FileChangeType;
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangesEvent = (function (_super) {
        __extends(FileChangesEvent, _super);
        function FileChangesEvent(changes) {
            var _this = _super.call(this) || this;
            _this._changes = changes;
            return _this;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            return this._changes.some(function (change) {
                if (change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (type === FileChangeType.DELETED) {
                    return isEqual(resource.fsPath, change.resource.fsPath) || isParent(resource.fsPath, change.resource.fsPath);
                }
                return isEqual(resource.fsPath, change.resource.fsPath);
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(FileChangeType.ADDED);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(FileChangeType.ADDED);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(FileChangeType.DELETED);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(FileChangeType.DELETED);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(FileChangeType.UPDATED);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(FileChangeType.UPDATED);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }(events.Event));
    exports.FileChangesEvent = FileChangesEvent;
    function isEqual(path1, path2) {
        var identityEquals = (path1 === path2);
        if (platform_1.isLinux || identityEquals) {
            return identityEquals;
        }
        return path1.toLowerCase() === path2.toLowerCase();
    }
    exports.isEqual = isEqual;
    function isParent(path, candidate) {
        if (!platform_1.isLinux) {
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        return path.indexOf(candidate + paths.nativeSep) === 0;
    }
    exports.isParent = isParent;
    var FileOperationResult;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
        FileOperationResult[FileOperationResult["FILE_INVALID_PATH"] = 8] = "FILE_INVALID_PATH";
    })(FileOperationResult = exports.FileOperationResult || (exports.FileOperationResult = {}));
    exports.MAX_FILE_SIZE = 50 * 1024 * 1024;
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange',
        ON_WINDOW_CHANGE: 'onWindowChange'
    };
    exports.HotExitConfiguration = {
        OFF: 'off',
        ON_EXIT: 'onExit',
        ON_EXIT_AND_WINDOW_CLOSE: 'onExitAndWindowClose'
    };
    exports.CONTENT_CHANGE_EVENT_BUFFER_DELAY = 1000;
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        cp852: {
            labelLong: 'Central European (CP 852)',
            labelShort: 'CP 852',
            order: 18
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 19
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 20
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 21
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 22
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 23
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 24
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 25
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 26
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 27
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 28
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 29
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 30
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 31
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 32
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 33
        },
        gbk: {
            labelLong: 'Chinese (GBK)',
            labelShort: 'GBK',
            order: 34
        },
        gb18030: {
            labelLong: 'Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 35
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 36
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 37
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 38
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 39
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 40
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 41
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 42
        },
        'koi8-ru': {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 43
        },
        'koi8-t': {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 44
        },
        GB2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 45
        }
    };
});

define(__m[79/*vs/platform/instantiation/common/serviceCollection*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ServiceCollection = (function () {
        function ServiceCollection() {
            var entries = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                entries[_i] = arguments[_i];
            }
            this._entries = new Map();
            for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
                var _b = entries_1[_a], id = _b[0], service = _b[1];
                this.set(id, service);
            }
        }
        ServiceCollection.prototype.set = function (id, instanceOrDescriptor) {
            var result = this._entries.get(id);
            this._entries.set(id, instanceOrDescriptor);
            return result;
        };
        ServiceCollection.prototype.forEach = function (callback) {
            this._entries.forEach(function (value, key) { return callback(key, value); });
        };
        ServiceCollection.prototype.has = function (id) {
            return this._entries.has(id);
        };
        ServiceCollection.prototype.get = function (id) {
            return this._entries.get(id);
        };
        return ServiceCollection;
    }());
    exports.ServiceCollection = ServiceCollection;
});






define(__m[404/*vs/editor/common/commonCodeEditor*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,12/*vs/base/common/event*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,79/*vs/platform/instantiation/common/serviceCollection*/,18/*vs/platform/contextkey/common/contextkey*/,44/*vs/editor/common/config/defaultConfig*/,352/*vs/editor/common/controller/cursor*/,41/*vs/editor/common/controller/cursorCommon*/,340/*vs/editor/common/core/editorState*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,161/*vs/editor/common/editorAction*/,2/*vs/editor/common/editorCommon*/,366/*vs/editor/common/viewModel/characterHardWrappingLineMapper*/,130/*vs/editor/common/viewModel/splitLinesCollection*/,395/*vs/editor/common/viewModel/viewModelImpl*/,211/*vs/base/common/hash*/,358/*vs/editor/common/modes/editorModeContext*/,59/*vs/platform/actions/common/actions*/,22/*vs/platform/commands/common/commands*/]), function (require, exports, errors_1, event_1, eventEmitter_1, lifecycle_1, winjs_base_1, serviceCollection_1, contextkey_1, defaultConfig_1, cursor_1, cursorCommon_1, editorState_1, position_1, range_1, selection_1, editorAction_1, editorCommon, characterHardWrappingLineMapper_1, splitLinesCollection_1, viewModelImpl_1, hash_1, editorModeContext_1, actions_1, commands_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var EDITOR_ID = 0;
    var CommonCodeEditor = (function (_super) {
        __extends(CommonCodeEditor, _super);
        function CommonCodeEditor(domElement, options, instantiationService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this.onDidChangeModelRawContent = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelRawContentChanged);
            _this.onDidChangeModelContent = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelContentChanged2);
            _this.onDidChangeModelLanguage = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelLanguageChanged);
            _this.onDidChangeModelOptions = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelOptionsChanged);
            _this.onDidChangeModelDecorations = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelDecorationsChanged);
            _this.onDidChangeConfiguration = event_1.fromEventEmitter(_this, editorCommon.EventType.ConfigurationChanged);
            _this.onDidChangeModel = event_1.fromEventEmitter(_this, editorCommon.EventType.ModelChanged);
            _this.onDidChangeCursorPosition = event_1.fromEventEmitter(_this, editorCommon.EventType.CursorPositionChanged);
            _this.onDidChangeCursorSelection = event_1.fromEventEmitter(_this, editorCommon.EventType.CursorSelectionChanged);
            _this.onDidFocusEditorText = event_1.fromEventEmitter(_this, editorCommon.EventType.EditorTextFocus);
            _this.onDidBlurEditorText = event_1.fromEventEmitter(_this, editorCommon.EventType.EditorTextBlur);
            _this.onDidFocusEditor = event_1.fromEventEmitter(_this, editorCommon.EventType.EditorFocus);
            _this.onDidBlurEditor = event_1.fromEventEmitter(_this, editorCommon.EventType.EditorBlur);
            _this.onDidDispose = event_1.fromEventEmitter(_this, editorCommon.EventType.Disposed);
            _this.onWillType = event_1.fromEventEmitter(_this, editorCommon.EventType.WillType);
            _this.onDidType = event_1.fromEventEmitter(_this, editorCommon.EventType.DidType);
            _this.domElement = domElement;
            _this.id = (++EDITOR_ID);
            // listeners that are kept during the whole editor lifetime
            _this._lifetimeDispose = [];
            _this._decorationTypeKeysToIds = {};
            _this._decorationTypeSubtypes = {};
            options = options || {};
            if (typeof options.ariaLabel === 'undefined') {
                options.ariaLabel = defaultConfig_1.DefaultConfig.editor.ariaLabel;
            }
            _this._configuration = _this._createConfiguration(options);
            _this._lifetimeDispose.push(_this._configuration.onDidChange(function (e) {
                _this.emit(editorCommon.EventType.ConfigurationChanged, e);
            }));
            _this._contextKeyService = contextKeyService.createScoped(_this.domElement);
            _this._lifetimeDispose.push(new EditorContextKeysManager(_this, _this._contextKeyService));
            _this._lifetimeDispose.push(new editorModeContext_1.EditorModeContext(_this, _this._contextKeyService));
            _this._instantiationService = instantiationService.createChild(new serviceCollection_1.ServiceCollection([contextkey_1.IContextKeyService, _this._contextKeyService]));
            _this._attachModel(null);
            _this._contributions = {};
            _this._actions = {};
            return _this;
        }
        CommonCodeEditor.prototype.getId = function () {
            return this.getEditorType() + ':' + this.id;
        };
        CommonCodeEditor.prototype.getEditorType = function () {
            return editorCommon.EditorType.ICodeEditor;
        };
        CommonCodeEditor.prototype.destroy = function () {
            this.dispose();
        };
        CommonCodeEditor.prototype.dispose = function () {
            this._lifetimeDispose = lifecycle_1.dispose(this._lifetimeDispose);
            var keys = Object.keys(this._contributions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var contributionId = keys[i];
                this._contributions[contributionId].dispose();
            }
            this._contributions = {};
            // editor actions don't need to be disposed
            this._actions = {};
            this._postDetachModelCleanup(this._detachModel());
            this._configuration.dispose();
            this._contextKeyService.dispose();
            this.emit(editorCommon.EventType.Disposed);
            _super.prototype.dispose.call(this);
        };
        CommonCodeEditor.prototype.captureState = function () {
            var flags = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                flags[_i] = arguments[_i];
            }
            return new editorState_1.EditorState(this, flags);
        };
        CommonCodeEditor.prototype.invokeWithinContext = function (fn) {
            return this._instantiationService.invokeFunction(fn);
        };
        CommonCodeEditor.prototype.updateOptions = function (newOptions) {
            this._configuration.updateOptions(newOptions);
        };
        CommonCodeEditor.prototype.getConfiguration = function () {
            return this._configuration.editorClone;
        };
        CommonCodeEditor.prototype.getRawConfiguration = function () {
            return this._configuration.getRawOptions();
        };
        CommonCodeEditor.prototype.getValue = function (options) {
            if (options === void 0) { options = null; }
            if (this.model) {
                var preserveBOM = (options && options.preserveBOM) ? true : false;
                var eolPreference = editorCommon.EndOfLinePreference.TextDefined;
                if (options && options.lineEnding && options.lineEnding === '\n') {
                    eolPreference = editorCommon.EndOfLinePreference.LF;
                }
                else if (options && options.lineEnding && options.lineEnding === '\r\n') {
                    eolPreference = editorCommon.EndOfLinePreference.CRLF;
                }
                return this.model.getValue(eolPreference, preserveBOM);
            }
            return '';
        };
        CommonCodeEditor.prototype.setValue = function (newValue) {
            if (this.model) {
                this.model.setValue(newValue);
            }
        };
        CommonCodeEditor.prototype.getModel = function () {
            return this.model;
        };
        CommonCodeEditor.prototype.setModel = function (model) {
            if (model === void 0) { model = null; }
            if (this.model === model) {
                // Current model is the new model
                return;
            }
            var detachedModel = this._detachModel();
            this._attachModel(model);
            var e = {
                oldModelUrl: detachedModel ? detachedModel.uri : null,
                newModelUrl: model ? model.uri : null
            };
            this.emit(editorCommon.EventType.ModelChanged, e);
            this._postDetachModelCleanup(detachedModel);
        };
        CommonCodeEditor.prototype.getVisibleColumnFromPosition = function (rawPosition) {
            if (!this.model) {
                return rawPosition.column;
            }
            var position = this.model.validatePosition(rawPosition);
            var tabSize = this.model.getOptions().tabSize;
            return cursorCommon_1.CursorColumns.visibleColumnFromColumn(this.model.getLineContent(position.lineNumber), position.column, tabSize) + 1;
        };
        CommonCodeEditor.prototype.getPosition = function () {
            if (!this.cursor) {
                return null;
            }
            return this.cursor.getPosition().clone();
        };
        CommonCodeEditor.prototype.setPosition = function (position, reveal, revealVerticalInCenter, revealHorizontal) {
            if (reveal === void 0) { reveal = false; }
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            if (!this.cursor) {
                return;
            }
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this.cursor.setSelections('api', [{
                    selectionStartLineNumber: position.lineNumber,
                    selectionStartColumn: position.column,
                    positionLineNumber: position.lineNumber,
                    positionColumn: position.column
                }]);
            if (reveal) {
                this.revealPosition(position, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype._sendRevealRange = function (range, verticalType, revealHorizontal) {
            if (!this.model || !this.cursor) {
                return;
            }
            if (!range_1.Range.isIRange(range)) {
                throw new Error('Invalid arguments');
            }
            var validatedRange = this.model.validateRange(range);
            var revealRangeEvent = {
                range: validatedRange,
                viewRange: null,
                verticalType: verticalType,
                revealHorizontal: revealHorizontal,
                revealCursor: false
            };
            this.cursor.emit(editorCommon.EventType.CursorRevealRange, revealRangeEvent);
        };
        CommonCodeEditor.prototype.revealLine = function (lineNumber) {
            this._revealLine(lineNumber, 0 /* Simple */);
        };
        CommonCodeEditor.prototype.revealLineInCenter = function (lineNumber) {
            this._revealLine(lineNumber, 1 /* Center */);
        };
        CommonCodeEditor.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber) {
            this._revealLine(lineNumber, 2 /* CenterIfOutsideViewport */);
        };
        CommonCodeEditor.prototype._revealLine = function (lineNumber, revealType) {
            if (typeof lineNumber !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange(new range_1.Range(lineNumber, 1, lineNumber, 1), revealType, false);
        };
        CommonCodeEditor.prototype.revealPosition = function (position, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            this._revealPosition(position, revealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, revealHorizontal);
        };
        CommonCodeEditor.prototype.revealPositionInCenter = function (position) {
            this._revealPosition(position, 1 /* Center */, true);
        };
        CommonCodeEditor.prototype.revealPositionInCenterIfOutsideViewport = function (position) {
            this._revealPosition(position, 2 /* CenterIfOutsideViewport */, true);
        };
        CommonCodeEditor.prototype._revealPosition = function (position, verticalType, revealHorizontal) {
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), verticalType, revealHorizontal);
        };
        CommonCodeEditor.prototype.getSelection = function () {
            if (!this.cursor) {
                return null;
            }
            return this.cursor.getSelection().clone();
        };
        CommonCodeEditor.prototype.getSelections = function () {
            if (!this.cursor) {
                return null;
            }
            var selections = this.cursor.getSelections();
            var result = [];
            for (var i = 0, len = selections.length; i < len; i++) {
                result[i] = selections[i].clone();
            }
            return result;
        };
        CommonCodeEditor.prototype.setSelection = function (something, reveal, revealVerticalInCenter, revealHorizontal) {
            if (reveal === void 0) { reveal = false; }
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            var isSelection = selection_1.Selection.isISelection(something);
            var isRange = range_1.Range.isIRange(something);
            if (!isSelection && !isRange) {
                throw new Error('Invalid arguments');
            }
            if (isSelection) {
                this._setSelectionImpl(something, reveal, revealVerticalInCenter, revealHorizontal);
            }
            else if (isRange) {
                // act as if it was an IRange
                var selection = {
                    selectionStartLineNumber: something.startLineNumber,
                    selectionStartColumn: something.startColumn,
                    positionLineNumber: something.endLineNumber,
                    positionColumn: something.endColumn
                };
                this._setSelectionImpl(selection, reveal, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype._setSelectionImpl = function (sel, reveal, revealVerticalInCenter, revealHorizontal) {
            if (!this.cursor) {
                return;
            }
            var selection = new selection_1.Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
            this.cursor.setSelections('api', [selection]);
            if (reveal) {
                this.revealRange(selection, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype.revealLines = function (startLineNumber, endLineNumber) {
            this._revealLines(startLineNumber, endLineNumber, 0 /* Simple */);
        };
        CommonCodeEditor.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber) {
            this._revealLines(startLineNumber, endLineNumber, 1 /* Center */);
        };
        CommonCodeEditor.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber) {
            this._revealLines(startLineNumber, endLineNumber, 2 /* CenterIfOutsideViewport */);
        };
        CommonCodeEditor.prototype._revealLines = function (startLineNumber, endLineNumber, verticalType) {
            if (typeof startLineNumber !== 'number' || typeof endLineNumber !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange(new range_1.Range(startLineNumber, 1, endLineNumber, 1), verticalType, false);
        };
        CommonCodeEditor.prototype.revealRange = function (range, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = true; }
            this._revealRange(range, revealVerticalInCenter ? 1 /* Center */ : 0 /* Simple */, revealHorizontal);
        };
        CommonCodeEditor.prototype.revealRangeInCenter = function (range) {
            this._revealRange(range, 1 /* Center */, true);
        };
        CommonCodeEditor.prototype.revealRangeInCenterIfOutsideViewport = function (range) {
            this._revealRange(range, 2 /* CenterIfOutsideViewport */, true);
        };
        CommonCodeEditor.prototype._revealRange = function (range, verticalType, revealHorizontal) {
            if (!range_1.Range.isIRange(range)) {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange(range_1.Range.lift(range), verticalType, revealHorizontal);
        };
        CommonCodeEditor.prototype.setSelections = function (ranges) {
            if (!this.cursor) {
                return;
            }
            if (!ranges || ranges.length === 0) {
                throw new Error('Invalid arguments');
            }
            for (var i = 0, len = ranges.length; i < len; i++) {
                if (!selection_1.Selection.isISelection(ranges[i])) {
                    throw new Error('Invalid arguments');
                }
            }
            this.cursor.setSelections('api', ranges);
        };
        CommonCodeEditor.prototype.onVisible = function () {
        };
        CommonCodeEditor.prototype.onHide = function () {
        };
        CommonCodeEditor.prototype.getContribution = function (id) {
            return (this._contributions[id] || null);
        };
        CommonCodeEditor.prototype._addAction = function (descriptor) {
            var _this = this;
            if ((typeof descriptor.id !== 'string')
                || (typeof descriptor.label !== 'string')
                || (typeof descriptor.run !== 'function')) {
                throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');
            }
            var toDispose = [];
            // Generate a unique id to allow the same descriptor.id across multiple editor instances
            var uniqueId = this.getId() + ':' + descriptor.id;
            var action = new editorAction_1.DynamicEditorAction(descriptor, this);
            // Register the command
            toDispose.push(commands_1.CommandsRegistry.registerCommand(uniqueId, function () { return action.run(); }));
            if (descriptor.contextMenuGroupId) {
                var menuItem = {
                    command: {
                        id: uniqueId,
                        title: descriptor.label
                    },
                    when: contextkey_1.ContextKeyExpr.equals('editorId', this.getId()),
                    group: descriptor.contextMenuGroupId,
                    order: descriptor.contextMenuOrder || 0
                };
                // Register the menu item
                toDispose.push(actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorContext, menuItem));
            }
            this._actions[action.id] = action;
            toDispose.push({
                dispose: function () {
                    delete _this._actions[action.id];
                }
            });
            return {
                uniqueId: uniqueId,
                disposable: lifecycle_1.combinedDisposable(toDispose)
            };
        };
        CommonCodeEditor.prototype.getActions = function () {
            var result = [];
            var keys = Object.keys(this._actions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                result.push(this._actions[id]);
            }
            return result;
        };
        CommonCodeEditor.prototype.getSupportedActions = function () {
            var result = this.getActions();
            result = result.filter(function (action) { return action.isSupported(); });
            return result;
        };
        CommonCodeEditor.prototype.getAction = function (id) {
            return this._actions[id] || null;
        };
        CommonCodeEditor.prototype.trigger = function (source, handlerId, payload) {
            payload = payload || {};
            // Special case for typing
            if (handlerId === editorCommon.Handler.Type) {
                if (!this.cursor || typeof payload.text !== 'string' || payload.text.length === 0) {
                    // nothing to do
                    return;
                }
                if (source === 'keyboard') {
                    this.emit(editorCommon.EventType.WillType, payload.text);
                }
                this.cursor.trigger(source, handlerId, payload);
                if (source === 'keyboard') {
                    this.emit(editorCommon.EventType.DidType, payload.text);
                }
                return;
            }
            var candidate = this.getAction(handlerId);
            if (candidate !== null) {
                winjs_base_1.TPromise.as(candidate.run()).done(null, errors_1.onUnexpectedError);
            }
            else {
                if (!this.cursor) {
                    return;
                }
                this.cursor.trigger(source, handlerId, payload);
            }
        };
        CommonCodeEditor.prototype.executeCommand = function (source, command) {
            if (!this.cursor) {
                return;
            }
            this.cursor.trigger(source, editorCommon.Handler.ExecuteCommand, command);
        };
        CommonCodeEditor.prototype.pushUndoStop = function () {
            if (!this.cursor) {
                // no view, no cursor
                return false;
            }
            if (this._configuration.editor.readOnly) {
                // read only editor => sorry!
                return false;
            }
            this.model.pushStackElement();
            return true;
        };
        CommonCodeEditor.prototype.executeEdits = function (source, edits, endCursorState) {
            var _this = this;
            if (!this.cursor) {
                // no view, no cursor
                return false;
            }
            if (this._configuration.editor.readOnly) {
                // read only editor => sorry!
                return false;
            }
            this.model.pushEditOperations(this.cursor.getSelections(), edits, function () {
                return endCursorState ? endCursorState : _this.cursor.getSelections();
            });
            if (endCursorState) {
                this.cursor.setSelections(source, endCursorState);
            }
            return true;
        };
        CommonCodeEditor.prototype.executeCommands = function (source, commands) {
            if (!this.cursor) {
                return;
            }
            this.cursor.trigger(source, editorCommon.Handler.ExecuteCommands, commands);
        };
        CommonCodeEditor.prototype.changeDecorations = function (callback) {
            if (!this.model) {
                //			console.warn('Cannot change decorations on editor that is not attached to a model');
                // callback will not be called
                return null;
            }
            return this.model.changeDecorations(callback, this.id);
        };
        CommonCodeEditor.prototype.getLineDecorations = function (lineNumber) {
            if (!this.model) {
                return null;
            }
            return this.model.getLineDecorations(lineNumber, this.id, this._configuration.editor.readOnly);
        };
        CommonCodeEditor.prototype.deltaDecorations = function (oldDecorations, newDecorations) {
            if (!this.model) {
                return [];
            }
            if (oldDecorations.length === 0 && newDecorations.length === 0) {
                return oldDecorations;
            }
            return this.model.deltaDecorations(oldDecorations, newDecorations, this.id);
        };
        CommonCodeEditor.prototype.setDecorations = function (decorationTypeKey, decorationOptions) {
            var newDecorationsSubTypes = {};
            var oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
            this._decorationTypeSubtypes[decorationTypeKey] = newDecorationsSubTypes;
            var newModelDecorations = [];
            for (var _i = 0, decorationOptions_1 = decorationOptions; _i < decorationOptions_1.length; _i++) {
                var decorationOption = decorationOptions_1[_i];
                var typeKey = decorationTypeKey;
                if (decorationOption.renderOptions) {
                    // identify custom reder options by a hash code over all keys and values
                    // For custom render options register a decoration type if necessary
                    var subType = hash_1.hash(decorationOption.renderOptions).toString(16);
                    // The fact that `decorationTypeKey` appears in the typeKey has no influence
                    // it is just a mechanism to get predictable and unique keys (repeatable for the same options and unique across clients)
                    typeKey = decorationTypeKey + '-' + subType;
                    if (!oldDecorationsSubTypes[subType] && !newDecorationsSubTypes[subType]) {
                        // decoration type did not exist before, register new one
                        this._registerDecorationType(typeKey, decorationOption.renderOptions, decorationTypeKey);
                    }
                    newDecorationsSubTypes[subType] = true;
                }
                var opts = this._resolveDecorationOptions(typeKey, !!decorationOption.hoverMessage);
                if (decorationOption.hoverMessage) {
                    opts.hoverMessage = decorationOption.hoverMessage;
                }
                newModelDecorations.push({ range: decorationOption.range, options: opts });
            }
            // remove decoration sub types that are no longer used, deregister decoration type if necessary
            for (var subType in oldDecorationsSubTypes) {
                if (!newDecorationsSubTypes[subType]) {
                    this._removeDecorationType(decorationTypeKey + '-' + subType);
                }
            }
            // update all decorations
            var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
            this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
        };
        CommonCodeEditor.prototype.removeDecorations = function (decorationTypeKey) {
            // remove decorations for type and sub type
            var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
            if (oldDecorationsIds) {
                this.deltaDecorations(oldDecorationsIds, []);
            }
            if (this._decorationTypeKeysToIds.hasOwnProperty(decorationTypeKey)) {
                delete this._decorationTypeKeysToIds[decorationTypeKey];
            }
            if (this._decorationTypeSubtypes.hasOwnProperty(decorationTypeKey)) {
                delete this._decorationTypeSubtypes[decorationTypeKey];
            }
        };
        CommonCodeEditor.prototype.getLayoutInfo = function () {
            return this._configuration.editor.layoutInfo;
        };
        CommonCodeEditor.prototype._attachModel = function (model) {
            var _this = this;
            this.model = model ? model : null;
            this.listenersToRemove = [];
            this.viewModel = null;
            this.cursor = null;
            if (this.model) {
                this.domElement.setAttribute('data-mode-id', this.model.getLanguageIdentifier().language);
                this._configuration.setIsDominatedByLongLines(this.model.isDominatedByLongLines());
                this.model.onBeforeAttached();
                var hardWrappingLineMapperFactory = new characterHardWrappingLineMapper_1.CharacterHardWrappingLineMapperFactory(this._configuration.editor.wrappingInfo.wordWrapBreakBeforeCharacters, this._configuration.editor.wrappingInfo.wordWrapBreakAfterCharacters, this._configuration.editor.wrappingInfo.wordWrapBreakObtrusiveCharacters);
                var linesCollection = new splitLinesCollection_1.SplitLinesCollection(this.model, hardWrappingLineMapperFactory, this.model.getOptions().tabSize, this._configuration.editor.wrappingInfo.wrappingColumn, this._configuration.editor.fontInfo.typicalFullwidthCharacterWidth / this._configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, this._configuration.editor.wrappingInfo.wrappingIndent);
                this.viewModel = new viewModelImpl_1.ViewModel(linesCollection, this.id, this._configuration, this.model, function () { return _this.getCenteredRangeInViewport(); });
                var viewModelHelper = {
                    viewModel: this.viewModel,
                    getCurrentCompletelyVisibleViewLinesRangeInViewport: function () {
                        return _this.viewModel.convertModelRangeToViewRange(_this.getCompletelyVisibleLinesRangeInViewport());
                    },
                    getCurrentCompletelyVisibleModelLinesRangeInViewport: function () {
                        return _this.getCompletelyVisibleLinesRangeInViewport();
                    },
                    convertModelPositionToViewPosition: function (lineNumber, column) {
                        return _this.viewModel.convertModelPositionToViewPosition(lineNumber, column);
                    },
                    convertModelRangeToViewRange: function (modelRange) {
                        return _this.viewModel.convertModelRangeToViewRange(modelRange);
                    },
                    convertViewToModelPosition: function (lineNumber, column) {
                        return _this.viewModel.convertViewPositionToModelPosition(lineNumber, column);
                    },
                    convertViewSelectionToModelSelection: function (viewSelection) {
                        return _this.viewModel.convertViewSelectionToModelSelection(viewSelection);
                    },
                    validateViewPosition: function (viewPosition, modelPosition) {
                        return _this.viewModel.validateViewPosition(viewPosition.lineNumber, viewPosition.column, modelPosition);
                    },
                    validateViewRange: function (viewRange, modelRange) {
                        return _this.viewModel.validateViewRange(viewRange.startLineNumber, viewRange.startColumn, viewRange.endLineNumber, viewRange.endColumn, modelRange);
                    }
                };
                this.cursor = new cursor_1.Cursor(this._configuration, this.model, viewModelHelper, this._enableEmptySelectionClipboard());
                this.viewModel.addEventSource(this.cursor);
                this._createView();
                this.listenersToRemove.push(this._getViewInternalEventBus().addBulkListener2(function (events) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.ViewFocusGained:
                                _this.emit(editorCommon.EventType.EditorTextFocus);
                                // In IE, the focus is not synchronous, so we give it a little help
                                _this.emit(editorCommon.EventType.EditorFocus, {});
                                break;
                            case 'scroll':
                                _this.emit('scroll', e);
                                break;
                            case editorCommon.EventType.ViewFocusLost:
                                _this.emit(editorCommon.EventType.EditorTextBlur);
                                break;
                            case editorCommon.EventType.ContextMenu:
                                _this.emit(editorCommon.EventType.ContextMenu, e);
                                break;
                            case editorCommon.EventType.MouseDown:
                                _this.emit(editorCommon.EventType.MouseDown, e);
                                break;
                            case editorCommon.EventType.MouseUp:
                                _this.emit(editorCommon.EventType.MouseUp, e);
                                break;
                            case editorCommon.EventType.KeyUp:
                                _this.emit(editorCommon.EventType.KeyUp, e);
                                break;
                            case editorCommon.EventType.MouseMove:
                                _this.emit(editorCommon.EventType.MouseMove, e);
                                break;
                            case editorCommon.EventType.MouseLeave:
                                _this.emit(editorCommon.EventType.MouseLeave, e);
                                break;
                            case editorCommon.EventType.KeyDown:
                                _this.emit(editorCommon.EventType.KeyDown, e);
                                break;
                            case editorCommon.EventType.ViewLayoutChanged:
                                _this.emit(editorCommon.EventType.EditorLayout, e);
                                break;
                            default:
                        }
                    }
                }));
                this.listenersToRemove.push(this.model.addBulkListener(function (events) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.ModelDecorationsChanged:
                                _this.emit(editorCommon.EventType.ModelDecorationsChanged, e);
                                break;
                            case editorCommon.EventType.ModelLanguageChanged:
                                _this.domElement.setAttribute('data-mode-id', _this.model.getLanguageIdentifier().language);
                                _this.emit(editorCommon.EventType.ModelLanguageChanged, e);
                                break;
                            case editorCommon.EventType.ModelRawContentChanged:
                                _this.emit(editorCommon.EventType.ModelRawContentChanged, e);
                                break;
                            case editorCommon.EventType.ModelContentChanged2:
                                _this.emit(editorCommon.EventType.ModelContentChanged2, e);
                                break;
                            case editorCommon.EventType.ModelOptionsChanged:
                                _this.emit(editorCommon.EventType.ModelOptionsChanged, e);
                                break;
                            case editorCommon.EventType.ModelDispose:
                                // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model
                                _this.setModel(null);
                                break;
                            default:
                        }
                    }
                }));
                this.listenersToRemove.push(this.cursor.addBulkListener2(function (events) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.CursorPositionChanged:
                                _this.emit(editorCommon.EventType.CursorPositionChanged, e);
                                break;
                            case editorCommon.EventType.CursorSelectionChanged:
                                _this.emit(editorCommon.EventType.CursorSelectionChanged, e);
                                break;
                            default:
                        }
                    }
                }));
            }
            else {
                this.hasView = false;
            }
        };
        CommonCodeEditor.prototype._postDetachModelCleanup = function (detachedModel) {
            if (detachedModel) {
                this._decorationTypeKeysToIds = {};
                if (this._decorationTypeSubtypes) {
                    for (var decorationType in this._decorationTypeSubtypes) {
                        var subTypes = this._decorationTypeSubtypes[decorationType];
                        for (var subType in subTypes) {
                            this._removeDecorationType(decorationType + '-' + subType);
                        }
                    }
                    this._decorationTypeSubtypes = {};
                }
                detachedModel.removeAllDecorationsWithOwnerId(this.id);
            }
        };
        CommonCodeEditor.prototype._detachModel = function () {
            if (this.model) {
                this.model.onBeforeDetached();
            }
            this.hasView = false;
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            if (this.cursor) {
                this.cursor.dispose();
                this.cursor = null;
            }
            if (this.viewModel) {
                this.viewModel.dispose();
                this.viewModel = null;
            }
            var result = this.model;
            this.model = null;
            this.domElement.removeAttribute('data-mode-id');
            return result;
        };
        return CommonCodeEditor;
    }(eventEmitter_1.EventEmitter));
    exports.CommonCodeEditor = CommonCodeEditor;
    var EditorContextKeysManager = (function (_super) {
        __extends(EditorContextKeysManager, _super);
        function EditorContextKeysManager(editor, contextKeyService) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._editorId = contextKeyService.createKey('editorId', editor.getId());
            _this._editorFocus = EditorContextKeys.Focus.bindTo(contextKeyService);
            _this._editorTextFocus = EditorContextKeys.TextFocus.bindTo(contextKeyService);
            _this._editorTabMovesFocus = EditorContextKeys.TabMovesFocus.bindTo(contextKeyService);
            _this._editorReadonly = EditorContextKeys.ReadOnly.bindTo(contextKeyService);
            _this._hasMultipleSelections = EditorContextKeys.HasMultipleSelections.bindTo(contextKeyService);
            _this._hasNonEmptySelection = EditorContextKeys.HasNonEmptySelection.bindTo(contextKeyService);
            _this._register(_this._editor.onDidChangeConfiguration(function () { return _this._updateFromConfig(); }));
            _this._register(_this._editor.onDidChangeCursorSelection(function () { return _this._updateFromSelection(); }));
            _this._register(_this._editor.onDidFocusEditor(function () { return _this._updateFromFocus(); }));
            _this._register(_this._editor.onDidBlurEditor(function () { return _this._updateFromFocus(); }));
            _this._register(_this._editor.onDidFocusEditorText(function () { return _this._updateFromFocus(); }));
            _this._register(_this._editor.onDidBlurEditorText(function () { return _this._updateFromFocus(); }));
            _this._updateFromConfig();
            _this._updateFromSelection();
            _this._updateFromFocus();
            return _this;
        }
        EditorContextKeysManager.prototype._updateFromConfig = function () {
            var config = this._editor.getConfiguration();
            this._editorTabMovesFocus.set(config.tabFocusMode);
            this._editorReadonly.set(config.readOnly);
        };
        EditorContextKeysManager.prototype._updateFromSelection = function () {
            var selections = this._editor.getSelections();
            if (!selections) {
                this._hasMultipleSelections.reset();
                this._hasNonEmptySelection.reset();
            }
            else {
                this._hasMultipleSelections.set(selections.length > 1);
                this._hasNonEmptySelection.set(selections.some(function (s) { return !s.isEmpty(); }));
            }
        };
        EditorContextKeysManager.prototype._updateFromFocus = function () {
            this._editorFocus.set(this._editor.hasWidgetFocus());
            this._editorTextFocus.set(this._editor.isFocused());
        };
        return EditorContextKeysManager;
    }(lifecycle_1.Disposable));
});

define(__m[405/*vs/platform/instantiation/common/instantiationService*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,10/*vs/base/common/errors*/,24/*vs/base/common/types*/,63/*vs/base/common/assert*/,472/*vs/base/common/graph*/,143/*vs/platform/instantiation/common/descriptors*/,14/*vs/platform/instantiation/common/instantiation*/,79/*vs/platform/instantiation/common/serviceCollection*/]), function (require, exports, winjs_base_1, errors_1, types_1, assert, graph_1, descriptors_1, instantiation_1, serviceCollection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InstantiationService = (function () {
        function InstantiationService(services, strict) {
            if (services === void 0) { services = new serviceCollection_1.ServiceCollection(); }
            if (strict === void 0) { strict = false; }
            this._services = services;
            this._strict = strict;
            this._services.set(instantiation_1.IInstantiationService, this);
        }
        InstantiationService.prototype.createChild = function (services) {
            var _this = this;
            this._services.forEach(function (id, thing) {
                if (services.has(id)) {
                    return;
                }
                // If we copy descriptors we might end up with
                // multiple instances of the same service
                if (thing instanceof descriptors_1.SyncDescriptor) {
                    thing = _this._createAndCacheServiceInstance(id, thing);
                }
                services.set(id, thing);
            });
            return new InstantiationService(services, this._strict);
        };
        InstantiationService.prototype.invokeFunction = function (signature) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var accessor;
            try {
                accessor = {
                    get: function (id, isOptional) {
                        var result = _this._getOrCreateServiceInstance(id);
                        if (!result && isOptional !== instantiation_1.optional) {
                            throw new Error("[invokeFunction] unkown service '" + id + "'");
                        }
                        return result;
                    }
                };
                return signature.apply(undefined, [accessor].concat(args));
            }
            finally {
                accessor.get = function () {
                    throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');
                };
            }
        };
        InstantiationService.prototype.createInstance = function (param) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            if (param instanceof descriptors_1.AsyncDescriptor) {
                // async
                return this._createInstanceAsync(param, rest);
            }
            else if (param instanceof descriptors_1.SyncDescriptor) {
                // sync
                return this._createInstance(param, rest);
            }
            else {
                // sync, just ctor
                return this._createInstance(new descriptors_1.SyncDescriptor(param), rest);
            }
        };
        InstantiationService.prototype._createInstanceAsync = function (descriptor, args) {
            var _this = this;
            var canceledError;
            return new winjs_base_1.TPromise(function (c, e, p) {
                require([descriptor.moduleName], function (_module) {
                    if (canceledError) {
                        e(canceledError);
                    }
                    if (!_module) {
                        return e(errors_1.illegalArgument('module not found: ' + descriptor.moduleName));
                    }
                    var ctor;
                    if (!descriptor.ctorName) {
                        ctor = _module;
                    }
                    else {
                        ctor = _module[descriptor.ctorName];
                    }
                    if (typeof ctor !== 'function') {
                        return e(errors_1.illegalArgument('not a function: ' + descriptor.ctorName || descriptor.moduleName));
                    }
                    try {
                        args.unshift.apply(args, descriptor.staticArguments()); // instead of spread in ctor call
                        c(_this._createInstance(new descriptors_1.SyncDescriptor(ctor), args));
                    }
                    catch (error) {
                        return e(error);
                    }
                }, e);
            }, function () {
                canceledError = errors_1.canceled();
            });
        };
        InstantiationService.prototype._createInstance = function (desc, args) {
            // arguments given by createInstance-call and/or the descriptor
            var staticArgs = desc.staticArguments().concat(args);
            // arguments defined by service decorators
            var serviceDependencies = instantiation_1._util.getServiceDependencies(desc.ctor).sort(function (a, b) { return a.index - b.index; });
            var serviceArgs = [];
            for (var _i = 0, serviceDependencies_1 = serviceDependencies; _i < serviceDependencies_1.length; _i++) {
                var dependency = serviceDependencies_1[_i];
                var service = this._getOrCreateServiceInstance(dependency.id);
                if (!service && this._strict && !dependency.optional) {
                    throw new Error("[createInstance] " + desc.ctor.name + " depends on UNKNOWN service " + dependency.id + ".");
                }
                serviceArgs.push(service);
            }
            var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : staticArgs.length;
            // check for argument mismatches, adjust static args if needed
            if (staticArgs.length !== firstServiceArgPos) {
                console.warn("[createInstance] First service dependency of " + desc.ctor.name + " at position " + (firstServiceArgPos + 1) + " conflicts with " + staticArgs.length + " static arguments");
                var delta = firstServiceArgPos - staticArgs.length;
                if (delta > 0) {
                    staticArgs = staticArgs.concat(new Array(delta));
                }
                else {
                    staticArgs = staticArgs.slice(0, firstServiceArgPos);
                }
            }
            // // check for missing args
            // for (let i = 0; i < serviceArgs.length; i++) {
            // 	if (!serviceArgs[i]) {
            // 		console.warn(`${desc.ctor.name} MISSES service dependency ${serviceDependencies[i].id}`, new Error().stack);
            // 	}
            // }
            // now create the instance
            var argArray = [desc.ctor];
            argArray.push.apply(argArray, staticArgs);
            argArray.push.apply(argArray, serviceArgs);
            var instance = types_1.create.apply(null, argArray);
            desc._validate(instance);
            return instance;
        };
        InstantiationService.prototype._getOrCreateServiceInstance = function (id) {
            var thing = this._services.get(id);
            if (thing instanceof descriptors_1.SyncDescriptor) {
                return this._createAndCacheServiceInstance(id, thing);
            }
            else {
                return thing;
            }
        };
        InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc) {
            assert.ok(this._services.get(id) instanceof descriptors_1.SyncDescriptor);
            var graph = new graph_1.Graph(function (data) { return data.id.toString(); });
            function throwCycleError() {
                var err = new Error('[createInstance] cyclic dependency between services');
                err.message = graph.toString();
                throw err;
            }
            var count = 0;
            var stack = [{ id: id, desc: desc }];
            while (stack.length) {
                var item = stack.pop();
                graph.lookupOrInsertNode(item);
                // TODO@joh use the graph to find a cycle
                // a weak heuristic for cycle checks
                if (count++ > 100) {
                    throwCycleError();
                }
                // check all dependencies for existence and if the need to be created first
                var dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);
                for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                    var dependency = dependencies_1[_i];
                    var instanceOrDesc = this._services.get(dependency.id);
                    if (!instanceOrDesc) {
                        console.warn("[createInstance] " + id + " depends on " + dependency.id + " which is NOT registered.");
                    }
                    if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {
                        var d = { id: dependency.id, desc: instanceOrDesc };
                        graph.insertEdge(item, d);
                        stack.push(d);
                    }
                }
            }
            while (true) {
                var roots = graph.roots();
                // if there is no more roots but still
                // nodes in the graph we have a cycle
                if (roots.length === 0) {
                    if (graph.length !== 0) {
                        throwCycleError();
                    }
                    break;
                }
                for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                    var root = roots_1[_a];
                    // create instance and overwrite the service collections
                    var instance = this._createInstance(root.data.desc, []);
                    this._services.set(root.data.id, instance);
                    graph.removeNode(root.data);
                }
            }
            return this._services.get(id);
        };
        return InstantiationService;
    }());
    exports.InstantiationService = InstantiationService;
});

define(__m[406/*vs/platform/keybinding/common/abstractKeybindingService*/], __M([1/*require*/,0/*exports*/,317/*vs/nls!vs/platform/keybinding/common/abstractKeybindingService*/,32/*vs/base/common/keyCodes*/,132/*vs/base/common/keybinding*/,3/*vs/base/common/lifecycle*/,30/*vs/base/common/severity*/,28/*vs/base/common/arrays*/,22/*vs/platform/commands/common/commands*/,12/*vs/base/common/event*/]), function (require, exports, nls, keyCodes_1, keybinding_1, lifecycle_1, severity_1, arrays_1, commands_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractKeybindingService = (function () {
        function AbstractKeybindingService(contextKeyService, commandService, messageService, statusService) {
            this.toDispose = [];
            this._contextKeyService = contextKeyService;
            this._commandService = commandService;
            this._statusService = statusService;
            this._messageService = messageService;
            this._currentChord = 0;
            this._currentChordStatusMessage = null;
            this._onDidUpdateKeybindings = new event_1.Emitter();
            this.toDispose.push(this._onDidUpdateKeybindings);
        }
        AbstractKeybindingService.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        Object.defineProperty(AbstractKeybindingService.prototype, "onDidUpdateKeybindings", {
            get: function () {
                return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : event_1.default.None; // Sinon stubbing walks properties on prototype
            },
            enumerable: true,
            configurable: true
        });
        AbstractKeybindingService.prototype.getLabelFor = function (keybinding) {
            return keybinding_1.KeybindingLabels._toUSLabel(keybinding);
        };
        AbstractKeybindingService.prototype.getHTMLLabelFor = function (keybinding) {
            return keybinding_1.KeybindingLabels._toUSHTMLLabel(keybinding);
        };
        AbstractKeybindingService.prototype.getAriaLabelFor = function (keybinding) {
            return keybinding_1.KeybindingLabels._toUSAriaLabel(keybinding);
        };
        AbstractKeybindingService.prototype.getElectronAcceleratorFor = function (keybinding) {
            return keybinding_1.KeybindingLabels._toElectronAccelerator(keybinding);
        };
        AbstractKeybindingService.prototype.getDefaultKeybindings = function () {
            return this._getResolver().getDefaultKeybindings() + '\n\n' + this._getAllCommandsAsComment();
        };
        AbstractKeybindingService.prototype.customKeybindingsCount = function () {
            return 0;
        };
        AbstractKeybindingService.prototype.lookupKeybindings = function (commandId) {
            return this._getResolver().lookupKeybinding(commandId);
        };
        AbstractKeybindingService.prototype._getAllCommandsAsComment = function () {
            var commands = commands_1.CommandsRegistry.getCommands();
            var unboundCommands = [];
            var boundCommands = this._getResolver().getDefaultBoundCommands();
            for (var id in commands) {
                if (id[0] === '_' || id.indexOf('vscode.') === 0) {
                    continue;
                }
                if (typeof commands[id].description === 'object'
                    && !arrays_1.isFalsyOrEmpty(commands[id].description.args)) {
                    continue;
                }
                if (boundCommands[id]) {
                    continue;
                }
                unboundCommands.push(id);
            }
            var pretty = unboundCommands.sort().join('\n// - ');
            return '// ' + nls.localize(0, null) + '\n// - ' + pretty;
        };
        AbstractKeybindingService.prototype.resolve = function (keybinding, target) {
            if (keybinding.isModifierKey()) {
                return null;
            }
            var contextValue = this._contextKeyService.getContextValue(target);
            return this._getResolver().resolve(contextValue, this._currentChord, keybinding.value);
        };
        AbstractKeybindingService.prototype._dispatch = function (keybinding, target) {
            var _this = this;
            // Check modifier key here and cancel early, it's also checked in resolve as the function
            // is used externally.
            var shouldPreventDefault = false;
            if (keybinding.isModifierKey()) {
                return shouldPreventDefault;
            }
            var resolveResult = this.resolve(keybinding, target);
            if (resolveResult && resolveResult.enterChord) {
                shouldPreventDefault = true;
                this._currentChord = resolveResult.enterChord;
                if (this._statusService) {
                    var firstPartLabel = this.getLabelFor(new keyCodes_1.Keybinding(this._currentChord));
                    this._currentChordStatusMessage = this._statusService.setStatusMessage(nls.localize(1, null, firstPartLabel));
                }
                return shouldPreventDefault;
            }
            if (this._statusService && this._currentChord) {
                if (!resolveResult || !resolveResult.commandId) {
                    var firstPartLabel = this.getLabelFor(new keyCodes_1.Keybinding(this._currentChord));
                    var chordPartLabel = this.getLabelFor(keybinding);
                    this._statusService.setStatusMessage(nls.localize(2, null, firstPartLabel, chordPartLabel), 10 * 1000 /* 10s */);
                    shouldPreventDefault = true;
                }
            }
            if (this._currentChordStatusMessage) {
                this._currentChordStatusMessage.dispose();
                this._currentChordStatusMessage = null;
            }
            this._currentChord = 0;
            if (resolveResult && resolveResult.commandId) {
                if (!/^\^/.test(resolveResult.commandId)) {
                    shouldPreventDefault = true;
                }
                var commandId = resolveResult.commandId.replace(/^\^/, '');
                this._commandService.executeCommand(commandId, resolveResult.commandArgs || {}).done(undefined, function (err) {
                    _this._messageService.show(severity_1.default.Warning, err);
                });
            }
            return shouldPreventDefault;
        };
        return AbstractKeybindingService;
    }());
    exports.AbstractKeybindingService = AbstractKeybindingService;
});

define(__m[42/*vs/platform/keybinding/common/keybinding*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KeybindingSource;
    (function (KeybindingSource) {
        KeybindingSource[KeybindingSource["Default"] = 1] = "Default";
        KeybindingSource[KeybindingSource["User"] = 2] = "User";
    })(KeybindingSource = exports.KeybindingSource || (exports.KeybindingSource = {}));
    exports.IKeybindingService = instantiation_1.createDecorator('keybindingService');
});

define(__m[142/*vs/platform/keybinding/common/keybindingResolver*/], __M([1/*require*/,0/*exports*/,32/*vs/base/common/keyCodes*/,132/*vs/base/common/keybinding*/,19/*vs/base/common/platform*/,18/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, keyCodes_1, keybinding_1, platform, contextkey_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NormalizedKeybindingItem = (function () {
        function NormalizedKeybindingItem(keybinding, command, commandArgs, when, isDefault) {
            this.keybinding = keybinding;
            this.command = command;
            this.commandArgs = commandArgs;
            this.actualCommand = this.command ? this.command.replace(/^\^/, '') : this.command;
            this.when = when;
            this.isDefault = isDefault;
        }
        NormalizedKeybindingItem.fromKeybindingItem = function (source, isDefault) {
            var when = null;
            if (source.when) {
                when = source.when.normalize();
            }
            return new NormalizedKeybindingItem(source.keybinding, source.command, source.commandArgs, when, isDefault);
        };
        return NormalizedKeybindingItem;
    }());
    exports.NormalizedKeybindingItem = NormalizedKeybindingItem;
    var KeybindingResolver = (function () {
        function KeybindingResolver(defaultKeybindings, overrides, shouldWarnOnConflict) {
            if (shouldWarnOnConflict === void 0) { shouldWarnOnConflict = true; }
            defaultKeybindings = defaultKeybindings.slice(0).sort(sorter);
            this._defaultKeybindings = defaultKeybindings;
            this._shouldWarnOnConflict = shouldWarnOnConflict;
            this._defaultBoundCommands = Object.create(null);
            for (var i = 0, len = defaultKeybindings.length; i < len; i++) {
                this._defaultBoundCommands[defaultKeybindings[i].command] = true;
            }
            this._map = Object.create(null);
            this._lookupMap = new Map();
            this._lookupMapUnreachable = new Map();
            this._chords = Object.create(null);
            var allKeybindings = KeybindingResolver.combine(defaultKeybindings, overrides);
            for (var i = 0, len = allKeybindings.length; i < len; i++) {
                var k = allKeybindings[i];
                if (k.keybinding === 0) {
                    continue;
                }
                var entry = {
                    when: k.when,
                    keybinding: k.keybinding,
                    commandId: k.command,
                    commandArgs: k.commandArgs
                };
                if (keyCodes_1.BinaryKeybindings.hasChord(k.keybinding)) {
                    // This is a chord
                    var keybindingFirstPart = keyCodes_1.BinaryKeybindings.extractFirstPart(k.keybinding);
                    var keybindingChordPart = keyCodes_1.BinaryKeybindings.extractChordPart(k.keybinding);
                    this._chords[keybindingFirstPart] = this._chords[keybindingFirstPart] || Object.create(null);
                    this._chords[keybindingFirstPart][keybindingChordPart] = this._chords[keybindingFirstPart][keybindingChordPart] || [];
                    this._chords[keybindingFirstPart][keybindingChordPart].push(entry);
                    this._addKeyPress(keybindingFirstPart, entry, k);
                }
                else {
                    this._addKeyPress(k.keybinding, entry, k);
                }
            }
        }
        KeybindingResolver._isTargetedForRemoval = function (defaultKb, keybinding, command, when) {
            if (defaultKb.actualCommand !== command) {
                return false;
            }
            if (keybinding) {
                if (defaultKb.keybinding !== keybinding) {
                    return false;
                }
            }
            if (when) {
                if (!defaultKb.when) {
                    return false;
                }
                if (!when.equals(defaultKb.when)) {
                    return false;
                }
            }
            return true;
        };
        KeybindingResolver.combine = function (rawDefaults, rawOverrides) {
            var defaults = rawDefaults.map(function (kb) { return NormalizedKeybindingItem.fromKeybindingItem(kb, true); });
            var overrides = [];
            for (var i = 0, len = rawOverrides.length; i < len; i++) {
                var override = NormalizedKeybindingItem.fromKeybindingItem(rawOverrides[i], false);
                if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {
                    overrides.push(override);
                    continue;
                }
                var commandToRemove = override.command.substr(1);
                var keybindingToRemove = override.keybinding;
                var whenToRemove = override.when;
                for (var j = defaults.length - 1; j >= 0; j--) {
                    if (this._isTargetedForRemoval(defaults[j], keybindingToRemove, commandToRemove, whenToRemove)) {
                        defaults.splice(j, 1);
                    }
                }
            }
            return defaults.concat(overrides);
        };
        KeybindingResolver.prototype._addKeyPress = function (keypress, entry, item) {
            if (!this._map[keypress]) {
                // There is no conflict so far
                this._map[keypress] = [entry];
                this._addToLookupMap(item);
                return;
            }
            var conflicts = this._map[keypress];
            for (var i = conflicts.length - 1; i >= 0; i--) {
                var conflict = conflicts[i];
                if (conflict.commandId === item.command) {
                    continue;
                }
                if (keyCodes_1.BinaryKeybindings.hasChord(conflict.keybinding) && keyCodes_1.BinaryKeybindings.hasChord(entry.keybinding) && conflict.keybinding !== entry.keybinding) {
                    // The conflict only shares the chord start with this command
                    continue;
                }
                if (KeybindingResolver.whenIsEntirelyIncluded(true, conflict.when, item.when)) {
                    // `item` completely overwrites `conflict`
                    if (this._shouldWarnOnConflict && item.isDefault) {
                        console.warn('Conflict detected, command `' + conflict.commandId + '` cannot be triggered by ' + keybinding_1.KeybindingLabels.toUserSettingsLabel(keypress) + ' due to ' + item.command);
                    }
                    KeybindingResolver._push(this._lookupMapUnreachable, conflict.commandId, conflict.keybinding);
                }
            }
            conflicts.push(entry);
            this._addToLookupMap(item);
        };
        /**
         * Returns true if `a` is completely covered by `b`.
         * Returns true if `b` is a more relaxed `a`.
         * Return true if (`a` === true implies `b` === true).
         */
        KeybindingResolver.whenIsEntirelyIncluded = function (inNormalizedForm, a, b) {
            if (!inNormalizedForm) {
                a = a ? a.normalize() : null;
                b = b ? b.normalize() : null;
            }
            if (!b) {
                return true;
            }
            if (!a) {
                return false;
            }
            var aRulesArr = a.serialize().split(' && ');
            var bRulesArr = b.serialize().split(' && ');
            var aRules = Object.create(null);
            for (var i = 0, len = aRulesArr.length; i < len; i++) {
                aRules[aRulesArr[i]] = true;
            }
            for (var i = 0, len = bRulesArr.length; i < len; i++) {
                if (!aRules[bRulesArr[i]]) {
                    return false;
                }
            }
            return true;
        };
        KeybindingResolver._push = function (map, key, value) {
            var oldRawEntries = map.get(key);
            if (typeof oldRawEntries === 'undefined') {
                var entries = new Uint32Array(1);
                entries[0] = value;
                map.set(key, entries.buffer);
            }
            else {
                var oldEntries = new Uint32Array(oldRawEntries);
                var newEntries = new Uint32Array(oldEntries.length + 1);
                newEntries.set(oldEntries, 0);
                newEntries[newEntries.length - 1] = value;
                map.set(key, newEntries.buffer);
            }
        };
        KeybindingResolver._read = function (map, key) {
            var arrBuff = map.get(key);
            if (typeof arrBuff === 'undefined') {
                return null;
            }
            var arr = new Uint32Array(arrBuff);
            var result = [];
            for (var i = 0, len = arr.length; i < len; i++) {
                result[i] = arr[i];
            }
            return result;
        };
        KeybindingResolver.prototype._addToLookupMap = function (item) {
            if (!item.command) {
                return;
            }
            KeybindingResolver._push(this._lookupMap, item.command, item.keybinding);
        };
        KeybindingResolver.prototype.getDefaultBoundCommands = function () {
            return this._defaultBoundCommands;
        };
        KeybindingResolver.prototype.getDefaultKeybindings = function () {
            var out = new OutputBuilder();
            out.writeLine('[');
            var lastIndex = this._defaultKeybindings.length - 1;
            this._defaultKeybindings.forEach(function (k, index) {
                IOSupport.writeKeybindingItem(out, k);
                if (index !== lastIndex) {
                    out.writeLine(',');
                }
                else {
                    out.writeLine();
                }
            });
            out.writeLine(']');
            return out.toString();
        };
        KeybindingResolver.prototype.lookupKeybinding = function (commandId) {
            var possibleTriggers = KeybindingResolver._read(this._lookupMap, commandId);
            if (!possibleTriggers) {
                return [];
            }
            var remove = KeybindingResolver._read(this._lookupMapUnreachable, commandId);
            if (remove) {
                possibleTriggers = possibleTriggers.filter(function (possibleTrigger) {
                    return remove.indexOf(possibleTrigger) === -1;
                });
            }
            var seenKeys = [];
            var result = possibleTriggers.filter(function (possibleTrigger) {
                if (seenKeys.indexOf(possibleTrigger) >= 0) {
                    return false;
                }
                seenKeys.push(possibleTrigger);
                return true;
            });
            return result.map(function (trigger) {
                return new keyCodes_1.Keybinding(trigger);
            }).reverse(); // sort most specific to the top
        };
        KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {
            // console.log('resolve: ' + Keybinding.toUserSettingsLabel(keypress));
            var lookupMap = null;
            if (currentChord !== 0) {
                var chords = this._chords[currentChord];
                if (!chords) {
                    return null;
                }
                lookupMap = chords[keypress];
            }
            else {
                lookupMap = this._map[keypress];
            }
            var result = this._findCommand(context, lookupMap);
            if (!result) {
                return null;
            }
            if (currentChord === 0 && keyCodes_1.BinaryKeybindings.hasChord(result.keybinding)) {
                return {
                    enterChord: keypress,
                    commandId: null,
                    commandArgs: null
                };
            }
            return {
                enterChord: 0,
                commandId: result.commandId,
                commandArgs: result.commandArgs
            };
        };
        KeybindingResolver.prototype._findCommand = function (context, matches) {
            if (!matches) {
                return null;
            }
            for (var i = matches.length - 1; i >= 0; i--) {
                var k = matches[i];
                if (!KeybindingResolver.contextMatchesRules(context, k.when)) {
                    continue;
                }
                return k;
            }
            return null;
        };
        KeybindingResolver.contextMatchesRules = function (context, rules) {
            if (!rules) {
                return true;
            }
            return rules.evaluate(context);
        };
        return KeybindingResolver;
    }());
    exports.KeybindingResolver = KeybindingResolver;
    function rightPaddedString(str, minChars) {
        if (str.length < minChars) {
            return str + (new Array(minChars - str.length).join(' '));
        }
        return str;
    }
    function sorter(a, b) {
        if (a.weight1 !== b.weight1) {
            return a.weight1 - b.weight1;
        }
        if (a.command < b.command) {
            return -1;
        }
        if (a.command > b.command) {
            return 1;
        }
        return a.weight2 - b.weight2;
    }
    var OutputBuilder = (function () {
        function OutputBuilder() {
            this._lines = [];
            this._currentLine = '';
        }
        OutputBuilder.prototype.write = function (str) {
            this._currentLine += str;
        };
        OutputBuilder.prototype.writeLine = function (str) {
            if (str === void 0) { str = ''; }
            this._lines.push(this._currentLine + str);
            this._currentLine = '';
        };
        OutputBuilder.prototype.toString = function () {
            this.writeLine();
            return this._lines.join('\n');
        };
        return OutputBuilder;
    }());
    exports.OutputBuilder = OutputBuilder;
    var IOSupport = (function () {
        function IOSupport() {
        }
        IOSupport.writeKeybindingItem = function (out, item) {
            var quotedSerializedKeybinding = JSON.stringify(IOSupport.writeKeybinding(item.keybinding));
            out.write("{ \"key\": " + rightPaddedString(quotedSerializedKeybinding + ',', 25) + " \"command\": ");
            var serializedWhen = item.when ? item.when.serialize() : '';
            var quotedSerializeCommand = JSON.stringify(item.command);
            if (serializedWhen.length > 0) {
                out.write(quotedSerializeCommand + ",");
                out.writeLine();
                out.write("                                     \"when\": \"" + serializedWhen + "\" ");
            }
            else {
                out.write(quotedSerializeCommand + " ");
            }
            // out.write(String(item.weight1 + '-' + item.weight2));
            out.write('}');
        };
        IOSupport.readKeybindingItem = function (input, index) {
            var key = 0;
            if (typeof input.key === 'string') {
                key = IOSupport.readKeybinding(input.key);
            }
            var when = null;
            if (typeof input.when === 'string') {
                when = IOSupport.readKeybindingWhen(input.when);
            }
            var command = null;
            if (typeof input.command === 'string') {
                command = input.command;
            }
            var commandArgs = null;
            if (typeof input.args !== 'undefined') {
                commandArgs = input.args;
            }
            return {
                keybinding: key,
                command: command,
                commandArgs: commandArgs,
                when: when,
                weight1: 1000,
                weight2: index
            };
        };
        IOSupport.writeKeybinding = function (input, Platform) {
            if (Platform === void 0) { Platform = platform; }
            return keybinding_1.KeybindingLabels.toUserSettingsLabel(input, Platform);
        };
        IOSupport.readKeybinding = function (input, Platform) {
            if (Platform === void 0) { Platform = platform; }
            return keybinding_1.KeybindingLabels.fromUserSettingsLabel(input, Platform);
        };
        IOSupport.readKeybindingWhen = function (input) {
            return contextkey_1.ContextKeyExpr.deserialize(input);
        };
        return IOSupport;
    }());
    exports.IOSupport = IOSupport;
});















define(__m[409/*vs/platform/contextkey/browser/contextKeyService*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,22/*vs/platform/commands/common/commands*/,142/*vs/platform/keybinding/common/keybindingResolver*/,18/*vs/platform/contextkey/common/contextkey*/,56/*vs/platform/configuration/common/configuration*/,12/*vs/base/common/event*/]), function (require, exports, lifecycle_1, commands_1, keybindingResolver_1, contextkey_1, configuration_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KEYBINDING_CONTEXT_ATTR = 'data-keybinding-context';
    var ContextValuesContainer = (function () {
        function ContextValuesContainer(id, parent) {
            this._id = id;
            this._parent = parent;
            this._value = Object.create(null);
            this._value['_contextId'] = id;
        }
        ContextValuesContainer.prototype.setValue = function (key, value) {
            // console.log('SET ' + key + ' = ' + value + ' ON ' + this._id);
            if (this._value[key] !== value) {
                this._value[key] = value;
                return true;
            }
        };
        ContextValuesContainer.prototype.removeValue = function (key) {
            // console.log('REMOVE ' + key + ' FROM ' + this._id);
            return delete this._value[key];
        };
        ContextValuesContainer.prototype.getValue = function (key) {
            var ret = this._value[key];
            if (typeof ret === 'undefined' && this._parent) {
                return this._parent.getValue(key);
            }
            return ret;
        };
        ContextValuesContainer.prototype.fillInContext = function (bucket) {
            if (this._parent) {
                this._parent.fillInContext(bucket);
            }
            for (var key in this._value) {
                bucket[key] = this._value[key];
            }
        };
        return ContextValuesContainer;
    }());
    exports.ContextValuesContainer = ContextValuesContainer;
    var ConfigAwareContextValuesContainer = (function (_super) {
        __extends(ConfigAwareContextValuesContainer, _super);
        function ConfigAwareContextValuesContainer(id, configurationService, emitter) {
            var _this = _super.call(this, id, null) || this;
            _this._emitter = emitter;
            _this._subscription = configurationService.onDidUpdateConfiguration(function (e) { return _this._updateConfigurationContext(e.config); });
            _this._updateConfigurationContext(configurationService.getConfiguration());
            return _this;
        }
        ConfigAwareContextValuesContainer.prototype.dispose = function () {
            this._subscription.dispose();
        };
        ConfigAwareContextValuesContainer.prototype._updateConfigurationContext = function (config) {
            var _this = this;
            // remove old config.xyz values
            for (var key in this._value) {
                if (key.indexOf('config.') === 0) {
                    delete this._value[key];
                }
            }
            // add new value from config
            var walk = function (obj, keys) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        keys.push(key);
                        var value = obj[key];
                        if (typeof value === 'boolean') {
                            var configKey = keys.join('.');
                            _this._value[configKey] = value;
                            _this._emitter.fire(configKey);
                        }
                        else if (typeof value === 'object') {
                            walk(value, keys);
                        }
                        keys.pop();
                    }
                }
            };
            walk(config, ['config']);
        };
        return ConfigAwareContextValuesContainer;
    }(ContextValuesContainer));
    var ContextKey = (function () {
        function ContextKey(parent, key, defaultValue) {
            this._parent = parent;
            this._key = key;
            this._defaultValue = defaultValue;
            this.reset();
        }
        ContextKey.prototype.set = function (value) {
            this._parent.setContext(this._key, value);
        };
        ContextKey.prototype.reset = function () {
            if (typeof this._defaultValue === 'undefined') {
                this._parent.removeContext(this._key);
            }
            else {
                this._parent.setContext(this._key, this._defaultValue);
            }
        };
        ContextKey.prototype.get = function () {
            return this._parent.getContextKeyValue(this._key);
        };
        return ContextKey;
    }());
    var AbstractContextKeyService = (function () {
        function AbstractContextKeyService(myContextId) {
            this._myContextId = myContextId;
            this._onDidChangeContextKey = new event_1.Emitter();
        }
        AbstractContextKeyService.prototype.createKey = function (key, defaultValue) {
            return new ContextKey(this, key, defaultValue);
        };
        Object.defineProperty(AbstractContextKeyService.prototype, "onDidChangeContext", {
            get: function () {
                if (!this._onDidChangeContext) {
                    this._onDidChangeContext = event_1.debounceEvent(this._onDidChangeContextKey.event, function (prev, cur) {
                        if (!prev) {
                            prev = [cur];
                        }
                        else if (prev.indexOf(cur) < 0) {
                            prev.push(cur);
                        }
                        return prev;
                    }, 25);
                }
                return this._onDidChangeContext;
            },
            enumerable: true,
            configurable: true
        });
        AbstractContextKeyService.prototype.createScoped = function (domNode) {
            return new ScopedContextKeyService(this, this._onDidChangeContextKey, domNode);
        };
        AbstractContextKeyService.prototype.contextMatchesRules = function (rules) {
            var ctx = Object.create(null);
            this.getContextValuesContainer(this._myContextId).fillInContext(ctx);
            var result = keybindingResolver_1.KeybindingResolver.contextMatchesRules(ctx, rules);
            // console.group(rules.serialize() + ' -> ' + result);
            // rules.keys().forEach(key => { console.log(key, ctx[key]); });
            // console.groupEnd();
            return result;
        };
        AbstractContextKeyService.prototype.getContextKeyValue = function (key) {
            return this.getContextValuesContainer(this._myContextId).getValue(key);
        };
        AbstractContextKeyService.prototype.setContext = function (key, value) {
            if (this.getContextValuesContainer(this._myContextId).setValue(key, value)) {
                this._onDidChangeContextKey.fire(key);
            }
        };
        AbstractContextKeyService.prototype.removeContext = function (key) {
            if (this.getContextValuesContainer(this._myContextId).removeValue(key)) {
                this._onDidChangeContextKey.fire(key);
            }
        };
        AbstractContextKeyService.prototype.getContextValue = function (target) {
            var res = Object.create(null);
            this.getContextValuesContainer(findContextAttr(target)).fillInContext(res);
            return res;
        };
        return AbstractContextKeyService;
    }());
    exports.AbstractContextKeyService = AbstractContextKeyService;
    var ContextKeyService = (function (_super) {
        __extends(ContextKeyService, _super);
        function ContextKeyService(configurationService) {
            var _this = _super.call(this, 0) || this;
            _this._toDispose = [];
            _this._lastContextId = 0;
            _this._contexts = Object.create(null);
            var myContext = new ConfigAwareContextValuesContainer(_this._myContextId, configurationService, _this._onDidChangeContextKey);
            _this._contexts[String(_this._myContextId)] = myContext;
            _this._toDispose.push(myContext);
            return _this;
            // Uncomment this to see the contexts continuously logged
            // let lastLoggedValue: string = null;
            // setInterval(() => {
            // 	let values = Object.keys(this._contexts).map((key) => this._contexts[key]);
            // 	let logValue = values.map(v => JSON.stringify(v._value, null, '\t')).join('\n');
            // 	if (lastLoggedValue !== logValue) {
            // 		lastLoggedValue = logValue;
            // 		console.log(lastLoggedValue);
            // 	}
            // }, 2000);
        }
        ContextKeyService.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        ContextKeyService.prototype.getContextValuesContainer = function (contextId) {
            return this._contexts[String(contextId)];
        };
        ContextKeyService.prototype.createChildContext = function (parentContextId) {
            if (parentContextId === void 0) { parentContextId = this._myContextId; }
            var id = (++this._lastContextId);
            this._contexts[String(id)] = new ContextValuesContainer(id, this.getContextValuesContainer(parentContextId));
            return id;
        };
        ContextKeyService.prototype.disposeContext = function (contextId) {
            delete this._contexts[String(contextId)];
        };
        return ContextKeyService;
    }(AbstractContextKeyService));
    ContextKeyService = __decorate([
        __param(0, configuration_1.IConfigurationService)
    ], ContextKeyService);
    exports.ContextKeyService = ContextKeyService;
    var ScopedContextKeyService = (function (_super) {
        __extends(ScopedContextKeyService, _super);
        function ScopedContextKeyService(parent, emitter, domNode) {
            var _this = _super.call(this, parent.createChildContext()) || this;
            _this._parent = parent;
            _this._onDidChangeContextKey = emitter;
            if (domNode) {
                _this._domNode = domNode;
                _this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(_this._myContextId));
            }
            return _this;
        }
        ScopedContextKeyService.prototype.dispose = function () {
            this._parent.disposeContext(this._myContextId);
            if (this._domNode) {
                this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
            }
        };
        Object.defineProperty(ScopedContextKeyService.prototype, "onDidChangeContext", {
            get: function () {
                return this._parent.onDidChangeContext;
            },
            enumerable: true,
            configurable: true
        });
        ScopedContextKeyService.prototype.getContextValuesContainer = function (contextId) {
            return this._parent.getContextValuesContainer(contextId);
        };
        ScopedContextKeyService.prototype.createChildContext = function (parentContextId) {
            if (parentContextId === void 0) { parentContextId = this._myContextId; }
            return this._parent.createChildContext(parentContextId);
        };
        ScopedContextKeyService.prototype.disposeContext = function (contextId) {
            this._parent.disposeContext(contextId);
        };
        return ScopedContextKeyService;
    }(AbstractContextKeyService));
    function findContextAttr(domNode) {
        while (domNode) {
            if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
                return parseInt(domNode.getAttribute(KEYBINDING_CONTEXT_ATTR), 10);
            }
            domNode = domNode.parentElement;
        }
        return 0;
    }
    commands_1.CommandsRegistry.registerCommand(contextkey_1.SET_CONTEXT_COMMAND_ID, function (accessor, contextKey, contextValue) {
        accessor.get(contextkey_1.IContextKeyService).createKey(String(contextKey), contextValue);
    });
});

define(__m[410/*vs/platform/markers/common/markerService*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,70/*vs/base/common/network*/,24/*vs/base/common/types*/,12/*vs/base/common/event*/,30/*vs/base/common/severity*/]), function (require, exports, arrays_1, network_1, types_1, event_1, severity_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MapMap;
    (function (MapMap) {
        function get(map, key1, key2) {
            if (map[key1]) {
                return map[key1][key2];
            }
        }
        MapMap.get = get;
        function set(map, key1, key2, value) {
            if (!map[key1]) {
                map[key1] = Object.create(null);
            }
            map[key1][key2] = value;
        }
        MapMap.set = set;
        function remove(map, key1, key2) {
            if (map[key1] && map[key1][key2]) {
                delete map[key1][key2];
                if (types_1.isEmptyObject(map[key1])) {
                    delete map[key1];
                }
                return true;
            }
            return false;
        }
        MapMap.remove = remove;
    })(MapMap || (MapMap = {}));
    var MarkerStats = (function () {
        function MarkerStats(service) {
            this.errors = 0;
            this.infos = 0;
            this.warnings = 0;
            this.unknowns = 0;
            this._data = Object.create(null);
            this._service = service;
            this._subscription = service.onMarkerChanged(this._update, this);
        }
        MarkerStats.prototype.dispose = function () {
            this._subscription.dispose();
            this._data = undefined;
        };
        MarkerStats.prototype._update = function (resources) {
            for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
                var resource = resources_1[_i];
                var key = resource.toString();
                var oldStats = this._data[key];
                if (oldStats) {
                    this._substract(oldStats);
                }
                var newStats = this._resourceStats(resource);
                this._add(newStats);
                this._data[key] = newStats;
            }
        };
        MarkerStats.prototype._resourceStats = function (resource) {
            var result = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
            // TODO this is a hack
            if (resource.scheme === network_1.Schemas.inMemory) {
                return result;
            }
            for (var _i = 0, _a = this._service.read({ resource: resource }); _i < _a.length; _i++) {
                var severity = _a[_i].severity;
                if (severity === severity_1.default.Error) {
                    result.errors += 1;
                }
                else if (severity === severity_1.default.Warning) {
                    result.warnings += 1;
                }
                else if (severity === severity_1.default.Info) {
                    result.infos += 1;
                }
                else {
                    result.unknowns += 1;
                }
            }
            return result;
        };
        MarkerStats.prototype._substract = function (op) {
            this.errors -= op.errors;
            this.warnings -= op.warnings;
            this.infos -= op.infos;
            this.unknowns -= op.unknowns;
        };
        MarkerStats.prototype._add = function (op) {
            this.errors += op.errors;
            this.warnings += op.warnings;
            this.infos += op.infos;
            this.unknowns += op.unknowns;
        };
        return MarkerStats;
    }());
    var MarkerService = (function () {
        function MarkerService() {
            this._onMarkerChanged = new event_1.Emitter();
            this._onMarkerChangedEvent = event_1.debounceEvent(this._onMarkerChanged.event, MarkerService._debouncer, 0);
            this._byResource = Object.create(null);
            this._byOwner = Object.create(null);
            this._stats = new MarkerStats(this);
        }
        MarkerService.prototype.dispose = function () {
            this._stats.dispose();
        };
        Object.defineProperty(MarkerService.prototype, "onMarkerChanged", {
            get: function () {
                return this._onMarkerChangedEvent;
            },
            enumerable: true,
            configurable: true
        });
        MarkerService.prototype.getStatistics = function () {
            return this._stats;
        };
        MarkerService.prototype.remove = function (owner, resources) {
            if (!arrays_1.isFalsyOrEmpty(resources)) {
                for (var _i = 0, resources_2 = resources; _i < resources_2.length; _i++) {
                    var resource = resources_2[_i];
                    this.changeOne(owner, resource, undefined);
                }
            }
        };
        MarkerService.prototype.changeOne = function (owner, resource, markerData) {
            if (arrays_1.isFalsyOrEmpty(markerData)) {
                // remove marker for this (owner,resource)-tuple
                var a = MapMap.remove(this._byResource, resource.toString(), owner);
                var b = MapMap.remove(this._byOwner, owner, resource.toString());
                if (a !== b) {
                    throw new Error('invalid marker service state');
                }
                if (a && b) {
                    this._onMarkerChanged.fire([resource]);
                }
            }
            else {
                // insert marker for this (owner,resource)-tuple
                var markers = [];
                for (var _i = 0, markerData_1 = markerData; _i < markerData_1.length; _i++) {
                    var data = markerData_1[_i];
                    var marker = MarkerService._toMarker(owner, resource, data);
                    if (marker) {
                        markers.push(marker);
                    }
                }
                MapMap.set(this._byResource, resource.toString(), owner, markers);
                MapMap.set(this._byOwner, owner, resource.toString(), markers);
                this._onMarkerChanged.fire([resource]);
            }
        };
        MarkerService._toMarker = function (owner, resource, data) {
            var code = data.code, severity = data.severity, message = data.message, source = data.source, startLineNumber = data.startLineNumber, startColumn = data.startColumn, endLineNumber = data.endLineNumber, endColumn = data.endColumn;
            if (!message) {
                return;
            }
            // santize data
            code = code || null;
            startLineNumber = startLineNumber > 0 ? startLineNumber : 1;
            startColumn = startColumn > 0 ? startColumn : 1;
            endLineNumber = endLineNumber >= startLineNumber ? endLineNumber : startLineNumber;
            endColumn = endColumn > 0 ? endColumn : startColumn;
            return {
                resource: resource,
                owner: owner,
                code: code,
                severity: severity,
                message: message,
                source: source,
                startLineNumber: startLineNumber,
                startColumn: startColumn,
                endLineNumber: endLineNumber,
                endColumn: endColumn
            };
        };
        MarkerService.prototype.changeAll = function (owner, data) {
            var changes = [];
            var map = this._byOwner[owner];
            // remove old marker
            if (map) {
                delete this._byOwner[owner];
                for (var resource in map) {
                    // remeber what we remove
                    var first = MapMap.get(this._byResource, resource, owner)[0];
                    if (first) {
                        changes.push(first.resource);
                    }
                    // actual remove
                    MapMap.remove(this._byResource, resource, owner);
                }
            }
            // add new markers
            if (!arrays_1.isFalsyOrEmpty(data)) {
                // group by resource
                var groups = Object.create(null);
                for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
                    var _a = data_1[_i], resource = _a.resource, markerData = _a.marker;
                    var marker = MarkerService._toMarker(owner, resource, markerData);
                    if (!marker) {
                        // filter bad markers
                        continue;
                    }
                    var array = groups[resource.toString()];
                    if (!array) {
                        groups[resource.toString()] = [marker];
                        changes.push(resource);
                    }
                    else {
                        array.push(marker);
                    }
                }
                // insert all
                for (var resource in groups) {
                    MapMap.set(this._byResource, resource, owner, groups[resource]);
                    MapMap.set(this._byOwner, owner, resource, groups[resource]);
                }
            }
            if (changes.length > 0) {
                this._onMarkerChanged.fire(changes);
            }
        };
        MarkerService.prototype.read = function (filter) {
            if (filter === void 0) { filter = Object.create(null); }
            var owner = filter.owner, resource = filter.resource, take = filter.take;
            if (!take || take < 0) {
                take = -1;
            }
            if (owner && resource) {
                // exactly one owner AND resource
                var result = MapMap.get(this._byResource, resource.toString(), owner);
                if (!result) {
                    return [];
                }
                else {
                    return result.slice(0, take > 0 ? take : undefined);
                }
            }
            else if (!owner && !resource) {
                // all
                var result = [];
                for (var key1 in this._byResource) {
                    for (var key2 in this._byResource[key1]) {
                        for (var _i = 0, _a = this._byResource[key1][key2]; _i < _a.length; _i++) {
                            var data = _a[_i];
                            var newLen = result.push(data);
                            if (take > 0 && newLen === take) {
                                return result;
                            }
                        }
                    }
                }
                return result;
            }
            else {
                // of one resource OR owner
                var map = owner
                    ? this._byOwner[owner]
                    : this._byResource[resource.toString()];
                if (!map) {
                    return [];
                }
                var result = [];
                for (var key in map) {
                    for (var _b = 0, _c = map[key]; _b < _c.length; _b++) {
                        var data = _c[_b];
                        var newLen = result.push(data);
                        if (take > 0 && newLen === take) {
                            return result;
                        }
                    }
                }
                return result;
            }
        };
        MarkerService._debouncer = function (last, event) {
            if (!last) {
                MarkerService._dedupeMap = Object.create(null);
                last = [];
            }
            for (var _i = 0, event_2 = event; _i < event_2.length; _i++) {
                var uri = event_2[_i];
                if (MarkerService._dedupeMap[uri.toString()] === void 0) {
                    MarkerService._dedupeMap[uri.toString()] = true;
                    last.push(uri);
                }
            }
            return last;
        };
        return MarkerService;
    }());
    exports.MarkerService = MarkerService;
});

define(__m[72/*vs/platform/markers/common/markers*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IMarkerService = instantiation_1.createDecorator('markerService');
});

define(__m[49/*vs/platform/message/common/message*/], __M([1/*require*/,0/*exports*/,318/*vs/nls!vs/platform/message/common/message*/,6/*vs/base/common/winjs.base*/,30/*vs/base/common/severity*/,14/*vs/platform/instantiation/common/instantiation*/,50/*vs/base/common/actions*/]), function (require, exports, nls, winjs_base_1, severity_1, instantiation_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.CloseAction = new actions_1.Action('close.message', nls.localize(0, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.LaterAction = new actions_1.Action('later.message', nls.localize(1, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.CancelAction = new actions_1.Action('cancel.message', nls.localize(2, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.IMessageService = instantiation_1.createDecorator('messageService');
    exports.IChoiceService = instantiation_1.createDecorator('choiceService');
    exports.Severity = severity_1.default;
});










define(__m[413/*vs/platform/opener/browser/openerService*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/uri*/,145/*vs/base/common/marshalling*/,70/*vs/base/common/network*/,6/*vs/base/common/winjs.base*/,57/*vs/platform/editor/common/editor*/,39/*vs/base/common/paths*/,22/*vs/platform/commands/common/commands*/]), function (require, exports, uri_1, marshalling_1, network_1, winjs_base_1, editor_1, paths_1, commands_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OpenerService = (function () {
        function OpenerService(_editorService, _commandService) {
            this._editorService = _editorService;
            this._commandService = _commandService;
            //
        }
        OpenerService.prototype.open = function (resource, options) {
            var scheme = resource.scheme, path = resource.path, query = resource.query, fragment = resource.fragment;
            var promise;
            if (scheme === network_1.Schemas.http || scheme === network_1.Schemas.https) {
                // open http
                window.open(resource.toString(true));
            }
            else if (scheme === 'command' && commands_1.CommandsRegistry.getCommand(path)) {
                // execute as command
                var args = [];
                try {
                    args = marshalling_1.parse(query);
                    if (!Array.isArray(args)) {
                        args = [args];
                    }
                }
                catch (e) {
                }
                promise = (_a = this._commandService).executeCommand.apply(_a, [path].concat(args));
            }
            else {
                var selection = void 0;
                var match = /^L?(\d+)(?:,(\d+))?/.exec(fragment);
                if (match) {
                    // support file:///some/file.js#73,84
                    // support file:///some/file.js#L73
                    selection = {
                        startLineNumber: parseInt(match[1]),
                        startColumn: match[2] ? parseInt(match[2]) : 1
                    };
                    // remove fragment
                    resource = resource.with({ fragment: '' });
                }
                if (!resource.scheme) {
                    // we cannot handle those
                    return winjs_base_1.TPromise.as(undefined);
                }
                else if (resource.scheme === network_1.Schemas.file) {
                    resource = uri_1.default.file(paths_1.normalize(resource.fsPath)); // workaround for non-normalized paths (https://github.com/Microsoft/vscode/issues/12954)
                }
                promise = this._editorService.openEditor({ resource: resource, options: { selection: selection, } }, options && options.openToSide);
            }
            return winjs_base_1.TPromise.as(promise);
            var _a;
        };
        return OpenerService;
    }());
    OpenerService = __decorate([
        __param(0, editor_1.IEditorService),
        __param(1, commands_1.ICommandService)
    ], OpenerService);
    exports.OpenerService = OpenerService;
});

define(__m[71/*vs/platform/opener/common/opener*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, winjs_base_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IOpenerService = instantiation_1.createDecorator('openerService');
    exports.NullOpenerService = Object.freeze({
        _serviceBrand: undefined,
        open: function () { return winjs_base_1.TPromise.as(undefined); }
    });
});






define(__m[415/*vs/editor/contrib/hover/browser/modesGlyphHover*/], __M([1/*require*/,0/*exports*/,153/*vs/editor/contrib/hover/browser/hoverOperation*/,154/*vs/editor/contrib/hover/browser/hoverWidgets*/,11/*vs/base/browser/dom*/,103/*vs/base/browser/htmlContentRenderer*/,71/*vs/platform/opener/common/opener*/,27/*vs/base/common/uri*/,10/*vs/base/common/errors*/,133/*vs/editor/common/modes/textToHtmlTokenizer*/]), function (require, exports, hoverOperation_1, hoverWidgets_1, dom_1, htmlContentRenderer_1, opener_1, uri_1, errors_1, textToHtmlTokenizer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MarginComputer = (function () {
        function MarginComputer(editor) {
            this._editor = editor;
            this._lineNumber = -1;
        }
        MarginComputer.prototype.setLineNumber = function (lineNumber) {
            this._lineNumber = lineNumber;
            this._result = [];
        };
        MarginComputer.prototype.clearResult = function () {
            this._result = [];
        };
        MarginComputer.prototype.computeSync = function () {
            var hasHoverContent = function (contents) {
                return contents && (!Array.isArray(contents) || contents.length > 0);
            };
            var toHoverMessage = function (contents) {
                return {
                    value: contents
                };
            };
            var lineDecorations = this._editor.getLineDecorations(this._lineNumber);
            var result = [];
            for (var i = 0, len = lineDecorations.length; i < len; i++) {
                var d = lineDecorations[i];
                if (!d.options.glyphMarginClassName) {
                    continue;
                }
                var hoverMessage = d.options.glyphMarginHoverMessage;
                if (!hasHoverContent(hoverMessage)) {
                    continue;
                }
                if (Array.isArray(hoverMessage)) {
                    result = result.concat(hoverMessage.map(toHoverMessage));
                }
                else {
                    result.push(toHoverMessage(hoverMessage));
                }
            }
            return result;
        };
        MarginComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
            this._result = this._result.concat(result);
        };
        MarginComputer.prototype.getResult = function () {
            return this._result;
        };
        MarginComputer.prototype.getResultWithLoadingMessage = function () {
            return this.getResult();
        };
        return MarginComputer;
    }());
    var ModesGlyphHoverWidget = (function (_super) {
        __extends(ModesGlyphHoverWidget, _super);
        function ModesGlyphHoverWidget(editor, openerService, modeService) {
            var _this = _super.call(this, ModesGlyphHoverWidget.ID, editor) || this;
            _this.openerService = openerService;
            _this.modeService = modeService;
            _this.openerService = openerService || opener_1.NullOpenerService;
            _this._lastLineNumber = -1;
            _this._computer = new MarginComputer(_this._editor);
            _this._hoverOperation = new hoverOperation_1.HoverOperation(_this._computer, function (result) { return _this._withResult(result); }, null, function (result) { return _this._withResult(result); });
            return _this;
        }
        ModesGlyphHoverWidget.prototype.dispose = function () {
            this._hoverOperation.cancel();
            _super.prototype.dispose.call(this);
        };
        ModesGlyphHoverWidget.prototype.onModelDecorationsChanged = function () {
            if (this.isVisible) {
                // The decorations have changed and the hover is visible,
                // we need to recompute the displayed text
                this._hoverOperation.cancel();
                this._computer.clearResult();
                this._hoverOperation.start();
            }
        };
        ModesGlyphHoverWidget.prototype.startShowingAt = function (lineNumber) {
            if (this._lastLineNumber === lineNumber) {
                // We have to show the widget at the exact same line number as before, so no work is needed
                return;
            }
            this._hoverOperation.cancel();
            this.hide();
            this._lastLineNumber = lineNumber;
            this._computer.setLineNumber(lineNumber);
            this._hoverOperation.start();
        };
        ModesGlyphHoverWidget.prototype.hide = function () {
            this._lastLineNumber = -1;
            this._hoverOperation.cancel();
            _super.prototype.hide.call(this);
        };
        ModesGlyphHoverWidget.prototype._withResult = function (result) {
            this._messages = result;
            if (this._messages.length > 0) {
                this._renderMessages(this._lastLineNumber, this._messages);
            }
            else {
                this.hide();
            }
        };
        ModesGlyphHoverWidget.prototype._renderMessages = function (lineNumber, messages) {
            var _this = this;
            var fragment = document.createDocumentFragment();
            messages.forEach(function (msg) {
                var renderedContents = htmlContentRenderer_1.renderMarkedString(msg.value, {
                    actionCallback: function (content) { return _this.openerService.open(uri_1.default.parse(content)).then(undefined, errors_1.onUnexpectedError); },
                    codeBlockRenderer: function (languageAlias, value) {
                        // In markdown, it is possible that we stumble upon language aliases (e.g. js instead of javascript)
                        var modeId = _this.modeService.getModeIdForLanguageName(languageAlias);
                        return _this.modeService.getOrCreateMode(modeId).then(function (_) {
                            return "<div class=\"code\">" + textToHtmlTokenizer_1.tokenizeToString(value, modeId) + "</div>";
                        });
                    }
                });
                fragment.appendChild(dom_1.$('div.hover-row', null, renderedContents));
            });
            this.updateContents(fragment);
            this.showAt(lineNumber);
        };
        return ModesGlyphHoverWidget;
    }(hoverWidgets_1.GlyphHoverWidget));
    ModesGlyphHoverWidget.ID = 'editor.contrib.modesGlyphHoverWidget';
    exports.ModesGlyphHoverWidget = ModesGlyphHoverWidget;
});

define(__m[35/*vs/platform/platform*/], __M([1/*require*/,0/*exports*/,24/*vs/base/common/types*/,63/*vs/base/common/assert*/]), function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RegistryImpl = (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
    /**
     * A base class for registries that leverage the instantiation service to create instances.
     */
    var BaseRegistry = (function () {
        function BaseRegistry() {
            this.toBeInstantiated = [];
            this.instances = [];
        }
        BaseRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            while (this.toBeInstantiated.length > 0) {
                var entry = this.toBeInstantiated.shift();
                this.instantiate(entry);
            }
        };
        BaseRegistry.prototype.instantiate = function (ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.instances.push(instance);
        };
        BaseRegistry.prototype._register = function (ctor) {
            if (this.instantiationService) {
                this.instantiate(ctor);
            }
            else {
                this.toBeInstantiated.push(ctor);
            }
        };
        BaseRegistry.prototype._getInstances = function () {
            return this.instances.slice(0);
        };
        BaseRegistry.prototype._setInstances = function (instances) {
            this.instances = instances;
        };
        return BaseRegistry;
    }());
    exports.BaseRegistry = BaseRegistry;
});

define(__m[26/*vs/editor/browser/editorBrowserExtensions*/], __M([1/*require*/,0/*exports*/,35/*vs/platform/platform*/]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function editorContribution(ctor) {
        EditorContributionRegistry.INSTANCE.registerEditorBrowserContribution(ctor);
    }
    exports.editorContribution = editorContribution;
    var EditorBrowserRegistry;
    (function (EditorBrowserRegistry) {
        function getEditorContributions() {
            return EditorContributionRegistry.INSTANCE.getEditorBrowserContributions();
        }
        EditorBrowserRegistry.getEditorContributions = getEditorContributions;
    })(EditorBrowserRegistry = exports.EditorBrowserRegistry || (exports.EditorBrowserRegistry = {}));
    var Extensions = {
        EditorContributions: 'editor.contributions'
    };
    var EditorContributionRegistry = (function () {
        function EditorContributionRegistry() {
            this.editorContributions = [];
        }
        EditorContributionRegistry.prototype.registerEditorBrowserContribution = function (ctor) {
            this.editorContributions.push(ctor);
        };
        EditorContributionRegistry.prototype.getEditorBrowserContributions = function () {
            return this.editorContributions.slice(0);
        };
        return EditorContributionRegistry;
    }());
    EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
    platform_1.Registry.add(Extensions.EditorContributions, EditorContributionRegistry.INSTANCE);
});

define(__m[111/*vs/editor/common/modes/modesRegistry*/], __M([1/*require*/,0/*exports*/,273/*vs/nls!vs/editor/common/modes/modesRegistry*/,12/*vs/base/common/event*/,35/*vs/platform/platform*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,15/*vs/editor/common/modes*/]), function (require, exports, nls, event_1, platform_1, languageConfigurationRegistry_1, modes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Define extension point ids
    exports.Extensions = {
        ModesRegistry: 'editor.modesRegistry'
    };
    var EditorModesRegistry = (function () {
        function EditorModesRegistry() {
            this._onDidAddLanguages = new event_1.Emitter();
            this.onDidAddLanguages = this._onDidAddLanguages.event;
            this._languages = [];
        }
        // --- languages
        EditorModesRegistry.prototype.registerLanguage = function (def) {
            this._languages.push(def);
            this._onDidAddLanguages.fire([def]);
        };
        EditorModesRegistry.prototype.registerLanguages = function (def) {
            this._languages = this._languages.concat(def);
            this._onDidAddLanguages.fire(def);
        };
        EditorModesRegistry.prototype.getLanguages = function () {
            return this._languages.slice(0);
        };
        return EditorModesRegistry;
    }());
    exports.EditorModesRegistry = EditorModesRegistry;
    exports.ModesRegistry = new EditorModesRegistry();
    platform_1.Registry.add(exports.Extensions.ModesRegistry, exports.ModesRegistry);
    exports.PLAINTEXT_MODE_ID = 'plaintext';
    exports.PLAINTEXT_LANGUAGE_IDENTIFIER = new modes_1.LanguageIdentifier(exports.PLAINTEXT_MODE_ID, 1 /* PlainText */);
    exports.ModesRegistry.registerLanguage({
        id: exports.PLAINTEXT_MODE_ID,
        extensions: ['.txt', '.gitignore'],
        aliases: [nls.localize(0, null), 'text'],
        mimetypes: ['text/plain']
    });
    languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(exports.PLAINTEXT_LANGUAGE_IDENTIFIER, {
        brackets: [
            ['(', ')'],
            ['[', ']'],
            ['{', '}'],
        ]
    });
});

define(__m[149/*vs/editor/common/modes/snippetsRegistry*/], __M([1/*require*/,0/*exports*/,274/*vs/nls!vs/editor/common/modes/snippetsRegistry*/,9/*vs/base/common/strings*/,35/*vs/platform/platform*/]), function (require, exports, nls_1, strings, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        Snippets: 'base.contributions.snippets'
    };
    var SnippetsRegistry = (function () {
        function SnippetsRegistry() {
            this._snippets = [];
        }
        SnippetsRegistry.prototype.registerSnippets = function (languageIdentifier, snippets, owner) {
            if (owner === void 0) { owner = ''; }
            var snippetsByMode = this._snippets[languageIdentifier.id];
            if (!snippetsByMode) {
                this._snippets[languageIdentifier.id] = snippetsByMode = {};
            }
            snippetsByMode[owner] = snippets;
        };
        SnippetsRegistry.prototype.visitSnippets = function (languageId, accept) {
            var snippetsByMode = this._snippets[languageId];
            if (snippetsByMode) {
                for (var s in snippetsByMode) {
                    var result = snippetsByMode[s].every(accept);
                    if (!result) {
                        return;
                    }
                }
            }
        };
        SnippetsRegistry.prototype.getSnippetCompletions = function (model, position) {
            var languageId = model.getLanguageIdAtPosition(position.lineNumber, position.column);
            if (!this._snippets[languageId]) {
                return;
            }
            var result = [];
            var word = model.getWordAtPosition(position);
            var currentWord = word ? word.word.substring(0, position.column - word.startColumn).toLowerCase() : '';
            var currentFullWord = getNonWhitespacePrefix(model, position).toLowerCase();
            this.visitSnippets(languageId, function (s) {
                var overwriteBefore;
                if (currentWord.length === 0 && currentFullWord.length === 0) {
                    // if there's no prefix, only show snippets at the beginning of the line, or after a whitespace
                    overwriteBefore = 0;
                }
                else {
                    var label = s.prefix.toLowerCase();
                    // force that the current word or full word matches with the snippet prefix
                    if (currentWord.length > 0 && strings.startsWith(label, currentWord)) {
                        overwriteBefore = currentWord.length;
                    }
                    else if (currentFullWord.length > currentWord.length && strings.startsWith(label, currentFullWord)) {
                        overwriteBefore = currentFullWord.length;
                    }
                    else {
                        return true;
                    }
                }
                // store in result
                result.push({
                    type: 'snippet',
                    label: s.prefix,
                    get disambiguateLabel() { return nls_1.localize(0, null, s.prefix, s.name); },
                    detail: s.owner,
                    documentation: s.description,
                    insertText: s.codeSnippet,
                    noAutoAccept: true,
                    snippetType: 'textmate',
                    overwriteBefore: overwriteBefore
                });
                return true;
            });
            // dismbiguate suggestions with same labels
            var lastSuggestion;
            for (var _i = 0, _a = result.sort(SnippetsRegistry._compareSuggestionsByLabel); _i < _a.length; _i++) {
                var suggestion = _a[_i];
                if (lastSuggestion && lastSuggestion.label === suggestion.label) {
                    // use the disambiguateLabel instead of the actual label
                    lastSuggestion.label = lastSuggestion.disambiguateLabel;
                    suggestion.label = suggestion.disambiguateLabel;
                }
                lastSuggestion = suggestion;
            }
            return result;
        };
        SnippetsRegistry._compareSuggestionsByLabel = function (a, b) {
            return strings.compare(a.label, b.label);
        };
        return SnippetsRegistry;
    }());
    function getNonWhitespacePrefix(model, position) {
        /**
         * Do not analyze more characters
         */
        var MAX_PREFIX_LENGTH = 100;
        var line = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
        var minChIndex = Math.max(0, line.length - MAX_PREFIX_LENGTH);
        for (var chIndex = line.length - 1; chIndex >= minChIndex; chIndex--) {
            var ch = line.charAt(chIndex);
            if (/\s/.test(ch)) {
                return line.substr(chIndex + 1);
            }
        }
        if (minChIndex === 0) {
            return line;
        }
        return '';
    }
    exports.getNonWhitespacePrefix = getNonWhitespacePrefix;
    var snippetsRegistry = new SnippetsRegistry();
    platform_1.Registry.add(exports.Extensions.Snippets, snippetsRegistry);
});

define(__m[420/*vs/editor/common/services/languagesRegistry*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,12/*vs/base/common/event*/,500/*vs/base/common/mime*/,9/*vs/base/common/strings*/,111/*vs/editor/common/modes/modesRegistry*/,15/*vs/editor/common/modes*/,64/*vs/editor/common/modes/nullMode*/]), function (require, exports, errors_1, event_1, mime, strings, modesRegistry_1, modes_1, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var LanguagesRegistry = (function () {
        function LanguagesRegistry(useModesRegistry) {
            if (useModesRegistry === void 0) { useModesRegistry = true; }
            var _this = this;
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this._nextLanguageId = 1;
            this._languages = {};
            this.mime2LanguageId = {};
            this.name2LanguageId = {};
            this.lowerName2Id = {};
            this.languageIds = [];
            if (useModesRegistry) {
                this._registerLanguages(modesRegistry_1.ModesRegistry.getLanguages());
                modesRegistry_1.ModesRegistry.onDidAddLanguages(function (m) { return _this._registerLanguages(m); });
            }
        }
        LanguagesRegistry.prototype._registerLanguages = function (desc) {
            var _this = this;
            if (desc.length === 0) {
                return;
            }
            var addedModes = [];
            for (var i = 0; i < desc.length; i++) {
                this._registerLanguage(desc[i]);
                addedModes.push(desc[i].id);
            }
            // Rebuild fast path maps
            this.mime2LanguageId = {};
            this.name2LanguageId = {};
            this.lowerName2Id = {};
            Object.keys(this._languages).forEach(function (langId) {
                var language = _this._languages[langId];
                if (language.name) {
                    _this.name2LanguageId[language.name] = langId;
                }
                language.aliases.forEach(function (alias) {
                    _this.lowerName2Id[alias.toLowerCase()] = langId;
                });
                language.mimetypes.forEach(function (mimetype) {
                    _this.mime2LanguageId[mimetype] = langId;
                });
            });
            this._onDidAddModes.fire(addedModes);
        };
        LanguagesRegistry.prototype._registerLanguage = function (lang) {
            var langId = lang.id;
            var resolvedLanguage = null;
            if (hasOwnProperty.call(this._languages, langId)) {
                resolvedLanguage = this._languages[langId];
            }
            else {
                var languageId = this._nextLanguageId++;
                resolvedLanguage = {
                    id: languageId,
                    name: null,
                    mimetypes: [],
                    aliases: [],
                    extensions: [],
                    filenames: [],
                    configurationFiles: []
                };
                this.languageIds[languageId] = langId;
                this._languages[langId] = resolvedLanguage;
            }
            LanguagesRegistry._mergeLanguage(resolvedLanguage, lang);
        };
        LanguagesRegistry._mergeLanguage = function (resolvedLanguage, lang) {
            var langId = lang.id;
            var primaryMime = null;
            if (typeof lang.mimetypes !== 'undefined' && Array.isArray(lang.mimetypes)) {
                for (var i = 0; i < lang.mimetypes.length; i++) {
                    if (!primaryMime) {
                        primaryMime = lang.mimetypes[i];
                    }
                    resolvedLanguage.mimetypes.push(lang.mimetypes[i]);
                }
            }
            if (!primaryMime) {
                primaryMime = "text/x-" + langId;
                resolvedLanguage.mimetypes.push(primaryMime);
            }
            if (Array.isArray(lang.extensions)) {
                for (var _i = 0, _a = lang.extensions; _i < _a.length; _i++) {
                    var extension = _a[_i];
                    mime.registerTextMime({ id: langId, mime: primaryMime, extension: extension });
                    resolvedLanguage.extensions.push(extension);
                }
            }
            if (Array.isArray(lang.filenames)) {
                for (var _b = 0, _c = lang.filenames; _b < _c.length; _b++) {
                    var filename = _c[_b];
                    mime.registerTextMime({ id: langId, mime: primaryMime, filename: filename });
                    resolvedLanguage.filenames.push(filename);
                }
            }
            if (Array.isArray(lang.filenamePatterns)) {
                for (var _d = 0, _e = lang.filenamePatterns; _d < _e.length; _d++) {
                    var filenamePattern = _e[_d];
                    mime.registerTextMime({ id: langId, mime: primaryMime, filepattern: filenamePattern });
                }
            }
            if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {
                var firstLineRegexStr = lang.firstLine;
                if (firstLineRegexStr.charAt(0) !== '^') {
                    firstLineRegexStr = '^' + firstLineRegexStr;
                }
                try {
                    var firstLineRegex = new RegExp(firstLineRegexStr);
                    if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {
                        mime.registerTextMime({ id: langId, mime: primaryMime, firstline: firstLineRegex });
                    }
                }
                catch (err) {
                    // Most likely, the regex was bad
                    errors_1.onUnexpectedError(err);
                }
            }
            resolvedLanguage.aliases.push(langId);
            var langAliases = null;
            if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {
                if (lang.aliases.length === 0) {
                    // signal that this language should not get a name
                    langAliases = [null];
                }
                else {
                    langAliases = lang.aliases;
                }
            }
            if (langAliases !== null) {
                for (var i = 0; i < langAliases.length; i++) {
                    if (!langAliases[i] || langAliases[i].length === 0) {
                        continue;
                    }
                    resolvedLanguage.aliases.push(langAliases[i]);
                }
            }
            var containsAliases = (langAliases !== null && langAliases.length > 0);
            if (containsAliases && langAliases[0] === null) {
            }
            else {
                var bestName = (containsAliases ? langAliases[0] : null) || langId;
                if (containsAliases || !resolvedLanguage.name) {
                    resolvedLanguage.name = bestName;
                }
            }
            if (typeof lang.configuration === 'string') {
                resolvedLanguage.configurationFiles.push(lang.configuration);
            }
        };
        LanguagesRegistry.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            // Is this a known mime type ?
            if (hasOwnProperty.call(this.mime2LanguageId, mimetypeOrModeId)) {
                return true;
            }
            // Is this a known mode id ?
            return hasOwnProperty.call(this._languages, mimetypeOrModeId);
        };
        LanguagesRegistry.prototype.getRegisteredModes = function () {
            return Object.keys(this._languages);
        };
        LanguagesRegistry.prototype.getRegisteredLanguageNames = function () {
            return Object.keys(this.name2LanguageId);
        };
        LanguagesRegistry.prototype.getLanguageName = function (modeId) {
            if (!hasOwnProperty.call(this._languages, modeId)) {
                return null;
            }
            return this._languages[modeId].name;
        };
        LanguagesRegistry.prototype.getModeIdForLanguageNameLowercase = function (languageNameLower) {
            return this.lowerName2Id[languageNameLower] || null;
        };
        LanguagesRegistry.prototype.getConfigurationFiles = function (modeId) {
            if (!hasOwnProperty.call(this._languages, modeId)) {
                return [];
            }
            return this._languages[modeId].configurationFiles || [];
        };
        LanguagesRegistry.prototype.getMimeForMode = function (theModeId) {
            var keys = Object.keys(this.mime2LanguageId);
            for (var i = 0, len = keys.length; i < len; i++) {
                var _mime = keys[i];
                var modeId = this.mime2LanguageId[_mime];
                if (modeId === theModeId) {
                    return _mime;
                }
            }
            return null;
        };
        LanguagesRegistry.prototype.extractModeIds = function (commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
            var _this = this;
            if (!commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
                return [];
            }
            return (commaSeparatedMimetypesOrCommaSeparatedIdsOrName.
                split(',').
                map(function (mimeTypeOrIdOrName) { return mimeTypeOrIdOrName.trim(); }).
                map(function (mimeTypeOrIdOrName) {
                return _this.mime2LanguageId[mimeTypeOrIdOrName] || mimeTypeOrIdOrName;
            }).
                filter(function (modeId) {
                return hasOwnProperty.call(_this._languages, modeId);
            }));
        };
        LanguagesRegistry.prototype.getLanguageIdentifier = function (_modeId) {
            if (_modeId === nullMode_1.NULL_MODE_ID || _modeId === 0 /* Null */) {
                return nullMode_1.NULL_LANGUAGE_IDENTIFIER;
            }
            var modeId;
            if (typeof _modeId === 'string') {
                modeId = _modeId;
            }
            else {
                modeId = this.languageIds[_modeId];
                if (!modeId) {
                    return null;
                }
            }
            if (!hasOwnProperty.call(this._languages, modeId)) {
                return null;
            }
            return new modes_1.LanguageIdentifier(modeId, this._languages[modeId].id);
        };
        LanguagesRegistry.prototype.getModeIdsFromLanguageName = function (languageName) {
            if (!languageName) {
                return [];
            }
            if (hasOwnProperty.call(this.name2LanguageId, languageName)) {
                return [this.name2LanguageId[languageName]];
            }
            return [];
        };
        LanguagesRegistry.prototype.getModeIdsFromFilenameOrFirstLine = function (filename, firstLine) {
            if (!filename && !firstLine) {
                return [];
            }
            var mimeTypes = mime.guessMimeTypes(filename, firstLine);
            return this.extractModeIds(mimeTypes.join(','));
        };
        LanguagesRegistry.prototype.getExtensions = function (languageName) {
            var languageId = this.name2LanguageId[languageName];
            if (!languageId) {
                return [];
            }
            if (!hasOwnProperty.call(this._languages, languageId)) {
                return [];
            }
            return this._languages[languageId].extensions;
        };
        LanguagesRegistry.prototype.getFilenames = function (languageName) {
            var languageId = this.name2LanguageId[languageName];
            if (!languageId) {
                return [];
            }
            if (!hasOwnProperty.call(this._languages, languageId)) {
                return [];
            }
            return this._languages[languageId].filenames;
        };
        return LanguagesRegistry;
    }());
    exports.LanguagesRegistry = LanguagesRegistry;
});










define(__m[421/*vs/editor/common/services/modelServiceImpl*/], __M([1/*require*/,0/*exports*/,278/*vs/nls!vs/editor/common/services/modelServiceImpl*/,70/*vs/base/common/network*/,12/*vs/base/common/event*/,30/*vs/base/common/severity*/,6/*vs/base/common/winjs.base*/,72/*vs/platform/markers/common/markers*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,126/*vs/editor/common/model/model*/,19/*vs/base/common/platform*/,56/*vs/platform/configuration/common/configuration*/,44/*vs/editor/common/config/defaultConfig*/,111/*vs/editor/common/modes/modesRegistry*/]), function (require, exports, nls, network, event_1, severity_1, winjs_base_1, markers_1, range_1, editorCommon, model_1, platform, configuration_1, defaultConfig_1, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function MODEL_ID(resource) {
        return resource.toString();
    }
    var ModelData = (function () {
        function ModelData(model, eventsHandler) {
            var _this = this;
            this.model = model;
            this._markerDecorations = [];
            this._modelEventsListener = model.addBulkListener(function (events) { return eventsHandler(_this, events); });
        }
        ModelData.prototype.dispose = function () {
            this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, []);
            this._modelEventsListener.dispose();
            this._modelEventsListener = null;
            this.model = null;
        };
        ModelData.prototype.getModelId = function () {
            return MODEL_ID(this.model.uri);
        };
        ModelData.prototype.acceptMarkerDecorations = function (newDecorations) {
            this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, newDecorations);
        };
        return ModelData;
    }());
    var ModelMarkerHandler = (function () {
        function ModelMarkerHandler() {
        }
        ModelMarkerHandler.setMarkers = function (modelData, markerService) {
            var _this = this;
            // Limit to the first 500 errors/warnings
            var markers = markerService.read({ resource: modelData.model.uri, take: 500 });
            var newModelDecorations = markers.map(function (marker) {
                return {
                    range: _this._createDecorationRange(modelData.model, marker),
                    options: _this._createDecorationOption(marker)
                };
            });
            modelData.acceptMarkerDecorations(newModelDecorations);
        };
        ModelMarkerHandler._createDecorationRange = function (model, rawMarker) {
            var marker = model.validateRange(new range_1.Range(rawMarker.startLineNumber, rawMarker.startColumn, rawMarker.endLineNumber, rawMarker.endColumn));
            var ret = new range_1.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn);
            if (ret.isEmpty()) {
                var word = model.getWordAtPosition(ret.getStartPosition());
                if (word) {
                    ret = new range_1.Range(ret.startLineNumber, word.startColumn, ret.endLineNumber, word.endColumn);
                }
                else {
                    var maxColumn = model.getLineLastNonWhitespaceColumn(marker.startLineNumber) ||
                        model.getLineMaxColumn(marker.startLineNumber);
                    if (maxColumn === 1) {
                    }
                    else if (ret.endColumn >= maxColumn) {
                        // behind eol
                        ret = new range_1.Range(ret.startLineNumber, maxColumn - 1, ret.endLineNumber, maxColumn);
                    }
                    else {
                        // extend marker to width = 1
                        ret = new range_1.Range(ret.startLineNumber, ret.startColumn, ret.endLineNumber, ret.endColumn + 1);
                    }
                }
            }
            else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
                var minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
                if (minColumn < ret.endColumn) {
                    ret = new range_1.Range(ret.startLineNumber, minColumn, ret.endLineNumber, ret.endColumn);
                    rawMarker.startColumn = minColumn;
                }
            }
            return ret;
        };
        ModelMarkerHandler._createDecorationOption = function (marker) {
            var className;
            var color;
            var darkColor;
            switch (marker.severity) {
                case severity_1.default.Ignore:
                    // do something
                    break;
                case severity_1.default.Warning:
                case severity_1.default.Info:
                    className = editorCommon.ClassName.EditorWarningDecoration;
                    color = 'rgba(18,136,18,0.7)';
                    darkColor = 'rgba(18,136,18,0.7)';
                    break;
                case severity_1.default.Error:
                default:
                    className = editorCommon.ClassName.EditorErrorDecoration;
                    color = 'rgba(255,18,18,0.7)';
                    darkColor = 'rgba(255,18,18,0.7)';
                    break;
            }
            var hoverMessage = null;
            var message = marker.message, source = marker.source;
            if (typeof message === 'string') {
                message = message.trim();
                if (source) {
                    if (/\n/g.test(message)) {
                        message = nls.localize(0, null, source, message);
                    }
                    else {
                        message = nls.localize(1, null, source, message);
                    }
                }
                hoverMessage = [{ language: '_', value: message }];
            }
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                className: className,
                hoverMessage: hoverMessage,
                overviewRuler: {
                    color: color,
                    darkColor: darkColor,
                    position: editorCommon.OverviewRulerLane.Right
                }
            };
        };
        return ModelMarkerHandler;
    }());
    var ModelServiceImpl = (function () {
        function ModelServiceImpl(markerService, configurationService) {
            var _this = this;
            this._modelCreationOptions = {
                tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
                insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
                detectIndentation: defaultConfig_1.DEFAULT_INDENTATION.detectIndentation,
                defaultEOL: (platform.isLinux || platform.isMacintosh) ? editorCommon.DefaultEndOfLine.LF : editorCommon.DefaultEndOfLine.CRLF,
                trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE
            };
            this._markerService = markerService;
            this._configurationService = configurationService;
            this._models = {};
            this._onModelAdded = new event_1.Emitter();
            this._onModelRemoved = new event_1.Emitter();
            this._onModelModeChanged = new event_1.Emitter();
            if (this._markerService) {
                this._markerServiceSubscription = this._markerService.onMarkerChanged(this._handleMarkerChange, this);
            }
            var readConfig = function (config) {
                var tabSize = defaultConfig_1.DEFAULT_INDENTATION.tabSize;
                if (config.editor && typeof config.editor.tabSize !== 'undefined') {
                    var parsedTabSize = parseInt(config.editor.tabSize, 10);
                    if (!isNaN(parsedTabSize)) {
                        tabSize = parsedTabSize;
                    }
                }
                var insertSpaces = defaultConfig_1.DEFAULT_INDENTATION.insertSpaces;
                if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {
                    insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));
                }
                var newDefaultEOL = _this._modelCreationOptions.defaultEOL;
                var eol = config.files && config.files.eol;
                if (eol === '\r\n') {
                    newDefaultEOL = editorCommon.DefaultEndOfLine.CRLF;
                }
                else if (eol === '\n') {
                    newDefaultEOL = editorCommon.DefaultEndOfLine.LF;
                }
                var trimAutoWhitespace = _this._modelCreationOptions.trimAutoWhitespace;
                if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {
                    trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));
                }
                var detectIndentation = defaultConfig_1.DEFAULT_INDENTATION.detectIndentation;
                if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {
                    detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));
                }
                _this._setModelOptions({
                    tabSize: tabSize,
                    insertSpaces: insertSpaces,
                    detectIndentation: detectIndentation,
                    defaultEOL: newDefaultEOL,
                    trimAutoWhitespace: trimAutoWhitespace
                });
            };
            this._configurationServiceSubscription = this._configurationService.onDidUpdateConfiguration(function (e) {
                readConfig(e.config);
            });
            readConfig(this._configurationService.getConfiguration());
        }
        ModelServiceImpl.prototype.getCreationOptions = function () {
            return this._modelCreationOptions;
        };
        ModelServiceImpl.prototype._setModelOptions = function (newOpts) {
            if ((this._modelCreationOptions.detectIndentation === newOpts.detectIndentation)
                && (this._modelCreationOptions.insertSpaces === newOpts.insertSpaces)
                && (this._modelCreationOptions.tabSize === newOpts.tabSize)
                && (this._modelCreationOptions.trimAutoWhitespace === newOpts.trimAutoWhitespace)) {
                // Same indent opts, no need to touch created models
                this._modelCreationOptions = newOpts;
                return;
            }
            this._modelCreationOptions = newOpts;
            // Update options on all models
            var keys = Object.keys(this._models);
            for (var i = 0, len = keys.length; i < len; i++) {
                var modelId = keys[i];
                var modelData = this._models[modelId];
                if (this._modelCreationOptions.detectIndentation) {
                    modelData.model.detectIndentation(this._modelCreationOptions.insertSpaces, this._modelCreationOptions.tabSize);
                    modelData.model.updateOptions({
                        trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                    });
                }
                else {
                    modelData.model.updateOptions({
                        insertSpaces: this._modelCreationOptions.insertSpaces,
                        tabSize: this._modelCreationOptions.tabSize,
                        trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                    });
                }
            }
        };
        ModelServiceImpl.prototype.dispose = function () {
            if (this._markerServiceSubscription) {
                this._markerServiceSubscription.dispose();
            }
            this._configurationServiceSubscription.dispose();
        };
        ModelServiceImpl.prototype._handleMarkerChange = function (changedResources) {
            var _this = this;
            changedResources.forEach(function (resource) {
                var modelId = MODEL_ID(resource);
                var modelData = _this._models[modelId];
                if (!modelData) {
                    return;
                }
                ModelMarkerHandler.setMarkers(modelData, _this._markerService);
            });
        };
        ModelServiceImpl.prototype._cleanUp = function (model) {
            var _this = this;
            // clean up markers for internal, transient models
            if (model.uri.scheme === network.Schemas.inMemory
                || model.uri.scheme === network.Schemas.internal
                || model.uri.scheme === network.Schemas.vscode) {
                if (this._markerService) {
                    this._markerService.read({ resource: model.uri }).map(function (marker) { return marker.owner; }).forEach(function (owner) { return _this._markerService.remove(owner, [model.uri]); });
                }
            }
        };
        // --- begin IModelService
        ModelServiceImpl.prototype._createModelData = function (value, languageIdentifier, resource) {
            var _this = this;
            // create & save the model
            var model;
            if (typeof value === 'string') {
                model = model_1.Model.createFromString(value, this._modelCreationOptions, languageIdentifier, resource);
            }
            else {
                model = new model_1.Model(value, languageIdentifier, resource);
            }
            var modelId = MODEL_ID(model.uri);
            if (this._models[modelId]) {
                // There already exists a model with this id => this is a programmer error
                throw new Error('ModelService: Cannot add model because it already exists!');
            }
            var modelData = new ModelData(model, function (modelData, events) { return _this._onModelEvents(modelData, events); });
            this._models[modelId] = modelData;
            return modelData;
        };
        ModelServiceImpl.prototype.createModel = function (value, modeOrPromise, resource) {
            var modelData;
            if (!modeOrPromise || winjs_base_1.TPromise.is(modeOrPromise)) {
                modelData = this._createModelData(value, modesRegistry_1.PLAINTEXT_LANGUAGE_IDENTIFIER, resource);
                this.setMode(modelData.model, modeOrPromise);
            }
            else {
                modelData = this._createModelData(value, modeOrPromise.getLanguageIdentifier(), resource);
            }
            // handle markers (marker service => model)
            if (this._markerService) {
                ModelMarkerHandler.setMarkers(modelData, this._markerService);
            }
            this._onModelAdded.fire(modelData.model);
            return modelData.model;
        };
        ModelServiceImpl.prototype.setMode = function (model, modeOrPromise) {
            if (!modeOrPromise) {
                return;
            }
            if (winjs_base_1.TPromise.is(modeOrPromise)) {
                modeOrPromise.then(function (mode) {
                    if (!model.isDisposed()) {
                        model.setMode(mode.getLanguageIdentifier());
                    }
                });
            }
            else {
                model.setMode(modeOrPromise.getLanguageIdentifier());
            }
        };
        ModelServiceImpl.prototype.destroyModel = function (resource) {
            // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
            var modelData = this._models[MODEL_ID(resource)];
            if (!modelData) {
                return;
            }
            modelData.model.dispose();
        };
        ModelServiceImpl.prototype.getModels = function () {
            var ret = [];
            var keys = Object.keys(this._models);
            for (var i = 0, len = keys.length; i < len; i++) {
                var modelId = keys[i];
                ret.push(this._models[modelId].model);
            }
            return ret;
        };
        ModelServiceImpl.prototype.getModel = function (resource) {
            var modelId = MODEL_ID(resource);
            var modelData = this._models[modelId];
            if (!modelData) {
                return null;
            }
            return modelData.model;
        };
        Object.defineProperty(ModelServiceImpl.prototype, "onModelAdded", {
            get: function () {
                return this._onModelAdded ? this._onModelAdded.event : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelServiceImpl.prototype, "onModelRemoved", {
            get: function () {
                return this._onModelRemoved ? this._onModelRemoved.event : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelServiceImpl.prototype, "onModelModeChanged", {
            get: function () {
                return this._onModelModeChanged ? this._onModelModeChanged.event : null;
            },
            enumerable: true,
            configurable: true
        });
        // --- end IModelService
        ModelServiceImpl.prototype._onModelDisposing = function (model) {
            var modelId = MODEL_ID(model.uri);
            var modelData = this._models[modelId];
            delete this._models[modelId];
            modelData.dispose();
            this._cleanUp(model);
            this._onModelRemoved.fire(model);
        };
        ModelServiceImpl.prototype._onModelEvents = function (modelData, events) {
            // First look for dispose
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.getType() === editorCommon.EventType.ModelDispose) {
                    this._onModelDisposing(modelData.model);
                    // no more processing since model got disposed
                    return;
                }
            }
            // Second, look for mode change
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.getType() === editorCommon.EventType.ModelLanguageChanged) {
                    this._onModelModeChanged.fire({
                        model: modelData.model,
                        oldModeId: e.getData().oldLanguage
                    });
                }
            }
        };
        return ModelServiceImpl;
    }());
    ModelServiceImpl = __decorate([
        __param(0, markers_1.IMarkerService),
        __param(1, configuration_1.IConfigurationService)
    ], ModelServiceImpl);
    exports.ModelServiceImpl = ModelServiceImpl;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






define(__m[422/*vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,21/*vs/editor/browser/editorBrowser*/,26/*vs/editor/browser/editorBrowserExtensions*/,370/*vs/css!vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard*/]), function (require, exports, lifecycle_1, browser, dom, editorBrowser_1, editorBrowserExtensions_1) {
    'use strict';
    var IPadShowKeyboard = IPadShowKeyboard_1 = (function () {
        function IPadShowKeyboard(editor) {
            var _this = this;
            this.editor = editor;
            this.toDispose = [];
            if (browser.isIPad) {
                this.toDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
                this.update();
            }
        }
        IPadShowKeyboard.prototype.update = function () {
            var hasWidget = (!!this.widget);
            var shouldHaveWidget = (!this.editor.getConfiguration().readOnly);
            if (!hasWidget && shouldHaveWidget) {
                this.widget = new ShowKeyboardWidget(this.editor);
            }
            else if (hasWidget && !shouldHaveWidget) {
                this.widget.dispose();
                this.widget = null;
            }
        };
        IPadShowKeyboard.prototype.getId = function () {
            return IPadShowKeyboard_1.ID;
        };
        IPadShowKeyboard.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            if (this.widget) {
                this.widget.dispose();
                this.widget = null;
            }
        };
        return IPadShowKeyboard;
    }());
    IPadShowKeyboard.ID = 'editor.contrib.iPadShowKeyboard';
    IPadShowKeyboard = IPadShowKeyboard_1 = __decorate([
        editorBrowserExtensions_1.editorContribution
    ], IPadShowKeyboard);
    exports.IPadShowKeyboard = IPadShowKeyboard;
    var ShowKeyboardWidget = (function () {
        function ShowKeyboardWidget(editor) {
            var _this = this;
            this.editor = editor;
            this._domNode = document.createElement('textarea');
            this._domNode.className = 'iPadShowKeyboard';
            this._toDispose = [];
            this._toDispose.push(dom.addDisposableListener(this._domNode, 'touchstart', function (e) {
                _this.editor.focus();
            }));
            this._toDispose.push(dom.addDisposableListener(this._domNode, 'focus', function (e) {
                _this.editor.focus();
            }));
            this.editor.addOverlayWidget(this);
        }
        ShowKeyboardWidget.prototype.dispose = function () {
            this.editor.removeOverlayWidget(this);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        // ----- IOverlayWidget API
        ShowKeyboardWidget.prototype.getId = function () {
            return ShowKeyboardWidget.ID;
        };
        ShowKeyboardWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        ShowKeyboardWidget.prototype.getPosition = function () {
            return {
                preference: editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER
            };
        };
        return ShowKeyboardWidget;
    }());
    ShowKeyboardWidget.ID = 'editor.contrib.ShowKeyboardWidget';
    var IPadShowKeyboard_1;
});












define(__m[423/*vs/editor/contrib/multicursor/browser/menuPreventer*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,26/*vs/editor/browser/editorBrowserExtensions*/]), function (require, exports, lifecycle_1, editorBrowserExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Prevents the top-level menu from showing up when doing Alt + Click in the editor
     */
    var MenuPreventer = MenuPreventer_1 = (function (_super) {
        __extends(MenuPreventer, _super);
        function MenuPreventer(editor) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._altListeningMouse = false;
            _this._altMouseTriggered = false;
            // A global crossover handler to prevent menu bar from showing up
            // When <alt> is hold, we will listen to mouse events and prevent
            // the release event up <alt> if the mouse is triggered.
            _this._register(_this._editor.onMouseDown(function (e) {
                if (_this._altListeningMouse) {
                    _this._altMouseTriggered = true;
                }
            }));
            _this._register(_this._editor.onKeyDown(function (e) {
                if (e.equals(512 /* Alt */)) {
                    if (!_this._altListeningMouse) {
                        _this._altMouseTriggered = false;
                    }
                    _this._altListeningMouse = true;
                }
            }));
            _this._register(_this._editor.onKeyUp(function (e) {
                if (e.equals(512 /* Alt */)) {
                    if (_this._altMouseTriggered) {
                        e.preventDefault();
                    }
                    _this._altListeningMouse = false;
                    _this._altMouseTriggered = false;
                }
            }));
            return _this;
        }
        MenuPreventer.prototype.getId = function () {
            return MenuPreventer_1.ID;
        };
        return MenuPreventer;
    }(lifecycle_1.Disposable));
    MenuPreventer.ID = 'editor.contrib.menuPreventer';
    MenuPreventer = MenuPreventer_1 = __decorate([
        editorBrowserExtensions_1.editorContribution
    ], MenuPreventer);
    exports.MenuPreventer = MenuPreventer;
    var MenuPreventer_1;
});

define(__m[150/*vs/platform/jsonschemas/common/jsonContributionRegistry*/], __M([1/*require*/,0/*exports*/,35/*vs/platform/platform*/,25/*vs/base/common/eventEmitter*/]), function (require, exports, platform, eventEmitter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = (function () {
        function JSONContributionRegistry() {
            this.schemasById = {};
            this.eventEmitter = new eventEmitter_1.EventEmitter();
        }
        JSONContributionRegistry.prototype.addRegistryChangedListener = function (callback) {
            return this.eventEmitter.addListener2('registryChanged', callback);
        };
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this.eventEmitter.emit('registryChanged', {});
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
});

define(__m[151/*vs/platform/extensions/common/extensionsRegistry*/], __M([1/*require*/,0/*exports*/,316/*vs/nls!vs/platform/extensions/common/extensionsRegistry*/,10/*vs/base/common/errors*/,30/*vs/base/common/severity*/,150/*vs/platform/jsonschemas/common/jsonContributionRegistry*/,35/*vs/platform/platform*/]), function (require, exports, nls, errors_1, severity_1, jsonContributionRegistry_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.hasOwnProperty;
    var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ExtensionMessageCollector = (function () {
        function ExtensionMessageCollector(messageHandler, source) {
            this._messageHandler = messageHandler;
            this._source = source;
        }
        ExtensionMessageCollector.prototype._msg = function (type, message) {
            this._messageHandler({
                type: type,
                message: message,
                source: this._source
            });
        };
        ExtensionMessageCollector.prototype.error = function (message) {
            this._msg(severity_1.default.Error, message);
        };
        ExtensionMessageCollector.prototype.warn = function (message) {
            this._msg(severity_1.default.Warning, message);
        };
        ExtensionMessageCollector.prototype.info = function (message) {
            this._msg(severity_1.default.Info, message);
        };
        return ExtensionMessageCollector;
    }());
    exports.ExtensionMessageCollector = ExtensionMessageCollector;
    var ExtensionPoint = (function () {
        function ExtensionPoint(name) {
            this.name = name;
            this._handler = null;
            this._users = null;
            this._done = false;
        }
        ExtensionPoint.prototype.setHandler = function (handler) {
            if (this._handler !== null || this._done) {
                throw new Error('Handler already set!');
            }
            this._handler = handler;
            this._handle();
        };
        ExtensionPoint.prototype.acceptUsers = function (users) {
            if (this._users !== null || this._done) {
                throw new Error('Users already set!');
            }
            this._users = users;
            this._handle();
        };
        ExtensionPoint.prototype._handle = function () {
            if (this._handler === null || this._users === null) {
                return;
            }
            this._done = true;
            var handler = this._handler;
            this._handler = null;
            var users = this._users;
            this._users = null;
            try {
                handler(users);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
            }
        };
        return ExtensionPoint;
    }());
    exports.ExtensionPoint = ExtensionPoint;
    var schemaId = 'vscode://schemas/vscode-extensions';
    var schema = {
        properties: {
            engines: {
                type: 'object',
                properties: {
                    'vscode': {
                        type: 'string',
                        description: nls.localize(0, null),
                        default: '^0.10.0',
                    }
                }
            },
            publisher: {
                description: nls.localize(1, null),
                type: 'string'
            },
            displayName: {
                description: nls.localize(2, null),
                type: 'string'
            },
            categories: {
                description: nls.localize(3, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string',
                    enum: ['Languages', 'Snippets', 'Linters', 'Themes', 'Debuggers', 'Other', 'Keymaps', 'Formatters']
                }
            },
            galleryBanner: {
                type: 'object',
                description: nls.localize(4, null),
                properties: {
                    color: {
                        description: nls.localize(5, null),
                        type: 'string'
                    },
                    theme: {
                        description: nls.localize(6, null),
                        type: 'string',
                        enum: ['dark', 'light']
                    }
                }
            },
            contributes: {
                description: nls.localize(7, null),
                type: 'object',
                properties: {},
                default: {}
            },
            preview: {
                type: 'boolean',
                description: nls.localize(8, null),
            },
            activationEvents: {
                description: nls.localize(9, null),
                type: 'array',
                items: {
                    type: 'string',
                    defaultSnippets: [{ label: 'onLanguage', body: 'onLanguage:${1:languageId}' }, { label: 'onCommand', body: 'onCommand:${2:commandId}' }, { label: 'onDebug', body: 'onDebug:${3:type}' }, { label: 'workspaceContains', body: 'workspaceContains:${4:fileName}' }],
                }
            },
            badges: {
                type: 'array',
                description: nls.localize(10, null),
                items: {
                    type: 'object',
                    required: ['url', 'href', 'description'],
                    properties: {
                        url: {
                            type: 'string',
                            description: nls.localize(11, null)
                        },
                        href: {
                            type: 'string',
                            description: nls.localize(12, null)
                        },
                        description: {
                            type: 'string',
                            description: nls.localize(13, null)
                        }
                    }
                }
            },
            extensionDependencies: {
                description: nls.localize(14, null),
                type: 'array',
                uniqueItems: true,
                items: {
                    type: 'string'
                }
            },
            scripts: {
                type: 'object',
                properties: {
                    'vscode:prepublish': {
                        description: nls.localize(15, null),
                        type: 'string'
                    }
                }
            },
            icon: {
                type: 'string',
                description: nls.localize(16, null)
            }
        }
    };
    var ExtensionsRegistryImpl = (function () {
        function ExtensionsRegistryImpl() {
            this._extensionPoints = {};
        }
        ExtensionsRegistryImpl.prototype.registerExtensionPoint = function (extensionPoint, deps, jsonSchema) {
            if (hasOwnProperty.call(this._extensionPoints, extensionPoint)) {
                throw new Error('Duplicate extension point: ' + extensionPoint);
            }
            var result = new ExtensionPoint(extensionPoint);
            this._extensionPoints[extensionPoint] = result;
            schema.properties['contributes'].properties[extensionPoint] = jsonSchema;
            schemaRegistry.registerSchema(schemaId, schema);
            return result;
        };
        ExtensionsRegistryImpl.prototype.getExtensionPoints = function () {
            var _this = this;
            return Object.keys(this._extensionPoints).map(function (point) { return _this._extensionPoints[point]; });
        };
        return ExtensionsRegistryImpl;
    }());
    exports.ExtensionsRegistryImpl = ExtensionsRegistryImpl;
    var PRExtensions = {
        ExtensionsRegistry: 'ExtensionsRegistry'
    };
    platform_1.Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
    exports.ExtensionsRegistry = platform_1.Registry.as(PRExtensions.ExtensionsRegistry);
    schemaRegistry.registerSchema(schemaId, schema);
});

define(__m[426/*vs/editor/common/services/modeServiceImpl*/], __M([1/*require*/,0/*exports*/,277/*vs/nls!vs/editor/common/services/modeServiceImpl*/,10/*vs/base/common/errors*/,12/*vs/base/common/event*/,6/*vs/base/common/winjs.base*/,151/*vs/platform/extensions/common/extensionsRegistry*/,177/*vs/editor/common/modes/abstractMode*/,420/*vs/editor/common/services/languagesRegistry*/]), function (require, exports, nls, errors_1, event_1, winjs_base_1, extensionsRegistry_1, abstractMode_1, languagesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.languagesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('languages', [], {
        description: nls.localize(0, null),
        type: 'array',
        items: {
            type: 'object',
            defaultSnippets: [{ body: { id: '${1:languageId}', aliases: ['${2:label}'], extensions: ['${3:extension}'], configuration: './language-configuration.json' } }],
            properties: {
                id: {
                    description: nls.localize(1, null),
                    type: 'string'
                },
                aliases: {
                    description: nls.localize(2, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                extensions: {
                    description: nls.localize(3, null),
                    default: ['.foo'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenames: {
                    description: nls.localize(4, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenamePatterns: {
                    description: nls.localize(5, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                mimetypes: {
                    description: nls.localize(6, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                firstLine: {
                    description: nls.localize(7, null),
                    type: 'string'
                },
                configuration: {
                    description: nls.localize(8, null),
                    type: 'string',
                    default: './language-configuration.json'
                }
            }
        }
    });
    var ModeServiceImpl = (function () {
        function ModeServiceImpl() {
            var _this = this;
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this._onDidCreateMode = new event_1.Emitter();
            this.onDidCreateMode = this._onDidCreateMode.event;
            this._instantiatedModes = {};
            this._registry = new languagesRegistry_1.LanguagesRegistry();
            this._registry.onDidAddModes(function (modes) { return _this._onDidAddModes.fire(modes); });
        }
        ModeServiceImpl.prototype._onReady = function () {
            return winjs_base_1.TPromise.as(true);
        };
        ModeServiceImpl.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            return this._registry.isRegisteredMode(mimetypeOrModeId);
        };
        ModeServiceImpl.prototype.getRegisteredModes = function () {
            return this._registry.getRegisteredModes();
        };
        ModeServiceImpl.prototype.getRegisteredLanguageNames = function () {
            return this._registry.getRegisteredLanguageNames();
        };
        ModeServiceImpl.prototype.getExtensions = function (alias) {
            return this._registry.getExtensions(alias);
        };
        ModeServiceImpl.prototype.getFilenames = function (alias) {
            return this._registry.getFilenames(alias);
        };
        ModeServiceImpl.prototype.getMimeForMode = function (modeId) {
            return this._registry.getMimeForMode(modeId);
        };
        ModeServiceImpl.prototype.getLanguageName = function (modeId) {
            return this._registry.getLanguageName(modeId);
        };
        ModeServiceImpl.prototype.getModeIdForLanguageName = function (alias) {
            return this._registry.getModeIdForLanguageNameLowercase(alias);
        };
        ModeServiceImpl.prototype.getModeIdByFilenameOrFirstLine = function (filename, firstLine) {
            var modeIds = this._registry.getModeIdsFromFilenameOrFirstLine(filename, firstLine);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getModeId = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getLanguageIdentifier = function (modeId) {
            return this._registry.getLanguageIdentifier(modeId);
        };
        ModeServiceImpl.prototype.getConfigurationFiles = function (modeId) {
            return this._registry.getConfigurationFiles(modeId);
        };
        // --- instantiation
        ModeServiceImpl.prototype.lookup = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var r = [];
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            for (var i = 0; i < modeIds.length; i++) {
                var modeId = modeIds[i];
                r.push({
                    modeId: modeId,
                    isInstantiated: this._instantiatedModes.hasOwnProperty(modeId)
                });
            }
            return r;
        };
        ModeServiceImpl.prototype.getMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            var isPlainText = false;
            for (var i = 0; i < modeIds.length; i++) {
                if (this._instantiatedModes.hasOwnProperty(modeIds[i])) {
                    return this._instantiatedModes[modeIds[i]];
                }
                isPlainText = isPlainText || (modeIds[i] === 'plaintext');
            }
            if (isPlainText) {
                // Try to do it synchronously
                var r = null;
                this.getOrCreateMode(commaSeparatedMimetypesOrCommaSeparatedIds).then(function (mode) {
                    r = mode;
                }).done(null, errors_1.onUnexpectedError);
                return r;
            }
        };
        ModeServiceImpl.prototype.getOrCreateMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var _this = this;
            return this._onReady().then(function () {
                var modeId = _this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype.getOrCreateModeByLanguageName = function (languageName) {
            var _this = this;
            return this._onReady().then(function () {
                var modeId = _this._getModeIdByLanguageName(languageName);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype._getModeIdByLanguageName = function (languageName) {
            var modeIds = this._registry.getModeIdsFromLanguageName(languageName);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getOrCreateModeByFilenameOrFirstLine = function (filename, firstLine) {
            var _this = this;
            return this._onReady().then(function () {
                var modeId = _this.getModeIdByFilenameOrFirstLine(filename, firstLine);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype._getOrCreateMode = function (modeId) {
            if (!this._instantiatedModes.hasOwnProperty(modeId)) {
                var languageIdentifier = this.getLanguageIdentifier(modeId);
                this._instantiatedModes[modeId] = new abstractMode_1.FrankensteinMode(languageIdentifier);
                this._onDidCreateMode.fire(this._instantiatedModes[modeId]);
            }
            return this._instantiatedModes[modeId];
        };
        return ModeServiceImpl;
    }());
    exports.ModeServiceImpl = ModeServiceImpl;
});

define(__m[152/*vs/platform/configuration/common/configurationRegistry*/], __M([1/*require*/,0/*exports*/,315/*vs/nls!vs/platform/configuration/common/configurationRegistry*/,12/*vs/base/common/event*/,35/*vs/platform/platform*/,36/*vs/base/common/objects*/,24/*vs/base/common/types*/,151/*vs/platform/extensions/common/extensionsRegistry*/,150/*vs/platform/jsonschemas/common/jsonContributionRegistry*/]), function (require, exports, nls, event_1, platform_1, objects, types, extensionsRegistry_1, jsonContributionRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        Configuration: 'base.contributions.configuration'
    };
    var schemaId = 'vscode://schemas/settings';
    var contributionRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ConfigurationRegistry = (function () {
        function ConfigurationRegistry() {
            this.configurationContributors = [];
            this.configurationSchema = { properties: {}, additionalProperties: false, errorMessage: 'Unknown configuration setting' };
            this._onDidRegisterConfiguration = new event_1.Emitter();
            this.configurationProperties = {};
            contributionRegistry.registerSchema(schemaId, this.configurationSchema);
            this.registerOverrideSettingsConfiguration();
        }
        Object.defineProperty(ConfigurationRegistry.prototype, "onDidRegisterConfiguration", {
            get: function () {
                return this._onDidRegisterConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationRegistry.prototype.registerConfiguration = function (configuration) {
            this.registerConfigurations([configuration]);
        };
        ConfigurationRegistry.prototype.registerConfigurations = function (configurations) {
            var _this = this;
            configurations.forEach(function (configuration) {
                _this.registerProperties(configuration); // fills in defaults
                _this.configurationContributors.push(configuration);
                _this.registerJSONConfiguration(configuration);
                _this.updateSchemaForOverrideSettingsConfiguration(configuration);
            });
            this._onDidRegisterConfiguration.fire(this);
        };
        ConfigurationRegistry.prototype.registerProperties = function (configuration) {
            var properties = configuration.properties;
            if (properties) {
                for (var key in properties) {
                    // fill in default values
                    var property = properties[key];
                    var defaultValue = property.default;
                    if (types.isUndefined(defaultValue)) {
                        property.default = getDefaultValue(property.type);
                    }
                    // add to properties map
                    this.configurationProperties[key] = properties[key];
                }
            }
            var subNodes = configuration.allOf;
            if (subNodes) {
                for (var _i = 0, subNodes_1 = subNodes; _i < subNodes_1.length; _i++) {
                    var node = subNodes_1[_i];
                    this.registerProperties(node);
                }
            }
        };
        ConfigurationRegistry.prototype.getConfigurations = function () {
            return this.configurationContributors;
        };
        ConfigurationRegistry.prototype.getConfigurationProperties = function () {
            return this.configurationProperties;
        };
        ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
            var configurationSchema = this.configurationSchema;
            function register(configuration) {
                var properties = configuration.properties;
                if (properties) {
                    for (var key in properties) {
                        configurationSchema.properties[key] = properties[key];
                    }
                }
                var subNodes = configuration.allOf;
                if (subNodes) {
                    subNodes.forEach(register);
                }
            }
            ;
            register(configuration);
            contributionRegistry.registerSchema(schemaId, configurationSchema);
        };
        ConfigurationRegistry.prototype.updateSchemaForOverrideSettingsConfiguration = function (configuration) {
            if (this.configurationSchema.properties[exports.SETTINGS_OVERRIDE]) {
                var propertyPattern = '.*';
                if (!this.configurationSchema.properties[exports.SETTINGS_OVERRIDE].patternProperties) {
                    var patternProperties = {};
                    patternProperties[propertyPattern] = {
                        type: 'object',
                        properties: {}
                    };
                    this.configurationSchema.properties[exports.SETTINGS_OVERRIDE].patternProperties = patternProperties;
                }
                var properties = this.configurationSchema.properties[exports.SETTINGS_OVERRIDE].patternProperties[propertyPattern].properties;
                if (configuration.id !== SETTINGS_OVERRRIDE_NODE_ID) {
                    if (configuration.properties) {
                        for (var key in configuration.properties) {
                            properties[key] = this.getConfigurationProperties()[key];
                        }
                    }
                }
            }
        };
        ConfigurationRegistry.prototype.registerOverrideSettingsConfiguration = function () {
            var properties = {};
            properties[exports.SETTINGS_OVERRIDE] = {
                type: 'object',
                description: nls.localize(0, null),
            };
            this.registerConfiguration({
                id: SETTINGS_OVERRRIDE_NODE_ID,
                type: 'object',
                title: nls.localize(1, null),
                properties: properties
            });
        };
        return ConfigurationRegistry;
    }());
    var SETTINGS_OVERRRIDE_NODE_ID = 'overrideSettings';
    exports.SETTINGS_OVERRIDE = 'settings.override';
    function getDefaultValue(type) {
        var t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
            case 'number':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
    var configurationRegistry = new ConfigurationRegistry();
    platform_1.Registry.add(exports.Extensions.Configuration, configurationRegistry);
    var configurationExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('configuration', [], {
        description: nls.localize(2, null),
        type: 'object',
        defaultSnippets: [{ body: { title: '', properties: {} } }],
        properties: {
            title: {
                description: nls.localize(3, null),
                type: 'string'
            },
            properties: {
                description: nls.localize(4, null),
                type: 'object',
                additionalProperties: {
                    $ref: 'http://json-schema.org/draft-04/schema#'
                }
            }
        }
    });
    configurationExtPoint.setHandler(function (extensions) {
        var configurations = [];
        for (var i = 0; i < extensions.length; i++) {
            var configuration = extensions[i].value;
            var collector = extensions[i].collector;
            if (configuration.type && configuration.type !== 'object') {
                collector.warn(nls.localize(5, null));
            }
            else {
                configuration.type = 'object';
            }
            if (configuration.title && (typeof configuration.title !== 'string')) {
                collector.error(nls.localize(6, null));
            }
            if (configuration.properties && (typeof configuration.properties !== 'object')) {
                collector.error(nls.localize(7, null));
                return;
            }
            var clonedConfiguration = objects.clone(configuration);
            clonedConfiguration.id = extensions[i].description.id;
            configurations.push(clonedConfiguration);
        }
        configurationRegistry.registerConfigurations(configurations);
    });
});






define(__m[112/*vs/editor/common/config/commonEditorConfig*/], __M([1/*require*/,0/*exports*/,267/*vs/nls!vs/editor/common/config/commonEditorConfig*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,36/*vs/base/common/objects*/,19/*vs/base/common/platform*/,152/*vs/platform/configuration/common/configurationRegistry*/,35/*vs/platform/platform*/,44/*vs/editor/common/config/defaultConfig*/,2/*vs/editor/common/editorCommon*/,364/*vs/editor/common/viewLayout/editorLayoutProvider*/,38/*vs/base/common/scrollable*/,107/*vs/editor/common/config/fontInfo*/,106/*vs/editor/common/config/editorZoom*/]), function (require, exports, nls, event_1, lifecycle_1, objects, platform, configurationRegistry_1, platform_1, defaultConfig_1, editorCommon, editorLayoutProvider_1, scrollable_1, fontInfo_1, editorZoom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.TabFocus = new (function () {
        function class_1() {
            this._tabFocus = false;
            this._onDidChangeTabFocus = new event_1.Emitter();
            this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
        }
        class_1.prototype.getTabFocusMode = function () {
            return this._tabFocus;
        };
        class_1.prototype.setTabFocusMode = function (tabFocusMode) {
            if (this._tabFocus === tabFocusMode) {
                return;
            }
            this._tabFocus = tabFocusMode;
            this._onDidChangeTabFocus.fire(this._tabFocus);
        };
        return class_1;
    }());
    /**
     * Experimental screen reader support toggle
     */
    var GlobalScreenReaderNVDA = (function () {
        function GlobalScreenReaderNVDA() {
        }
        GlobalScreenReaderNVDA.getValue = function () {
            return this._value;
        };
        GlobalScreenReaderNVDA.setValue = function (value) {
            if (this._value === value) {
                return;
            }
            this._value = value;
            this._onChange.fire(this._value);
        };
        return GlobalScreenReaderNVDA;
    }());
    GlobalScreenReaderNVDA._value = false;
    GlobalScreenReaderNVDA._onChange = new event_1.Emitter();
    GlobalScreenReaderNVDA.onChange = GlobalScreenReaderNVDA._onChange.event;
    exports.GlobalScreenReaderNVDA = GlobalScreenReaderNVDA;
    var ConfigurationWithDefaults = (function () {
        function ConfigurationWithDefaults(options) {
            this._editor = objects.clone(defaultConfig_1.DefaultConfig.editor);
            this._mergeOptionsIn(options);
        }
        ConfigurationWithDefaults.prototype.getEditorOptions = function () {
            return this._editor;
        };
        ConfigurationWithDefaults.prototype._mergeOptionsIn = function (newOptions) {
            this._editor = objects.mixin(this._editor, newOptions || {});
        };
        ConfigurationWithDefaults.prototype.updateOptions = function (newOptions) {
            // Apply new options
            this._mergeOptionsIn(newOptions);
        };
        return ConfigurationWithDefaults;
    }());
    exports.ConfigurationWithDefaults = ConfigurationWithDefaults;
    var InternalEditorOptionsHelper = (function () {
        function InternalEditorOptionsHelper() {
        }
        InternalEditorOptionsHelper.createInternalEditorOptions = function (outerWidth, outerHeight, opts, fontInfo, editorClassName, isDominatedByLongLines, maxLineNumber, canUseTranslate3d) {
            var wrappingColumn = toInteger(opts.wrappingColumn, -1);
            var wordWrap = toBoolean(opts.wordWrap);
            var stopRenderingLineAfter;
            if (typeof opts.stopRenderingLineAfter !== 'undefined') {
                stopRenderingLineAfter = toInteger(opts.stopRenderingLineAfter, -1);
            }
            else if (wrappingColumn >= 0) {
                stopRenderingLineAfter = -1;
            }
            else {
                stopRenderingLineAfter = 10000;
            }
            var mouseWheelScrollSensitivity = toFloat(opts.mouseWheelScrollSensitivity, 1);
            var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, mouseWheelScrollSensitivity);
            var glyphMargin = toBoolean(opts.glyphMargin);
            var lineNumbers = opts.lineNumbers;
            var lineNumbersMinChars = toInteger(opts.lineNumbersMinChars, 1);
            var lineDecorationsWidth;
            if (typeof opts.lineDecorationsWidth === 'string' && /^\d+(\.\d+)?ch$/.test(opts.lineDecorationsWidth)) {
                var multiple = parseFloat(opts.lineDecorationsWidth.substr(0, opts.lineDecorationsWidth.length - 2));
                lineDecorationsWidth = multiple * fontInfo.typicalHalfwidthCharacterWidth;
            }
            else {
                lineDecorationsWidth = toInteger(opts.lineDecorationsWidth, 0);
            }
            if (opts.folding) {
                lineDecorationsWidth += 16;
            }
            var renderLineNumbers;
            var renderCustomLineNumbers;
            var renderRelativeLineNumbers;
            // Compatibility with old true or false values
            if (lineNumbers === true) {
                lineNumbers = 'on';
            }
            else if (lineNumbers === false) {
                lineNumbers = 'off';
            }
            if (typeof lineNumbers === 'function') {
                renderLineNumbers = true;
                renderCustomLineNumbers = lineNumbers;
                renderRelativeLineNumbers = false;
            }
            else if (lineNumbers === 'relative') {
                renderLineNumbers = true;
                renderCustomLineNumbers = null;
                renderRelativeLineNumbers = true;
            }
            else if (lineNumbers === 'on') {
                renderLineNumbers = true;
                renderCustomLineNumbers = null;
                renderRelativeLineNumbers = false;
            }
            else {
                renderLineNumbers = false;
                renderCustomLineNumbers = null;
                renderRelativeLineNumbers = false;
            }
            var layoutInfo = editorLayoutProvider_1.EditorLayoutProvider.compute({
                outerWidth: outerWidth,
                outerHeight: outerHeight,
                showGlyphMargin: glyphMargin,
                lineHeight: fontInfo.lineHeight,
                showLineNumbers: renderLineNumbers,
                lineNumbersMinChars: lineNumbersMinChars,
                lineDecorationsWidth: lineDecorationsWidth,
                maxDigitWidth: fontInfo.maxDigitWidth,
                maxLineNumber: maxLineNumber,
                verticalScrollbarWidth: scrollbar.verticalScrollbarSize,
                horizontalScrollbarHeight: scrollbar.horizontalScrollbarSize,
                scrollbarArrowSize: scrollbar.arrowSize,
                verticalScrollbarHasArrows: scrollbar.verticalHasArrows
            });
            if (isDominatedByLongLines && wrappingColumn > 0) {
                // Force viewport width wrapping if model is dominated by long lines
                wrappingColumn = 0;
            }
            var bareWrappingInfo;
            if (wrappingColumn === 0) {
                // If viewport width wrapping is enabled
                bareWrappingInfo = {
                    isViewportWrapping: true,
                    wrappingColumn: Math.max(1, Math.floor((layoutInfo.contentWidth - layoutInfo.verticalScrollbarWidth) / fontInfo.typicalHalfwidthCharacterWidth))
                };
            }
            else if (wrappingColumn > 0 && wordWrap === true) {
                // Enable smart viewport wrapping
                bareWrappingInfo = {
                    isViewportWrapping: true,
                    wrappingColumn: Math.min(wrappingColumn, Math.floor((layoutInfo.contentWidth - layoutInfo.verticalScrollbarWidth) / fontInfo.typicalHalfwidthCharacterWidth))
                };
            }
            else if (wrappingColumn > 0) {
                // Wrapping is enabled
                bareWrappingInfo = {
                    isViewportWrapping: false,
                    wrappingColumn: wrappingColumn
                };
            }
            else {
                bareWrappingInfo = {
                    isViewportWrapping: false,
                    wrappingColumn: -1
                };
            }
            var wrappingInfo = new editorCommon.EditorWrappingInfo({
                isViewportWrapping: bareWrappingInfo.isViewportWrapping,
                wrappingColumn: bareWrappingInfo.wrappingColumn,
                wrappingIndent: wrappingIndentFromString(opts.wrappingIndent),
                wordWrapBreakBeforeCharacters: String(opts.wordWrapBreakBeforeCharacters),
                wordWrapBreakAfterCharacters: String(opts.wordWrapBreakAfterCharacters),
                wordWrapBreakObtrusiveCharacters: String(opts.wordWrapBreakObtrusiveCharacters),
            });
            var readOnly = toBoolean(opts.readOnly);
            var tabFocusMode = exports.TabFocus.getTabFocusMode();
            if (readOnly) {
                tabFocusMode = true;
            }
            var renderWhitespace = opts.renderWhitespace;
            // Compatibility with old true or false values
            if (renderWhitespace === true) {
                renderWhitespace = 'boundary';
            }
            else if (renderWhitespace === false) {
                renderWhitespace = 'none';
            }
            var renderLineHighlight = opts.renderLineHighlight;
            // Compatibility with old true or false values
            if (renderLineHighlight === true) {
                renderLineHighlight = 'line';
            }
            else if (renderLineHighlight === false) {
                renderLineHighlight = 'none';
            }
            var viewInfo = new editorCommon.InternalEditorViewOptions({
                theme: opts.theme,
                canUseTranslate3d: canUseTranslate3d,
                experimentalScreenReader: toBoolean(opts.experimentalScreenReader),
                rulers: toSortedIntegerArray(opts.rulers),
                ariaLabel: String(opts.ariaLabel),
                renderLineNumbers: renderLineNumbers,
                renderCustomLineNumbers: renderCustomLineNumbers,
                renderRelativeLineNumbers: renderRelativeLineNumbers,
                selectOnLineNumbers: toBoolean(opts.selectOnLineNumbers),
                glyphMargin: glyphMargin,
                revealHorizontalRightPadding: toInteger(opts.revealHorizontalRightPadding, 0),
                roundedSelection: toBoolean(opts.roundedSelection),
                overviewRulerLanes: toInteger(opts.overviewRulerLanes, 0, 3),
                cursorBlinking: cursorBlinkingStyleFromString(opts.cursorBlinking),
                mouseWheelZoom: toBoolean(opts.mouseWheelZoom),
                cursorStyle: cursorStyleFromString(opts.cursorStyle),
                hideCursorInOverviewRuler: toBoolean(opts.hideCursorInOverviewRuler),
                scrollBeyondLastLine: toBoolean(opts.scrollBeyondLastLine),
                editorClassName: editorClassName,
                stopRenderingLineAfter: stopRenderingLineAfter,
                renderWhitespace: renderWhitespace,
                renderControlCharacters: toBoolean(opts.renderControlCharacters),
                renderIndentGuides: toBoolean(opts.renderIndentGuides),
                renderLineHighlight: renderLineHighlight,
                scrollbar: scrollbar,
                fixedOverflowWidgets: toBoolean(opts.fixedOverflowWidgets)
            });
            var contribInfo = new editorCommon.EditorContribOptions({
                selectionClipboard: toBoolean(opts.selectionClipboard),
                hover: toBoolean(opts.hover),
                contextmenu: toBoolean(opts.contextmenu),
                quickSuggestions: toBoolean(opts.quickSuggestions),
                quickSuggestionsDelay: toInteger(opts.quickSuggestionsDelay),
                parameterHints: toBoolean(opts.parameterHints),
                iconsInSuggestions: toBoolean(opts.iconsInSuggestions),
                formatOnType: toBoolean(opts.formatOnType),
                suggestOnTriggerCharacters: toBoolean(opts.suggestOnTriggerCharacters),
                acceptSuggestionOnEnter: toBoolean(opts.acceptSuggestionOnEnter),
                acceptSuggestionOnCommitCharacter: toBoolean(opts.acceptSuggestionOnCommitCharacter),
                snippetSuggestions: opts.snippetSuggestions,
                emptySelectionClipboard: opts.emptySelectionClipboard,
                tabCompletion: opts.tabCompletion,
                wordBasedSuggestions: opts.wordBasedSuggestions,
                suggestFontSize: opts.suggestFontSize,
                suggestLineHeight: opts.suggestLineHeight,
                selectionHighlight: toBoolean(opts.selectionHighlight),
                codeLens: opts.referenceInfos && opts.codeLens,
                folding: toBoolean(opts.folding),
            });
            return new editorCommon.InternalEditorOptions({
                lineHeight: fontInfo.lineHeight,
                readOnly: readOnly,
                wordSeparators: String(opts.wordSeparators),
                autoClosingBrackets: toBoolean(opts.autoClosingBrackets),
                useTabStops: toBoolean(opts.useTabStops),
                tabFocusMode: tabFocusMode,
                layoutInfo: layoutInfo,
                fontInfo: fontInfo,
                viewInfo: viewInfo,
                wrappingInfo: wrappingInfo,
                contribInfo: contribInfo,
            });
        };
        InternalEditorOptionsHelper._sanitizeScrollbarOpts = function (raw, mouseWheelScrollSensitivity) {
            var visibilityFromString = function (visibility) {
                switch (visibility) {
                    case 'hidden':
                        return scrollable_1.ScrollbarVisibility.Hidden;
                    case 'visible':
                        return scrollable_1.ScrollbarVisibility.Visible;
                    default:
                        return scrollable_1.ScrollbarVisibility.Auto;
                }
            };
            var horizontalScrollbarSize = toIntegerWithDefault(raw.horizontalScrollbarSize, 10);
            var verticalScrollbarSize = toIntegerWithDefault(raw.verticalScrollbarSize, 14);
            return new editorCommon.InternalEditorScrollbarOptions({
                vertical: visibilityFromString(raw.vertical),
                horizontal: visibilityFromString(raw.horizontal),
                arrowSize: toIntegerWithDefault(raw.arrowSize, 11),
                useShadows: toBooleanWithDefault(raw.useShadows, true),
                verticalHasArrows: toBooleanWithDefault(raw.verticalHasArrows, false),
                horizontalHasArrows: toBooleanWithDefault(raw.horizontalHasArrows, false),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: toIntegerWithDefault(raw.horizontalSliderSize, horizontalScrollbarSize),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: toIntegerWithDefault(raw.verticalSliderSize, verticalScrollbarSize),
                handleMouseWheel: toBooleanWithDefault(raw.handleMouseWheel, true),
                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
            });
        };
        return InternalEditorOptionsHelper;
    }());
    function toBoolean(value) {
        return value === 'false' ? false : Boolean(value);
    }
    function toBooleanWithDefault(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        return toBoolean(value);
    }
    function toFloat(source, defaultValue) {
        var r = parseFloat(source);
        if (isNaN(r)) {
            r = defaultValue;
        }
        return r;
    }
    function toInteger(source, minimum, maximum) {
        if (minimum === void 0) { minimum = -1073741824 /* MIN_SAFE_SMALL_INTEGER */; }
        if (maximum === void 0) { maximum = 1073741824 /* MAX_SAFE_SMALL_INTEGER */; }
        var r = parseInt(source, 10);
        if (isNaN(r)) {
            r = 0;
        }
        r = Math.max(minimum, r);
        r = Math.min(maximum, r);
        return r | 0;
    }
    function toSortedIntegerArray(source) {
        if (!Array.isArray(source)) {
            return [];
        }
        var arrSource = source;
        var r = arrSource.map(function (el) { return toInteger(el); });
        r.sort();
        return r;
    }
    function wrappingIndentFromString(wrappingIndent) {
        if (wrappingIndent === 'indent') {
            return editorCommon.WrappingIndent.Indent;
        }
        else if (wrappingIndent === 'same') {
            return editorCommon.WrappingIndent.Same;
        }
        else {
            return editorCommon.WrappingIndent.None;
        }
    }
    function cursorStyleFromString(cursorStyle) {
        if (cursorStyle === 'line') {
            return editorCommon.TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return editorCommon.TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return editorCommon.TextEditorCursorStyle.Underline;
        }
        return editorCommon.TextEditorCursorStyle.Line;
    }
    function cursorBlinkingStyleFromString(cursorBlinkingStyle) {
        switch (cursorBlinkingStyle) {
            case 'blink':
                return editorCommon.TextEditorCursorBlinkingStyle.Blink;
            case 'smooth':
                return editorCommon.TextEditorCursorBlinkingStyle.Smooth;
            case 'phase':
                return editorCommon.TextEditorCursorBlinkingStyle.Phase;
            case 'expand':
                return editorCommon.TextEditorCursorBlinkingStyle.Expand;
            case 'visible': // maintain compatibility
            case 'solid':
                return editorCommon.TextEditorCursorBlinkingStyle.Solid;
        }
        return editorCommon.TextEditorCursorBlinkingStyle.Blink;
    }
    function toIntegerWithDefault(source, defaultValue) {
        if (typeof source === 'undefined') {
            return defaultValue;
        }
        return toInteger(source);
    }
    var CommonEditorConfiguration = (function (_super) {
        __extends(CommonEditorConfiguration, _super);
        function CommonEditorConfiguration(options, elementSizeObserver) {
            if (elementSizeObserver === void 0) { elementSizeObserver = null; }
            var _this = _super.call(this) || this;
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            _this._configWithDefaults = new ConfigurationWithDefaults(options);
            _this._elementSizeObserver = elementSizeObserver;
            _this._isDominatedByLongLines = false;
            _this._maxLineNumber = 1;
            _this.editor = _this._computeInternalOptions();
            _this.editorClone = _this.editor.clone();
            _this._register(editorZoom_1.EditorZoom.onDidChangeZoomLevel(function (_) { return _this._recomputeOptions(); }));
            _this._register(exports.TabFocus.onDidChangeTabFocus(function (_) { return _this._recomputeOptions(); }));
            return _this;
        }
        CommonEditorConfiguration.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        CommonEditorConfiguration.prototype._recomputeOptions = function () {
            this._setOptions(this._computeInternalOptions());
        };
        CommonEditorConfiguration.prototype._setOptions = function (newOptions) {
            if (this.editor && this.editor.equals(newOptions)) {
                return;
            }
            var changeEvent = this.editor.createChangeEvent(newOptions);
            this.editor = newOptions;
            this.editorClone = this.editor.clone();
            this._onDidChange.fire(changeEvent);
        };
        CommonEditorConfiguration.prototype.getRawOptions = function () {
            return this._configWithDefaults.getEditorOptions();
        };
        CommonEditorConfiguration.prototype._computeInternalOptions = function () {
            var opts = this._configWithDefaults.getEditorOptions();
            var editorClassName = this._getEditorClassName(opts.theme, toBoolean(opts.fontLigatures));
            var disableTranslate3d = toBoolean(opts.disableTranslate3d);
            var canUseTranslate3d = this._getCanUseTranslate3d();
            if (disableTranslate3d) {
                canUseTranslate3d = false;
            }
            var bareFontInfo = fontInfo_1.BareFontInfo.createFromRawSettings(opts);
            return InternalEditorOptionsHelper.createInternalEditorOptions(this.getOuterWidth(), this.getOuterHeight(), opts, this.readConfiguration(bareFontInfo), editorClassName, this._isDominatedByLongLines, this._maxLineNumber, canUseTranslate3d);
        };
        CommonEditorConfiguration.prototype.updateOptions = function (newOptions) {
            this._configWithDefaults.updateOptions(newOptions);
            this._recomputeOptions();
        };
        CommonEditorConfiguration.prototype.setIsDominatedByLongLines = function (isDominatedByLongLines) {
            this._isDominatedByLongLines = isDominatedByLongLines;
            this._recomputeOptions();
        };
        CommonEditorConfiguration.prototype.setMaxLineNumber = function (maxLineNumber) {
            this._maxLineNumber = maxLineNumber;
            this._recomputeOptions();
        };
        return CommonEditorConfiguration;
    }(lifecycle_1.Disposable));
    exports.CommonEditorConfiguration = CommonEditorConfiguration;
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    var editorConfiguration = {
        'id': 'editor',
        'order': 5,
        'type': 'object',
        'title': nls.localize(0, null),
        'properties': {
            'editor.fontFamily': {
                'type': 'string',
                'default': defaultConfig_1.DefaultConfig.editor.fontFamily,
                'description': nls.localize(1, null)
            },
            'editor.fontWeight': {
                'type': 'string',
                'enum': ['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900'],
                'default': defaultConfig_1.DefaultConfig.editor.fontWeight,
                'description': nls.localize(2, null)
            },
            'editor.fontSize': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.fontSize,
                'description': nls.localize(3, null)
            },
            'editor.lineHeight': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.lineHeight,
                'description': nls.localize(4, null)
            },
            'editor.lineNumbers': {
                'type': 'string',
                'enum': ['off', 'on', 'relative'],
                'default': defaultConfig_1.DefaultConfig.editor.lineNumbers,
                'description': nls.localize(5, null)
            },
            'editor.rulers': {
                'type': 'array',
                'items': {
                    'type': 'number'
                },
                'default': defaultConfig_1.DefaultConfig.editor.rulers,
                'description': nls.localize(6, null)
            },
            'editor.wordSeparators': {
                'type': 'string',
                'default': defaultConfig_1.DefaultConfig.editor.wordSeparators,
                'description': nls.localize(7, null)
            },
            'editor.tabSize': {
                'type': 'number',
                'default': defaultConfig_1.DEFAULT_INDENTATION.tabSize,
                'minimum': 1,
                'description': nls.localize(8, null),
                'errorMessage': nls.localize(9, null)
            },
            'editor.insertSpaces': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
                'description': nls.localize(10, null),
                'errorMessage': nls.localize(11, null)
            },
            'editor.detectIndentation': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_INDENTATION.detectIndentation,
                'description': nls.localize(12, null)
            },
            'editor.roundedSelection': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.roundedSelection,
                'description': nls.localize(13, null)
            },
            'editor.scrollBeyondLastLine': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.scrollBeyondLastLine,
                'description': nls.localize(14, null)
            },
            'editor.wrappingColumn': {
                'type': 'integer',
                'default': defaultConfig_1.DefaultConfig.editor.wrappingColumn,
                'minimum': -1,
                'description': nls.localize(15, null)
            },
            'editor.wordWrap': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.wordWrap,
                'description': nls.localize(16, null)
            },
            'editor.wrappingIndent': {
                'type': 'string',
                'enum': ['none', 'same', 'indent'],
                'default': defaultConfig_1.DefaultConfig.editor.wrappingIndent,
                'description': nls.localize(17, null)
            },
            'editor.mouseWheelScrollSensitivity': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.mouseWheelScrollSensitivity,
                'description': nls.localize(18, null)
            },
            'editor.quickSuggestions': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.quickSuggestions,
                'description': nls.localize(19, null)
            },
            'editor.quickSuggestionsDelay': {
                'type': 'integer',
                'default': defaultConfig_1.DefaultConfig.editor.quickSuggestionsDelay,
                'minimum': 0,
                'description': nls.localize(20, null)
            },
            'editor.parameterHints': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.parameterHints,
                'description': nls.localize(21, null)
            },
            'editor.autoClosingBrackets': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.autoClosingBrackets,
                'description': nls.localize(22, null)
            },
            'editor.formatOnType': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.formatOnType,
                'description': nls.localize(23, null)
            },
            'editor.suggestOnTriggerCharacters': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.suggestOnTriggerCharacters,
                'description': nls.localize(24, null)
            },
            'editor.acceptSuggestionOnEnter': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.acceptSuggestionOnEnter,
                'description': nls.localize(25, null)
            },
            'editor.acceptSuggestionOnCommitCharacter': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.acceptSuggestionOnCommitCharacter,
                'description': nls.localize(26, null)
            },
            'editor.snippetSuggestions': {
                'type': 'string',
                'enum': ['top', 'bottom', 'inline', 'none'],
                'default': defaultConfig_1.DefaultConfig.editor.snippetSuggestions,
                'description': nls.localize(27, null)
            },
            'editor.emptySelectionClipboard': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.emptySelectionClipboard,
                'description': nls.localize(28, null)
            },
            'editor.wordBasedSuggestions': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.wordBasedSuggestions,
                'description': nls.localize(29, null)
            },
            'editor.suggestFontSize': {
                'type': 'integer',
                'default': 0,
                'minimum': 0,
                'description': nls.localize(30, null)
            },
            'editor.suggestLineHeight': {
                'type': 'integer',
                'default': 0,
                'minimum': 0,
                'description': nls.localize(31, null)
            },
            'editor.tabCompletion': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.tabCompletion,
                'description': nls.localize(32, null)
            },
            'editor.selectionHighlight': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.selectionHighlight,
                'description': nls.localize(33, null)
            },
            'editor.overviewRulerLanes': {
                'type': 'integer',
                'default': 3,
                'description': nls.localize(34, null)
            },
            'editor.cursorBlinking': {
                'type': 'string',
                'enum': ['blink', 'smooth', 'phase', 'expand', 'solid'],
                'default': defaultConfig_1.DefaultConfig.editor.cursorBlinking,
                'description': nls.localize(35, null)
            },
            'editor.mouseWheelZoom': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.mouseWheelZoom,
                'description': nls.localize(36, null)
            },
            'editor.cursorStyle': {
                'type': 'string',
                'enum': ['block', 'line', 'underline'],
                'default': defaultConfig_1.DefaultConfig.editor.cursorStyle,
                'description': nls.localize(37, null)
            },
            'editor.fontLigatures': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.fontLigatures,
                'description': nls.localize(38, null)
            },
            'editor.hideCursorInOverviewRuler': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.hideCursorInOverviewRuler,
                'description': nls.localize(39, null)
            },
            'editor.renderWhitespace': {
                'type': 'string',
                'enum': ['none', 'boundary', 'all'],
                default: defaultConfig_1.DefaultConfig.editor.renderWhitespace,
                description: nls.localize(40, null)
            },
            'editor.renderControlCharacters': {
                'type': 'boolean',
                default: defaultConfig_1.DefaultConfig.editor.renderControlCharacters,
                description: nls.localize(41, null)
            },
            'editor.renderIndentGuides': {
                'type': 'boolean',
                default: defaultConfig_1.DefaultConfig.editor.renderIndentGuides,
                description: nls.localize(42, null)
            },
            'editor.renderLineHighlight': {
                'type': 'string',
                'enum': ['none', 'gutter', 'line', 'all'],
                default: defaultConfig_1.DefaultConfig.editor.renderLineHighlight,
                description: nls.localize(43, null)
            },
            'editor.codeLens': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.codeLens,
                'description': nls.localize(44, null)
            },
            'editor.folding': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.folding,
                'description': nls.localize(45, null)
            },
            'editor.glyphMargin': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.glyphMargin,
                'description': nls.localize(46, null)
            },
            'editor.useTabStops': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.useTabStops,
                'description': nls.localize(47, null)
            },
            'editor.trimAutoWhitespace': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
                'description': nls.localize(48, null)
            },
            'editor.stablePeek': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(49, null)
            },
            'diffEditor.renderSideBySide': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(50, null)
            },
            'diffEditor.ignoreTrimWhitespace': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(51, null)
            },
            'diffEditor.renderIndicators': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(52, null)
            }
        }
    };
    if (platform.isLinux) {
        editorConfiguration['properties']['editor.selectionClipboard'] = {
            'type': 'boolean',
            'default': defaultConfig_1.DefaultConfig.editor.selectionClipboard,
            'description': nls.localize(53, null)
        };
    }
    configurationRegistry.registerConfiguration(editorConfiguration);
});






define(__m[55/*vs/editor/browser/config/configuration*/], __M([1/*require*/,0/*exports*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,19/*vs/base/common/platform*/,23/*vs/base/browser/browser*/,112/*vs/editor/common/config/commonEditorConfig*/,107/*vs/editor/common/config/fontInfo*/,425/*vs/editor/browser/config/elementSizeObserver*/,424/*vs/editor/browser/config/charWidthReader*/]), function (require, exports, event_1, lifecycle_1, platform, browser, commonEditorConfig_1, fontInfo_1, elementSizeObserver_1, charWidthReader_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CSSBasedConfigurationCache = (function () {
        function CSSBasedConfigurationCache() {
            this._keys = Object.create(null);
            this._values = Object.create(null);
        }
        CSSBasedConfigurationCache.prototype.has = function (item) {
            return !!this._values[item.getId()];
        };
        CSSBasedConfigurationCache.prototype.get = function (item) {
            return this._values[item.getId()];
        };
        CSSBasedConfigurationCache.prototype.put = function (item, value) {
            this._keys[item.getId()] = item;
            this._values[item.getId()] = value;
        };
        CSSBasedConfigurationCache.prototype.getKeys = function () {
            var _this = this;
            return Object.keys(this._keys).map(function (id) { return _this._keys[id]; });
        };
        return CSSBasedConfigurationCache;
    }());
    function readFontInfo(bareFontInfo) {
        return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);
    }
    exports.readFontInfo = readFontInfo;
    var CSSBasedConfiguration = (function (_super) {
        __extends(CSSBasedConfiguration, _super);
        function CSSBasedConfiguration() {
            var _this = _super.call(this) || this;
            _this._changeMonitorTimeout = -1;
            _this._onDidChange = _this._register(new event_1.Emitter());
            _this.onDidChange = _this._onDidChange.event;
            _this._cache = new CSSBasedConfigurationCache();
            return _this;
        }
        CSSBasedConfiguration.prototype.dispose = function () {
            if (this._changeMonitorTimeout !== -1) {
                clearTimeout(this._changeMonitorTimeout);
                this._changeMonitorTimeout = -1;
            }
            _super.prototype.dispose.call(this);
        };
        CSSBasedConfiguration.prototype.readConfiguration = function (bareFontInfo) {
            if (!this._cache.has(bareFontInfo)) {
                var readConfig = CSSBasedConfiguration._actualReadConfiguration(bareFontInfo);
                if (readConfig.typicalHalfwidthCharacterWidth <= 2 || readConfig.typicalFullwidthCharacterWidth <= 2 || readConfig.spaceWidth <= 2 || readConfig.maxDigitWidth <= 2) {
                    // Hey, it's Bug 14341 ... we couldn't read
                    readConfig = new fontInfo_1.FontInfo({
                        fontFamily: readConfig.fontFamily,
                        fontWeight: readConfig.fontWeight,
                        fontSize: readConfig.fontSize,
                        lineHeight: readConfig.lineHeight,
                        isMonospace: readConfig.isMonospace,
                        typicalHalfwidthCharacterWidth: Math.max(readConfig.typicalHalfwidthCharacterWidth, 5),
                        typicalFullwidthCharacterWidth: Math.max(readConfig.typicalFullwidthCharacterWidth, 5),
                        spaceWidth: Math.max(readConfig.spaceWidth, 5),
                        maxDigitWidth: Math.max(readConfig.maxDigitWidth, 5),
                    });
                    this._installChangeMonitor();
                }
                this._cache.put(bareFontInfo, readConfig);
            }
            return this._cache.get(bareFontInfo);
        };
        CSSBasedConfiguration.prototype._installChangeMonitor = function () {
            var _this = this;
            if (this._changeMonitorTimeout === -1) {
                this._changeMonitorTimeout = setTimeout(function () {
                    _this._changeMonitorTimeout = -1;
                    _this._monitorForChanges();
                }, 500);
            }
        };
        CSSBasedConfiguration.prototype._monitorForChanges = function () {
            var shouldInstallChangeMonitor = false;
            var keys = this._cache.getKeys();
            for (var i = 0; i < keys.length; i++) {
                var styling = keys[i];
                var newValue = CSSBasedConfiguration._actualReadConfiguration(styling);
                if (newValue.typicalHalfwidthCharacterWidth <= 2 || newValue.typicalFullwidthCharacterWidth <= 2 || newValue.maxDigitWidth <= 2) {
                    // We still couldn't read the CSS config
                    shouldInstallChangeMonitor = true;
                }
                else {
                    this._cache.put(styling, newValue);
                    this._onDidChange.fire();
                }
            }
            if (shouldInstallChangeMonitor) {
                this._installChangeMonitor();
            }
        };
        CSSBasedConfiguration.createRequest = function (chr, type, all, monospace) {
            var result = new charWidthReader_1.CharWidthRequest(chr, type);
            all.push(result);
            if (monospace) {
                monospace.push(result);
            }
            return result;
        };
        CSSBasedConfiguration._actualReadConfiguration = function (bareFontInfo) {
            var all = [];
            var monospace = [];
            var typicalHalfwidthCharacter = this.createRequest('n', 0 /* Regular */, all, monospace);
            var typicalFullwidthCharacter = this.createRequest('\uff4d', 0 /* Regular */, all, null);
            var space = this.createRequest(' ', 0 /* Regular */, all, monospace);
            var digit0 = this.createRequest('0', 0 /* Regular */, all, monospace);
            var digit1 = this.createRequest('1', 0 /* Regular */, all, monospace);
            var digit2 = this.createRequest('2', 0 /* Regular */, all, monospace);
            var digit3 = this.createRequest('3', 0 /* Regular */, all, monospace);
            var digit4 = this.createRequest('4', 0 /* Regular */, all, monospace);
            var digit5 = this.createRequest('5', 0 /* Regular */, all, monospace);
            var digit6 = this.createRequest('6', 0 /* Regular */, all, monospace);
            var digit7 = this.createRequest('7', 0 /* Regular */, all, monospace);
            var digit8 = this.createRequest('8', 0 /* Regular */, all, monospace);
            var digit9 = this.createRequest('9', 0 /* Regular */, all, monospace);
            // monospace test: used for whitespace rendering
            this.createRequest('→', 0 /* Regular */, all, monospace);
            this.createRequest('·', 0 /* Regular */, all, monospace);
            // monospace test: some characters
            this.createRequest('|', 0 /* Regular */, all, monospace);
            this.createRequest('/', 0 /* Regular */, all, monospace);
            this.createRequest('-', 0 /* Regular */, all, monospace);
            this.createRequest('_', 0 /* Regular */, all, monospace);
            this.createRequest('i', 0 /* Regular */, all, monospace);
            this.createRequest('l', 0 /* Regular */, all, monospace);
            this.createRequest('m', 0 /* Regular */, all, monospace);
            // monospace italic test
            this.createRequest('|', 1 /* Italic */, all, monospace);
            this.createRequest('_', 1 /* Italic */, all, monospace);
            this.createRequest('i', 1 /* Italic */, all, monospace);
            this.createRequest('l', 1 /* Italic */, all, monospace);
            this.createRequest('m', 1 /* Italic */, all, monospace);
            this.createRequest('n', 1 /* Italic */, all, monospace);
            // monospace bold test
            this.createRequest('|', 2 /* Bold */, all, monospace);
            this.createRequest('_', 2 /* Bold */, all, monospace);
            this.createRequest('i', 2 /* Bold */, all, monospace);
            this.createRequest('l', 2 /* Bold */, all, monospace);
            this.createRequest('m', 2 /* Bold */, all, monospace);
            this.createRequest('n', 2 /* Bold */, all, monospace);
            charWidthReader_1.readCharWidths(bareFontInfo, all);
            var maxDigitWidth = Math.max(digit0.width, digit1.width, digit2.width, digit3.width, digit4.width, digit5.width, digit6.width, digit7.width, digit8.width, digit9.width);
            var isMonospace = true;
            var referenceWidth = monospace[0].width;
            for (var i = 1, len = monospace.length; i < len; i++) {
                var diff = referenceWidth - monospace[i].width;
                if (diff < -0.001 || diff > 0.001) {
                    isMonospace = false;
                    break;
                }
            }
            return new fontInfo_1.FontInfo({
                fontFamily: bareFontInfo.fontFamily,
                fontWeight: bareFontInfo.fontWeight,
                fontSize: bareFontInfo.fontSize,
                lineHeight: bareFontInfo.lineHeight,
                isMonospace: isMonospace,
                typicalHalfwidthCharacterWidth: typicalHalfwidthCharacter.width,
                typicalFullwidthCharacterWidth: typicalFullwidthCharacter.width,
                spaceWidth: space.width,
                maxDigitWidth: maxDigitWidth
            });
        };
        return CSSBasedConfiguration;
    }(lifecycle_1.Disposable));
    CSSBasedConfiguration.INSTANCE = new CSSBasedConfiguration();
    var Configuration = (function (_super) {
        __extends(Configuration, _super);
        function Configuration(options, referenceDomElement) {
            if (referenceDomElement === void 0) { referenceDomElement = null; }
            var _this = _super.call(this, options, new elementSizeObserver_1.ElementSizeObserver(referenceDomElement, function () { return _this._onReferenceDomElementSizeChanged(); })) || this;
            _this._register(CSSBasedConfiguration.INSTANCE.onDidChange(function () { return function () { return _this._onCSSBasedConfigurationChanged(); }; }));
            if (_this._configWithDefaults.getEditorOptions().automaticLayout) {
                _this._elementSizeObserver.startObserving();
            }
            _this._register(browser.onDidChangeZoomLevel(function (_) { return _this._recomputeOptions(); }));
            return _this;
        }
        Configuration.applyFontInfoSlow = function (domNode, fontInfo) {
            domNode.style.fontFamily = fontInfo.fontFamily;
            domNode.style.fontWeight = fontInfo.fontWeight;
            domNode.style.fontSize = fontInfo.fontSize + 'px';
            domNode.style.lineHeight = fontInfo.lineHeight + 'px';
        };
        Configuration.applyFontInfo = function (domNode, fontInfo) {
            domNode.setFontFamily(fontInfo.fontFamily);
            domNode.setFontWeight(fontInfo.fontWeight);
            domNode.setFontSize(fontInfo.fontSize);
            domNode.setLineHeight(fontInfo.lineHeight);
        };
        Configuration.prototype._onReferenceDomElementSizeChanged = function () {
            this._recomputeOptions();
        };
        Configuration.prototype._onCSSBasedConfigurationChanged = function () {
            this._recomputeOptions();
        };
        Configuration.prototype.observeReferenceElement = function (dimension) {
            this._elementSizeObserver.observe(dimension);
        };
        Configuration.prototype.dispose = function () {
            this._elementSizeObserver.dispose();
            _super.prototype.dispose.call(this);
        };
        Configuration.prototype._getEditorClassName = function (theme, fontLigatures) {
            var extra = '';
            if (browser.isIE) {
                extra += 'ie ';
            }
            else if (browser.isFirefox) {
                extra += 'ff ';
            }
            else if (browser.isEdge) {
                extra += 'edge ';
            }
            if (platform.isMacintosh) {
                extra += 'mac ';
            }
            if (fontLigatures) {
                extra += 'enable-ligatures ';
            }
            return 'monaco-editor ' + extra + theme;
        };
        Configuration.prototype.getOuterWidth = function () {
            return this._elementSizeObserver.getWidth();
        };
        Configuration.prototype.getOuterHeight = function () {
            return this._elementSizeObserver.getHeight();
        };
        Configuration.prototype._getCanUseTranslate3d = function () {
            return browser.canUseTranslate3d && browser.getZoomLevel() === 0;
        };
        Configuration.prototype.readConfiguration = function (bareFontInfo) {
            return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);
        };
        return Configuration;
    }(commonEditorConfig_1.CommonEditorConfiguration));
    exports.Configuration = Configuration;
});






define(__m[430/*vs/editor/browser/controller/keyboardHandler*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,29/*vs/base/browser/styleMutator*/,112/*vs/editor/common/config/commonEditorConfig*/,339/*vs/editor/common/controller/textAreaHandler*/,166/*vs/editor/common/controller/textAreaState*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,47/*vs/editor/common/viewModel/viewEventHandler*/,55/*vs/editor/browser/config/configuration*/,427/*vs/editor/browser/controller/input/textAreaWrapper*/]), function (require, exports, lifecycle_1, browser, dom, styleMutator_1, commonEditorConfig_1, textAreaHandler_1, textAreaState_1, range_1, editorCommon, viewEventHandler_1, configuration_1, textAreaWrapper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KeyboardHandler = (function (_super) {
        __extends(KeyboardHandler, _super);
        function KeyboardHandler(context, viewController, viewHelper) {
            var _this = _super.call(this) || this;
            _this._lastCursorSelectionChanged = null;
            _this._context = context;
            _this.viewController = viewController;
            _this.textArea = new textAreaWrapper_1.TextAreaWrapper(viewHelper.textArea);
            configuration_1.Configuration.applyFontInfoSlow(_this.textArea.actual, _this._context.configuration.editor.fontInfo);
            _this.viewHelper = viewHelper;
            _this.contentLeft = 0;
            _this.contentWidth = 0;
            _this.scrollLeft = 0;
            _this.textAreaHandler = new textAreaHandler_1.TextAreaHandler(browser, _this._getStrategy(), _this.textArea, _this._context.model, function () { return _this.viewHelper.flushAnyAccumulatedEvents(); });
            _this._toDispose = [];
            _this._toDispose.push(_this.textAreaHandler.onKeyDown(function (e) { return _this.viewController.emitKeyDown(e._actual); }));
            _this._toDispose.push(_this.textAreaHandler.onKeyUp(function (e) { return _this.viewController.emitKeyUp(e._actual); }));
            _this._toDispose.push(_this.textAreaHandler.onPaste(function (e) { return _this.viewController.paste('keyboard', e.text, e.pasteOnNewLine); }));
            _this._toDispose.push(_this.textAreaHandler.onCut(function (e) { return _this.viewController.cut('keyboard'); }));
            _this._toDispose.push(_this.textAreaHandler.onType(function (e) {
                if (e.replaceCharCnt) {
                    _this.viewController.replacePreviousChar('keyboard', e.text, e.replaceCharCnt);
                }
                else {
                    _this.viewController.type('keyboard', e.text);
                }
            }));
            _this._toDispose.push(_this.textAreaHandler.onCompositionStart(function (e) {
                var lineNumber = e.showAtLineNumber;
                var column = e.showAtColumn;
                var revealPositionEvent = {
                    range: new range_1.Range(lineNumber, column, lineNumber, column),
                    verticalType: 0 /* Simple */,
                    revealHorizontal: true,
                    revealCursor: false
                };
                _this._context.privateViewEventBus.emit(editorCommon.ViewEventNames.RevealRangeEvent, revealPositionEvent);
                // Find range pixel position
                _this.visibleRange = _this.viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);
                if (_this.visibleRange) {
                    styleMutator_1.StyleMutator.setTop(_this.textArea.actual, _this.visibleRange.top);
                    styleMutator_1.StyleMutator.setLeft(_this.textArea.actual, _this.contentLeft + _this.visibleRange.left - _this.scrollLeft);
                }
                // Show the textarea
                styleMutator_1.StyleMutator.setHeight(_this.textArea.actual, _this._context.configuration.editor.lineHeight);
                dom.addClass(_this.viewHelper.viewDomNode, 'ime-input');
                _this.viewController.compositionStart('keyboard');
            }));
            _this._toDispose.push(_this.textAreaHandler.onCompositionUpdate(function (e) {
                if (browser.isEdgeOrIE) {
                    // Due to isEdgeOrIE (where the textarea was not cleared initially)
                    // we cannot assume the text consists only of the composited text
                    styleMutator_1.StyleMutator.setWidth(_this.textArea.actual, 0);
                }
                else {
                    // adjust width by its size
                    var canvasElem = document.createElement('canvas');
                    var context_1 = canvasElem.getContext('2d');
                    var cs = dom.getComputedStyle(_this.textArea.actual);
                    if (browser.isFirefox) {
                        // computedStyle.font is empty in Firefox...
                        context_1.font = cs.fontStyle + " " + cs.fontVariant + " " + cs.fontWeight + " " + cs.fontStretch + " " + cs.fontSize + " / " + cs.lineHeight + " " + cs.fontFamily;
                        var metrics = context_1.measureText(e.data);
                        styleMutator_1.StyleMutator.setWidth(_this.textArea.actual, metrics.width + 2); // +2 for Japanese...
                    }
                    else {
                        context_1.font = cs.font;
                        var metrics = context_1.measureText(e.data);
                        styleMutator_1.StyleMutator.setWidth(_this.textArea.actual, metrics.width);
                    }
                }
            }));
            _this._toDispose.push(_this.textAreaHandler.onCompositionEnd(function (e) {
                _this.textArea.actual.style.height = '';
                _this.textArea.actual.style.width = '';
                styleMutator_1.StyleMutator.setLeft(_this.textArea.actual, 0);
                styleMutator_1.StyleMutator.setTop(_this.textArea.actual, 0);
                dom.removeClass(_this.viewHelper.viewDomNode, 'ime-input');
                _this.visibleRange = null;
                _this.viewController.compositionEnd('keyboard');
            }));
            _this._toDispose.push(commonEditorConfig_1.GlobalScreenReaderNVDA.onChange(function (value) {
                _this.textAreaHandler.setStrategy(_this._getStrategy());
            }));
            _this._context.addEventHandler(_this);
            return _this;
        }
        KeyboardHandler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this.textAreaHandler.dispose();
            this.textArea.dispose();
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        KeyboardHandler.prototype._getStrategy = function () {
            if (commonEditorConfig_1.GlobalScreenReaderNVDA.getValue()) {
                return textAreaState_1.TextAreaStrategy.NVDA;
            }
            if (this._context.configuration.editor.viewInfo.experimentalScreenReader) {
                return textAreaState_1.TextAreaStrategy.NVDA;
            }
            return textAreaState_1.TextAreaStrategy.IENarrator;
        };
        KeyboardHandler.prototype.focusTextArea = function () {
            this.textAreaHandler.focusTextArea();
        };
        KeyboardHandler.prototype.onConfigurationChanged = function (e) {
            // Give textarea same font size & line height as editor, for the IME case (when the textarea is visible)
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfoSlow(this.textArea.actual, this._context.configuration.editor.fontInfo);
            }
            if (e.viewInfo.experimentalScreenReader) {
                this.textAreaHandler.setStrategy(this._getStrategy());
            }
            return false;
        };
        KeyboardHandler.prototype.onScrollChanged = function (e) {
            this.scrollLeft = e.scrollLeft;
            if (this.visibleRange) {
                styleMutator_1.StyleMutator.setTop(this.textArea.actual, this.visibleRange.top);
                styleMutator_1.StyleMutator.setLeft(this.textArea.actual, this.contentLeft + this.visibleRange.left - this.scrollLeft);
            }
            return false;
        };
        KeyboardHandler.prototype.onViewFocusChanged = function (isFocused) {
            this.textAreaHandler.setHasFocus(isFocused);
            return false;
        };
        KeyboardHandler.prototype.onCursorSelectionChanged = function (e) {
            this._lastCursorSelectionChanged = e;
            return false;
        };
        KeyboardHandler.prototype.onLayoutChanged = function (layoutInfo) {
            this.contentLeft = layoutInfo.contentLeft;
            this.contentWidth = layoutInfo.contentWidth;
            return false;
        };
        KeyboardHandler.prototype.writeToTextArea = function () {
            if (this._lastCursorSelectionChanged) {
                var e = this._lastCursorSelectionChanged;
                this._lastCursorSelectionChanged = null;
                this.textAreaHandler.setCursorSelections(e.selection, e.secondarySelections);
            }
        };
        return KeyboardHandler;
    }(viewEventHandler_1.ViewEventHandler));
    exports.KeyboardHandler = KeyboardHandler;
});






define(__m[431/*vs/editor/browser/view/viewOverlays*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,21/*vs/editor/browser/editorBrowser*/,135/*vs/editor/browser/view/viewLayer*/,55/*vs/editor/browser/config/configuration*/]), function (require, exports, styleMutator_1, editorBrowser, viewLayer_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewOverlays = (function (_super) {
        __extends(ViewOverlays, _super);
        function ViewOverlays(context, layoutProvider) {
            var _this = _super.call(this, context) || this;
            _this._dynamicOverlays = [];
            _this._isFocused = false;
            _this._layoutProvider = layoutProvider;
            _this.domNode.setClassName('view-overlays');
            return _this;
        }
        ViewOverlays.prototype.shouldRender = function () {
            if (_super.prototype.shouldRender.call(this)) {
                return true;
            }
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                if (dynamicOverlay.shouldRender()) {
                    return true;
                }
            }
            return false;
        };
        ViewOverlays.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._layoutProvider = null;
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                dynamicOverlay.dispose();
            }
            this._dynamicOverlays = null;
        };
        ViewOverlays.prototype.getDomNode = function () {
            return this.domNode.domNode;
        };
        ViewOverlays.prototype.addDynamicOverlay = function (overlay) {
            this._dynamicOverlays.push(overlay);
        };
        // ----- event handlers
        ViewOverlays.prototype.onViewFocusChanged = function (isFocused) {
            this._isFocused = isFocused;
            return true;
        };
        // ----- end event handlers
        ViewOverlays.prototype._createLine = function () {
            return new ViewOverlayLine(this._context, this._dynamicOverlays);
        };
        ViewOverlays.prototype.prepareRender = function (ctx) {
            var toRender = this._dynamicOverlays.filter(function (overlay) { return overlay.shouldRender(); });
            for (var i = 0, len = toRender.length; i < len; i++) {
                var dynamicOverlay = toRender[i];
                dynamicOverlay.prepareRender(ctx);
                dynamicOverlay.onDidRender();
            }
            return null;
        };
        ViewOverlays.prototype.render = function (ctx) {
            // Overwriting to bypass `shouldRender` flag
            this._viewOverlaysRender(ctx);
            this.domNode.toggleClassName('focused', this._isFocused);
        };
        ViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._renderLines.call(this, ctx.linesViewportData);
        };
        return ViewOverlays;
    }(viewLayer_1.ViewLayer));
    exports.ViewOverlays = ViewOverlays;
    var ViewOverlayLine = (function () {
        function ViewOverlayLine(context, dynamicOverlays) {
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._dynamicOverlays = dynamicOverlays;
            this._domNode = null;
            this._renderPieces = null;
        }
        ViewOverlayLine.prototype.getDomNode = function () {
            if (!this._domNode) {
                return null;
            }
            return this._domNode.domNode;
        };
        ViewOverlayLine.prototype.setDomNode = function (domNode) {
            this._domNode = styleMutator_1.createFastDomNode(domNode);
        };
        ViewOverlayLine.prototype.onContentChanged = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onTokensChanged = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
        };
        ViewOverlayLine.prototype.shouldUpdateHTML = function (startLineNumber, lineNumber, inlineDecorations) {
            var newPieces = '';
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                newPieces += dynamicOverlay.render(startLineNumber, lineNumber);
            }
            var piecesEqual = (this._renderPieces === newPieces);
            if (!piecesEqual) {
                this._renderPieces = newPieces;
            }
            return !piecesEqual;
        };
        ViewOverlayLine.prototype.getLineOuterHTML = function (out, lineNumber, deltaTop) {
            out.push("<div lineNumber=\"" + lineNumber + "\" style=\"position:absolute;top:" + deltaTop + "px;width:100%;height:" + this._lineHeight + "px;\">");
            out.push(this.getLineInnerHTML(lineNumber));
            out.push("</div>");
        };
        ViewOverlayLine.prototype.getLineInnerHTML = function (lineNumber) {
            return this._renderPieces;
        };
        ViewOverlayLine.prototype.layoutLine = function (lineNumber, deltaTop) {
            this._domNode.setLineNumber(String(lineNumber));
            this._domNode.setTop(deltaTop);
            this._domNode.setHeight(this._lineHeight);
        };
        return ViewOverlayLine;
    }());
    exports.ViewOverlayLine = ViewOverlayLine;
    var ContentViewOverlays = (function (_super) {
        __extends(ContentViewOverlays, _super);
        function ContentViewOverlays(context, layoutProvider) {
            var _this = _super.call(this, context, layoutProvider) || this;
            _this._scrollWidth = _this._layoutProvider.getScrollWidth();
            _this._contentWidth = _this._context.configuration.editor.layoutInfo.contentWidth;
            _this.domNode.setWidth(_this._scrollWidth);
            _this.domNode.setHeight(0);
            return _this;
        }
        ContentViewOverlays.prototype.onConfigurationChanged = function (e) {
            if (e.layoutInfo) {
                this._contentWidth = this._context.configuration.editor.layoutInfo.contentWidth;
            }
            return _super.prototype.onConfigurationChanged.call(this, e);
        };
        ContentViewOverlays.prototype.onScrollChanged = function (e) {
            this._scrollWidth = e.scrollWidth;
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollWidthChanged;
        };
        ContentViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._viewOverlaysRender.call(this, ctx);
            this.domNode.setWidth(Math.max(this._scrollWidth, this._contentWidth));
        };
        return ContentViewOverlays;
    }(ViewOverlays));
    exports.ContentViewOverlays = ContentViewOverlays;
    var MarginViewOverlays = (function (_super) {
        __extends(MarginViewOverlays, _super);
        function MarginViewOverlays(context, layoutProvider) {
            var _this = _super.call(this, context, layoutProvider) || this;
            _this._contentLeft = context.configuration.editor.layoutInfo.contentLeft;
            _this._canUseTranslate3d = context.configuration.editor.viewInfo.canUseTranslate3d;
            _this.domNode.setClassName(editorBrowser.ClassNames.MARGIN_VIEW_OVERLAYS);
            _this.domNode.setWidth(1);
            configuration_1.Configuration.applyFontInfo(_this.domNode, _this._context.configuration.editor.fontInfo);
            return _this;
        }
        MarginViewOverlays.prototype.onScrollChanged = function (e) {
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        MarginViewOverlays.prototype.onLayoutChanged = function (layoutInfo) {
            this._contentLeft = layoutInfo.contentLeft;
            return _super.prototype.onLayoutChanged.call(this, layoutInfo) || true;
        };
        MarginViewOverlays.prototype.onConfigurationChanged = function (e) {
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            return _super.prototype.onConfigurationChanged.call(this, e);
        };
        MarginViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._viewOverlaysRender.call(this, ctx);
            var height = Math.min(this._layoutProvider.getTotalHeight(), 1000000);
            this.domNode.setHeight(height);
            this.domNode.setWidth(this._contentLeft);
        };
        return MarginViewOverlays;
    }(ViewOverlays));
    exports.MarginViewOverlays = MarginViewOverlays;
});






define(__m[432/*vs/editor/browser/viewParts/lines/viewLines*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,29/*vs/base/browser/styleMutator*/,4/*vs/editor/common/core/range*/,16/*vs/editor/common/core/position*/,2/*vs/editor/common/editorCommon*/,21/*vs/editor/browser/editorBrowser*/,135/*vs/editor/browser/view/viewLayer*/,206/*vs/editor/browser/viewParts/lines/viewLine*/,55/*vs/editor/browser/config/configuration*/,83/*vs/editor/common/view/renderingContext*/,31/*vs/editor/browser/view/viewPart*/,332/*vs/css!vs/editor/browser/viewParts/lines/viewLines*/]), function (require, exports, async_1, styleMutator_1, range_1, position_1, editorCommon, editorBrowser_1, viewLayer_1, viewLine_1, configuration_1, renderingContext_1, viewPart_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LastRenderedData = (function () {
        function LastRenderedData() {
            this._currentVisibleRange = new range_1.Range(1, 1, 1, 1);
            this._bigNumbersDelta = 0;
        }
        LastRenderedData.prototype.getCurrentVisibleRange = function () {
            return this._currentVisibleRange;
        };
        LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {
            this._currentVisibleRange = currentVisibleRange;
        };
        LastRenderedData.prototype.getBigNumbersDelta = function () {
            return this._bigNumbersDelta;
        };
        LastRenderedData.prototype.setBigNumbersDelta = function (bigNumbersDelta) {
            this._bigNumbersDelta = bigNumbersDelta;
        };
        return LastRenderedData;
    }());
    var ViewLines = (function (_super) {
        __extends(ViewLines, _super);
        function ViewLines(context, layoutProvider) {
            var _this = _super.call(this, context) || this;
            _this._lineHeight = _this._context.configuration.editor.lineHeight;
            _this._isViewportWrapping = _this._context.configuration.editor.wrappingInfo.isViewportWrapping;
            _this._revealHorizontalRightPadding = _this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
            _this._canUseTranslate3d = context.configuration.editor.viewInfo.canUseTranslate3d;
            _this._layoutProvider = layoutProvider;
            viewPart_1.PartFingerprints.write(_this.domNode.domNode, 7 /* ViewLines */);
            _this.domNode.setClassName(editorBrowser_1.ClassNames.VIEW_LINES);
            configuration_1.Configuration.applyFontInfo(_this.domNode, _this._context.configuration.editor.fontInfo);
            // --- width & height
            _this._maxLineWidth = 0;
            _this._asyncUpdateLineWidths = new async_1.RunOnceScheduler(function () {
                _this._updateLineWidths();
            }, 200);
            _this._lastRenderedData = new LastRenderedData();
            _this._lastCursorRevealRangeHorizontallyEvent = null;
            _this._textRangeRestingSpot = document.createElement('div');
            _this._textRangeRestingSpot.className = 'textRangeRestingSpot';
            return _this;
        }
        ViewLines.prototype.dispose = function () {
            this._asyncUpdateLineWidths.dispose();
            this._layoutProvider = null;
            _super.prototype.dispose.call(this);
        };
        ViewLines.prototype.getDomNode = function () {
            return this.domNode.domNode;
        };
        // ---- begin view event handlers
        ViewLines.prototype.onConfigurationChanged = function (e) {
            var shouldRender = _super.prototype.onConfigurationChanged.call(this, e);
            if (e.wrappingInfo) {
                this._maxLineWidth = 0;
            }
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.wrappingInfo) {
                this._isViewportWrapping = this._context.configuration.editor.wrappingInfo.isViewportWrapping;
            }
            if (e.viewInfo.revealHorizontalRightPadding) {
                this._revealHorizontalRightPadding = this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            }
            return shouldRender;
        };
        ViewLines.prototype.onLayoutChanged = function (layoutInfo) {
            var shouldRender = _super.prototype.onLayoutChanged.call(this, layoutInfo);
            this._maxLineWidth = 0;
            return shouldRender;
        };
        ViewLines.prototype.onModelFlushed = function () {
            var shouldRender = _super.prototype.onModelFlushed.call(this);
            this._maxLineWidth = 0;
            return shouldRender;
        };
        ViewLines.prototype.onModelDecorationsChanged = function (e) {
            var shouldRender = _super.prototype.onModelDecorationsChanged.call(this, e);
            if (true /*e.inlineDecorationsChanged*/) {
                var rendStartLineNumber = this._linesCollection.getStartLineNumber();
                var rendEndLineNumber = this._linesCollection.getEndLineNumber();
                for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
                    this._linesCollection.getLine(lineNumber).onModelDecorationsChanged();
                }
            }
            return shouldRender || true;
        };
        ViewLines.prototype.onCursorRevealRange = function (e) {
            var newScrollTop = this._computeScrollTopToRevealRange(this._layoutProvider.getCurrentViewport(), e.range, e.verticalType);
            if (e.revealHorizontal) {
                this._lastCursorRevealRangeHorizontallyEvent = e;
            }
            this._layoutProvider.setScrollPosition({
                scrollTop: newScrollTop
            });
            return true;
        };
        ViewLines.prototype.onCursorScrollRequest = function (e) {
            var currentScrollTop = this._layoutProvider.getScrollTop();
            var newScrollTop = currentScrollTop + e.deltaLines * this._lineHeight;
            this._layoutProvider.setScrollPosition({
                scrollTop: newScrollTop
            });
            return true;
        };
        ViewLines.prototype.onScrollChanged = function (e) {
            this.domNode.setWidth(e.scrollWidth);
            return _super.prototype.onScrollChanged.call(this, e) || true;
        };
        // ---- end view event handlers
        // ----------- HELPERS FOR OTHERS
        ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
            var lineNumber = this._getLineNumberFromDOMInfo(spanNode);
            if (lineNumber === -1) {
                // Couldn't find span node
                return null;
            }
            if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {
                // lineNumber is outside range
                return null;
            }
            if (this._context.model.getLineMaxColumn(lineNumber) === 1) {
                // Line is empty
                return new position_1.Position(lineNumber, 1);
            }
            var rendStartLineNumber = this._linesCollection.getStartLineNumber();
            var rendEndLineNumber = this._linesCollection.getEndLineNumber();
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                // Couldn't find line
                return null;
            }
            var column = this._linesCollection.getLine(lineNumber).getColumnOfNodeOffset(lineNumber, spanNode, offset);
            var minColumn = this._context.model.getLineMinColumn(lineNumber);
            if (column < minColumn) {
                column = minColumn;
            }
            return new position_1.Position(lineNumber, column);
        };
        ViewLines.prototype._getLineNumberFromDOMInfo = function (spanNode) {
            while (spanNode && spanNode.nodeType === 1) {
                if (spanNode.className === editorBrowser_1.ClassNames.VIEW_LINE) {
                    return parseInt(spanNode.getAttribute('lineNumber'), 10);
                }
                spanNode = spanNode.parentElement;
            }
            return -1;
        };
        ViewLines.prototype.getLineWidth = function (lineNumber) {
            var rendStartLineNumber = this._linesCollection.getStartLineNumber();
            var rendEndLineNumber = this._linesCollection.getEndLineNumber();
            if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                // Couldn't find line
                return -1;
            }
            return this._linesCollection.getLine(lineNumber).getWidth();
        };
        ViewLines.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
            if (this.shouldRender()) {
                // Cannot read from the DOM because it is dirty
                // i.e. the model & the dom are out of sync, so I'd be reading something stale
                return null;
            }
            var originalEndLineNumber = range.endLineNumber;
            range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
            if (!range) {
                return null;
            }
            var visibleRanges = [];
            var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
            var nextLineModelLineNumber;
            if (includeNewLines) {
                nextLineModelLineNumber = this._context.model.convertViewPositionToModelPosition(range.startLineNumber, 1).lineNumber;
            }
            var rendStartLineNumber = this._linesCollection.getStartLineNumber();
            var rendEndLineNumber = this._linesCollection.getEndLineNumber();
            for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
                if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                    continue;
                }
                var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
                var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
                var visibleRangesForLine = this._linesCollection.getLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
                if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                    continue;
                }
                if (includeNewLines && lineNumber < originalEndLineNumber) {
                    var currentLineModelLineNumber = nextLineModelLineNumber;
                    nextLineModelLineNumber = this._context.model.convertViewPositionToModelPosition(lineNumber + 1, 1).lineNumber;
                    if (currentLineModelLineNumber !== nextLineModelLineNumber) {
                        visibleRangesForLine[visibleRangesForLine.length - 1].width += ViewLines.LINE_FEED_WIDTH;
                    }
                }
                visibleRanges.push(new renderingContext_1.LineVisibleRanges(lineNumber, visibleRangesForLine));
            }
            if (visibleRanges.length === 0) {
                return null;
            }
            return visibleRanges;
        };
        ViewLines.prototype.visibleRangesForRange2 = function (range, deltaTop) {
            if (this.shouldRender()) {
                // Cannot read from the DOM because it is dirty
                // i.e. the model & the dom are out of sync, so I'd be reading something stale
                return null;
            }
            range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
            if (!range) {
                return null;
            }
            var result = [];
            var domReadingContext = new viewLine_1.DomReadingContext(this.domNode.domNode, this._textRangeRestingSpot);
            var bigNumbersDelta = this._lastRenderedData.getBigNumbersDelta();
            var rendStartLineNumber = this._linesCollection.getStartLineNumber();
            var rendEndLineNumber = this._linesCollection.getEndLineNumber();
            for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
                if (lineNumber < rendStartLineNumber || lineNumber > rendEndLineNumber) {
                    continue;
                }
                var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
                var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
                var visibleRangesForLine = this._linesCollection.getLine(lineNumber).getVisibleRangesForRange(startColumn, endColumn, domReadingContext);
                if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                    continue;
                }
                var adjustedLineNumberVerticalOffset = this._layoutProvider.getVerticalOffsetForLineNumber(lineNumber) - bigNumbersDelta + deltaTop;
                for (var i = 0, len = visibleRangesForLine.length; i < len; i++) {
                    result.push(new renderingContext_1.VisibleRange(adjustedLineNumberVerticalOffset, visibleRangesForLine[i].left, visibleRangesForLine[i].width));
                }
            }
            if (result.length === 0) {
                return null;
            }
            return result;
        };
        // --- implementation
        ViewLines.prototype._createLine = function () {
            return new viewLine_1.ViewLine(this._context);
        };
        ViewLines.prototype._updateLineWidths = function () {
            var rendStartLineNumber = this._linesCollection.getStartLineNumber();
            var rendEndLineNumber = this._linesCollection.getEndLineNumber();
            var localMaxLineWidth = 1;
            for (var lineNumber = rendStartLineNumber; lineNumber <= rendEndLineNumber; lineNumber++) {
                var widthInPx = this._linesCollection.getLine(lineNumber).getWidth();
                localMaxLineWidth = Math.max(localMaxLineWidth, widthInPx);
            }
            this._ensureMaxLineWidth(localMaxLineWidth);
        };
        ViewLines.prototype.prepareRender = function () {
            throw new Error('Not supported');
        };
        ViewLines.prototype.render = function () {
            throw new Error('Not supported');
        };
        ViewLines.prototype.renderText = function (linesViewportData, onAfterLinesRendered) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            // (1) render lines - ensures lines are in the DOM
            _super.prototype._renderLines.call(this, linesViewportData);
            this._lastRenderedData.setBigNumbersDelta(linesViewportData.bigNumbersDelta);
            this._lastRenderedData.setCurrentVisibleRange(linesViewportData.visibleRange);
            this.domNode.setWidth(this._layoutProvider.getScrollWidth());
            this.domNode.setHeight(Math.min(this._layoutProvider.getTotalHeight(), 1000000));
            // (2) execute DOM writing that forces sync layout (e.g. textArea manipulation)
            onAfterLinesRendered();
            // (3) compute horizontal scroll position:
            //  - this must happen after the lines are in the DOM since it might need a line that rendered just now
            //  - it might change `scrollWidth` and `scrollLeft`
            if (this._lastCursorRevealRangeHorizontallyEvent) {
                var revealHorizontalRange = this._lastCursorRevealRangeHorizontallyEvent.range;
                this._lastCursorRevealRangeHorizontallyEvent = null;
                // allow `visibleRangesForRange2` to work
                this.onDidRender();
                // compute new scroll position
                var newScrollLeft = this._computeScrollLeftToRevealRange(revealHorizontalRange);
                var isViewportWrapping = this._isViewportWrapping;
                if (!isViewportWrapping) {
                    // ensure `scrollWidth` is large enough
                    this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);
                }
                // set `scrollLeft`
                this._layoutProvider.setScrollPosition({
                    scrollLeft: newScrollLeft.scrollLeft
                });
            }
            // (4) handle scrolling
            if (this._canUseTranslate3d) {
                var transform = 'translate3d(' + -this._layoutProvider.getScrollLeft() + 'px, ' + linesViewportData.visibleRangesDeltaTop + 'px, 0px)';
                styleMutator_1.StyleMutator.setTransform(this.domNode.domNode.parentNode, transform);
                styleMutator_1.StyleMutator.setTop(this.domNode.domNode.parentNode, 0); // TODO@Alex
                styleMutator_1.StyleMutator.setLeft(this.domNode.domNode.parentNode, 0); // TODO@Alex
            }
            else {
                styleMutator_1.StyleMutator.setTransform(this.domNode.domNode.parentNode, '');
                styleMutator_1.StyleMutator.setTop(this.domNode.domNode.parentNode, linesViewportData.visibleRangesDeltaTop); // TODO@Alex
                styleMutator_1.StyleMutator.setLeft(this.domNode.domNode.parentNode, -this._layoutProvider.getScrollLeft()); // TODO@Alex
            }
            // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)
            this._asyncUpdateLineWidths.schedule();
        };
        // --- width
        ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {
            var iLineWidth = Math.ceil(lineWidth);
            if (this._maxLineWidth < iLineWidth) {
                this._maxLineWidth = iLineWidth;
                this._layoutProvider.onMaxLineWidthChanged(this._maxLineWidth);
            }
        };
        ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {
            var viewportStartY = viewport.top;
            var viewportHeight = viewport.height;
            var viewportEndY = viewportStartY + viewportHeight;
            var boxStartY;
            var boxEndY;
            // Have a box that includes one extra line height (for the horizontal scrollbar)
            boxStartY = this._layoutProvider.getVerticalOffsetForLineNumber(range.startLineNumber);
            boxEndY = this._layoutProvider.getVerticalOffsetForLineNumber(range.endLineNumber) + this._layoutProvider.heightInPxForLine(range.endLineNumber);
            if (verticalType === 0 /* Simple */ || verticalType === 4 /* Bottom */) {
                // Reveal one line more when the last line would be covered by the scrollbar - arrow down case or revealing a line explicitly at bottom
                boxEndY += this._lineHeight;
            }
            var newScrollTop;
            if (verticalType === 1 /* Center */ || verticalType === 2 /* CenterIfOutsideViewport */) {
                if (verticalType === 2 /* CenterIfOutsideViewport */ && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
                    // Box is already in the viewport... do nothing
                    newScrollTop = viewportStartY;
                }
                else {
                    // Box is outside the viewport... center it
                    var boxMiddleY = (boxStartY + boxEndY) / 2;
                    newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);
                }
            }
            else {
                newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY, verticalType === 3 /* Top */, verticalType === 4 /* Bottom */);
            }
            return newScrollTop;
        };
        ViewLines.prototype._computeScrollLeftToRevealRange = function (range) {
            var maxHorizontalOffset = 0;
            if (range.startLineNumber !== range.endLineNumber) {
                // Two or more lines? => scroll to base (That's how you see most of the two lines)
                return {
                    scrollLeft: 0,
                    maxHorizontalOffset: maxHorizontalOffset
                };
            }
            var viewport = this._layoutProvider.getCurrentViewport();
            var viewportStartX = viewport.left;
            var viewportEndX = viewportStartX + viewport.width;
            var visibleRanges = this.visibleRangesForRange2(range, 0);
            var boxStartX = Number.MAX_VALUE;
            var boxEndX = 0;
            if (!visibleRanges) {
                // Unknown
                return {
                    scrollLeft: viewportStartX,
                    maxHorizontalOffset: maxHorizontalOffset
                };
            }
            for (var i = 0; i < visibleRanges.length; i++) {
                var visibleRange = visibleRanges[i];
                if (visibleRange.left < boxStartX) {
                    boxStartX = visibleRange.left;
                }
                if (visibleRange.left + visibleRange.width > boxEndX) {
                    boxEndX = visibleRange.left + visibleRange.width;
                }
            }
            maxHorizontalOffset = boxEndX;
            boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);
            boxEndX += this._revealHorizontalRightPadding;
            var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);
            return {
                scrollLeft: newScrollLeft,
                maxHorizontalOffset: maxHorizontalOffset
            };
        };
        ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd, revealAtStart, revealAtEnd) {
            viewportStart = viewportStart | 0;
            viewportEnd = viewportEnd | 0;
            boxStart = boxStart | 0;
            boxEnd = boxEnd | 0;
            revealAtStart = !!revealAtStart;
            revealAtEnd = !!revealAtEnd;
            var viewportLength = viewportEnd - viewportStart;
            var boxLength = boxEnd - boxStart;
            if (boxLength < viewportLength) {
                // The box would fit in the viewport
                if (revealAtStart) {
                    return boxStart;
                }
                if (revealAtEnd) {
                    return Math.max(0, boxEnd - viewportLength);
                }
                if (boxStart < viewportStart) {
                    // The box is above the viewport
                    return boxStart;
                }
                else if (boxEnd > viewportEnd) {
                    // The box is below the viewport
                    return Math.max(0, boxEnd - viewportLength);
                }
            }
            else {
                // The box would not fit in the viewport
                // Reveal the beginning of the box
                return boxStart;
            }
            return viewportStart;
        };
        return ViewLines;
    }(viewLayer_1.ViewLayer));
    /**
     * Width to extends a line to render the line feed at the end of the line
     */
    ViewLines.LINE_FEED_WIDTH = 10;
    /**
     * Adds this ammount of pixels to the right of lines (no-one wants to type near the edge of the viewport)
     */
    ViewLines.HORIZONTAL_EXTRA_PX = 30;
    exports.ViewLines = ViewLines;
});

define(__m[433/*vs/editor/browser/viewParts/viewCursors/viewCursor*/], __M([1/*require*/,0/*exports*/,29/*vs/base/browser/styleMutator*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,55/*vs/editor/browser/config/configuration*/]), function (require, exports, styleMutator_1, position_1, range_1, editorCommon_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewCursorRenderData = (function () {
        function ViewCursorRenderData(top, left, width, textContent) {
            this.top = top;
            this.left = left;
            this.width = width;
            this.textContent = textContent;
        }
        return ViewCursorRenderData;
    }());
    exports.ViewCursorRenderData = ViewCursorRenderData;
    var ViewCursor = (function () {
        function ViewCursor(context, isSecondary) {
            this._context = context;
            this._isSecondary = isSecondary;
            this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            this._isVisible = true;
            // Create the dom node
            this._domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            if (this._isSecondary) {
                this._domNode.setClassName('cursor secondary');
            }
            else {
                this._domNode.setClassName('cursor');
            }
            this._domNode.setHeight(this._lineHeight);
            this._domNode.setTop(0);
            this._domNode.setLeft(0);
            this._domNode.setAttribute('role', 'presentation');
            this._domNode.setAttribute('aria-hidden', 'true');
            configuration_1.Configuration.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
            this._domNode.setDisplay('none');
            this.updatePosition(new position_1.Position(1, 1));
            this._isInEditableRange = true;
            this._lastRenderedContent = '';
            this._renderData = null;
        }
        ViewCursor.prototype.getDomNode = function () {
            return this._domNode.domNode;
        };
        ViewCursor.prototype.getIsInEditableRange = function () {
            return this._isInEditableRange;
        };
        ViewCursor.prototype.getPosition = function () {
            return this._position;
        };
        ViewCursor.prototype.show = function () {
            if (!this._isVisible) {
                this._domNode.setVisibility('inherit');
                this._isVisible = true;
            }
        };
        ViewCursor.prototype.hide = function () {
            if (this._isVisible) {
                this._domNode.setVisibility('hidden');
                this._isVisible = false;
            }
        };
        ViewCursor.prototype.onModelFlushed = function () {
            this.updatePosition(new position_1.Position(1, 1));
            this._isInEditableRange = true;
            return true;
        };
        ViewCursor.prototype.onCursorPositionChanged = function (position, isInEditableRange) {
            this.updatePosition(position);
            this._isInEditableRange = isInEditableRange;
            return true;
        };
        ViewCursor.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.cursorStyle) {
                this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            }
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
                this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            }
            return true;
        };
        ViewCursor.prototype._prepareRender = function (ctx) {
            if (this._cursorStyle === editorCommon_1.TextEditorCursorStyle.Line) {
                var visibleRange = ctx.visibleRangeForPosition(this._position);
                if (!visibleRange) {
                    // Outside viewport
                    return null;
                }
                var width_1 = this._isSecondary ? 1 : 2;
                return new ViewCursorRenderData(visibleRange.top, visibleRange.left, width_1, '');
            }
            var visibleRangeForCharacter = ctx.linesVisibleRangesForRange(new range_1.Range(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column + 1), false);
            if (!visibleRangeForCharacter || visibleRangeForCharacter.length === 0 || visibleRangeForCharacter[0].ranges.length === 0) {
                // Outside viewport
                return null;
            }
            var range = visibleRangeForCharacter[0].ranges[0];
            var top = ctx.getViewportVerticalOffsetForLineNumber(this._position.lineNumber);
            var width = range.width < 1 ? this._typicalHalfwidthCharacterWidth : range.width;
            var textContent = '';
            if (this._cursorStyle === editorCommon_1.TextEditorCursorStyle.Block) {
                var lineContent = this._context.model.getLineContent(this._position.lineNumber);
                textContent = lineContent.charAt(this._position.column - 1);
            }
            return new ViewCursorRenderData(top, range.left, width, textContent);
        };
        ViewCursor.prototype.prepareRender = function (ctx) {
            this._renderData = this._prepareRender(ctx);
        };
        ViewCursor.prototype.render = function (ctx) {
            if (!this._renderData) {
                this._domNode.setDisplay('none');
                return null;
            }
            if (this._lastRenderedContent !== this._renderData.textContent) {
                this._lastRenderedContent = this._renderData.textContent;
                this._domNode.domNode.textContent = this._lastRenderedContent;
            }
            var top = this._renderData.top + ctx.viewportTop - ctx.bigNumbersDelta;
            this._domNode.setDisplay('block');
            this._domNode.setTop(top);
            this._domNode.setLeft(this._renderData.left);
            this._domNode.setWidth(this._renderData.width);
            this._domNode.setLineHeight(this._lineHeight);
            this._domNode.setHeight(this._lineHeight);
            return {
                position: this._position,
                contentTop: top,
                contentLeft: this._renderData.left,
                height: this._lineHeight,
                width: 2
            };
        };
        ViewCursor.prototype.updatePosition = function (newPosition) {
            this._position = newPosition;
            this._domNode.domNode.setAttribute('lineNumber', this._position.lineNumber.toString());
            this._domNode.domNode.setAttribute('column', this._position.column.toString());
        };
        return ViewCursor;
    }());
    exports.ViewCursor = ViewCursor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[434/*vs/editor/browser/viewParts/viewCursors/viewCursors*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/,21/*vs/editor/browser/editorBrowser*/,31/*vs/editor/browser/view/viewPart*/,433/*vs/editor/browser/viewParts/viewCursors/viewCursor*/,29/*vs/base/browser/styleMutator*/,17/*vs/base/common/async*/,346/*vs/css!vs/editor/browser/viewParts/viewCursors/viewCursors*/]), function (require, exports, editorCommon, editorBrowser_1, viewPart_1, viewCursor_1, styleMutator_1, async_1) {
    'use strict';
    var ViewCursors = (function (_super) {
        __extends(ViewCursors, _super);
        function ViewCursors(context) {
            var _this = _super.call(this, context) || this;
            _this._readOnly = _this._context.configuration.editor.readOnly;
            _this._cursorBlinking = _this._context.configuration.editor.viewInfo.cursorBlinking;
            _this._cursorStyle = _this._context.configuration.editor.viewInfo.cursorStyle;
            _this._primaryCursor = new viewCursor_1.ViewCursor(_this._context, false);
            _this._secondaryCursors = [];
            _this._renderData = [];
            _this._domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            _this._updateDomClassName();
            _this._domNode.domNode.appendChild(_this._primaryCursor.getDomNode());
            _this._startCursorBlinkAnimation = new async_1.TimeoutTimer();
            _this._blinkingEnabled = false;
            _this._editorHasFocus = false;
            _this._updateBlinking();
            return _this;
        }
        ViewCursors.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._startCursorBlinkAnimation.dispose();
        };
        ViewCursors.prototype.getDomNode = function () {
            return this._domNode.domNode;
        };
        // --- begin event handlers
        ViewCursors.prototype.onModelFlushed = function () {
            this._primaryCursor.onModelFlushed();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                var domNode = this._secondaryCursors[i].getDomNode();
                domNode.parentNode.removeChild(domNode);
            }
            this._secondaryCursors = [];
            return true;
        };
        ViewCursors.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return true; //e.inlineDecorationsChanged;
        };
        ViewCursors.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelLineChanged = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelTokensChanged = function (e) {
            var shouldRender = function (position) {
                for (var i = 0, len = e.ranges.length; i < len; i++) {
                    if (e.ranges[i].fromLineNumber <= position.lineNumber && position.lineNumber <= e.ranges[i].toLineNumber) {
                        return true;
                    }
                }
                return false;
            };
            if (shouldRender(this._primaryCursor.getPosition())) {
                return true;
            }
            for (var i = 0; i < this._secondaryCursors.length; i++) {
                if (shouldRender(this._secondaryCursors[i].getPosition())) {
                    return true;
                }
            }
            return false;
        };
        ViewCursors.prototype.onCursorPositionChanged = function (e) {
            this._primaryCursor.onCursorPositionChanged(e.position, e.isInEditableRange);
            this._updateBlinking();
            if (this._secondaryCursors.length < e.secondaryPositions.length) {
                // Create new cursors
                var addCnt = e.secondaryPositions.length - this._secondaryCursors.length;
                for (var i = 0; i < addCnt; i++) {
                    var newCursor = new viewCursor_1.ViewCursor(this._context, true);
                    this._primaryCursor.getDomNode().parentNode.insertBefore(newCursor.getDomNode(), this._primaryCursor.getDomNode().nextSibling);
                    this._secondaryCursors.push(newCursor);
                }
            }
            else if (this._secondaryCursors.length > e.secondaryPositions.length) {
                // Remove some cursors
                var removeCnt = this._secondaryCursors.length - e.secondaryPositions.length;
                for (var i = 0; i < removeCnt; i++) {
                    this._secondaryCursors[0].getDomNode().parentNode.removeChild(this._secondaryCursors[0].getDomNode());
                    this._secondaryCursors.splice(0, 1);
                }
            }
            for (var i = 0; i < e.secondaryPositions.length; i++) {
                this._secondaryCursors[i].onCursorPositionChanged(e.secondaryPositions[i], e.isInEditableRange);
            }
            return true;
        };
        ViewCursors.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewCursors.prototype.onConfigurationChanged = function (e) {
            if (e.readOnly) {
                this._readOnly = this._context.configuration.editor.readOnly;
            }
            if (e.viewInfo.cursorBlinking) {
                this._cursorBlinking = this._context.configuration.editor.viewInfo.cursorBlinking;
            }
            if (e.viewInfo.cursorStyle) {
                this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            }
            this._primaryCursor.onConfigurationChanged(e);
            this._updateBlinking();
            if (e.viewInfo.cursorStyle || e.viewInfo.cursorBlinking) {
                this._updateDomClassName();
            }
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].onConfigurationChanged(e);
            }
            return true;
        };
        ViewCursors.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewCursors.prototype.onScrollChanged = function (e) {
            return true;
        };
        ViewCursors.prototype.onZonesChanged = function () {
            return true;
        };
        ViewCursors.prototype.onViewFocusChanged = function (isFocused) {
            this._editorHasFocus = isFocused;
            this._updateBlinking();
            return false;
        };
        // --- end event handlers
        ViewCursors.prototype.getPosition = function () {
            return this._primaryCursor.getPosition();
        };
        // ---- blinking logic
        ViewCursors.prototype._getCursorBlinking = function () {
            if (!this._editorHasFocus) {
                return editorCommon.TextEditorCursorBlinkingStyle.Hidden;
            }
            if (this._readOnly || !this._primaryCursor.getIsInEditableRange()) {
                return editorCommon.TextEditorCursorBlinkingStyle.Solid;
            }
            return this._cursorBlinking;
        };
        ViewCursors.prototype._updateBlinking = function () {
            var _this = this;
            this._startCursorBlinkAnimation.cancel();
            var blinkingStyle = this._getCursorBlinking();
            // hidden and solid are special as they involve no animations
            var isHidden = (blinkingStyle === editorCommon.TextEditorCursorBlinkingStyle.Hidden);
            var isSolid = (blinkingStyle === editorCommon.TextEditorCursorBlinkingStyle.Solid);
            if (isHidden) {
                this._hide();
            }
            else {
                this._show();
            }
            this._blinkingEnabled = false;
            this._updateDomClassName();
            if (!isHidden && !isSolid) {
                this._startCursorBlinkAnimation.setIfNotSet(function () {
                    _this._blinkingEnabled = true;
                    _this._updateDomClassName();
                }, ViewCursors.BLINK_INTERVAL);
            }
        };
        // --- end blinking logic
        ViewCursors.prototype._updateDomClassName = function () {
            this._domNode.setClassName(this._getClassName());
        };
        ViewCursors.prototype._getClassName = function () {
            var result = editorBrowser_1.ClassNames.VIEW_CURSORS_LAYER;
            switch (this._cursorStyle) {
                case editorCommon.TextEditorCursorStyle.Line:
                    result += ' cursor-line-style';
                    break;
                case editorCommon.TextEditorCursorStyle.Block:
                    result += ' cursor-block-style';
                    break;
                case editorCommon.TextEditorCursorStyle.Underline:
                    result += ' cursor-underline-style';
                    break;
                default:
                    result += ' cursor-line-style';
            }
            if (this._blinkingEnabled) {
                switch (this._getCursorBlinking()) {
                    case editorCommon.TextEditorCursorBlinkingStyle.Blink:
                        result += ' cursor-blink';
                        break;
                    case editorCommon.TextEditorCursorBlinkingStyle.Smooth:
                        result += ' cursor-smooth';
                        break;
                    case editorCommon.TextEditorCursorBlinkingStyle.Phase:
                        result += ' cursor-phase';
                        break;
                    case editorCommon.TextEditorCursorBlinkingStyle.Expand:
                        result += ' cursor-expand';
                        break;
                    case editorCommon.TextEditorCursorBlinkingStyle.Solid:
                        result += ' cursor-solid';
                        break;
                    default:
                        result += ' cursor-solid';
                }
            }
            else {
                result += ' cursor-solid';
            }
            return result;
        };
        ViewCursors.prototype._show = function () {
            this._primaryCursor.show();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].show();
            }
            this._isVisible = true;
        };
        ViewCursors.prototype._hide = function () {
            this._primaryCursor.hide();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].hide();
            }
            this._isVisible = false;
        };
        // ---- IViewPart implementation
        ViewCursors.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            this._primaryCursor.prepareRender(ctx);
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].prepareRender(ctx);
            }
        };
        ViewCursors.prototype.render = function (ctx) {
            this._renderData = [];
            this._renderData.push(this._primaryCursor.render(ctx));
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._renderData.push(this._secondaryCursors[i].render(ctx));
            }
            // Keep only data of cursors that are visible
            this._renderData = this._renderData.filter(function (d) { return !!d; });
        };
        ViewCursors.prototype.getLastRenderData = function () {
            return this._renderData;
        };
        return ViewCursors;
    }(viewPart_1.ViewPart));
    ViewCursors.BLINK_INTERVAL = 500;
    exports.ViewCursors = ViewCursors;
});






define(__m[435/*vs/platform/configuration/common/model*/], __M([1/*require*/,0/*exports*/,35/*vs/platform/platform*/,24/*vs/base/common/types*/,253/*vs/base/common/json*/,36/*vs/base/common/objects*/,152/*vs/platform/configuration/common/configurationRegistry*/]), function (require, exports, platform_1, types, json, objects, configurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function getDefaultValues() {
        var valueTreeRoot = Object.create(null);
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        for (var key in properties) {
            var value = properties[key].default;
            addToValueTree(valueTreeRoot, key, value, function (message) { return console.error("Conflict in default settings: " + message); });
        }
        return valueTreeRoot;
    }
    exports.getDefaultValues = getDefaultValues;
    function toValuesTree(properties, conflictReporter) {
        var root = Object.create(null);
        for (var key in properties) {
            addToValueTree(root, key, properties[key], conflictReporter);
        }
        return root;
    }
    exports.toValuesTree = toValuesTree;
    function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
        var segments = key.split('.');
        var last = segments.pop();
        var curr = settingsTreeRoot;
        for (var i = 0; i < segments.length; i++) {
            var s = segments[i];
            var obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    break;
                default:
                    conflictReporter("Ignoring " + key + " as " + segments.slice(0, i + 1).join('.') + " is " + JSON.stringify(obj));
                    return;
            }
            curr = obj;
        }
        ;
        if (typeof curr === 'object') {
            curr[last] = value; // workaround https://github.com/Microsoft/vscode/issues/13606
        }
        else {
            conflictReporter("Ignoring " + key + " as " + segments.join('.') + " is " + JSON.stringify(curr));
        }
    }
    function getConfigurationKeys() {
        var properties = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).getConfigurationProperties();
        return Object.keys(properties);
    }
    exports.getConfigurationKeys = getConfigurationKeys;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    var ConfigModel = (function () {
        function ConfigModel(content, name) {
            if (name === void 0) { name = ''; }
            this.name = name;
            this._overrides = null;
            this._raw = {};
            this._parseErrors = [];
            if (content) {
                this.update(content);
            }
        }
        Object.defineProperty(ConfigModel.prototype, "contents", {
            get: function () {
                return this._contents || {};
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigModel.prototype, "overrides", {
            get: function () {
                return this._overrides;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigModel.prototype, "keys", {
            get: function () {
                return Object.keys(this._raw);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigModel.prototype, "raw", {
            get: function () {
                return this._raw;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConfigModel.prototype, "errors", {
            get: function () {
                return this._parseErrors;
            },
            enumerable: true,
            configurable: true
        });
        ConfigModel.prototype.merge = function (other, overwrite) {
            if (overwrite === void 0) { overwrite = true; }
            var mergedModel = new ConfigModel(null);
            mergedModel._contents = objects.clone(this.contents);
            merge(mergedModel.contents, other.contents, overwrite);
            mergedModel._overrides = other.overrides ? other.overrides : this.overrides;
            return mergedModel;
        };
        ConfigModel.prototype.config = function (section) {
            var result = new ConfigModel(null);
            result._contents = objects.clone(this.contents[section]);
            return result;
        };
        ConfigModel.prototype.languageConfig = function (language) {
            var result = new ConfigModel(null);
            var contents = objects.clone(this.contents);
            if (this.overrides) {
                for (var _i = 0, _a = this.overrides; _i < _a.length; _i++) {
                    var override = _a[_i];
                    if (override.languages.indexOf(language) !== -1) {
                        merge(contents, override.contents, true);
                    }
                }
                result._contents = contents;
            }
            return result;
        };
        ConfigModel.prototype.update = function (content) {
            var _this = this;
            var overrides = null;
            var currentProperty = null;
            var currentParent = [];
            var previousParents = [];
            var parseErrors = [];
            function onValue(value) {
                if (Array.isArray(currentParent)) {
                    currentParent.push(value);
                }
                else if (currentProperty) {
                    currentParent[currentProperty] = value;
                    if (currentParent['overrideSettings']) {
                        onOverrideSettingsValue(currentProperty, value);
                    }
                }
            }
            function onOverrideSettingsValue(property, value) {
                overrides.push({
                    languages: property.split(',').map(function (p) { return p.trim(); }),
                    raw: value,
                    contents: null
                });
            }
            var visitor = {
                onObjectBegin: function () {
                    var object = {};
                    if (currentProperty === configurationRegistry_1.SETTINGS_OVERRIDE) {
                        overrides = [];
                        object['overrideSettings'] = true;
                    }
                    onValue(object);
                    previousParents.push(currentParent);
                    currentParent = object;
                    currentProperty = null;
                },
                onObjectProperty: function (name) {
                    currentProperty = name;
                },
                onObjectEnd: function () {
                    currentParent = previousParents.pop();
                    if (currentParent['overrideSettings']) {
                        delete currentParent['overrideSettings'];
                    }
                },
                onArrayBegin: function () {
                    var array = [];
                    onValue(array);
                    previousParents.push(currentParent);
                    currentParent = array;
                    currentProperty = null;
                },
                onArrayEnd: function () {
                    currentParent = previousParents.pop();
                },
                onLiteralValue: onValue,
                onError: function (error) {
                    parseErrors.push({ error: error });
                }
            };
            try {
                json.visit(content, visitor);
                this._raw = currentParent[0];
            }
            catch (e) {
                console.error("Error while parsing settings file " + this.name + ": " + e);
                this._raw = {};
                this._parseErrors = [e];
            }
            this._contents = toValuesTree(this._raw, function (message) { return console.error("Conflict in settings file " + _this.name + ": " + message); });
            this._overrides = overrides ? overrides.map(function (override) {
                return {
                    languages: override.languages,
                    contents: toValuesTree(override.raw, function (message) { return console.error("Conflict in settings file " + _this.name + ": " + message); })
                };
            }) : null;
        };
        return ConfigModel;
    }());
    exports.ConfigModel = ConfigModel;
    var DefaultConfigModel = (function (_super) {
        __extends(DefaultConfigModel, _super);
        function DefaultConfigModel() {
            return _super.call(this, null) || this;
        }
        Object.defineProperty(DefaultConfigModel.prototype, "_contents", {
            get: function () {
                return getDefaultValues(); // defaults coming from contributions to registries
            },
            set: function (arg) {
                //no op
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DefaultConfigModel.prototype, "keys", {
            get: function () {
                return getConfigurationKeys();
            },
            enumerable: true,
            configurable: true
        });
        return DefaultConfigModel;
    }(ConfigModel));
    exports.DefaultConfigModel = DefaultConfigModel;
});

define(__m[68/*vs/platform/keybinding/common/keybindingsRegistry*/], __M([1/*require*/,0/*exports*/,32/*vs/base/common/keyCodes*/,19/*vs/base/common/platform*/,22/*vs/platform/commands/common/commands*/,35/*vs/platform/platform*/]), function (require, exports, keyCodes_1, platform, commands_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KeybindingsRegistryImpl = (function () {
        function KeybindingsRegistryImpl() {
            this.WEIGHT = {
                editorCore: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 0 + importance;
                },
                editorContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 100 + importance;
                },
                workbenchContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 200 + importance;
                },
                builtinExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 300 + importance;
                },
                externalExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 400 + importance;
                }
            };
            this._keybindings = [];
        }
        /**
         * Take current platform into account and reduce to primary & secondary.
         */
        KeybindingsRegistryImpl.bindToCurrentPlatform = function (kb) {
            if (platform.isWindows) {
                if (kb && kb.win) {
                    return kb.win;
                }
            }
            else if (platform.isMacintosh) {
                if (kb && kb.mac) {
                    return kb.mac;
                }
            }
            else {
                if (kb && kb.linux) {
                    return kb.linux;
                }
            }
            return kb;
        };
        KeybindingsRegistryImpl.prototype.registerKeybindingRule = function (rule) {
            var _this = this;
            var actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
            // here
            if (actualKb && actualKb.primary) {
                this.registerDefaultKeybinding(actualKb.primary, rule.id, rule.weight, 0, rule.when);
            }
            // here
            if (actualKb && Array.isArray(actualKb.secondary)) {
                actualKb.secondary.forEach(function (k, i) { return _this.registerDefaultKeybinding(k, rule.id, rule.weight, -i - 1, rule.when); });
            }
        };
        KeybindingsRegistryImpl.prototype.registerCommandAndKeybindingRule = function (desc) {
            this.registerKeybindingRule(desc);
            commands_1.CommandsRegistry.registerCommand(desc.id, desc);
        };
        KeybindingsRegistryImpl.prototype.registerDefaultKeybinding = function (keybinding, commandId, weight1, weight2, when) {
            if (platform.isWindows) {
                if (keyCodes_1.BinaryKeybindings.hasCtrlCmd(keybinding) && !keyCodes_1.BinaryKeybindings.hasShift(keybinding) && keyCodes_1.BinaryKeybindings.hasAlt(keybinding) && !keyCodes_1.BinaryKeybindings.hasWinCtrl(keybinding)) {
                    if (/^[A-Z0-9\[\]\|\;\'\,\.\/\`]$/.test(keyCodes_1.KeyCodeUtils.toString(keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding)))) {
                        console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);
                    }
                }
            }
            this._keybindings.push({
                keybinding: keybinding,
                command: commandId,
                commandArgs: null,
                when: when,
                weight1: weight1,
                weight2: weight2
            });
        };
        KeybindingsRegistryImpl.prototype.getDefaultKeybindings = function () {
            return this._keybindings;
        };
        return KeybindingsRegistryImpl;
    }());
    exports.KeybindingsRegistry = new KeybindingsRegistryImpl();
    // Define extension point ids
    exports.Extensions = {
        EditorModes: 'platform.keybindingsRegistry'
    };
    platform_1.Registry.add(exports.Extensions.EditorModes, exports.KeybindingsRegistry);
});






define(__m[115/*vs/editor/browser/standalone/simpleServices*/], __M([1/*require*/,0/*exports*/,70/*vs/base/common/network*/,30/*vs/base/common/severity*/,6/*vs/base/common/winjs.base*/,56/*vs/platform/configuration/common/configuration*/,22/*vs/platform/commands/common/commands*/,406/*vs/platform/keybinding/common/abstractKeybindingService*/,142/*vs/platform/keybinding/common/keybindingResolver*/,42/*vs/platform/keybinding/common/keybinding*/,2/*vs/editor/common/editorCommon*/,12/*vs/base/common/event*/,435/*vs/platform/configuration/common/model*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/,51/*vs/base/browser/keyboardEvent*/,68/*vs/platform/keybinding/common/keybindingsRegistry*/,91/*vs/base/common/collections*/,59/*vs/platform/actions/common/actions*/,399/*vs/platform/actions/common/menu*/]), function (require, exports, network_1, severity_1, winjs_base_1, configuration_1, commands_1, abstractKeybindingService_1, keybindingResolver_1, keybinding_1, editorCommon, event_1, model_1, lifecycle_1, dom, keyboardEvent_1, keybindingsRegistry_1, collections_1, actions_1, menu_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SimpleEditor = (function () {
        function SimpleEditor(editor) {
            this._widget = editor;
        }
        SimpleEditor.prototype.getId = function () { return 'editor'; };
        SimpleEditor.prototype.getControl = function () { return this._widget; };
        SimpleEditor.prototype.getSelection = function () { return this._widget.getSelection(); };
        SimpleEditor.prototype.focus = function () { this._widget.focus(); };
        SimpleEditor.prototype.isVisible = function () { return true; };
        SimpleEditor.prototype.withTypedEditor = function (codeEditorCallback, diffEditorCallback) {
            if (this._widget.getEditorType() === editorCommon.EditorType.ICodeEditor) {
                // Single Editor
                return codeEditorCallback(this._widget);
            }
            else {
                // Diff Editor
                return diffEditorCallback(this._widget);
            }
        };
        return SimpleEditor;
    }());
    exports.SimpleEditor = SimpleEditor;
    var SimpleModel = (function () {
        function SimpleModel(model) {
            this.model = model;
            this._onDispose = new event_1.Emitter();
        }
        Object.defineProperty(SimpleModel.prototype, "onDispose", {
            get: function () {
                return this._onDispose.event;
            },
            enumerable: true,
            configurable: true
        });
        SimpleModel.prototype.load = function () {
            return winjs_base_1.TPromise.as(this);
        };
        Object.defineProperty(SimpleModel.prototype, "textEditorModel", {
            get: function () {
                return this.model;
            },
            enumerable: true,
            configurable: true
        });
        SimpleModel.prototype.dispose = function () {
            this._onDispose.fire();
        };
        return SimpleModel;
    }());
    exports.SimpleModel = SimpleModel;
    var SimpleEditorService = (function () {
        function SimpleEditorService() {
            this.openEditorDelegate = null;
        }
        SimpleEditorService.prototype.setEditor = function (editor) {
            this.editor = new SimpleEditor(editor);
        };
        SimpleEditorService.prototype.setOpenEditorDelegate = function (openEditorDelegate) {
            this.openEditorDelegate = openEditorDelegate;
        };
        SimpleEditorService.prototype.openEditor = function (typedData, sideBySide) {
            var _this = this;
            return winjs_base_1.TPromise.as(this.editor.withTypedEditor(function (editor) { return _this.doOpenEditor(editor, typedData); }, function (diffEditor) { return (_this.doOpenEditor(diffEditor.getOriginalEditor(), typedData) ||
                _this.doOpenEditor(diffEditor.getModifiedEditor(), typedData)); }));
        };
        SimpleEditorService.prototype.doOpenEditor = function (editor, data) {
            var model = this.findModel(editor, data);
            if (!model) {
                if (data.resource) {
                    if (this.openEditorDelegate) {
                        this.openEditorDelegate(data.resource.toString());
                        return null;
                    }
                    else {
                        var schema = data.resource.scheme;
                        if (schema === network_1.Schemas.http || schema === network_1.Schemas.https) {
                            // This is a fully qualified http or https URL
                            window.open(data.resource.toString());
                            return this.editor;
                        }
                    }
                }
                return null;
            }
            var selection = data.options.selection;
            if (selection) {
                if (typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
                    editor.setSelection(selection);
                    editor.revealRangeInCenter(selection);
                }
                else {
                    var pos = {
                        lineNumber: selection.startLineNumber,
                        column: selection.startColumn
                    };
                    editor.setPosition(pos);
                    editor.revealPositionInCenter(pos);
                }
            }
            return this.editor;
        };
        SimpleEditorService.prototype.findModel = function (editor, data) {
            var model = editor.getModel();
            if (model.uri.toString() !== data.resource.toString()) {
                return null;
            }
            return model;
        };
        return SimpleEditorService;
    }());
    exports.SimpleEditorService = SimpleEditorService;
    var SimpleEditorModelResolverService = (function () {
        function SimpleEditorModelResolverService() {
        }
        SimpleEditorModelResolverService.prototype.setEditor = function (editor) {
            this.editor = new SimpleEditor(editor);
        };
        SimpleEditorModelResolverService.prototype.createModelReference = function (resource) {
            var _this = this;
            var model;
            model = this.editor.withTypedEditor(function (editor) { return _this.findModel(editor, resource); }, function (diffEditor) { return _this.findModel(diffEditor.getOriginalEditor(), resource) || _this.findModel(diffEditor.getModifiedEditor(), resource); });
            if (!model) {
                return winjs_base_1.TPromise.as(new lifecycle_1.ImmortalReference(null));
            }
            return winjs_base_1.TPromise.as(new lifecycle_1.ImmortalReference(new SimpleModel(model)));
        };
        SimpleEditorModelResolverService.prototype.registerTextModelContentProvider = function (scheme, provider) {
            return {
                dispose: function () { }
            };
        };
        SimpleEditorModelResolverService.prototype.findModel = function (editor, resource) {
            var model = editor.getModel();
            if (model.uri.toString() !== resource.toString()) {
                return null;
            }
            return model;
        };
        return SimpleEditorModelResolverService;
    }());
    exports.SimpleEditorModelResolverService = SimpleEditorModelResolverService;
    var SimpleProgressService = (function () {
        function SimpleProgressService() {
        }
        SimpleProgressService.prototype.show = function () {
            return SimpleProgressService.NULL_PROGRESS_RUNNER;
        };
        SimpleProgressService.prototype.showWhile = function (promise, delay) {
            return null;
        };
        return SimpleProgressService;
    }());
    SimpleProgressService.NULL_PROGRESS_RUNNER = {
        done: function () { },
        total: function () { },
        worked: function () { }
    };
    exports.SimpleProgressService = SimpleProgressService;
    var SimpleMessageService = (function () {
        function SimpleMessageService() {
        }
        SimpleMessageService.prototype.show = function (sev, message) {
            switch (sev) {
                case severity_1.default.Error:
                    console.error(message);
                    break;
                case severity_1.default.Warning:
                    console.warn(message);
                    break;
                default:
                    console.log(message);
                    break;
            }
            return SimpleMessageService.Empty;
        };
        SimpleMessageService.prototype.hideAll = function () {
            // No-op
        };
        SimpleMessageService.prototype.confirm = function (confirmation) {
            var messageText = confirmation.message;
            if (confirmation.detail) {
                messageText = messageText + '\n\n' + confirmation.detail;
            }
            return window.confirm(messageText);
        };
        return SimpleMessageService;
    }());
    SimpleMessageService.Empty = function () { };
    exports.SimpleMessageService = SimpleMessageService;
    var StandaloneCommandService = (function () {
        function StandaloneCommandService(instantiationService) {
            this._instantiationService = instantiationService;
            this._dynamicCommands = Object.create(null);
        }
        StandaloneCommandService.prototype.addCommand = function (id, command) {
            var _this = this;
            this._dynamicCommands[id] = command;
            return {
                dispose: function () {
                    delete _this._dynamicCommands[id];
                }
            };
        };
        StandaloneCommandService.prototype.executeCommand = function (id) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var command = (commands_1.CommandsRegistry.getCommand(id) || this._dynamicCommands[id]);
            if (!command) {
                return winjs_base_1.TPromise.wrapError(new Error("command '" + id + "' not found"));
            }
            try {
                var result = this._instantiationService.invokeFunction.apply(this._instantiationService, [command.handler].concat(args));
                return winjs_base_1.TPromise.as(result);
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        return StandaloneCommandService;
    }());
    exports.StandaloneCommandService = StandaloneCommandService;
    var StandaloneKeybindingService = (function (_super) {
        __extends(StandaloneKeybindingService, _super);
        function StandaloneKeybindingService(contextKeyService, commandService, messageService, domNode) {
            var _this = _super.call(this, contextKeyService, commandService, messageService) || this;
            _this._cachedResolver = null;
            _this._dynamicKeybindings = [];
            _this.toDispose.push(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, function (e) {
                var keyEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                var shouldPreventDefault = _this._dispatch(keyEvent.toKeybinding(), keyEvent.target);
                if (shouldPreventDefault) {
                    keyEvent.preventDefault();
                }
            }));
            return _this;
        }
        StandaloneKeybindingService.prototype.addDynamicKeybinding = function (commandId, keybinding, handler, when) {
            var _this = this;
            var toDispose = [];
            var parsedContext = keybindingResolver_1.IOSupport.readKeybindingWhen(when);
            this._dynamicKeybindings.push({
                keybinding: keybinding,
                command: commandId,
                when: parsedContext,
                weight1: 1000,
                weight2: 0
            });
            toDispose.push({
                dispose: function () {
                    for (var i = 0; i < _this._dynamicKeybindings.length; i++) {
                        var kb = _this._dynamicKeybindings[i];
                        if (kb.command === commandId) {
                            _this._dynamicKeybindings.splice(i, 1);
                            _this.updateResolver({ source: keybinding_1.KeybindingSource.Default });
                            return;
                        }
                    }
                }
            });
            var commandService = this._commandService;
            if (commandService instanceof StandaloneCommandService) {
                toDispose.push(commandService.addCommand(commandId, {
                    handler: handler
                }));
            }
            else {
                throw new Error('Unknown command service!');
            }
            this.updateResolver({ source: keybinding_1.KeybindingSource.Default });
            return lifecycle_1.combinedDisposable(toDispose);
        };
        StandaloneKeybindingService.prototype.updateResolver = function (event) {
            this._cachedResolver = null;
            this._onDidUpdateKeybindings.fire(event);
        };
        StandaloneKeybindingService.prototype._getResolver = function () {
            if (!this._cachedResolver) {
                this._cachedResolver = new keybindingResolver_1.KeybindingResolver(keybindingsRegistry_1.KeybindingsRegistry.getDefaultKeybindings(), this._getExtraKeybindings());
            }
            return this._cachedResolver;
        };
        StandaloneKeybindingService.prototype._getExtraKeybindings = function () {
            return this._dynamicKeybindings;
        };
        return StandaloneKeybindingService;
    }(abstractKeybindingService_1.AbstractKeybindingService));
    exports.StandaloneKeybindingService = StandaloneKeybindingService;
    var SimpleConfigurationService = (function () {
        function SimpleConfigurationService() {
            this._onDidUpdateConfiguration = new event_1.Emitter();
            this.onDidUpdateConfiguration = this._onDidUpdateConfiguration.event;
            this._config = model_1.getDefaultValues();
        }
        SimpleConfigurationService.prototype.getConfiguration = function (section) {
            return this._config;
        };
        SimpleConfigurationService.prototype.reloadConfiguration = function (section) {
            return winjs_base_1.TPromise.as(this.getConfiguration(section));
        };
        SimpleConfigurationService.prototype.lookup = function (key) {
            return {
                value: configuration_1.getConfigurationValue(this.getConfiguration(), key),
                default: configuration_1.getConfigurationValue(this.getConfiguration(), key),
                user: configuration_1.getConfigurationValue(this.getConfiguration(), key)
            };
        };
        SimpleConfigurationService.prototype.keys = function () {
            return { default: [], user: [] };
        };
        return SimpleConfigurationService;
    }());
    exports.SimpleConfigurationService = SimpleConfigurationService;
    var SimpleMenuService = (function () {
        function SimpleMenuService(commandService) {
            this._commandService = commandService;
        }
        SimpleMenuService.prototype.createMenu = function (id, contextKeyService) {
            return new menu_1.Menu(id, winjs_base_1.TPromise.as(true), this._commandService, contextKeyService);
        };
        SimpleMenuService.prototype.getCommandActions = function () {
            return collections_1.values(actions_1.MenuRegistry.commands);
        };
        return SimpleMenuService;
    }());
    exports.SimpleMenuService = SimpleMenuService;
    var StandaloneTelemetryService = (function () {
        function StandaloneTelemetryService() {
            this.isOptedIn = false;
        }
        StandaloneTelemetryService.prototype.publicLog = function (eventName, data) {
            return winjs_base_1.TPromise.as(null);
        };
        StandaloneTelemetryService.prototype.getTelemetryInfo = function () {
            return null;
        };
        StandaloneTelemetryService.prototype.getExperiments = function () {
            return null;
        };
        return StandaloneTelemetryService;
    }());
    exports.StandaloneTelemetryService = StandaloneTelemetryService;
});






define(__m[157/*vs/editor/common/config/config*/], __M([1/*require*/,0/*exports*/,57/*vs/platform/editor/common/editor*/,18/*vs/platform/contextkey/common/contextkey*/,68/*vs/platform/keybinding/common/keybindingsRegistry*/,2/*vs/editor/common/editorCommon*/,45/*vs/editor/common/services/codeEditorService*/,22/*vs/platform/commands/common/commands*/]), function (require, exports, editor_1, contextkey_1, keybindingsRegistry_1, editorCommon, codeEditorService_1, commands_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var H = editorCommon.Handler;
    var D = editorCommon.CommandDescription;
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var CORE_WEIGHT = keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore();
    var Command = (function () {
        function Command(opts) {
            this.id = opts.id;
            this.precondition = opts.precondition;
            this.kbOpts = opts.kbOpts;
            this.description = opts.description;
        }
        Command.prototype.toCommandAndKeybindingRule = function (defaultWeight) {
            var _this = this;
            var kbOpts = this.kbOpts || { primary: 0 };
            var kbWhen = kbOpts.kbExpr;
            if (this.precondition) {
                if (kbWhen) {
                    kbWhen = contextkey_1.ContextKeyExpr.and(kbWhen, this.precondition);
                }
                else {
                    kbWhen = this.precondition;
                }
            }
            return {
                id: this.id,
                handler: function (accessor, args) { return _this.runCommand(accessor, args); },
                weight: kbOpts.weight || defaultWeight,
                when: kbWhen,
                primary: kbOpts.primary,
                secondary: kbOpts.secondary,
                win: kbOpts.win,
                linux: kbOpts.linux,
                mac: kbOpts.mac,
                description: this.description
            };
        };
        return Command;
    }());
    exports.Command = Command;
    var EditorCommand = (function (_super) {
        __extends(EditorCommand, _super);
        function EditorCommand(opts) {
            return _super.call(this, opts) || this;
        }
        EditorCommand.bindToContribution = function (controllerGetter) {
            return (function (_super) {
                __extends(EditorControllerCommandImpl, _super);
                function EditorControllerCommandImpl(opts) {
                    var _this = _super.call(this, opts) || this;
                    _this._callback = opts.handler;
                    return _this;
                }
                EditorControllerCommandImpl.prototype.runEditorCommand = function (accessor, editor, args) {
                    var controller = controllerGetter(editor);
                    if (controller) {
                        this._callback(controllerGetter(editor));
                    }
                };
                return EditorControllerCommandImpl;
            }(EditorCommand));
        };
        EditorCommand.prototype.runCommand = function (accessor, args) {
            var _this = this;
            var editor = findFocusedEditor(this.id, accessor, false);
            if (!editor) {
                editor = getActiveEditorWidget(accessor);
            }
            if (!editor) {
                // well, at least we tried...
                return;
            }
            return editor.invokeWithinContext(function (editorAccessor) {
                var kbService = editorAccessor.get(contextkey_1.IContextKeyService);
                if (!kbService.contextMatchesRules(_this.precondition)) {
                    // precondition does not hold
                    return;
                }
                return _this.runEditorCommand(editorAccessor, editor, args);
            });
        };
        return EditorCommand;
    }(Command));
    exports.EditorCommand = EditorCommand;
    function findFocusedEditor(commandId, accessor, complain) {
        var editor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (!editor) {
            if (complain) {
                console.warn('Cannot execute ' + commandId + ' because no code editor is focused.');
            }
            return null;
        }
        return editor;
    }
    exports.findFocusedEditor = findFocusedEditor;
    function withCodeEditorFromCommandHandler(commandId, accessor, callback) {
        var editor = findFocusedEditor(commandId, accessor, true);
        if (editor) {
            callback(editor);
        }
    }
    function getActiveEditorWidget(accessor) {
        var editorService = accessor.get(editor_1.IEditorService);
        var activeEditor = editorService.getActiveEditor && editorService.getActiveEditor();
        return codeEditorService_1.getCodeEditor(activeEditor);
    }
    function triggerEditorHandler(handlerId, accessor, args) {
        withCodeEditorFromCommandHandler(handlerId, accessor, function (editor) {
            editor.trigger('keyboard', handlerId, args);
        });
    }
    var CoreCommand = (function (_super) {
        __extends(CoreCommand, _super);
        function CoreCommand() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CoreCommand.prototype.runCommand = function (accessor, args) {
            triggerEditorHandler(this.id, accessor, args);
        };
        return CoreCommand;
    }(Command));
    var UnboundCoreCommand = (function (_super) {
        __extends(UnboundCoreCommand, _super);
        function UnboundCoreCommand(handlerId, precondition) {
            if (precondition === void 0) { precondition = null; }
            return _super.call(this, {
                id: handlerId,
                precondition: precondition
            }) || this;
        }
        return UnboundCoreCommand;
    }(CoreCommand));
    function registerCommand(command) {
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(command.toCommandAndKeybindingRule(CORE_WEIGHT));
    }
    function registerCoreAPICommand(handlerId, description) {
        commands_1.CommandsRegistry.registerCommand(handlerId, {
            handler: triggerEditorHandler.bind(null, handlerId),
            description: description
        });
    }
    function registerOverwritableCommand(handlerId, handler) {
        commands_1.CommandsRegistry.registerCommand(handlerId, handler);
        commands_1.CommandsRegistry.registerCommand('default:' + handlerId, handler);
    }
    function registerCoreDispatchCommand(handlerId) {
        registerOverwritableCommand(handlerId, triggerEditorHandler.bind(null, handlerId));
    }
    registerCoreDispatchCommand(H.Type);
    registerCoreDispatchCommand(H.ReplacePreviousChar);
    registerCoreDispatchCommand(H.Paste);
    registerCoreDispatchCommand(H.Cut);
    registerOverwritableCommand(H.CompositionStart, function () { });
    registerOverwritableCommand(H.CompositionEnd, function () { });
    var WordCommand = (function (_super) {
        __extends(WordCommand, _super);
        function WordCommand(handlerId, shift, key, precondition) {
            if (precondition === void 0) { precondition = null; }
            return _super.call(this, {
                id: handlerId,
                precondition: precondition,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: WordCommand.getWordNavigationKB(shift, key),
                    mac: { primary: WordCommand.getMacWordNavigationKB(shift, key) }
                }
            }) || this;
        }
        WordCommand.getMacWordNavigationKB = function (shift, key) {
            // For macs, word navigation is based on the alt modifier
            if (shift) {
                return 1024 /* Shift */ | 512 /* Alt */ | key;
            }
            else {
                return 512 /* Alt */ | key;
            }
        };
        WordCommand.getWordNavigationKB = function (shift, key) {
            // Normally word navigation is based on the ctrl modifier
            if (shift) {
                return 2048 /* CtrlCmd */ | 1024 /* Shift */ | key;
            }
            else {
                return 2048 /* CtrlCmd */ | key;
            }
        };
        return WordCommand;
    }(CoreCommand));
    // https://support.apple.com/en-gb/HT201236
    // [ADDED] Control-H					Delete the character to the left of the insertion point. Or use Delete.
    // [ADDED] Control-D					Delete the character to the right of the insertion point. Or use Fn-Delete.
    // [ADDED] Control-K					Delete the text between the insertion point and the end of the line or paragraph.
    // [ADDED] Command–Up Arrow				Move the insertion point to the beginning of the document.
    // [ADDED] Command–Down Arrow			Move the insertion point to the end of the document.
    // [ADDED] Command–Left Arrow			Move the insertion point to the beginning of the current line.
    // [ADDED] Command–Right Arrow			Move the insertion point to the end of the current line.
    // [ADDED] Option–Left Arrow			Move the insertion point to the beginning of the previous word.
    // [ADDED] Option–Right Arrow			Move the insertion point to the end of the next word.
    // [ADDED] Command–Shift–Up Arrow		Select the text between the insertion point and the beginning of the document.
    // [ADDED] Command–Shift–Down Arrow		Select the text between the insertion point and the end of the document.
    // [ADDED] Command–Shift–Left Arrow		Select the text between the insertion point and the beginning of the current line.
    // [ADDED] Command–Shift–Right Arrow	Select the text between the insertion point and the end of the current line.
    // [USED BY DUPLICATE LINES] Shift–Option–Up Arrow		Extend text selection to the beginning of the current paragraph, then to the beginning of the following paragraph if pressed again.
    // [USED BY DUPLICATE LINES] Shift–Option–Down Arrow	Extend text selection to the end of the current paragraph, then to the end of the following paragraph if pressed again.
    // [ADDED] Shift–Option–Left Arrow		Extend text selection to the beginning of the current word, then to the beginning of the following word if pressed again.
    // [ADDED] Shift–Option–Right Arrow		Extend text selection to the end of the current word, then to the end of the following word if pressed again.
    // [ADDED] Control-A					Move to the beginning of the line or paragraph.
    // [ADDED] Control-E					Move to the end of a line or paragraph.
    // [ADDED] Control-F					Move one character forward.
    // [ADDED] Control-B					Move one character backward.
    //Control-L								Center the cursor or selection in the visible area.
    // [ADDED] Control-P					Move up one line.
    // [ADDED] Control-N					Move down one line.
    // [ADDED] Control-O					Insert a new line after the insertion point.
    //Control-T								Swap the character behind the insertion point with the character in front of the insertion point.
    // Unconfirmed????
    //	Config.addKeyBinding(editorCommon.Handler.CursorPageDown,		KeyMod.WinCtrl | KeyCode.KEY_V);
    // OS X built in commands
    // Control+y => yank
    // [ADDED] Command+backspace => Delete to Hard BOL
    // [ADDED] Command+delete => Delete to Hard EOL
    // [ADDED] Control+k => Delete to Hard EOL
    // Control+l => show_at_center
    // Control+Command+d => noop
    // Control+Command+shift+d => noop
    // Register cursor commands
    registerCoreAPICommand(H.CursorMove, D.CursorMove);
    registerCommand(new CoreCommand({
        id: H.CursorLeft,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 15 /* LeftArrow */,
            mac: { primary: 15 /* LeftArrow */, secondary: [256 /* WinCtrl */ | 32 /* KEY_B */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorLeftSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 15 /* LeftArrow */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorRight,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 17 /* RightArrow */,
            mac: { primary: 17 /* RightArrow */, secondary: [256 /* WinCtrl */ | 36 /* KEY_F */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorRightSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 17 /* RightArrow */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 16 /* UpArrow */,
            mac: { primary: 16 /* UpArrow */, secondary: [256 /* WinCtrl */ | 46 /* KEY_P */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorUpSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 16 /* UpArrow */,
            secondary: [WordCommand.getWordNavigationKB(true, 16 /* UpArrow */)],
            mac: { primary: 1024 /* Shift */ | 16 /* UpArrow */ },
            linux: { primary: 1024 /* Shift */ | 16 /* UpArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 18 /* DownArrow */,
            mac: { primary: 18 /* DownArrow */, secondary: [256 /* WinCtrl */ | 44 /* KEY_N */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorDownSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 18 /* DownArrow */,
            secondary: [WordCommand.getWordNavigationKB(true, 18 /* DownArrow */)],
            mac: { primary: 1024 /* Shift */ | 18 /* DownArrow */ },
            linux: { primary: 1024 /* Shift */ | 18 /* DownArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorPageUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 11 /* PageUp */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorPageUpSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 11 /* PageUp */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorPageDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 12 /* PageDown */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorPageDownSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 12 /* PageDown */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorHome,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 14 /* Home */,
            mac: { primary: 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 15 /* LeftArrow */, 256 /* WinCtrl */ | 31 /* KEY_A */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorHomeSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 14 /* Home */,
            mac: { primary: 1024 /* Shift */ | 14 /* Home */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 15 /* LeftArrow */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorEnd,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 13 /* End */,
            mac: { primary: 13 /* End */, secondary: [2048 /* CtrlCmd */ | 17 /* RightArrow */, 256 /* WinCtrl */ | 35 /* KEY_E */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorEndSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 13 /* End */,
            mac: { primary: 1024 /* Shift */ | 13 /* End */, secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 17 /* RightArrow */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.ExpandLineSelection,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 39 /* KEY_I */
        }
    }));
    registerCoreAPICommand(H.EditorScroll, D.EditorScroll);
    registerCommand(new CoreCommand({
        id: H.ScrollLineUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */,
            mac: { primary: 256 /* WinCtrl */ | 11 /* PageUp */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.ScrollLineDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */,
            mac: { primary: 256 /* WinCtrl */ | 12 /* PageDown */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.ScrollPageUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 11 /* PageUp */,
            win: { primary: 512 /* Alt */ | 11 /* PageUp */ },
            linux: { primary: 512 /* Alt */ | 11 /* PageUp */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.ScrollPageDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 12 /* PageDown */,
            win: { primary: 512 /* Alt */ | 12 /* PageDown */ },
            linux: { primary: 512 /* Alt */ | 12 /* PageDown */ }
        }
    }));
    registerCoreAPICommand(H.RevealLine, D.RevealLine);
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectLeft,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 15 /* LeftArrow */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectRight,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 17 /* RightArrow */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 16 /* UpArrow */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectPageUp,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 11 /* PageUp */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 18 /* DownArrow */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorColumnSelectPageDown,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 512 /* Alt */ | 12 /* PageDown */,
            linux: { primary: 0 }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.Tab,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: contextkey_1.ContextKeyExpr.and(EditorContextKeys.TextFocus, EditorContextKeys.TabDoesNotMoveFocus),
            primary: 2 /* Tab */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.Outdent,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: contextkey_1.ContextKeyExpr.and(EditorContextKeys.TextFocus, EditorContextKeys.TabDoesNotMoveFocus),
            primary: 1024 /* Shift */ | 2 /* Tab */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.DeleteLeft,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1 /* Backspace */,
            secondary: [1024 /* Shift */ | 1 /* Backspace */],
            mac: { primary: 1 /* Backspace */, secondary: [1024 /* Shift */ | 1 /* Backspace */, 256 /* WinCtrl */ | 38 /* KEY_H */, 256 /* WinCtrl */ | 1 /* Backspace */] }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.DeleteRight,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 20 /* Delete */,
            mac: { primary: 20 /* Delete */, secondary: [256 /* WinCtrl */ | 34 /* KEY_D */, 256 /* WinCtrl */ | 20 /* Delete */] }
        }
    }));
    registerCommand(new WordCommand(H.CursorWordStartLeft, false, 15 /* LeftArrow */));
    registerCommand(new UnboundCoreCommand(H.CursorWordEndLeft));
    registerCommand(new UnboundCoreCommand(H.CursorWordLeft));
    registerCommand(new WordCommand(H.CursorWordStartLeftSelect, true, 15 /* LeftArrow */));
    registerCommand(new UnboundCoreCommand(H.CursorWordEndLeftSelect));
    registerCommand(new UnboundCoreCommand(H.CursorWordLeftSelect));
    registerCommand(new WordCommand(H.CursorWordEndRight, false, 17 /* RightArrow */));
    registerCommand(new UnboundCoreCommand(H.CursorWordStartRight));
    registerCommand(new UnboundCoreCommand(H.CursorWordRight));
    registerCommand(new WordCommand(H.CursorWordEndRightSelect, true, 17 /* RightArrow */));
    registerCommand(new UnboundCoreCommand(H.CursorWordStartRightSelect));
    registerCommand(new UnboundCoreCommand(H.CursorWordRightSelect));
    registerCommand(new WordCommand(H.DeleteWordLeft, false, 1 /* Backspace */, EditorContextKeys.Writable));
    registerCommand(new UnboundCoreCommand(H.DeleteWordStartLeft, EditorContextKeys.Writable));
    registerCommand(new UnboundCoreCommand(H.DeleteWordEndLeft, EditorContextKeys.Writable));
    registerCommand(new WordCommand(H.DeleteWordRight, false, 20 /* Delete */, EditorContextKeys.Writable));
    registerCommand(new UnboundCoreCommand(H.DeleteWordStartRight, EditorContextKeys.Writable));
    registerCommand(new UnboundCoreCommand(H.DeleteWordEndRight, EditorContextKeys.Writable));
    registerCommand(new CoreCommand({
        id: H.CancelSelection,
        precondition: EditorContextKeys.HasNonEmptySelection,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    registerCommand(new CoreCommand({
        id: H.RemoveSecondaryCursors,
        precondition: EditorContextKeys.HasMultipleSelections,
        kbOpts: {
            weight: CORE_WEIGHT + 1,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorTop,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 14 /* Home */,
            mac: { primary: 2048 /* CtrlCmd */ | 16 /* UpArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorTopSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 14 /* Home */,
            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorBottom,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 13 /* End */,
            mac: { primary: 2048 /* CtrlCmd */ | 18 /* DownArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorBottomSelect,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 13 /* End */,
            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.LineBreakInsert,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: null,
            mac: { primary: 256 /* WinCtrl */ | 45 /* KEY_O */ }
        }
    }));
    registerCommand(new CoreCommand({
        id: H.Undo,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 56 /* KEY_Z */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.CursorUndo,
        precondition: null,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 51 /* KEY_U */
        }
    }));
    registerCommand(new CoreCommand({
        id: H.Redo,
        precondition: EditorContextKeys.Writable,
        kbOpts: {
            weight: CORE_WEIGHT,
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 55 /* KEY_Y */,
            secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */],
            mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 56 /* KEY_Z */ }
        }
    }));
    var SelectAllCommand = (function (_super) {
        __extends(SelectAllCommand, _super);
        function SelectAllCommand() {
            return _super.call(this, {
                id: 'editor.action.selectAll',
                precondition: null,
                kbOpts: {
                    weight: CORE_WEIGHT,
                    kbExpr: null,
                    primary: 2048 /* CtrlCmd */ | 31 /* KEY_A */
                }
            }) || this;
        }
        SelectAllCommand.prototype.runCommand = function (accessor, args) {
            var HANDLER = editorCommon.Handler.SelectAll;
            var focusedEditor = findFocusedEditor(HANDLER, accessor, false);
            // Only if editor text focus (i.e. not if editor has widget focus).
            if (focusedEditor && focusedEditor.isFocused()) {
                focusedEditor.trigger('keyboard', HANDLER, args);
                return;
            }
            // Ignore this action when user is focussed on an element that allows for entering text
            var activeElement = document.activeElement;
            if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {
                activeElement.select();
                return;
            }
            // Redirecting to last active editor
            var activeEditor = getActiveEditorWidget(accessor);
            if (activeEditor) {
                activeEditor.focus();
                activeEditor.trigger('keyboard', HANDLER, args);
                return;
            }
        };
        return SelectAllCommand;
    }(Command));
    registerCommand(new SelectAllCommand());
});

define(__m[158/*vs/platform/progress/common/progress*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IProgressService = instantiation_1.createDecorator('progressService');
    exports.emptyProgress = Object.freeze({ report: function () { } });
    var Progress = (function () {
        function Progress(callback) {
            this._callback = callback;
        }
        Object.defineProperty(Progress.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        Progress.prototype.report = function (item) {
            this._value = item;
            this._callback();
        };
        return Progress;
    }());
    exports.Progress = Progress;
    exports.IProgressService2 = instantiation_1.createDecorator('progressService2');
});

define(__m[159/*vs/platform/storage/common/storage*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID = 'storageService';
    exports.IStorageService = instantiation_1.createDecorator(exports.ID);
    var StorageScope;
    (function (StorageScope) {
        /**
         * The stored data will be scoped to all workspaces of this domain.
         */
        StorageScope[StorageScope["GLOBAL"] = 0] = "GLOBAL";
        /**
         * The stored data will be scoped to the current workspace.
         */
        StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
    })(StorageScope = exports.StorageScope || (exports.StorageScope = {}));
    exports.NullStorageService = {
        _serviceBrand: undefined,
        store: function () { return undefined; },
        swap: function () { return undefined; },
        remove: function () { return undefined; },
        get: function (a, b, defaultValue) { return defaultValue; },
        getInteger: function (a, b, defaultValue) { return defaultValue; },
        getBoolean: function (a, b, defaultValue) { return defaultValue; }
    };
});

define(__m[53/*vs/platform/telemetry/common/telemetry*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ITelemetryService = instantiation_1.createDecorator('telemetryService');
});






define(__m[13/*vs/editor/common/editorCommonExtensions*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,22/*vs/platform/commands/common/commands*/,68/*vs/platform/keybinding/common/keybindingsRegistry*/,35/*vs/platform/platform*/,53/*vs/platform/telemetry/common/telemetry*/,157/*vs/editor/common/config/config*/,16/*vs/editor/common/core/position*/,43/*vs/editor/common/services/modelService*/,59/*vs/platform/actions/common/actions*/]), function (require, exports, errors_1, uri_1, commands_1, keybindingsRegistry_1, platform_1, telemetry_1, config_1, position_1, modelService_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Command = config_1.Command;
    exports.EditorCommand = config_1.EditorCommand;
    var EditorAction = (function (_super) {
        __extends(EditorAction, _super);
        function EditorAction(opts) {
            var _this = _super.call(this, opts) || this;
            _this.label = opts.label;
            _this.alias = opts.alias;
            _this.menuOpts = opts.menuOpts;
            return _this;
        }
        EditorAction.prototype.toMenuItem = function () {
            if (!this.menuOpts) {
                return null;
            }
            return {
                command: {
                    id: this.id,
                    title: this.label
                },
                when: this.precondition,
                group: this.menuOpts.group,
                order: this.menuOpts.order
            };
        };
        EditorAction.prototype.runEditorCommand = function (accessor, editor, args) {
            this.reportTelemetry(accessor);
            return this.run(accessor, editor, args);
        };
        EditorAction.prototype.reportTelemetry = function (accessor) {
            accessor.get(telemetry_1.ITelemetryService).publicLog('editorActionInvoked', { name: this.label, id: this.id });
        };
        return EditorAction;
    }(config_1.EditorCommand));
    exports.EditorAction = EditorAction;
    var HandlerEditorAction = (function (_super) {
        __extends(HandlerEditorAction, _super);
        function HandlerEditorAction(opts) {
            var _this = _super.call(this, opts) || this;
            _this._handlerId = opts.handlerId;
            return _this;
        }
        HandlerEditorAction.prototype.run = function (accessor, editor) {
            editor.trigger(this.id, this._handlerId, null);
        };
        return HandlerEditorAction;
    }(EditorAction));
    exports.HandlerEditorAction = HandlerEditorAction;
    // --- Editor Actions
    function editorAction(ctor) {
        CommonEditorRegistry.registerEditorAction(new ctor());
    }
    exports.editorAction = editorAction;
    function commonEditorContribution(ctor) {
        EditorContributionRegistry.INSTANCE.registerEditorContribution(ctor);
    }
    exports.commonEditorContribution = commonEditorContribution;
    var CommonEditorRegistry;
    (function (CommonEditorRegistry) {
        // --- Editor Actions
        function registerEditorAction(desc) {
            EditorContributionRegistry.INSTANCE.registerEditorAction(desc);
        }
        CommonEditorRegistry.registerEditorAction = registerEditorAction;
        function getEditorActions() {
            return EditorContributionRegistry.INSTANCE.getEditorActions();
        }
        CommonEditorRegistry.getEditorActions = getEditorActions;
        // --- Editor Contributions
        function getEditorContributions() {
            return EditorContributionRegistry.INSTANCE.getEditorContributions();
        }
        CommonEditorRegistry.getEditorContributions = getEditorContributions;
        // --- Editor Commands
        function commandWeight(importance) {
            if (importance === void 0) { importance = 0; }
            return keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(importance);
        }
        CommonEditorRegistry.commandWeight = commandWeight;
        function registerEditorCommand(desc) {
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(desc.toCommandAndKeybindingRule(keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib()));
        }
        CommonEditorRegistry.registerEditorCommand = registerEditorCommand;
        function registerLanguageCommand(id, handler) {
            commands_1.CommandsRegistry.registerCommand(id, function (accessor, args) { return handler(accessor, args || {}); });
        }
        CommonEditorRegistry.registerLanguageCommand = registerLanguageCommand;
        function registerDefaultLanguageCommand(id, handler) {
            registerLanguageCommand(id, function (accessor, args) {
                var resource = args.resource, position = args.position;
                if (!(resource instanceof uri_1.default)) {
                    throw errors_1.illegalArgument('resource');
                }
                if (!position_1.Position.isIPosition(position)) {
                    throw errors_1.illegalArgument('position');
                }
                var model = accessor.get(modelService_1.IModelService).getModel(resource);
                if (!model) {
                    throw errors_1.illegalArgument('Can not find open model for ' + resource);
                }
                var editorPosition = position_1.Position.lift(position);
                return handler(model, editorPosition, args);
            });
        }
        CommonEditorRegistry.registerDefaultLanguageCommand = registerDefaultLanguageCommand;
    })(CommonEditorRegistry = exports.CommonEditorRegistry || (exports.CommonEditorRegistry = {}));
    // Editor extension points
    var Extensions = {
        EditorCommonContributions: 'editor.commonContributions'
    };
    var EditorContributionRegistry = (function () {
        function EditorContributionRegistry() {
            this.editorContributions = [];
            this.editorActions = [];
        }
        EditorContributionRegistry.prototype.registerEditorContribution = function (ctor) {
            this.editorContributions.push(ctor);
        };
        EditorContributionRegistry.prototype.registerEditorAction = function (action) {
            var menuItem = action.toMenuItem();
            if (menuItem) {
                actions_1.MenuRegistry.appendMenuItem(actions_1.MenuId.EditorContext, menuItem);
            }
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule(action.toCommandAndKeybindingRule(keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib()));
            this.editorActions.push(action);
        };
        EditorContributionRegistry.prototype.getEditorContributions = function () {
            return this.editorContributions.slice(0);
        };
        EditorContributionRegistry.prototype.getEditorActions = function () {
            return this.editorActions.slice(0);
        };
        return EditorContributionRegistry;
    }());
    EditorContributionRegistry.INSTANCE = new EditorContributionRegistry();
    platform_1.Registry.add(Extensions.EditorCommonContributions, EditorContributionRegistry.INSTANCE);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[443/*vs/editor/contrib/bracketMatching/common/bracketMatching*/], __M([1/*require*/,0/*exports*/,279/*vs/nls!vs/editor/contrib/bracketMatching/common/bracketMatching*/,3/*vs/base/common/lifecycle*/,16/*vs/editor/common/core/position*/,17/*vs/base/common/async*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/]), function (require, exports, nls, lifecycle_1, position_1, async_1, editorCommon, editorCommonExtensions_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var SelectBracketAction = (function (_super) {
        __extends(SelectBracketAction, _super);
        function SelectBracketAction() {
            return _super.call(this, {
                id: 'editor.action.jumpToBracket',
                label: nls.localize(0, null),
                alias: 'Go to Bracket',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 88 /* US_BACKSLASH */
                }
            }) || this;
        }
        SelectBracketAction.prototype.run = function (accessor, editor) {
            var controller = BracketMatchingController.get(editor);
            if (!controller) {
                return;
            }
            controller.jumpToBracket();
        };
        return SelectBracketAction;
    }(editorCommonExtensions_1.EditorAction));
    SelectBracketAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], SelectBracketAction);
    var BracketsData = (function () {
        function BracketsData(position, brackets) {
            this.position = position;
            this.brackets = brackets;
        }
        return BracketsData;
    }());
    var BracketMatchingController = BracketMatchingController_1 = (function (_super) {
        __extends(BracketMatchingController, _super);
        function BracketMatchingController(editor) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._lastBracketsData = [];
            _this._lastVersionId = 0;
            _this._decorations = [];
            _this._updateBracketsSoon = _this._register(new async_1.RunOnceScheduler(function () { return _this._updateBrackets(); }, 50));
            _this._updateBracketsSoon.schedule();
            _this._register(editor.onDidChangeCursorPosition(function (e) { return _this._updateBracketsSoon.schedule(); }));
            _this._register(editor.onDidChangeModel(function (e) { _this._decorations = []; _this._updateBracketsSoon.schedule(); }));
            return _this;
        }
        BracketMatchingController.get = function (editor) {
            return editor.getContribution(BracketMatchingController_1.ID);
        };
        BracketMatchingController.prototype.getId = function () {
            return BracketMatchingController_1.ID;
        };
        BracketMatchingController.prototype.jumpToBracket = function () {
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            var selection = this._editor.getSelection();
            if (!selection.isEmpty()) {
                return;
            }
            var position = selection.getStartPosition();
            var brackets = model.matchBracket(position);
            if (!brackets) {
                return;
            }
            if (brackets[0].containsPosition(position)) {
                this._editor.setPosition(brackets[1].getStartPosition());
                return;
            }
            if (brackets[1].containsPosition(position)) {
                this._editor.setPosition(brackets[0].getStartPosition());
                return;
            }
        };
        BracketMatchingController.prototype._updateBrackets = function () {
            this._recomputeBrackets();
            var newDecorations = [], newDecorationsLen = 0;
            for (var i = 0, len = this._lastBracketsData.length; i < len; i++) {
                var brackets = this._lastBracketsData[i].brackets;
                if (brackets) {
                    newDecorations[newDecorationsLen++] = { range: brackets[0], options: BracketMatchingController_1._DECORATION_OPTIONS };
                    newDecorations[newDecorationsLen++] = { range: brackets[1], options: BracketMatchingController_1._DECORATION_OPTIONS };
                }
            }
            this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
        };
        BracketMatchingController.prototype._recomputeBrackets = function () {
            var model = this._editor.getModel();
            if (!model) {
                // no model => no brackets!
                this._lastBracketsData = [];
                this._lastVersionId = 0;
                return;
            }
            var versionId = model.getVersionId();
            var previousData = [];
            if (this._lastVersionId === versionId) {
                // use the previous data only if the model is at the same version id
                previousData = this._lastBracketsData;
            }
            var selections = this._editor.getSelections();
            var positions = [], positionsLen = 0;
            for (var i = 0, len = selections.length; i < len; i++) {
                var selection = selections[i];
                if (selection.isEmpty()) {
                    // will bracket match a cursor only if the selection is collapsed
                    positions[positionsLen++] = selection.getStartPosition();
                }
            }
            // sort positions for `previousData` cache hits
            if (positions.length > 1) {
                positions.sort(position_1.Position.compare);
            }
            var newData = [], newDataLen = 0;
            var previousIndex = 0, previousLen = previousData.length;
            for (var i = 0, len = positions.length; i < len; i++) {
                var position = positions[i];
                while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
                    previousIndex++;
                }
                if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
                    newData[newDataLen++] = previousData[previousIndex];
                }
                else {
                    var brackets = model.matchBracket(position);
                    newData[newDataLen++] = new BracketsData(position, brackets);
                }
            }
            this._lastBracketsData = newData;
            this._lastVersionId = versionId;
        };
        return BracketMatchingController;
    }(lifecycle_1.Disposable));
    BracketMatchingController.ID = 'editor.contrib.bracketMatchingController';
    BracketMatchingController._DECORATION_OPTIONS = {
        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'bracket-match'
    };
    BracketMatchingController = BracketMatchingController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution
    ], BracketMatchingController);
    exports.BracketMatchingController = BracketMatchingController;
    var BracketMatchingController_1;
});












define(__m[444/*vs/editor/contrib/caretOperations/common/caretOperations*/], __M([1/*require*/,0/*exports*/,280/*vs/nls!vs/editor/contrib/caretOperations/common/caretOperations*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,215/*vs/editor/contrib/caretOperations/common/moveCaretCommand*/]), function (require, exports, nls, editorCommon_1, editorCommonExtensions_1, moveCaretCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveCaretAction = (function (_super) {
        __extends(MoveCaretAction, _super);
        function MoveCaretAction(left, opts) {
            var _this = _super.call(this, opts) || this;
            _this.left = left;
            return _this;
        }
        MoveCaretAction.prototype.run = function (accessor, editor) {
            var commands = [];
            var selections = editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new moveCaretCommand_1.MoveCaretCommand(selections[i], this.left));
            }
            editor.executeCommands(this.id, commands);
        };
        return MoveCaretAction;
    }(editorCommonExtensions_1.EditorAction));
    var MoveCaretLeftAction = (function (_super) {
        __extends(MoveCaretLeftAction, _super);
        function MoveCaretLeftAction() {
            return _super.call(this, true, {
                id: 'editor.action.moveCarretLeftAction',
                label: nls.localize(0, null),
                alias: 'Move Caret Left',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        return MoveCaretLeftAction;
    }(MoveCaretAction));
    MoveCaretLeftAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveCaretLeftAction);
    var MoveCaretRightAction = (function (_super) {
        __extends(MoveCaretRightAction, _super);
        function MoveCaretRightAction() {
            return _super.call(this, false, {
                id: 'editor.action.moveCarretRightAction',
                label: nls.localize(1, null),
                alias: 'Move Caret Right',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        return MoveCaretRightAction;
    }(MoveCaretAction));
    MoveCaretRightAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveCaretRightAction);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[445/*vs/editor/contrib/clipboard/browser/clipboard*/], __M([1/*require*/,0/*exports*/,281/*vs/nls!vs/editor/contrib/clipboard/browser/clipboard*/,23/*vs/base/browser/browser*/,157/*vs/editor/common/config/config*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,359/*vs/css!vs/editor/contrib/clipboard/browser/clipboard*/]), function (require, exports, nls, browser, config_1, editorCommon, editorCommonExtensions_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var CLIPBOARD_CONTEXT_MENU_GROUP = '9_cutcopypaste';
    function conditionalEditorAction(testCommand) {
        if (!browser.supportsExecCommand(testCommand)) {
            return function () { };
        }
        return editorCommonExtensions_1.editorAction;
    }
    var ExecCommandAction = (function (_super) {
        __extends(ExecCommandAction, _super);
        function ExecCommandAction(browserCommand, opts) {
            var _this = _super.call(this, opts) || this;
            _this.browserCommand = browserCommand;
            return _this;
        }
        ExecCommandAction.prototype.runCommand = function (accessor, args) {
            var focusedEditor = config_1.findFocusedEditor(this.id, accessor, false);
            // Only if editor text focus (i.e. not if editor has widget focus).
            if (focusedEditor && focusedEditor.isFocused()) {
                focusedEditor.trigger('keyboard', this.id, args);
                return;
            }
            document.execCommand(this.browserCommand);
        };
        ExecCommandAction.prototype.run = function (accessor, editor) {
            editor.focus();
            document.execCommand(this.browserCommand);
        };
        return ExecCommandAction;
    }(editorCommonExtensions_1.EditorAction));
    var ExecCommandCutAction = (function (_super) {
        __extends(ExecCommandCutAction, _super);
        function ExecCommandCutAction() {
            return _super.call(this, 'cut', {
                id: 'editor.action.clipboardCutAction',
                label: nls.localize(0, null),
                alias: 'Cut',
                precondition: EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 54 /* KEY_X */,
                    win: { primary: 2048 /* CtrlCmd */ | 54 /* KEY_X */, secondary: [1024 /* Shift */ | 20 /* Delete */] }
                },
                menuOpts: {
                    group: CLIPBOARD_CONTEXT_MENU_GROUP,
                    order: 1
                }
            }) || this;
        }
        ExecCommandCutAction.prototype.run = function (accessor, editor) {
            var enableEmptySelectionClipboard = editor.getConfiguration().contribInfo.emptySelectionClipboard && browser.enableEmptySelectionClipboard;
            if (!enableEmptySelectionClipboard && editor.getSelection().isEmpty()) {
                return;
            }
            _super.prototype.run.call(this, accessor, editor);
        };
        return ExecCommandCutAction;
    }(ExecCommandAction));
    ExecCommandCutAction = __decorate([
        conditionalEditorAction('cut')
    ], ExecCommandCutAction);
    var ExecCommandCopyAction = (function (_super) {
        __extends(ExecCommandCopyAction, _super);
        function ExecCommandCopyAction() {
            return _super.call(this, 'copy', {
                id: 'editor.action.clipboardCopyAction',
                label: nls.localize(1, null),
                alias: 'Copy',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */,
                    win: { primary: 2048 /* CtrlCmd */ | 33 /* KEY_C */, secondary: [2048 /* CtrlCmd */ | 19 /* Insert */] }
                },
                menuOpts: {
                    group: CLIPBOARD_CONTEXT_MENU_GROUP,
                    order: 2
                }
            }) || this;
        }
        ExecCommandCopyAction.prototype.run = function (accessor, editor) {
            var enableEmptySelectionClipboard = editor.getConfiguration().contribInfo.emptySelectionClipboard && browser.enableEmptySelectionClipboard;
            if (!enableEmptySelectionClipboard && editor.getSelection().isEmpty()) {
                return;
            }
            _super.prototype.run.call(this, accessor, editor);
        };
        return ExecCommandCopyAction;
    }(ExecCommandAction));
    ExecCommandCopyAction = __decorate([
        conditionalEditorAction('copy')
    ], ExecCommandCopyAction);
    var ExecCommandPasteAction = (function (_super) {
        __extends(ExecCommandPasteAction, _super);
        function ExecCommandPasteAction() {
            return _super.call(this, 'paste', {
                id: 'editor.action.clipboardPasteAction',
                label: nls.localize(2, null),
                alias: 'Paste',
                precondition: EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 52 /* KEY_V */,
                    win: { primary: 2048 /* CtrlCmd */ | 52 /* KEY_V */, secondary: [1024 /* Shift */ | 19 /* Insert */] }
                },
                menuOpts: {
                    group: CLIPBOARD_CONTEXT_MENU_GROUP,
                    order: 3
                }
            }) || this;
        }
        return ExecCommandPasteAction;
    }(ExecCommandAction));
    ExecCommandPasteAction = __decorate([
        conditionalEditorAction('paste')
    ], ExecCommandPasteAction);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[446/*vs/editor/contrib/codelens/common/codelens*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,43/*vs/editor/common/services/modelService*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, uri_1, winjs_base_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getCodeLensData(model) {
        var symbols = [];
        var provider = modes_1.CodeLensProviderRegistry.ordered(model);
        var promises = provider.map(function (provider) { return async_1.asWinJsPromise(function (token) { return provider.provideCodeLenses(model, token); }).then(function (result) {
            if (Array.isArray(result)) {
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var symbol = result_1[_i];
                    symbols.push({ symbol: symbol, provider: provider });
                }
            }
        }, errors_1.onUnexpectedExternalError); });
        return winjs_base_1.TPromise.join(promises).then(function () {
            return symbols.sort(function (a, b) {
                // sort by lineNumber, provider-rank, and column
                if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
                    return -1;
                }
                else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
                    return 1;
                }
                else if (provider.indexOf(a.provider) < provider.indexOf(b.provider)) {
                    return -1;
                }
                else if (provider.indexOf(a.provider) > provider.indexOf(b.provider)) {
                    return 1;
                }
                else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
                    return -1;
                }
                else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
        });
    }
    exports.getCodeLensData = getCodeLensData;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeLensProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        return getCodeLensData(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[447/*vs/editor/contrib/codelens/browser/codelens*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,30/*vs/base/common/severity*/,9/*vs/base/common/strings*/,6/*vs/base/common/winjs.base*/,11/*vs/base/browser/dom*/,22/*vs/platform/commands/common/commands*/,49/*vs/platform/message/common/message*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,15/*vs/editor/common/modes*/,21/*vs/editor/browser/editorBrowser*/,26/*vs/editor/browser/editorBrowserExtensions*/,446/*vs/editor/contrib/codelens/common/codelens*/,360/*vs/css!vs/editor/contrib/codelens/browser/codelens*/]), function (require, exports, async_1, errors_1, lifecycle_1, severity_1, strings_1, winjs_base_1, dom, commands_1, message_1, range_1, editorCommon, modes_1, editorBrowser, editorBrowserExtensions_1, codelens_1) {
    'use strict';
    var CodeLensViewZone = (function () {
        function CodeLensViewZone(afterLineNumber) {
            this.afterLineNumber = afterLineNumber;
            this.heightInLines = 1;
            this.suppressMouseDown = true;
            this.domNode = document.createElement('div');
        }
        CodeLensViewZone.prototype.setAfterLineNumber = function (afterLineNumber) {
            this.afterLineNumber = afterLineNumber;
        };
        return CodeLensViewZone;
    }());
    var CodeLensContentWidget = (function () {
        function CodeLensContentWidget(editor, symbolRange, commandService, messageService) {
            var _this = this;
            this._commands = Object.create(null);
            this._id = 'codeLensWidget' + (++CodeLensContentWidget.ID);
            this._editor = editor;
            this.suppressMouseDown = true;
            this.setSymbolRange(symbolRange);
            this._domNode = document.createElement('span');
            this._domNode.style.height = editor.getConfiguration().lineHeight + "px";
            this._domNode.innerHTML = '&nbsp;';
            dom.addClass(this._domNode, 'codelens-decoration');
            dom.addClass(this._domNode, 'invisible-cl');
            this._subscription = dom.addDisposableListener(this._domNode, 'click', function (e) {
                var element = e.target;
                if (element.tagName === 'A' && element.id) {
                    var command = _this._commands[element.id];
                    if (command) {
                        editor.focus();
                        commandService.executeCommand.apply(commandService, [command.id].concat(command.arguments)).done(undefined, function (err) {
                            messageService.show(severity_1.default.Error, err);
                        });
                    }
                }
            });
            this.updateVisibility();
        }
        CodeLensContentWidget.prototype.dispose = function () {
            this._subscription.dispose();
            this._symbolRange = null;
        };
        CodeLensContentWidget.prototype.updateVisibility = function () {
            if (this.isVisible()) {
                dom.removeClass(this._domNode, 'invisible-cl');
                dom.addClass(this._domNode, 'fadein');
            }
        };
        CodeLensContentWidget.prototype.withCommands = function (symbols) {
            this._commands = Object.create(null);
            if (!symbols || !symbols.length) {
                this._domNode.innerHTML = 'no commands';
                return;
            }
            var html = [];
            for (var i = 0; i < symbols.length; i++) {
                var command = symbols[i].command;
                var title = strings_1.escape(command.title);
                var part = void 0;
                if (command.id) {
                    part = strings_1.format('<a id={0}>{1}</a>', i, title);
                    this._commands[i] = command;
                }
                else {
                    part = strings_1.format('<span>{0}</span>', title);
                }
                html.push(part);
            }
            this._domNode.innerHTML = html.join('<span>&nbsp;|&nbsp;</span>');
            this._editor.layoutContentWidget(this);
        };
        CodeLensContentWidget.prototype.getId = function () {
            return this._id;
        };
        CodeLensContentWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        CodeLensContentWidget.prototype.setSymbolRange = function (range) {
            this._symbolRange = range;
            var lineNumber = range.startLineNumber;
            var column = this._editor.getModel().getLineFirstNonWhitespaceColumn(lineNumber);
            this._widgetPosition = {
                position: { lineNumber: lineNumber, column: column },
                preference: [editorBrowser.ContentWidgetPositionPreference.ABOVE]
            };
        };
        CodeLensContentWidget.prototype.getPosition = function () {
            return this._widgetPosition;
        };
        CodeLensContentWidget.prototype.isVisible = function () {
            return this._domNode.hasAttribute('monaco-visible-content-widget');
        };
        return CodeLensContentWidget;
    }());
    CodeLensContentWidget.ID = 0;
    var CodeLensHelper = (function () {
        function CodeLensHelper() {
            this._removeDecorations = [];
            this._addDecorations = [];
            this._addDecorationsCallbacks = [];
        }
        CodeLensHelper.prototype.addDecoration = function (decoration, callback) {
            this._addDecorations.push(decoration);
            this._addDecorationsCallbacks.push(callback);
        };
        CodeLensHelper.prototype.removeDecoration = function (decorationId) {
            this._removeDecorations.push(decorationId);
        };
        CodeLensHelper.prototype.commit = function (changeAccessor) {
            var resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
            for (var i = 0, len = resultingDecorations.length; i < len; i++) {
                this._addDecorationsCallbacks[i](resultingDecorations[i]);
            }
        };
        return CodeLensHelper;
    }());
    var CodeLens = (function () {
        function CodeLens(data, editor, helper, viewZoneChangeAccessor, commandService, messageService) {
            var _this = this;
            this._editor = editor;
            this._data = data;
            this._decorationIds = new Array(this._data.length);
            var range;
            this._data.forEach(function (codeLensData, i) {
                helper.addDecoration({
                    range: codeLensData.symbol.range,
                    options: {}
                }, function (id) { return _this._decorationIds[i] = id; });
                // the range contains all lenses on this line
                if (!range) {
                    range = codeLensData.symbol.range;
                }
                else {
                    range = range_1.Range.plusRange(range, codeLensData.symbol.range);
                }
            });
            this._viewZone = new CodeLensViewZone(range.startLineNumber - 1);
            this._contentWidget = new CodeLensContentWidget(editor, range_1.Range.lift(range), commandService, messageService);
            this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
            this._editor.addContentWidget(this._contentWidget);
        }
        CodeLens.prototype.dispose = function (helper, viewZoneChangeAccessor) {
            while (this._decorationIds.length) {
                helper.removeDecoration(this._decorationIds.pop());
            }
            if (viewZoneChangeAccessor) {
                viewZoneChangeAccessor.removeZone(this._viewZoneId);
            }
            this._editor.removeContentWidget(this._contentWidget);
            this._contentWidget.dispose();
        };
        CodeLens.prototype.isValid = function () {
            var _this = this;
            return this._decorationIds.some(function (id, i) {
                var range = _this._editor.getModel().getDecorationRange(id);
                var symbol = _this._data[i].symbol;
                return range && range_1.Range.isEmpty(symbol.range) === range.isEmpty();
            });
        };
        CodeLens.prototype.updateCodeLensSymbols = function (data, helper) {
            var _this = this;
            while (this._decorationIds.length) {
                helper.removeDecoration(this._decorationIds.pop());
            }
            this._data = data;
            this._decorationIds = new Array(this._data.length);
            this._data.forEach(function (codeLensData, i) {
                helper.addDecoration({
                    range: codeLensData.symbol.range,
                    options: {}
                }, function (id) { return _this._decorationIds[i] = id; });
            });
        };
        CodeLens.prototype.computeIfNecessary = function (model) {
            this._contentWidget.updateVisibility(); // trigger the fade in
            if (!this._contentWidget.isVisible()) {
                return null;
            }
            // Read editor current state
            for (var i = 0; i < this._decorationIds.length; i++) {
                this._data[i].symbol.range = model.getDecorationRange(this._decorationIds[i]);
            }
            return this._data;
        };
        CodeLens.prototype.updateCommands = function (symbols) {
            this._contentWidget.withCommands(symbols);
        };
        CodeLens.prototype.getLineNumber = function () {
            var range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
            if (range) {
                return range.startLineNumber;
            }
            return -1;
        };
        CodeLens.prototype.update = function (viewZoneChangeAccessor) {
            if (this.isValid()) {
                var range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
                this._viewZone.setAfterLineNumber(range.startLineNumber - 1);
                viewZoneChangeAccessor.layoutZone(this._viewZoneId);
                this._contentWidget.setSymbolRange(range);
                this._editor.layoutContentWidget(this._contentWidget);
            }
        };
        return CodeLens;
    }());
    var CodeLensContribution = CodeLensContribution_1 = (function () {
        function CodeLensContribution(_editor, _commandService, _messageService) {
            var _this = this;
            this._editor = _editor;
            this._commandService = _commandService;
            this._messageService = _messageService;
            this._isEnabled = this._editor.getConfiguration().contribInfo.codeLens;
            this._globalToDispose = [];
            this._localToDispose = [];
            this._lenses = [];
            this._currentFindCodeLensSymbolsPromise = null;
            this._modelChangeCounter = 0;
            this._globalToDispose.push(this._editor.onDidChangeModel(function () { return _this.onModelChange(); }));
            this._globalToDispose.push(this._editor.onDidChangeModelLanguage(function () { return _this.onModelChange(); }));
            this._globalToDispose.push(this._editor.onDidChangeConfiguration(function (e) {
                var prevIsEnabled = _this._isEnabled;
                _this._isEnabled = _this._editor.getConfiguration().contribInfo.codeLens;
                if (prevIsEnabled !== _this._isEnabled) {
                    _this.onModelChange();
                }
            }));
            this._globalToDispose.push(modes_1.CodeLensProviderRegistry.onDidChange(this.onModelChange, this));
            this.onModelChange();
        }
        CodeLensContribution.prototype.dispose = function () {
            this.localDispose();
            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);
        };
        CodeLensContribution.prototype.localDispose = function () {
            if (this._currentFindCodeLensSymbolsPromise) {
                this._currentFindCodeLensSymbolsPromise.cancel();
                this._currentFindCodeLensSymbolsPromise = null;
                this._modelChangeCounter++;
            }
            if (this._currentFindOccPromise) {
                this._currentFindOccPromise.cancel();
                this._currentFindOccPromise = null;
            }
            this._localToDispose = lifecycle_1.dispose(this._localToDispose);
        };
        CodeLensContribution.prototype.getId = function () {
            return CodeLensContribution_1.ID;
        };
        CodeLensContribution.prototype.onModelChange = function () {
            var _this = this;
            this.localDispose();
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            if (!this._isEnabled) {
                return;
            }
            if (!modes_1.CodeLensProviderRegistry.has(model)) {
                return;
            }
            var providerSubscriptions = new lifecycle_1.Disposables();
            this._localToDispose.push(providerSubscriptions);
            var onEvent = function () {
                providerSubscriptions.dispose();
                scheduler.schedule();
            };
            var subscribeToProviders = function (result) {
                var seen = new Set();
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var provider = result_1[_i].provider;
                    if (provider.onDidChange && !seen.has(provider)) {
                        providerSubscriptions.add(provider.onDidChange(onEvent));
                        seen.add(provider);
                    }
                }
            };
            var detectVisible = new async_1.RunOnceScheduler(function () {
                _this._onViewportChanged(model.getLanguageIdentifier().language);
            }, 500);
            var scheduler = new async_1.RunOnceScheduler(function () {
                if (_this._currentFindCodeLensSymbolsPromise) {
                    _this._currentFindCodeLensSymbolsPromise.cancel();
                }
                _this._currentFindCodeLensSymbolsPromise = codelens_1.getCodeLensData(model);
                var counterValue = ++_this._modelChangeCounter;
                _this._currentFindCodeLensSymbolsPromise.then(function (result) {
                    if (counterValue === _this._modelChangeCounter) {
                        _this.renderCodeLensSymbols(result);
                        subscribeToProviders(result);
                        detectVisible.schedule();
                    }
                }, function (error) {
                    errors_1.onUnexpectedError(error);
                });
            }, 250);
            this._localToDispose.push(scheduler);
            this._localToDispose.push(detectVisible);
            this._localToDispose.push(model.addBulkListener(function (events) {
                var hadChange = false;
                for (var i = 0; i < events.length; i++) {
                    var eventType = events[i].getType();
                    if (eventType === editorCommon.EventType.ModelRawContentChanged) {
                        hadChange = true;
                        break;
                    }
                }
                if (hadChange) {
                    _this._editor.changeDecorations(function (changeAccessor) {
                        _this._editor.changeViewZones(function (viewAccessor) {
                            var toDispose = [];
                            _this._lenses.forEach(function (lens) {
                                if (lens.isValid()) {
                                    lens.update(viewAccessor);
                                }
                                else {
                                    toDispose.push(lens);
                                }
                            });
                            var helper = new CodeLensHelper();
                            toDispose.forEach(function (l) {
                                l.dispose(helper, viewAccessor);
                                _this._lenses.splice(_this._lenses.indexOf(l), 1);
                            });
                            helper.commit(changeAccessor);
                        });
                    });
                    // Compute new `visible` code lenses
                    detectVisible.schedule();
                    // Ask for all references again
                    scheduler.schedule();
                }
            }));
            this._localToDispose.push(this._editor.onDidScrollChange(function (e) {
                if (e.scrollTopChanged) {
                    detectVisible.schedule();
                }
            }));
            this._localToDispose.push({
                dispose: function () {
                    if (_this._editor.getModel()) {
                        _this._editor.changeDecorations(function (changeAccessor) {
                            _this._editor.changeViewZones(function (accessor) {
                                _this._disposeAllLenses(changeAccessor, accessor);
                            });
                        });
                    }
                    else {
                        // No accessors available
                        _this._disposeAllLenses(null, null);
                    }
                }
            });
            scheduler.schedule();
        };
        CodeLensContribution.prototype._disposeAllLenses = function (decChangeAccessor, viewZoneChangeAccessor) {
            var helper = new CodeLensHelper();
            this._lenses.forEach(function (lens) { return lens.dispose(helper, viewZoneChangeAccessor); });
            if (decChangeAccessor) {
                helper.commit(decChangeAccessor);
            }
            this._lenses = [];
        };
        CodeLensContribution.prototype.renderCodeLensSymbols = function (symbols) {
            var _this = this;
            if (!this._editor.getModel()) {
                return;
            }
            var maxLineNumber = this._editor.getModel().getLineCount();
            var groups = [];
            var lastGroup;
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                var line = symbol.symbol.range.startLineNumber;
                if (line < 1 || line > maxLineNumber) {
                    // invalid code lens
                    continue;
                }
                else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
                    // on same line as previous
                    lastGroup.push(symbol);
                }
                else {
                    // on later line as previous
                    lastGroup = [symbol];
                    groups.push(lastGroup);
                }
            }
            var centeredRange = this._editor.getCenteredRangeInViewport();
            var shouldRestoreCenteredRange = (groups.length !== this._lenses.length && this._editor.getScrollTop() !== 0);
            this._editor.changeDecorations(function (changeAccessor) {
                _this._editor.changeViewZones(function (accessor) {
                    var codeLensIndex = 0, groupsIndex = 0, helper = new CodeLensHelper();
                    while (groupsIndex < groups.length && codeLensIndex < _this._lenses.length) {
                        var symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
                        var codeLensLineNumber = _this._lenses[codeLensIndex].getLineNumber();
                        if (codeLensLineNumber < symbolsLineNumber) {
                            _this._lenses[codeLensIndex].dispose(helper, accessor);
                            _this._lenses.splice(codeLensIndex, 1);
                        }
                        else if (codeLensLineNumber === symbolsLineNumber) {
                            _this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
                            groupsIndex++;
                            codeLensIndex++;
                        }
                        else {
                            _this._lenses.splice(codeLensIndex, 0, new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._commandService, _this._messageService));
                            codeLensIndex++;
                            groupsIndex++;
                        }
                    }
                    // Delete extra code lenses
                    while (codeLensIndex < _this._lenses.length) {
                        _this._lenses[codeLensIndex].dispose(helper, accessor);
                        _this._lenses.splice(codeLensIndex, 1);
                    }
                    // Create extra symbols
                    while (groupsIndex < groups.length) {
                        _this._lenses.push(new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._commandService, _this._messageService));
                        groupsIndex++;
                    }
                    helper.commit(changeAccessor);
                });
            });
            if (shouldRestoreCenteredRange) {
                this._editor.revealRangeInCenter(centeredRange);
            }
        };
        CodeLensContribution.prototype._onViewportChanged = function (modeId) {
            var _this = this;
            if (this._currentFindOccPromise) {
                this._currentFindOccPromise.cancel();
                this._currentFindOccPromise = null;
            }
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            var toResolve = [];
            var lenses = [];
            this._lenses.forEach(function (lens) {
                var request = lens.computeIfNecessary(model);
                if (request) {
                    toResolve.push(request);
                    lenses.push(lens);
                }
            });
            if (toResolve.length === 0) {
                return;
            }
            var promises = toResolve.map(function (request, i) {
                var resolvedSymbols = new Array(request.length);
                var promises = request.map(function (request, i) {
                    return async_1.asWinJsPromise(function (token) {
                        return request.provider.resolveCodeLens(model, request.symbol, token);
                    }).then(function (symbol) {
                        resolvedSymbols[i] = symbol;
                    });
                });
                return winjs_base_1.TPromise.join(promises).then(function () {
                    lenses[i].updateCommands(resolvedSymbols);
                });
            });
            this._currentFindOccPromise = winjs_base_1.TPromise.join(promises).then(function () {
                _this._currentFindOccPromise = null;
            });
        };
        return CodeLensContribution;
    }());
    CodeLensContribution.ID = 'css.editor.codeLens';
    CodeLensContribution = CodeLensContribution_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, commands_1.ICommandService),
        __param(2, message_1.IMessageService)
    ], CodeLensContribution);
    exports.CodeLensContribution = CodeLensContribution;
    var CodeLensContribution_1;
});












define(__m[448/*vs/editor/contrib/comment/common/comment*/], __M([1/*require*/,0/*exports*/,282/*vs/nls!vs/editor/contrib/comment/common/comment*/,32/*vs/base/common/keyCodes*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,147/*vs/editor/contrib/comment/common/blockCommentCommand*/,217/*vs/editor/contrib/comment/common/lineCommentCommand*/]), function (require, exports, nls, keyCodes_1, editorCommon_1, editorCommonExtensions_1, blockCommentCommand_1, lineCommentCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CommentLineAction = (function (_super) {
        __extends(CommentLineAction, _super);
        function CommentLineAction(type, opts) {
            var _this = _super.call(this, opts) || this;
            _this._type = type;
            return _this;
        }
        CommentLineAction.prototype.run = function (accessor, editor) {
            var model = editor.getModel();
            if (!model) {
                return;
            }
            var commands = [];
            var selections = editor.getSelections();
            var opts = model.getOptions();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new lineCommentCommand_1.LineCommentCommand(selections[i], opts.tabSize, this._type));
            }
            editor.executeCommands(this.id, commands);
        };
        return CommentLineAction;
    }(editorCommonExtensions_1.EditorAction));
    var ToggleCommentLineAction = (function (_super) {
        __extends(ToggleCommentLineAction, _super);
        function ToggleCommentLineAction() {
            return _super.call(this, 0 /* Toggle */, {
                id: 'editor.action.commentLine',
                label: nls.localize(0, null),
                alias: 'Toggle Line Comment',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 85 /* US_SLASH */
                }
            }) || this;
        }
        return ToggleCommentLineAction;
    }(CommentLineAction));
    ToggleCommentLineAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], ToggleCommentLineAction);
    var AddLineCommentAction = (function (_super) {
        __extends(AddLineCommentAction, _super);
        function AddLineCommentAction() {
            return _super.call(this, 1 /* ForceAdd */, {
                id: 'editor.action.addCommentLine',
                label: nls.localize(1, null),
                alias: 'Add Line Comment',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 33 /* KEY_C */)
                }
            }) || this;
        }
        return AddLineCommentAction;
    }(CommentLineAction));
    AddLineCommentAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], AddLineCommentAction);
    var RemoveLineCommentAction = (function (_super) {
        __extends(RemoveLineCommentAction, _super);
        function RemoveLineCommentAction() {
            return _super.call(this, 2 /* ForceRemove */, {
                id: 'editor.action.removeCommentLine',
                label: nls.localize(2, null),
                alias: 'Remove Line Comment',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 51 /* KEY_U */)
                }
            }) || this;
        }
        return RemoveLineCommentAction;
    }(CommentLineAction));
    RemoveLineCommentAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], RemoveLineCommentAction);
    var BlockCommentAction = (function (_super) {
        __extends(BlockCommentAction, _super);
        function BlockCommentAction() {
            return _super.call(this, {
                id: 'editor.action.blockComment',
                label: nls.localize(3, null),
                alias: 'Toggle Block Comment',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 31 /* KEY_A */,
                    linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 31 /* KEY_A */ }
                }
            }) || this;
        }
        BlockCommentAction.prototype.run = function (accessor, editor) {
            var commands = [];
            var selections = editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new blockCommentCommand_1.BlockCommentCommand(selections[i]));
            }
            editor.executeCommands(this.id, commands);
        };
        return BlockCommentAction;
    }(editorCommonExtensions_1.EditorAction));
    BlockCommentAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], BlockCommentAction);
});















define(__m[449/*vs/editor/contrib/contextmenu/browser/contextmenu*/], __M([1/*require*/,0/*exports*/,283/*vs/nls!vs/editor/contrib/contextmenu/browser/contextmenu*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,11/*vs/base/browser/dom*/,69/*vs/base/browser/ui/actionbar/actionbar*/,58/*vs/platform/contextview/browser/contextView*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,59/*vs/platform/actions/common/actions*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/]), function (require, exports, nls, lifecycle_1, winjs_base_1, dom, actionbar_1, contextView_1, keybinding_1, contextkey_1, actions_1, editorCommon_1, editorCommonExtensions_1, editorBrowserExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuController = ContextMenuController_1 = (function () {
        function ContextMenuController(editor, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService) {
            var _this = this;
            this._contextMenuService = _contextMenuService;
            this._contextViewService = _contextViewService;
            this._contextKeyService = _contextKeyService;
            this._keybindingService = _keybindingService;
            this._menuService = _menuService;
            this._toDispose = [];
            this._contextMenuIsBeingShownCount = 0;
            this._editor = editor;
            this._toDispose.push(this._editor.onContextMenu(function (e) { return _this._onContextMenu(e); }));
            this._toDispose.push(this._editor.onDidScrollChange(function (e) {
                if (_this._contextMenuIsBeingShownCount > 0) {
                    _this._contextViewService.hideContextView();
                }
            }));
            this._toDispose.push(this._editor.onKeyDown(function (e) {
                if (e.keyCode === 58 /* ContextMenu */) {
                    // Chrome is funny like that
                    e.preventDefault();
                    e.stopPropagation();
                    _this.showContextMenu();
                }
            }));
        }
        ContextMenuController.get = function (editor) {
            return editor.getContribution(ContextMenuController_1.ID);
        };
        ContextMenuController.prototype._onContextMenu = function (e) {
            if (!this._editor.getConfiguration().contribInfo.contextmenu) {
                this._editor.focus();
                // Ensure the cursor is at the position of the mouse click
                if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
                    this._editor.setPosition(e.target.position);
                }
                return; // Context menu is turned off through configuration
            }
            if (e.target.type === editorCommon_1.MouseTargetType.OVERLAY_WIDGET) {
                return; // allow native menu on widgets to support right click on input field for example in find
            }
            e.event.preventDefault();
            if (e.target.type !== editorCommon_1.MouseTargetType.CONTENT_TEXT && e.target.type !== editorCommon_1.MouseTargetType.CONTENT_EMPTY && e.target.type !== editorCommon_1.MouseTargetType.TEXTAREA) {
                return; // only support mouse click into text or native context menu key for now
            }
            // Ensure the editor gets focus if it hasn't, so the right events are being sent to other contributions
            this._editor.focus();
            // Ensure the cursor is at the position of the mouse click
            if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
                this._editor.setPosition(e.target.position);
            }
            // Unless the user triggerd the context menu through Shift+F10, use the mouse position as menu position
            var forcedPosition;
            if (e.target.type !== editorCommon_1.MouseTargetType.TEXTAREA) {
                forcedPosition = { x: e.event.posx, y: e.event.posy + 1 };
            }
            // Show the context menu
            this.showContextMenu(forcedPosition);
        };
        ContextMenuController.prototype.showContextMenu = function (forcedPosition) {
            if (!this._editor.getConfiguration().contribInfo.contextmenu) {
                return; // Context menu is turned off through configuration
            }
            if (!this._contextMenuService) {
                this._editor.focus();
                return; // We need the context menu service to function
            }
            // Find actions available for menu
            var menuActions = this._getMenuActions();
            // Show menu if we have actions to show
            if (menuActions.length > 0) {
                this._doShowContextMenu(menuActions, forcedPosition);
            }
        };
        ContextMenuController.prototype._getMenuActions = function () {
            var result = [];
            var contextMenu = this._menuService.createMenu(actions_1.MenuId.EditorContext, this._contextKeyService);
            var groups = contextMenu.getActions(this._editor.getModel().uri);
            contextMenu.dispose();
            for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
                var group = groups_1[_i];
                var actions = group[1];
                result.push.apply(result, actions);
                result.push(new actionbar_1.Separator());
            }
            result.pop(); // remove last separator
            return result;
        };
        ContextMenuController.prototype._doShowContextMenu = function (actions, forcedPosition) {
            var _this = this;
            if (forcedPosition === void 0) { forcedPosition = null; }
            // Disable hover
            var oldHoverSetting = this._editor.getConfiguration().contribInfo.hover;
            this._editor.updateOptions({
                hover: false
            });
            var menuPosition = forcedPosition;
            if (!menuPosition) {
                // Ensure selection is visible
                this._editor.revealPosition(this._editor.getPosition());
                this._editor.render();
                var cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
                // Translate to absolute editor position
                var editorCoords = dom.getDomNodePagePosition(this._editor.getDomNode());
                var posx = editorCoords.left + cursorCoords.left;
                var posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
                menuPosition = { x: posx, y: posy };
            }
            // Show menu
            this._contextMenuIsBeingShownCount++;
            this._contextMenuService.showContextMenu({
                getAnchor: function () { return menuPosition; },
                getActions: function () {
                    return winjs_base_1.TPromise.as(actions);
                },
                getActionItem: function (action) {
                    var keybinding = _this._keybindingFor(action);
                    if (keybinding) {
                        return new actionbar_1.ActionItem(action, action, { label: true, keybinding: _this._keybindingService.getLabelFor(keybinding) });
                    }
                    var customActionItem = action;
                    if (typeof customActionItem.getActionItem === 'function') {
                        return customActionItem.getActionItem();
                    }
                    return null;
                },
                getKeyBinding: function (action) {
                    return _this._keybindingFor(action);
                },
                onHide: function (wasCancelled) {
                    _this._contextMenuIsBeingShownCount--;
                    _this._editor.focus();
                    _this._editor.updateOptions({
                        hover: oldHoverSetting
                    });
                }
            });
        };
        ContextMenuController.prototype._keybindingFor = function (action) {
            var opts = this._keybindingService.lookupKeybindings(action.id);
            if (opts.length > 0) {
                return opts[0]; // only take the first one
            }
            return null;
        };
        ContextMenuController.prototype.getId = function () {
            return ContextMenuController_1.ID;
        };
        ContextMenuController.prototype.dispose = function () {
            if (this._contextMenuIsBeingShownCount > 0) {
                this._contextViewService.hideContextView();
            }
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        return ContextMenuController;
    }());
    ContextMenuController.ID = 'editor.contrib.contextmenu';
    ContextMenuController = ContextMenuController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, contextView_1.IContextMenuService),
        __param(2, contextView_1.IContextViewService),
        __param(3, contextkey_1.IContextKeyService),
        __param(4, keybinding_1.IKeybindingService),
        __param(5, actions_1.IMenuService)
    ], ContextMenuController);
    exports.ContextMenuController = ContextMenuController;
    var ShowContextMenu = (function (_super) {
        __extends(ShowContextMenu, _super);
        function ShowContextMenu() {
            return _super.call(this, {
                id: 'editor.action.showContextMenu',
                label: nls.localize(0, null),
                alias: 'Show Editor Context Menu',
                precondition: null,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 68 /* F10 */
                }
            }) || this;
        }
        ShowContextMenu.prototype.run = function (accessor, editor) {
            var contribution = ContextMenuController.get(editor);
            contribution.showContextMenu();
        };
        return ShowContextMenu;
    }(editorCommonExtensions_1.EditorAction));
    ShowContextMenu = __decorate([
        editorCommonExtensions_1.editorAction
    ], ShowContextMenu);
    var ContextMenuController_1;
});















define(__m[162/*vs/editor/contrib/find/common/findController*/], __M([1/*require*/,0/*exports*/,285/*vs/nls!vs/editor/contrib/find/common/findController*/,438/*vs/base/common/history*/,32/*vs/base/common/keyCodes*/,3/*vs/base/common/lifecycle*/,18/*vs/platform/contextkey/common/contextkey*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,9/*vs/base/common/strings*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,137/*vs/editor/contrib/find/common/findModel*/,219/*vs/editor/contrib/find/common/findState*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/]), function (require, exports, nls, history_1, keyCodes_1, lifecycle_1, contextkey_1, range_1, selection_1, strings, editorCommon, editorCommonExtensions_1, findModel_1, findState_1, modes_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var FindStartFocusAction;
    (function (FindStartFocusAction) {
        FindStartFocusAction[FindStartFocusAction["NoFocusChange"] = 0] = "NoFocusChange";
        FindStartFocusAction[FindStartFocusAction["FocusFindInput"] = 1] = "FocusFindInput";
        FindStartFocusAction[FindStartFocusAction["FocusReplaceInput"] = 2] = "FocusReplaceInput";
    })(FindStartFocusAction = exports.FindStartFocusAction || (exports.FindStartFocusAction = {}));
    exports.CONTEXT_FIND_WIDGET_VISIBLE = new contextkey_1.RawContextKey('findWidgetVisible', false);
    exports.CONTEXT_FIND_WIDGET_NOT_VISIBLE = exports.CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
    exports.CONTEXT_FIND_INPUT_FOCUSSED = new contextkey_1.RawContextKey('findInputFocussed', false);
    var CommonFindController = (function (_super) {
        __extends(CommonFindController, _super);
        function CommonFindController(editor, contextKeyService) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._findWidgetVisible = exports.CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
            _this._updateHistoryDelayer = new async_1.Delayer(500);
            _this._currentHistoryNavigator = new history_1.HistoryNavigator();
            _this._state = _this._register(new findState_1.FindReplaceState());
            _this._register(_this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            _this._model = null;
            _this._register(_this._editor.onDidChangeModel(function () {
                var shouldRestartFind = (_this._editor.getModel() && _this._state.isRevealed);
                _this.disposeModel();
                _this._state.change({
                    searchScope: null
                }, false);
                if (shouldRestartFind) {
                    _this._start({
                        forceRevealReplace: false,
                        seedSearchStringFromSelection: false,
                        shouldFocus: 0 /* NoFocusChange */,
                        shouldAnimate: false,
                    });
                }
            }));
            return _this;
        }
        CommonFindController.get = function (editor) {
            return editor.getContribution(CommonFindController.ID);
        };
        CommonFindController.prototype.dispose = function () {
            this.disposeModel();
            _super.prototype.dispose.call(this);
        };
        CommonFindController.prototype.disposeModel = function () {
            if (this._model) {
                this._model.dispose();
                this._model = null;
            }
        };
        CommonFindController.prototype.getId = function () {
            return CommonFindController.ID;
        };
        CommonFindController.prototype._onStateChanged = function (e) {
            if (e.updateHistory && e.searchString) {
                this._delayedUpdateHistory();
            }
            if (e.isRevealed) {
                if (this._state.isRevealed) {
                    this._findWidgetVisible.set(true);
                }
                else {
                    this._findWidgetVisible.reset();
                    this.disposeModel();
                }
            }
        };
        CommonFindController.prototype._delayedUpdateHistory = function () {
            this._updateHistoryDelayer.trigger(this._updateHistory.bind(this));
        };
        CommonFindController.prototype._updateHistory = function () {
            if (this._state.searchString) {
                this._currentHistoryNavigator.add(this._state.searchString);
            }
        };
        CommonFindController.prototype.getState = function () {
            return this._state;
        };
        CommonFindController.prototype.getHistory = function () {
            return this._currentHistoryNavigator;
        };
        CommonFindController.prototype.closeFindWidget = function () {
            this._state.change({
                isRevealed: false,
                searchScope: null
            }, false);
            this._editor.focus();
        };
        CommonFindController.prototype.toggleCaseSensitive = function () {
            this._state.change({ matchCase: !this._state.matchCase }, false);
        };
        CommonFindController.prototype.toggleWholeWords = function () {
            this._state.change({ wholeWord: !this._state.wholeWord }, false);
        };
        CommonFindController.prototype.toggleRegex = function () {
            this._state.change({ isRegex: !this._state.isRegex }, false);
        };
        CommonFindController.prototype.setSearchString = function (searchString) {
            this._state.change({ searchString: searchString }, false);
        };
        CommonFindController.prototype.getSelectionSearchString = function () {
            var selection = this._editor.getSelection();
            if (selection.startLineNumber === selection.endLineNumber) {
                if (selection.isEmpty()) {
                    var wordAtPosition = this._editor.getModel().getWordAtPosition(selection.getStartPosition());
                    if (wordAtPosition) {
                        return wordAtPosition.word;
                    }
                }
                else {
                    return this._editor.getModel().getValueInRange(selection);
                }
            }
            return null;
        };
        CommonFindController.prototype._start = function (opts) {
            this.disposeModel();
            if (!this._editor.getModel()) {
                // cannot do anything with an editor that doesn't have a model...
                return;
            }
            var stateChanges = {
                isRevealed: true
            };
            // Consider editor selection and overwrite the state with it
            if (opts.seedSearchStringFromSelection) {
                var selectionSearchString = this.getSelectionSearchString();
                if (selectionSearchString) {
                    if (this._state.isRegex) {
                        stateChanges.searchString = strings.escapeRegExpCharacters(selectionSearchString);
                    }
                    else {
                        stateChanges.searchString = selectionSearchString;
                    }
                }
            }
            // Overwrite isReplaceRevealed
            if (opts.forceRevealReplace) {
                stateChanges.isReplaceRevealed = true;
            }
            this._state.change(stateChanges, false);
            if (!this._model) {
                this._model = new findModel_1.FindModelBoundToEditorModel(this._editor, this._state);
            }
        };
        CommonFindController.prototype.start = function (opts) {
            this._start(opts);
        };
        CommonFindController.prototype.moveToNextMatch = function () {
            if (this._model) {
                this._model.moveToNextMatch();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.moveToPrevMatch = function () {
            if (this._model) {
                this._model.moveToPrevMatch();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.replace = function () {
            if (this._model) {
                this._model.replace();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.replaceAll = function () {
            if (this._model) {
                this._model.replaceAll();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.selectAllMatches = function () {
            if (this._model) {
                this._model.selectAllMatches();
                this._editor.focus();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.showPreviousFindTerm = function () {
            var previousTerm = this._currentHistoryNavigator.previous();
            if (previousTerm) {
                this._state.change({ searchString: previousTerm }, false, false);
            }
            return true;
        };
        CommonFindController.prototype.showNextFindTerm = function () {
            var nextTerm = this._currentHistoryNavigator.next();
            if (nextTerm) {
                this._state.change({ searchString: nextTerm }, false, false);
            }
            return true;
        };
        return CommonFindController;
    }(lifecycle_1.Disposable));
    CommonFindController.ID = 'editor.contrib.findController';
    CommonFindController = __decorate([
        __param(1, contextkey_1.IContextKeyService)
    ], CommonFindController);
    exports.CommonFindController = CommonFindController;
    var StartFindAction = (function (_super) {
        __extends(StartFindAction, _super);
        function StartFindAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.StartFindAction,
                label: nls.localize(0, null),
                alias: 'Find',
                precondition: null,
                kbOpts: {
                    kbExpr: null,
                    primary: 2048 /* CtrlCmd */ | 36 /* KEY_F */,
                    mac: {
                        primary: 2048 /* CtrlCmd */ | 36 /* KEY_F */,
                        secondary: [2048 /* CtrlCmd */ | 35 /* KEY_E */]
                    }
                }
            }) || this;
        }
        StartFindAction.prototype.run = function (accessor, editor) {
            var controller = CommonFindController.get(editor);
            if (controller) {
                controller.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: true,
                    shouldFocus: 1 /* FocusFindInput */,
                    shouldAnimate: true
                });
            }
        };
        return StartFindAction;
    }(editorCommonExtensions_1.EditorAction));
    StartFindAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], StartFindAction);
    exports.StartFindAction = StartFindAction;
    var MatchFindAction = (function (_super) {
        __extends(MatchFindAction, _super);
        function MatchFindAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        MatchFindAction.prototype.run = function (accessor, editor) {
            var controller = CommonFindController.get(editor);
            if (controller && !this._run(controller)) {
                controller.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0),
                    shouldFocus: 0 /* NoFocusChange */,
                    shouldAnimate: true
                });
                this._run(controller);
            }
        };
        return MatchFindAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.MatchFindAction = MatchFindAction;
    var NextMatchFindAction = (function (_super) {
        __extends(NextMatchFindAction, _super);
        function NextMatchFindAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.NextMatchFindAction,
                label: nls.localize(1, null),
                alias: 'Find Next',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 61 /* F3 */,
                    mac: { primary: 2048 /* CtrlCmd */ | 37 /* KEY_G */, secondary: [61 /* F3 */] }
                }
            }) || this;
        }
        NextMatchFindAction.prototype._run = function (controller) {
            return controller.moveToNextMatch();
        };
        return NextMatchFindAction;
    }(MatchFindAction));
    NextMatchFindAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], NextMatchFindAction);
    exports.NextMatchFindAction = NextMatchFindAction;
    var PreviousMatchFindAction = (function (_super) {
        __extends(PreviousMatchFindAction, _super);
        function PreviousMatchFindAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.PreviousMatchFindAction,
                label: nls.localize(2, null),
                alias: 'Find Previous',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 1024 /* Shift */ | 61 /* F3 */,
                    mac: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 37 /* KEY_G */, secondary: [1024 /* Shift */ | 61 /* F3 */] }
                }
            }) || this;
        }
        PreviousMatchFindAction.prototype._run = function (controller) {
            return controller.moveToPrevMatch();
        };
        return PreviousMatchFindAction;
    }(MatchFindAction));
    PreviousMatchFindAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], PreviousMatchFindAction);
    exports.PreviousMatchFindAction = PreviousMatchFindAction;
    var SelectionMatchFindAction = (function (_super) {
        __extends(SelectionMatchFindAction, _super);
        function SelectionMatchFindAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SelectionMatchFindAction.prototype.run = function (accessor, editor) {
            var controller = CommonFindController.get(editor);
            if (!controller) {
                return;
            }
            var selectionSearchString = controller.getSelectionSearchString();
            if (selectionSearchString) {
                controller.setSearchString(selectionSearchString);
            }
            if (!this._run(controller)) {
                controller.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: false,
                    shouldFocus: 0 /* NoFocusChange */,
                    shouldAnimate: true
                });
                this._run(controller);
            }
        };
        return SelectionMatchFindAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.SelectionMatchFindAction = SelectionMatchFindAction;
    var NextSelectionMatchFindAction = (function (_super) {
        __extends(NextSelectionMatchFindAction, _super);
        function NextSelectionMatchFindAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.NextSelectionMatchFindAction,
                label: nls.localize(3, null),
                alias: 'Find Next Selection',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 61 /* F3 */
                }
            }) || this;
        }
        NextSelectionMatchFindAction.prototype._run = function (controller) {
            return controller.moveToNextMatch();
        };
        return NextSelectionMatchFindAction;
    }(SelectionMatchFindAction));
    NextSelectionMatchFindAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], NextSelectionMatchFindAction);
    exports.NextSelectionMatchFindAction = NextSelectionMatchFindAction;
    var PreviousSelectionMatchFindAction = (function (_super) {
        __extends(PreviousSelectionMatchFindAction, _super);
        function PreviousSelectionMatchFindAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.PreviousSelectionMatchFindAction,
                label: nls.localize(4, null),
                alias: 'Find Previous Selection',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 61 /* F3 */
                }
            }) || this;
        }
        PreviousSelectionMatchFindAction.prototype._run = function (controller) {
            return controller.moveToPrevMatch();
        };
        return PreviousSelectionMatchFindAction;
    }(SelectionMatchFindAction));
    PreviousSelectionMatchFindAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], PreviousSelectionMatchFindAction);
    exports.PreviousSelectionMatchFindAction = PreviousSelectionMatchFindAction;
    var StartFindReplaceAction = (function (_super) {
        __extends(StartFindReplaceAction, _super);
        function StartFindReplaceAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.StartFindReplaceAction,
                label: nls.localize(5, null),
                alias: 'Replace',
                precondition: null,
                kbOpts: {
                    kbExpr: null,
                    primary: 2048 /* CtrlCmd */ | 38 /* KEY_H */,
                    mac: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 36 /* KEY_F */ }
                }
            }) || this;
        }
        StartFindReplaceAction.prototype.run = function (accessor, editor) {
            if (editor.getConfiguration().readOnly) {
                return;
            }
            var controller = CommonFindController.get(editor);
            if (controller) {
                controller.start({
                    forceRevealReplace: true,
                    seedSearchStringFromSelection: true,
                    shouldFocus: 2 /* FocusReplaceInput */,
                    shouldAnimate: true
                });
            }
        };
        return StartFindReplaceAction;
    }(editorCommonExtensions_1.EditorAction));
    StartFindReplaceAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], StartFindReplaceAction);
    exports.StartFindReplaceAction = StartFindReplaceAction;
    function multiCursorFind(editor, changeFindSearchString, allowMultiline) {
        var controller = CommonFindController.get(editor);
        if (!controller) {
            return null;
        }
        var state = controller.getState();
        var searchText;
        var currentMatch;
        // In any case, if the find widget was ever opened, the options are taken from it
        var wholeWord = state.wholeWord;
        var matchCase = state.matchCase;
        // Find widget owns what we search for if:
        //  - focus is not in the editor (i.e. it is in the find widget)
        //  - and the search widget is visible
        //  - and the search string is non-empty
        if (!editor.isFocused() && state.isRevealed && state.searchString.length > 0) {
            // Find widget owns what is searched for
            searchText = state.searchString;
        }
        else {
            // Selection owns what is searched for
            var s = editor.getSelection();
            if (s.startLineNumber !== s.endLineNumber && !allowMultiline) {
                // multiline forbidden
                return null;
            }
            if (s.isEmpty()) {
                // selection is empty => expand to current word
                var word = editor.getModel().getWordAtPosition(s.getStartPosition());
                if (!word) {
                    return null;
                }
                searchText = word.word;
                currentMatch = new selection_1.Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
            }
            else {
                searchText = editor.getModel().getValueInRange(s);
            }
            if (changeFindSearchString) {
                controller.setSearchString(searchText);
            }
        }
        return {
            searchText: searchText,
            matchCase: matchCase,
            wholeWord: wholeWord,
            currentMatch: currentMatch
        };
    }
    var SelectNextFindMatchAction = (function (_super) {
        __extends(SelectNextFindMatchAction, _super);
        function SelectNextFindMatchAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SelectNextFindMatchAction.prototype._getNextMatch = function (editor) {
            var r = multiCursorFind(editor, /*changeFindSearchString*/ true, /*allowMultiline*/ true);
            if (!r) {
                return null;
            }
            if (r.currentMatch) {
                return r.currentMatch;
            }
            var allSelections = editor.getSelections();
            var lastAddedSelection = allSelections[allSelections.length - 1];
            var nextMatch = editor.getModel().findNextMatch(r.searchText, lastAddedSelection.getEndPosition(), false, r.matchCase, r.wholeWord, false);
            if (!nextMatch) {
                return null;
            }
            return new selection_1.Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
        };
        return SelectNextFindMatchAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.SelectNextFindMatchAction = SelectNextFindMatchAction;
    var SelectPreviousFindMatchAction = (function (_super) {
        __extends(SelectPreviousFindMatchAction, _super);
        function SelectPreviousFindMatchAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SelectPreviousFindMatchAction.prototype._getPreviousMatch = function (editor) {
            var r = multiCursorFind(editor, /*changeFindSearchString*/ true, /*allowMultiline*/ true);
            if (!r) {
                return null;
            }
            if (r.currentMatch) {
                return r.currentMatch;
            }
            var allSelections = editor.getSelections();
            var lastAddedSelection = allSelections[allSelections.length - 1];
            var previousMatch = editor.getModel().findPreviousMatch(r.searchText, lastAddedSelection.getStartPosition(), false, r.matchCase, r.wholeWord, false);
            if (!previousMatch) {
                return null;
            }
            return new selection_1.Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
        };
        return SelectPreviousFindMatchAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.SelectPreviousFindMatchAction = SelectPreviousFindMatchAction;
    var AddSelectionToNextFindMatchAction = (function (_super) {
        __extends(AddSelectionToNextFindMatchAction, _super);
        function AddSelectionToNextFindMatchAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.AddSelectionToNextFindMatchAction,
                label: nls.localize(6, null),
                alias: 'Add Selection To Next Find Match',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 34 /* KEY_D */
                }
            }) || this;
        }
        AddSelectionToNextFindMatchAction.prototype.run = function (accessor, editor) {
            var nextMatch = this._getNextMatch(editor);
            if (!nextMatch) {
                return;
            }
            var allSelections = editor.getSelections();
            editor.setSelections(allSelections.concat(nextMatch));
            editor.revealRangeInCenterIfOutsideViewport(nextMatch);
        };
        return AddSelectionToNextFindMatchAction;
    }(SelectNextFindMatchAction));
    AddSelectionToNextFindMatchAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], AddSelectionToNextFindMatchAction);
    exports.AddSelectionToNextFindMatchAction = AddSelectionToNextFindMatchAction;
    var AddSelectionToPreviousFindMatchAction = (function (_super) {
        __extends(AddSelectionToPreviousFindMatchAction, _super);
        function AddSelectionToPreviousFindMatchAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.AddSelectionToPreviousFindMatchAction,
                label: nls.localize(7, null),
                alias: 'Add Selection To Previous Find Match',
                precondition: null
            }) || this;
        }
        AddSelectionToPreviousFindMatchAction.prototype.run = function (accessor, editor) {
            var previousMatch = this._getPreviousMatch(editor);
            if (!previousMatch) {
                return;
            }
            var allSelections = editor.getSelections();
            editor.setSelections(allSelections.concat(previousMatch));
            editor.revealRangeInCenterIfOutsideViewport(previousMatch);
        };
        return AddSelectionToPreviousFindMatchAction;
    }(SelectPreviousFindMatchAction));
    AddSelectionToPreviousFindMatchAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], AddSelectionToPreviousFindMatchAction);
    exports.AddSelectionToPreviousFindMatchAction = AddSelectionToPreviousFindMatchAction;
    var MoveSelectionToNextFindMatchAction = (function (_super) {
        __extends(MoveSelectionToNextFindMatchAction, _super);
        function MoveSelectionToNextFindMatchAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.MoveSelectionToNextFindMatchAction,
                label: nls.localize(8, null),
                alias: 'Move Last Selection To Next Find Match',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 34 /* KEY_D */)
                }
            }) || this;
        }
        MoveSelectionToNextFindMatchAction.prototype.run = function (accessor, editor) {
            var nextMatch = this._getNextMatch(editor);
            if (!nextMatch) {
                return;
            }
            var allSelections = editor.getSelections();
            editor.setSelections(allSelections.slice(0, allSelections.length - 1).concat(nextMatch));
            editor.revealRangeInCenterIfOutsideViewport(nextMatch);
        };
        return MoveSelectionToNextFindMatchAction;
    }(SelectNextFindMatchAction));
    MoveSelectionToNextFindMatchAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveSelectionToNextFindMatchAction);
    exports.MoveSelectionToNextFindMatchAction = MoveSelectionToNextFindMatchAction;
    var MoveSelectionToPreviousFindMatchAction = (function (_super) {
        __extends(MoveSelectionToPreviousFindMatchAction, _super);
        function MoveSelectionToPreviousFindMatchAction() {
            return _super.call(this, {
                id: findModel_1.FIND_IDS.MoveSelectionToPreviousFindMatchAction,
                label: nls.localize(9, null),
                alias: 'Move Last Selection To Previous Find Match',
                precondition: null
            }) || this;
        }
        MoveSelectionToPreviousFindMatchAction.prototype.run = function (accessor, editor) {
            var previousMatch = this._getPreviousMatch(editor);
            if (!previousMatch) {
                return;
            }
            var allSelections = editor.getSelections();
            editor.setSelections(allSelections.slice(0, allSelections.length - 1).concat(previousMatch));
            editor.revealRangeInCenterIfOutsideViewport(previousMatch);
        };
        return MoveSelectionToPreviousFindMatchAction;
    }(SelectPreviousFindMatchAction));
    MoveSelectionToPreviousFindMatchAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveSelectionToPreviousFindMatchAction);
    exports.MoveSelectionToPreviousFindMatchAction = MoveSelectionToPreviousFindMatchAction;
    var AbstractSelectHighlightsAction = (function (_super) {
        __extends(AbstractSelectHighlightsAction, _super);
        function AbstractSelectHighlightsAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbstractSelectHighlightsAction.prototype.run = function (accessor, editor) {
            var r = multiCursorFind(editor, /*changeFindSearchString*/ true, /*allowMultiline*/ true);
            if (!r) {
                return;
            }
            var matches = editor.getModel().findMatches(r.searchText, true, false, r.matchCase, r.wholeWord, false).map(function (m) { return m.range; });
            if (matches.length > 0) {
                var editorSelection = editor.getSelection();
                for (var i = 0, len = matches.length; i < len; i++) {
                    var match = matches[i];
                    var intersection = match.intersectRanges(editorSelection);
                    if (intersection) {
                        // bingo!
                        matches.splice(i, 1);
                        matches.unshift(match);
                        break;
                    }
                }
                editor.setSelections(matches.map(function (m) { return new selection_1.Selection(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn); }));
            }
        };
        return AbstractSelectHighlightsAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.AbstractSelectHighlightsAction = AbstractSelectHighlightsAction;
    var SelectHighlightsAction = (function (_super) {
        __extends(SelectHighlightsAction, _super);
        function SelectHighlightsAction() {
            return _super.call(this, {
                id: 'editor.action.selectHighlights',
                label: nls.localize(10, null),
                alias: 'Select All Occurrences of Find Match',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 42 /* KEY_L */
                }
            }) || this;
        }
        return SelectHighlightsAction;
    }(AbstractSelectHighlightsAction));
    SelectHighlightsAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], SelectHighlightsAction);
    exports.SelectHighlightsAction = SelectHighlightsAction;
    var CompatChangeAll = (function (_super) {
        __extends(CompatChangeAll, _super);
        function CompatChangeAll() {
            return _super.call(this, {
                id: 'editor.action.changeAll',
                label: nls.localize(11, null),
                alias: 'Change All Occurrences',
                precondition: EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 60 /* F2 */
                },
                menuOpts: {
                    group: '1_modification',
                    order: 1.2
                }
            }) || this;
        }
        return CompatChangeAll;
    }(AbstractSelectHighlightsAction));
    CompatChangeAll = __decorate([
        editorCommonExtensions_1.editorAction
    ], CompatChangeAll);
    exports.CompatChangeAll = CompatChangeAll;
    var SelectionHighlighter = SelectionHighlighter_1 = (function (_super) {
        __extends(SelectionHighlighter, _super);
        function SelectionHighlighter(editor) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.decorations = [];
            _this.updateSoon = _this._register(new async_1.RunOnceScheduler(function () { return _this._update(); }, 300));
            _this.lastWordUnderCursor = null;
            _this._register(editor.onDidChangeCursorSelection(function (e) {
                if (e.selection.isEmpty()) {
                    if (e.reason === editorCommon.CursorChangeReason.Explicit) {
                        if (!_this.lastWordUnderCursor || !_this.lastWordUnderCursor.containsPosition(e.selection.getStartPosition())) {
                            // no longer valid
                            _this.removeDecorations();
                        }
                        _this.updateSoon.schedule();
                    }
                    else {
                        _this.removeDecorations();
                    }
                }
                else {
                    _this._update();
                }
            }));
            _this._register(editor.onDidChangeModel(function (e) {
                _this.removeDecorations();
            }));
            _this._register(CommonFindController.get(editor).getState().addChangeListener(function (e) {
                _this._update();
            }));
            return _this;
        }
        SelectionHighlighter.prototype.getId = function () {
            return SelectionHighlighter_1.ID;
        };
        SelectionHighlighter.prototype.removeDecorations = function () {
            this.lastWordUnderCursor = null;
            if (this.decorations.length > 0) {
                this.decorations = this.editor.deltaDecorations(this.decorations, []);
            }
        };
        SelectionHighlighter.prototype._update = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            this.lastWordUnderCursor = null;
            if (!this.editor.getConfiguration().contribInfo.selectionHighlight) {
                return;
            }
            var r = multiCursorFind(this.editor, /*changeFindSearchString*/ false, /*allowMultiline*/ false);
            if (!r) {
                this.removeDecorations();
                return;
            }
            var hasFindOccurences = modes_1.DocumentHighlightProviderRegistry.has(model);
            if (r.currentMatch) {
                // This is an empty selection
                if (hasFindOccurences) {
                    // Do not interfere with semantic word highlighting in the no selection case
                    this.removeDecorations();
                    return;
                }
                this.lastWordUnderCursor = r.currentMatch;
            }
            if (/^[ \t]+$/.test(r.searchText)) {
                // whitespace only selection
                this.removeDecorations();
                return;
            }
            if (r.searchText.length > 200) {
                // very long selection
                this.removeDecorations();
                return;
            }
            var selections = this.editor.getSelections();
            var firstSelectedText = model.getValueInRange(selections[0]);
            for (var i = 1; i < selections.length; i++) {
                var selectedText = model.getValueInRange(selections[i]);
                if (firstSelectedText !== selectedText) {
                    // not all selections have the same text
                    this.removeDecorations();
                    return;
                }
            }
            var allMatches = model.findMatches(r.searchText, true, false, r.matchCase, r.wholeWord, false).map(function (m) { return m.range; });
            allMatches.sort(range_1.Range.compareRangesUsingStarts);
            selections.sort(range_1.Range.compareRangesUsingStarts);
            // do not overlap with selection (issue #64 and #512)
            var matches = [];
            for (var i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {
                var match = allMatches[i];
                if (j >= lenJ) {
                    // finished all editor selections
                    matches.push(match);
                    i++;
                }
                else {
                    var cmp = range_1.Range.compareRangesUsingStarts(match, selections[j]);
                    if (cmp < 0) {
                        // match is before sel
                        matches.push(match);
                        i++;
                    }
                    else if (cmp > 0) {
                        // sel is before match
                        j++;
                    }
                    else {
                        // sel is equal to match
                        i++;
                        j++;
                    }
                }
            }
            var decorations = matches.map(function (r) {
                return {
                    range: r,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: 'selectionHighlight',
                        // Show in overviewRuler only if model has no semantic highlighting
                        overviewRuler: (hasFindOccurences ? undefined : {
                            color: '#A0A0A0',
                            darkColor: '#A0A0A0',
                            position: editorCommon.OverviewRulerLane.Center
                        })
                    }
                };
            });
            this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
        };
        SelectionHighlighter.prototype.dispose = function () {
            this.removeDecorations();
            _super.prototype.dispose.call(this);
        };
        return SelectionHighlighter;
    }(lifecycle_1.Disposable));
    SelectionHighlighter.ID = 'editor.contrib.selectionHighlighter';
    SelectionHighlighter = SelectionHighlighter_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution
    ], SelectionHighlighter);
    exports.SelectionHighlighter = SelectionHighlighter;
    var FindCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(CommonFindController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.CloseFindWidgetCommand,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.closeFindWidget(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ToggleCaseSensitiveCommand,
        precondition: null,
        handler: function (x) { return x.toggleCaseSensitive(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: findModel_1.ToggleCaseSensitiveKeybinding.primary,
            mac: findModel_1.ToggleCaseSensitiveKeybinding.mac,
            win: findModel_1.ToggleCaseSensitiveKeybinding.win,
            linux: findModel_1.ToggleCaseSensitiveKeybinding.linux
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ToggleWholeWordCommand,
        precondition: null,
        handler: function (x) { return x.toggleWholeWords(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: findModel_1.ToggleWholeWordKeybinding.primary,
            mac: findModel_1.ToggleWholeWordKeybinding.mac,
            win: findModel_1.ToggleWholeWordKeybinding.win,
            linux: findModel_1.ToggleWholeWordKeybinding.linux
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ToggleRegexCommand,
        precondition: null,
        handler: function (x) { return x.toggleRegex(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: findModel_1.ToggleRegexKeybinding.primary,
            mac: findModel_1.ToggleRegexKeybinding.mac,
            win: findModel_1.ToggleRegexKeybinding.win,
            linux: findModel_1.ToggleRegexKeybinding.linux
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ReplaceOneAction,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.replace(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 22 /* KEY_1 */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ReplaceAllAction,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.replaceAll(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 3 /* Enter */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.SelectAllMatchesAction,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.selectAllMatches(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: EditorContextKeys.Focus,
            primary: 512 /* Alt */ | 3 /* Enter */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ShowPreviousFindTermAction,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.showPreviousFindTerm(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: contextkey_1.ContextKeyExpr.and(exports.CONTEXT_FIND_INPUT_FOCUSSED, EditorContextKeys.Focus),
            primary: findModel_1.ShowPreviousFindTermKeybinding.primary,
            mac: findModel_1.ShowPreviousFindTermKeybinding.mac,
            win: findModel_1.ShowPreviousFindTermKeybinding.win,
            linux: findModel_1.ShowPreviousFindTermKeybinding.linux
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new FindCommand({
        id: findModel_1.FIND_IDS.ShowNextFindTermAction,
        precondition: exports.CONTEXT_FIND_WIDGET_VISIBLE,
        handler: function (x) { return x.showNextFindTerm(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5),
            kbExpr: contextkey_1.ContextKeyExpr.and(exports.CONTEXT_FIND_INPUT_FOCUSSED, EditorContextKeys.Focus),
            primary: findModel_1.ShowNextFindTermKeybinding.primary,
            mac: findModel_1.ShowNextFindTermKeybinding.mac,
            win: findModel_1.ShowNextFindTermKeybinding.win,
            linux: findModel_1.ShowNextFindTermKeybinding.linux
        }
    }));
    var SelectionHighlighter_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[451/*vs/editor/contrib/find/browser/findWidget*/], __M([1/*require*/,0/*exports*/,284/*vs/nls!vs/editor/contrib/find/browser/findWidget*/,10/*vs/base/common/errors*/,9/*vs/base/common/strings*/,11/*vs/base/browser/dom*/,251/*vs/base/browser/ui/findinput/findInput*/,100/*vs/base/browser/ui/inputbox/inputBox*/,40/*vs/base/browser/ui/widget*/,21/*vs/editor/browser/editorBrowser*/,137/*vs/editor/contrib/find/common/findModel*/,4/*vs/editor/common/core/range*/,162/*vs/editor/contrib/find/common/findController*/,363/*vs/css!vs/editor/contrib/find/browser/findWidget*/]), function (require, exports, nls, errors_1, strings, dom, findInput_1, inputBox_1, widget_1, editorBrowser_1, findModel_1, range_1, findController_1) {
    'use strict';
    var NLS_FIND_INPUT_LABEL = nls.localize(0, null);
    var NLS_FIND_INPUT_PLACEHOLDER = nls.localize(1, null);
    var NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize(2, null);
    var NLS_NEXT_MATCH_BTN_LABEL = nls.localize(3, null);
    var NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize(4, null);
    var NLS_CLOSE_BTN_LABEL = nls.localize(5, null);
    var NLS_REPLACE_INPUT_LABEL = nls.localize(6, null);
    var NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize(7, null);
    var NLS_REPLACE_BTN_LABEL = nls.localize(8, null);
    var NLS_REPLACE_ALL_BTN_LABEL = nls.localize(9, null);
    var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize(10, null);
    var NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize(11, null);
    var NLS_MATCHES_LOCATION = nls.localize(12, null);
    var NLS_NO_RESULTS = nls.localize(13, null);
    var MAX_MATCHES_COUNT_WIDTH = 69;
    var WIDGET_FIXED_WIDTH = 411 - 69;
    var FindWidget = (function (_super) {
        __extends(FindWidget, _super);
        function FindWidget(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService) {
            var _this = _super.call(this) || this;
            _this._codeEditor = codeEditor;
            _this._controller = controller;
            _this._state = state;
            _this._contextViewProvider = contextViewProvider;
            _this._keybindingService = keybindingService;
            _this._isVisible = false;
            _this._isReplaceVisible = false;
            _this._register(_this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            _this._buildDomNode();
            _this._updateButtons();
            var checkEditorWidth = function () {
                var editorWidth = _this._codeEditor.getConfiguration().layoutInfo.width;
                var collapsedFindWidget = false;
                var reducedFindWidget = false;
                var narrowFindWidget = false;
                if (WIDGET_FIXED_WIDTH + 28 >= editorWidth + 50) {
                    collapsedFindWidget = true;
                }
                if (WIDGET_FIXED_WIDTH + 28 >= editorWidth) {
                    narrowFindWidget = true;
                }
                if (WIDGET_FIXED_WIDTH + MAX_MATCHES_COUNT_WIDTH + 28 >= editorWidth) {
                    reducedFindWidget = true;
                }
                dom.toggleClass(_this._domNode, 'collapsed-find-widget', collapsedFindWidget);
                dom.toggleClass(_this._domNode, 'reduced-find-widget', reducedFindWidget);
                dom.toggleClass(_this._domNode, 'narrow-find-widget', narrowFindWidget);
            };
            checkEditorWidth();
            _this._register(_this._codeEditor.onDidChangeConfiguration(function (e) {
                if (e.readOnly) {
                    if (_this._codeEditor.getConfiguration().readOnly) {
                        // Hide replace part if editor becomes read only
                        _this._state.change({ isReplaceRevealed: false }, false);
                    }
                    _this._updateButtons();
                }
                if (e.layoutInfo) {
                    checkEditorWidth();
                }
            }));
            _this._register(_this._codeEditor.onDidChangeCursorSelection(function () {
                if (_this._isVisible) {
                    _this._updateToggleSelectionFindButton();
                }
            }));
            _this._findInputFocussed = findController_1.CONTEXT_FIND_INPUT_FOCUSSED.bindTo(contextKeyService);
            _this._focusTracker = _this._register(dom.trackFocus(_this._findInput.inputBox.inputElement));
            _this._focusTracker.addFocusListener(function () {
                _this._findInputFocussed.set(true);
                if (_this._toggleSelectionFind.checked) {
                    var selection = _this._codeEditor.getSelection();
                    if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                        selection = selection.setEndPosition(selection.endLineNumber - 1, 1);
                    }
                    var currentMatch = _this._state.currentMatch;
                    if (selection.startLineNumber !== selection.endLineNumber) {
                        if (!range_1.Range.equalsRange(selection, currentMatch)) {
                            // Reseed find scope
                            _this._state.change({ searchScope: selection }, true);
                        }
                    }
                }
            });
            _this._focusTracker.addBlurListener(function () {
                _this._findInputFocussed.set(false);
            });
            _this._codeEditor.addOverlayWidget(_this);
            return _this;
        }
        // ----- IOverlayWidget API
        FindWidget.prototype.getId = function () {
            return FindWidget.ID;
        };
        FindWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        FindWidget.prototype.getPosition = function () {
            if (this._isVisible) {
                return {
                    preference: editorBrowser_1.OverlayWidgetPositionPreference.TOP_RIGHT_CORNER
                };
            }
            return null;
        };
        // ----- React to state changes
        FindWidget.prototype._onStateChanged = function (e) {
            if (e.searchString) {
                this._findInput.setValue(this._state.searchString);
                this._updateButtons();
            }
            if (e.replaceString) {
                this._replaceInputBox.value = this._state.replaceString;
            }
            if (e.isRevealed) {
                if (this._state.isRevealed) {
                    this._reveal(true);
                }
                else {
                    this._hide(true);
                }
            }
            if (e.isReplaceRevealed) {
                if (this._state.isReplaceRevealed) {
                    if (!this._codeEditor.getConfiguration().readOnly && !this._isReplaceVisible) {
                        this._isReplaceVisible = true;
                        this._updateButtons();
                    }
                }
                else {
                    if (this._isReplaceVisible) {
                        this._isReplaceVisible = false;
                        this._updateButtons();
                    }
                }
            }
            if (e.isRegex) {
                this._findInput.setRegex(this._state.isRegex);
            }
            if (e.wholeWord) {
                this._findInput.setWholeWords(this._state.wholeWord);
            }
            if (e.matchCase) {
                this._findInput.setCaseSensitive(this._state.matchCase);
            }
            if (e.searchScope) {
                if (this._state.searchScope) {
                    this._toggleSelectionFind.checked = true;
                }
                else {
                    this._toggleSelectionFind.checked = false;
                }
                this._updateToggleSelectionFindButton();
            }
            if (e.searchString || e.matchesCount || e.matchesPosition) {
                var showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);
                dom.toggleClass(this._domNode, 'no-results', showRedOutline);
                this._updateMatchesCount();
            }
        };
        FindWidget.prototype._updateMatchesCount = function () {
            this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + 'px';
            if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {
                this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
            }
            else {
                this._matchesCount.title = '';
            }
            // remove previous content
            if (this._matchesCount.firstChild) {
                this._matchesCount.removeChild(this._matchesCount.firstChild);
            }
            var label;
            if (this._state.matchesCount > 0) {
                var matchesCount = String(this._state.matchesCount);
                if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {
                    matchesCount += '+';
                }
                var matchesPosition = String(this._state.matchesPosition);
                if (matchesPosition === '0') {
                    matchesPosition = '?';
                }
                label = strings.format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
            }
            else {
                label = NLS_NO_RESULTS;
            }
            this._matchesCount.appendChild(document.createTextNode(label));
            MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
        };
        // ----- actions
        /**
         * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
         * If 'selection find' is OFF we enable the button only if there is a multi line selection.
         */
        FindWidget.prototype._updateToggleSelectionFindButton = function () {
            var selection = this._codeEditor.getSelection();
            var isMultiLineSelection = selection ? (selection.startLineNumber !== selection.endLineNumber) : false;
            var isChecked = this._toggleSelectionFind.checked;
            this._toggleSelectionFind.setEnabled(this._isVisible && (isChecked || isMultiLineSelection));
        };
        FindWidget.prototype._updateButtons = function () {
            this._findInput.setEnabled(this._isVisible);
            this._replaceInputBox.setEnabled(this._isVisible && this._isReplaceVisible);
            this._updateToggleSelectionFindButton();
            this._closeBtn.setEnabled(this._isVisible);
            var findInputIsNonEmpty = (this._state.searchString.length > 0);
            this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
            this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
            this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
            this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
            dom.toggleClass(this._domNode, 'replaceToggled', this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
            var canReplace = !this._codeEditor.getConfiguration().readOnly;
            this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
        };
        FindWidget.prototype._reveal = function (animate) {
            var _this = this;
            if (!this._isVisible) {
                this._isVisible = true;
                this._updateButtons();
                setTimeout(function () {
                    dom.addClass(_this._domNode, 'visible');
                    if (!animate) {
                        dom.addClass(_this._domNode, 'noanimation');
                        setTimeout(function () {
                            dom.removeClass(_this._domNode, 'noanimation');
                        }, 200);
                    }
                }, 0);
                this._codeEditor.layoutOverlayWidget(this);
            }
        };
        FindWidget.prototype._hide = function (focusTheEditor) {
            if (this._isVisible) {
                this._isVisible = false;
                this._updateButtons();
                dom.removeClass(this._domNode, 'visible');
                if (focusTheEditor) {
                    this._codeEditor.focus();
                }
                this._codeEditor.layoutOverlayWidget(this);
            }
        };
        // ----- Public
        FindWidget.prototype.focusFindInput = function () {
            this._findInput.select();
            // Edge browser requires focus() in addition to select()
            this._findInput.focus();
        };
        FindWidget.prototype.focusReplaceInput = function () {
            this._replaceInputBox.select();
            // Edge browser requires focus() in addition to select()
            this._replaceInputBox.focus();
        };
        FindWidget.prototype._onFindInputKeyDown = function (e) {
            switch (e.toKeybinding().value) {
                case 3 /* Enter */:
                    this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                    e.preventDefault();
                    return;
                case 1024 /* Shift */ | 3 /* Enter */:
                    this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                    e.preventDefault();
                    return;
                case 2 /* Tab */:
                    if (this._isReplaceVisible) {
                        this._replaceInputBox.focus();
                    }
                    else {
                        this._findInput.focusOnCaseSensitive();
                    }
                    e.preventDefault();
                    return;
                case 2048 /* CtrlCmd */ | 18 /* DownArrow */:
                    this._codeEditor.focus();
                    e.preventDefault();
                    return;
            }
        };
        FindWidget.prototype._onReplaceInputKeyDown = function (e) {
            switch (e.toKeybinding().value) {
                case 3 /* Enter */:
                    this._controller.replace();
                    e.preventDefault();
                    return;
                case 2048 /* CtrlCmd */ | 3 /* Enter */:
                    this._controller.replaceAll();
                    e.preventDefault();
                    return;
                case 2 /* Tab */:
                    this._findInput.focusOnCaseSensitive();
                    e.preventDefault();
                    return;
                case 1024 /* Shift */ | 2 /* Tab */:
                    this._findInput.focus();
                    e.preventDefault();
                    return;
                case 2048 /* CtrlCmd */ | 18 /* DownArrow */:
                    this._codeEditor.focus();
                    e.preventDefault();
                    return;
            }
        };
        // ----- initialization
        FindWidget.prototype._keybindingLabelFor = function (actionId) {
            var keybindings = this._keybindingService.lookupKeybindings(actionId);
            if (keybindings.length === 0) {
                return '';
            }
            return ' (' + this._keybindingService.getLabelFor(keybindings[0]) + ')';
        };
        FindWidget.prototype._buildFindPart = function () {
            var _this = this;
            // Find input
            this._findInput = this._register(new findInput_1.FindInput(null, this._contextViewProvider, {
                width: FindWidget.FIND_INPUT_AREA_WIDTH,
                label: NLS_FIND_INPUT_LABEL,
                placeholder: NLS_FIND_INPUT_PLACEHOLDER,
                appendCaseSensitiveLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleCaseSensitiveCommand),
                appendWholeWordsLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleWholeWordCommand),
                appendRegexLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleRegexCommand),
                validation: function (value) {
                    if (value.length === 0) {
                        return null;
                    }
                    if (!_this._findInput.getRegex()) {
                        return null;
                    }
                    try {
                        /* tslint:disable:no-unused-expression */
                        new RegExp(value);
                        /* tslint:enable:no-unused-expression */
                        return null;
                    }
                    catch (e) {
                        return { content: e.message };
                    }
                }
            }));
            this._register(this._findInput.onKeyDown(function (e) { return _this._onFindInputKeyDown(e); }));
            this._register(this._findInput.onInput(function () {
                _this._state.change({ searchString: _this._findInput.getValue() }, true);
            }));
            this._register(this._findInput.onDidOptionChange(function () {
                _this._state.change({
                    isRegex: _this._findInput.getRegex(),
                    wholeWord: _this._findInput.getWholeWords(),
                    matchCase: _this._findInput.getCaseSensitive()
                }, true);
            }));
            this._register(this._findInput.onCaseSensitiveKeyDown(function (e) {
                if (e.equals(1024 /* Shift */ | 2 /* Tab */)) {
                    if (_this._isReplaceVisible) {
                        _this._replaceInputBox.focus();
                        e.preventDefault();
                    }
                }
            }));
            this._matchesCount = document.createElement('div');
            this._matchesCount.className = 'matchesCount';
            this._updateMatchesCount();
            // Previous button
            this._prevBtn = this._register(new SimpleButton({
                label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.PreviousMatchFindAction),
                className: 'previous',
                onTrigger: function () {
                    _this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                },
                onKeyDown: function (e) { }
            }));
            // Next button
            this._nextBtn = this._register(new SimpleButton({
                label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.NextMatchFindAction),
                className: 'next',
                onTrigger: function () {
                    _this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                },
                onKeyDown: function (e) { }
            }));
            var findPart = document.createElement('div');
            findPart.className = 'find-part';
            findPart.appendChild(this._findInput.domNode);
            findPart.appendChild(this._matchesCount);
            findPart.appendChild(this._prevBtn.domNode);
            findPart.appendChild(this._nextBtn.domNode);
            // Toggle selection button
            this._toggleSelectionFind = this._register(new SimpleCheckbox({
                parent: findPart,
                title: NLS_TOGGLE_SELECTION_FIND_TITLE,
                onChange: function () {
                    if (_this._toggleSelectionFind.checked) {
                        var selection = _this._codeEditor.getSelection();
                        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
                            selection = selection.setEndPosition(selection.endLineNumber - 1, 1);
                        }
                        if (!selection.isEmpty()) {
                            _this._state.change({ searchScope: selection }, true);
                        }
                    }
                    else {
                        _this._state.change({ searchScope: null }, true);
                    }
                }
            }));
            // Close button
            this._closeBtn = this._register(new SimpleButton({
                label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.CloseFindWidgetCommand),
                className: 'close-fw',
                onTrigger: function () {
                    _this._state.change({ isRevealed: false }, false);
                },
                onKeyDown: function (e) {
                    if (e.equals(2 /* Tab */)) {
                        if (_this._isReplaceVisible) {
                            if (_this._replaceBtn.isEnabled()) {
                                _this._replaceBtn.focus();
                            }
                            else {
                                _this._codeEditor.focus();
                            }
                            e.preventDefault();
                        }
                    }
                }
            }));
            findPart.appendChild(this._closeBtn.domNode);
            return findPart;
        };
        FindWidget.prototype._buildReplacePart = function () {
            var _this = this;
            // Replace input
            var replaceInput = document.createElement('div');
            replaceInput.className = 'replace-input';
            replaceInput.style.width = FindWidget.REPLACE_INPUT_AREA_WIDTH + 'px';
            this._replaceInputBox = this._register(new inputBox_1.InputBox(replaceInput, null, {
                ariaLabel: NLS_REPLACE_INPUT_LABEL,
                placeholder: NLS_REPLACE_INPUT_PLACEHOLDER
            }));
            this._register(dom.addStandardDisposableListener(this._replaceInputBox.inputElement, 'keydown', function (e) { return _this._onReplaceInputKeyDown(e); }));
            this._register(dom.addStandardDisposableListener(this._replaceInputBox.inputElement, 'input', function (e) {
                _this._state.change({ replaceString: _this._replaceInputBox.value }, false);
            }));
            // Replace one button
            this._replaceBtn = this._register(new SimpleButton({
                label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceOneAction),
                className: 'replace',
                onTrigger: function () {
                    _this._controller.replace();
                },
                onKeyDown: function (e) {
                    if (e.equals(1024 /* Shift */ | 2 /* Tab */)) {
                        _this._closeBtn.focus();
                        e.preventDefault();
                    }
                }
            }));
            // Replace all button
            this._replaceAllBtn = this._register(new SimpleButton({
                label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceAllAction),
                className: 'replace-all',
                onTrigger: function () {
                    _this._controller.replaceAll();
                },
                onKeyDown: function (e) { }
            }));
            var replacePart = document.createElement('div');
            replacePart.className = 'replace-part';
            replacePart.appendChild(replaceInput);
            replacePart.appendChild(this._replaceBtn.domNode);
            replacePart.appendChild(this._replaceAllBtn.domNode);
            return replacePart;
        };
        FindWidget.prototype._buildDomNode = function () {
            var _this = this;
            // Find part
            var findPart = this._buildFindPart();
            // Replace part
            var replacePart = this._buildReplacePart();
            // Toggle replace button
            this._toggleReplaceBtn = this._register(new SimpleButton({
                label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
                className: 'toggle left',
                onTrigger: function () {
                    _this._state.change({ isReplaceRevealed: !_this._isReplaceVisible }, false);
                },
                onKeyDown: function (e) { }
            }));
            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
            // Widget
            this._domNode = document.createElement('div');
            this._domNode.className = 'editor-widget find-widget';
            this._domNode.setAttribute('aria-hidden', 'false');
            this._domNode.appendChild(this._toggleReplaceBtn.domNode);
            this._domNode.appendChild(findPart);
            this._domNode.appendChild(replacePart);
        };
        return FindWidget;
    }(widget_1.Widget));
    FindWidget.ID = 'editor.contrib.findWidget';
    FindWidget.PART_WIDTH = 275;
    FindWidget.FIND_INPUT_AREA_WIDTH = FindWidget.PART_WIDTH - 54;
    FindWidget.REPLACE_INPUT_AREA_WIDTH = FindWidget.FIND_INPUT_AREA_WIDTH;
    exports.FindWidget = FindWidget;
    var SimpleCheckbox = (function (_super) {
        __extends(SimpleCheckbox, _super);
        function SimpleCheckbox(opts) {
            var _this = _super.call(this) || this;
            _this._opts = opts;
            _this._domNode = document.createElement('div');
            _this._domNode.className = 'monaco-checkbox';
            _this._domNode.title = _this._opts.title;
            _this._checkbox = document.createElement('input');
            _this._checkbox.type = 'checkbox';
            _this._checkbox.className = 'checkbox';
            _this._checkbox.id = 'checkbox-' + SimpleCheckbox._COUNTER++;
            _this._label = document.createElement('label');
            _this._label.className = 'label';
            // Connect the label and the checkbox. Checkbox will get checked when the label recieves a click.
            _this._label.htmlFor = _this._checkbox.id;
            _this._domNode.appendChild(_this._checkbox);
            _this._domNode.appendChild(_this._label);
            _this._opts.parent.appendChild(_this._domNode);
            _this.onchange(_this._checkbox, function (e) {
                _this._opts.onChange();
            });
            return _this;
        }
        Object.defineProperty(SimpleCheckbox.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleCheckbox.prototype, "checked", {
            get: function () {
                return this._checkbox.checked;
            },
            set: function (newValue) {
                this._checkbox.checked = newValue;
            },
            enumerable: true,
            configurable: true
        });
        SimpleCheckbox.prototype.focus = function () {
            this._checkbox.focus();
        };
        SimpleCheckbox.prototype.enable = function () {
            this._checkbox.removeAttribute('disabled');
        };
        SimpleCheckbox.prototype.disable = function () {
            this._checkbox.disabled = true;
        };
        SimpleCheckbox.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        return SimpleCheckbox;
    }(widget_1.Widget));
    SimpleCheckbox._COUNTER = 0;
    var SimpleButton = (function (_super) {
        __extends(SimpleButton, _super);
        function SimpleButton(opts) {
            var _this = _super.call(this) || this;
            _this._opts = opts;
            _this._domNode = document.createElement('div');
            _this._domNode.title = _this._opts.label;
            _this._domNode.tabIndex = 0;
            _this._domNode.className = 'button ' + _this._opts.className;
            _this._domNode.setAttribute('role', 'button');
            _this._domNode.setAttribute('aria-label', _this._opts.label);
            _this.onclick(_this._domNode, function (e) {
                _this._opts.onTrigger();
                e.preventDefault();
            });
            _this.onkeydown(_this._domNode, function (e) {
                if (e.equals(10 /* Space */) || e.equals(3 /* Enter */)) {
                    _this._opts.onTrigger();
                    e.preventDefault();
                    return;
                }
                _this._opts.onKeyDown(e);
            });
            return _this;
        }
        Object.defineProperty(SimpleButton.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        SimpleButton.prototype.isEnabled = function () {
            return (this._domNode.tabIndex >= 0);
        };
        SimpleButton.prototype.focus = function () {
            this._domNode.focus();
        };
        SimpleButton.prototype.setEnabled = function (enabled) {
            dom.toggleClass(this._domNode, 'disabled', !enabled);
            this._domNode.setAttribute('aria-disabled', String(!enabled));
            this._domNode.tabIndex = enabled ? 0 : -1;
        };
        SimpleButton.prototype.setExpanded = function (expanded) {
            this._domNode.setAttribute('aria-expanded', String(expanded));
        };
        SimpleButton.prototype.toggleClass = function (className, shouldHaveIt) {
            dom.toggleClass(this._domNode, className, shouldHaveIt);
        };
        return SimpleButton;
    }(widget_1.Widget));
});















define(__m[452/*vs/editor/contrib/find/browser/find*/], __M([1/*require*/,0/*exports*/,58/*vs/platform/contextview/browser/contextView*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,26/*vs/editor/browser/editorBrowserExtensions*/,451/*vs/editor/contrib/find/browser/findWidget*/,162/*vs/editor/contrib/find/common/findController*/]), function (require, exports, contextView_1, keybinding_1, contextkey_1, editorBrowserExtensions_1, findWidget_1, findController_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindController = (function (_super) {
        __extends(FindController, _super);
        function FindController(editor, contextViewService, contextKeyService, keybindingService) {
            var _this = _super.call(this, editor, contextKeyService) || this;
            _this._widget = _this._register(new findWidget_1.FindWidget(editor, _this, _this._state, contextViewService, keybindingService, contextKeyService));
            return _this;
        }
        FindController.prototype._start = function (opts) {
            _super.prototype._start.call(this, opts);
            if (opts.shouldFocus === 2 /* FocusReplaceInput */) {
                this._widget.focusReplaceInput();
            }
            else if (opts.shouldFocus === 1 /* FocusFindInput */) {
                this._widget.focusFindInput();
            }
        };
        return FindController;
    }(findController_1.CommonFindController));
    FindController = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, contextView_1.IContextViewService),
        __param(2, contextkey_1.IContextKeyService),
        __param(3, keybinding_1.IKeybindingService)
    ], FindController);
    exports.FindController = FindController;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/// <amd-dependency path="vs/css!./folding" />











define(__m[453/*vs/editor/contrib/folding/browser/folding*/], __M([1/*require*/,0/*exports*/,286/*vs/nls!vs/editor/contrib/folding/browser/folding*/,24/*vs/base/common/types*/,17/*vs/base/common/async*/,32/*vs/base/common/keyCodes*/,3/*vs/base/common/lifecycle*/,2/*vs/editor/common/editorCommon*/,4/*vs/editor/common/core/range*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,398/*vs/editor/contrib/folding/common/foldingModel*/,223/*vs/editor/contrib/folding/common/indentFoldStrategy*/,222/*vs/editor/contrib/folding/common/folding*/,365/*vs/css!vs/editor/contrib/folding/browser/folding*/]), function (require, exports, nls, types, async_1, keyCodes_1, lifecycle_1, editorCommon, range_1, editorCommonExtensions_1, editorBrowserExtensions_1, foldingModel_1, indentFoldStrategy_1, folding_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var FoldingController = FoldingController_1 = (function () {
        function FoldingController(editor) {
            var _this = this;
            this.editor = editor;
            this._isEnabled = this.editor.getConfiguration().contribInfo.folding;
            this.globalToDispose = [];
            this.localToDispose = [];
            this.decorations = [];
            this.computeToken = 0;
            this.globalToDispose.push(this.editor.onDidChangeModel(function () { return _this.onModelChanged(); }));
            this.globalToDispose.push(this.editor.onDidChangeConfiguration(function (e) {
                var oldIsEnabled = _this._isEnabled;
                _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;
                if (oldIsEnabled !== _this._isEnabled) {
                    _this.onModelChanged();
                }
            }));
            this.onModelChanged();
        }
        FoldingController.get = function (editor) {
            return editor.getContribution(folding_1.ID);
        };
        FoldingController.prototype.getId = function () {
            return folding_1.ID;
        };
        FoldingController.prototype.dispose = function () {
            this.cleanState();
            this.globalToDispose = lifecycle_1.dispose(this.globalToDispose);
        };
        /**
         * Store view state.
         */
        FoldingController.prototype.saveViewState = function () {
            var model = this.editor.getModel();
            if (!model) {
                return {};
            }
            var collapsedRegions = [];
            this.decorations.forEach(function (d) {
                if (d.isCollapsed) {
                    var range = d.getDecorationRange(model);
                    if (range) {
                        collapsedRegions.push({ startLineNumber: range.startLineNumber, endLineNumber: range.endLineNumber, indent: d.indent, isCollapsed: true });
                    }
                }
            });
            return { collapsedRegions: collapsedRegions, lineCount: model.getLineCount() };
        };
        /**
         * Restore view state.
         */
        FoldingController.prototype.restoreViewState = function (state) {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            if (!this._isEnabled) {
                return;
            }
            if (!state || !Array.isArray(state.collapsedRegions) || state.collapsedRegions.length === 0 || state.lineCount !== model.getLineCount()) {
                return;
            }
            // State should be applied on the clean state
            // Clean the state
            this.cleanState();
            // apply state
            this.applyRegions(state.collapsedRegions);
            // Start listening to the model
            this.onModelChanged();
        };
        FoldingController.prototype.cleanState = function () {
            this.localToDispose = lifecycle_1.dispose(this.localToDispose);
        };
        FoldingController.prototype.applyRegions = function (regions) {
            var _this = this;
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var updateHiddenRegions = false;
            regions = indentFoldStrategy_1.limitByIndent(regions, FoldingController_1.MAX_FOLDING_REGIONS).sort(function (r1, r2) { return r1.startLineNumber - r2.startLineNumber; });
            this.editor.changeDecorations(function (changeAccessor) {
                var newDecorations = [];
                var k = 0, i = 0;
                while (i < _this.decorations.length && k < regions.length) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                        dec.dispose(changeAccessor);
                        i++;
                    }
                    else {
                        while (k < regions.length && decRange.startLineNumber > regions[k].startLineNumber) {
                            var region = regions[k];
                            updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                            newDecorations.push(new foldingModel_1.CollapsibleRegion(region, model, changeAccessor));
                            k++;
                        }
                        if (k < regions.length) {
                            var currRange = regions[k];
                            if (decRange.startLineNumber < currRange.startLineNumber) {
                                updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                                dec.dispose(changeAccessor);
                                i++;
                            }
                            else if (decRange.startLineNumber === currRange.startLineNumber) {
                                if (dec.isCollapsed && (dec.startLineNumber !== currRange.startLineNumber || dec.endLineNumber !== currRange.endLineNumber)) {
                                    updateHiddenRegions = true;
                                }
                                currRange.isCollapsed = dec.isCollapsed; // preserve collapse state
                                dec.update(currRange, model, changeAccessor);
                                newDecorations.push(dec);
                                i++;
                                k++;
                            }
                        }
                    }
                }
                while (i < _this.decorations.length) {
                    var dec = _this.decorations[i];
                    updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                    dec.dispose(changeAccessor);
                    i++;
                }
                while (k < regions.length) {
                    var region = regions[k];
                    updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                    newDecorations.push(new foldingModel_1.CollapsibleRegion(region, model, changeAccessor));
                    k++;
                }
                _this.decorations = newDecorations;
            });
            if (updateHiddenRegions) {
                this.updateHiddenAreas();
            }
        };
        FoldingController.prototype.onModelChanged = function () {
            var _this = this;
            this.cleanState();
            var model = this.editor.getModel();
            if (!this._isEnabled || !model) {
                return;
            }
            this.computeAndApplyCollapsibleRegions();
            this.contentChangedScheduler = new async_1.RunOnceScheduler(function () { return _this.computeAndApplyCollapsibleRegions(); }, 200);
            this.cursorChangedScheduler = new async_1.RunOnceScheduler(function () { return _this.revealCursor(); }, 200);
            this.localToDispose.push(this.contentChangedScheduler);
            this.localToDispose.push(this.cursorChangedScheduler);
            this.localToDispose.push(this.editor.onDidChangeModelContent(function (e) { return _this.contentChangedScheduler.schedule(); }));
            this.localToDispose.push(this.editor.onDidChangeCursorPosition(function (e) { return _this.cursorChangedScheduler.schedule(); }));
            this.localToDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
            this.localToDispose.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.localToDispose.push({ dispose: function () { return _this.disposeDecorations(); } });
        };
        FoldingController.prototype.computeAndApplyCollapsibleRegions = function () {
            var model = this.editor.getModel();
            this.applyRegions(model ? indentFoldStrategy_1.computeRanges(model) : []);
        };
        FoldingController.prototype.disposeDecorations = function () {
            var _this = this;
            this.editor.changeDecorations(function (changeAccessor) {
                _this.decorations.forEach(function (dec) { return dec.dispose(changeAccessor); });
            });
            this.decorations = [];
            this.editor.setHiddenAreas([]);
        };
        FoldingController.prototype.revealCursor = function () {
            var _this = this;
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var hasChanges = false;
            var selections = this.editor.getSelections();
            this.editor.changeDecorations(function (changeAccessor) {
                return _this.decorations.forEach(function (dec) {
                    if (dec.isCollapsed) {
                        var decRange = dec.getDecorationRange(model);
                        if (decRange) {
                            for (var _i = 0, selections_1 = selections; _i < selections_1.length; _i++) {
                                var selection = selections_1[_i];
                                // reveal if cursor in in one of the collapsed line (not the first)
                                if (decRange.startLineNumber < selection.selectionStartLineNumber && selection.selectionStartLineNumber <= decRange.endLineNumber) {
                                    dec.setCollapsed(false, changeAccessor);
                                    hasChanges = true;
                                    break;
                                }
                            }
                        }
                    }
                });
            });
            if (hasChanges) {
                this.updateHiddenAreas(this.editor.getPosition().lineNumber);
            }
        };
        FoldingController.prototype.onEditorMouseDown = function (e) {
            this.mouseDownInfo = null;
            if (this.decorations.length === 0) {
                return;
            }
            var range = e.target.range;
            if (!range || !range.isEmpty) {
                return;
            }
            if (!e.event.leftButton) {
                return;
            }
            var model = this.editor.getModel();
            var iconClicked = false;
            switch (e.target.type) {
                case editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS:
                    iconClicked = true;
                    break;
                case editorCommon.MouseTargetType.CONTENT_TEXT:
                    if (range.isEmpty && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
                        break;
                    }
                    return;
                default:
                    return;
            }
            this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked: iconClicked };
        };
        FoldingController.prototype.onEditorMouseUp = function (e) {
            var _this = this;
            if (!this.mouseDownInfo) {
                return;
            }
            var lineNumber = this.mouseDownInfo.lineNumber;
            var iconClicked = this.mouseDownInfo.iconClicked;
            var range = e.target.range;
            if (!range || !range.isEmpty || range.startLineNumber !== lineNumber) {
                return;
            }
            var model = this.editor.getModel();
            if (iconClicked) {
                if (e.target.type !== editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS) {
                    return;
                }
            }
            else {
                if (range.startColumn !== model.getLineMaxColumn(lineNumber)) {
                    return;
                }
            }
            this.editor.changeDecorations(function (changeAccessor) {
                for (var i = 0; i < _this.decorations.length; i++) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (decRange && decRange.startLineNumber === lineNumber) {
                        if (iconClicked || dec.isCollapsed) {
                            dec.setCollapsed(!dec.isCollapsed, changeAccessor);
                            _this.updateHiddenAreas(lineNumber);
                        }
                        return;
                    }
                }
            });
        };
        FoldingController.prototype.updateHiddenAreas = function (focusLine) {
            var model = this.editor.getModel();
            var selections = this.editor.getSelections();
            var updateSelections = false;
            var hiddenAreas = [];
            this.decorations.filter(function (dec) { return dec.isCollapsed; }).forEach(function (dec) {
                var decRange = dec.getDecorationRange(model);
                if (!decRange) {
                    return;
                }
                hiddenAreas.push({
                    startLineNumber: decRange.startLineNumber + 1,
                    startColumn: 1,
                    endLineNumber: decRange.endLineNumber,
                    endColumn: 1
                });
                selections.forEach(function (selection, i) {
                    if (range_1.Range.containsPosition(decRange, selection.getStartPosition())) {
                        selections[i] = selection = selection.setStartPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                        updateSelections = true;
                    }
                    if (range_1.Range.containsPosition(decRange, selection.getEndPosition())) {
                        selections[i] = selection.setEndPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                        updateSelections = true;
                    }
                });
            });
            if (updateSelections) {
                this.editor.setSelections(selections);
            }
            this.editor.setHiddenAreas(hiddenAreas);
            if (focusLine) {
                this.editor.revealPositionInCenterIfOutsideViewport({ lineNumber: focusLine, column: 1 });
            }
        };
        FoldingController.prototype.unfold = function (levels) {
            var _this = this;
            var model = this.editor.getModel();
            var hasChanges = false;
            var selections = this.editor.getSelections();
            var selectionsHasChanged = false;
            selections.forEach(function (selection, index) {
                var toUnfold = foldingModel_1.getCollapsibleRegionsToUnfoldAtLine(_this.decorations, model, selection.startLineNumber, levels);
                if (toUnfold.length > 0) {
                    toUnfold.forEach(function (collapsibleRegion, index) {
                        _this.editor.changeDecorations(function (changeAccessor) {
                            collapsibleRegion.setCollapsed(false, changeAccessor);
                            hasChanges = true;
                        });
                    });
                    if (!foldingModel_1.doesLineBelongsToCollapsibleRegion(toUnfold[0].foldingRange, selection.startLineNumber)) {
                        var lineNumber = toUnfold[0].startLineNumber, column = model.getLineMaxColumn(toUnfold[0].startLineNumber);
                        selections[index] = selection.setEndPosition(lineNumber, column).setStartPosition(lineNumber, column);
                        selectionsHasChanged = true;
                    }
                }
            });
            if (selectionsHasChanged) {
                this.editor.setSelections(selections);
            }
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.fold = function (levels, up) {
            var _this = this;
            var hasChanges = false;
            var selections = this.editor.getSelections();
            selections.forEach(function (selection) {
                var lineNumber = selection.startLineNumber;
                var toFold = foldingModel_1.getCollapsibleRegionsToFoldAtLine(_this.decorations, _this.editor.getModel(), lineNumber, levels, up);
                toFold.forEach(function (collapsibleRegion) { return _this.editor.changeDecorations(function (changeAccessor) {
                    collapsibleRegion.setCollapsed(true, changeAccessor);
                    hasChanges = true;
                }); });
            });
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.foldUnfoldRecursively = function (isFold) {
            var _this = this;
            var hasChanges = false;
            var model = this.editor.getModel();
            var selections = this.editor.getSelections();
            selections.forEach(function (selection) {
                var lineNumber = selection.startLineNumber;
                var endLineNumber;
                var decToFoldUnfold = [];
                for (var i = 0, len = _this.decorations.length; i < len; i++) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        continue;
                    }
                    if (decRange.startLineNumber >= lineNumber && (decRange.endLineNumber <= endLineNumber || typeof endLineNumber === 'undefined')) {
                        //Protect against cursor not being in decoration and lower decoration folding/unfolding
                        if (decRange.startLineNumber !== lineNumber && typeof endLineNumber === 'undefined') {
                            return;
                        }
                        endLineNumber = endLineNumber || decRange.endLineNumber;
                        decToFoldUnfold.push(dec);
                    }
                }
                ;
                if (decToFoldUnfold.length > 0) {
                    decToFoldUnfold.forEach(function (dec) {
                        _this.editor.changeDecorations(function (changeAccessor) {
                            dec.setCollapsed(isFold, changeAccessor);
                            hasChanges = true;
                        });
                    });
                }
            });
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.foldAll = function () {
            this.changeAll(true);
        };
        FoldingController.prototype.unfoldAll = function () {
            this.changeAll(false);
        };
        FoldingController.prototype.changeAll = function (collapse) {
            var _this = this;
            if (this.decorations.length > 0) {
                var hasChanges_1 = true;
                this.editor.changeDecorations(function (changeAccessor) {
                    _this.decorations.forEach(function (d) {
                        if (collapse !== d.isCollapsed) {
                            d.setCollapsed(collapse, changeAccessor);
                            hasChanges_1 = true;
                        }
                    });
                });
                if (hasChanges_1) {
                    this.updateHiddenAreas(this.editor.getPosition().lineNumber);
                }
            }
        };
        FoldingController.prototype.foldLevel = function (foldLevel, selectedLineNumbers) {
            var _this = this;
            var model = this.editor.getModel();
            var foldingRegionStack = [model.getFullModelRange()]; // sentinel
            var hasChanges = false;
            this.editor.changeDecorations(function (changeAccessor) {
                _this.decorations.forEach(function (dec) {
                    var decRange = dec.getDecorationRange(model);
                    if (decRange) {
                        while (!range_1.Range.containsRange(foldingRegionStack[foldingRegionStack.length - 1], decRange)) {
                            foldingRegionStack.pop();
                        }
                        foldingRegionStack.push(decRange);
                        if (foldingRegionStack.length === foldLevel + 1 && !dec.isCollapsed && !selectedLineNumbers.some(function (lineNumber) { return decRange.startLineNumber < lineNumber && lineNumber <= decRange.endLineNumber; })) {
                            dec.setCollapsed(true, changeAccessor);
                            hasChanges = true;
                        }
                    }
                });
            });
            if (hasChanges) {
                this.updateHiddenAreas(selectedLineNumbers[0]);
            }
        };
        return FoldingController;
    }());
    FoldingController.MAX_FOLDING_REGIONS = 5000;
    FoldingController = FoldingController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution
    ], FoldingController);
    exports.FoldingController = FoldingController;
    var FoldingAction = (function (_super) {
        __extends(FoldingAction, _super);
        function FoldingAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FoldingAction.prototype.runEditorCommand = function (accessor, editor, args) {
            var foldingController = FoldingController.get(editor);
            if (!foldingController) {
                return;
            }
            this.reportTelemetry(accessor);
            this.invoke(foldingController, editor, args);
        };
        FoldingAction.prototype.run = function (accessor, editor) {
        };
        return FoldingAction;
    }(editorCommonExtensions_1.EditorAction));
    function foldingArgumentsConstraint(args) {
        if (!types.isUndefined(args)) {
            if (!types.isObject(args)) {
                return false;
            }
            var foldingArgs = args;
            if (!types.isUndefined(foldingArgs.levels) && !types.isNumber(foldingArgs.levels)) {
                return false;
            }
            if (!types.isUndefined(foldingArgs.direction) && !types.isString(foldingArgs.direction)) {
                return false;
            }
        }
        return true;
    }
    var UnfoldAction = (function (_super) {
        __extends(UnfoldAction, _super);
        function UnfoldAction() {
            return _super.call(this, {
                id: 'editor.unfold',
                label: nls.localize(0, null),
                alias: 'Unfold',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 89 /* US_CLOSE_SQUARE_BRACKET */,
                    mac: {
                        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 89 /* US_CLOSE_SQUARE_BRACKET */
                    }
                },
                description: {
                    description: 'Unfold the content in the editor',
                    args: [
                        {
                            name: 'Unfold editor argument',
                            description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'level': Number of levels to unfold\n\t\t\t\t\t\t",
                            constraint: foldingArgumentsConstraint
                        }
                    ]
                }
            }) || this;
        }
        UnfoldAction.prototype.invoke = function (foldingController, editor, args) {
            foldingController.unfold(args ? args.levels || 1 : 1);
        };
        return UnfoldAction;
    }(FoldingAction));
    UnfoldAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnfoldAction);
    var UnFoldRecursivelyAction = (function (_super) {
        __extends(UnFoldRecursivelyAction, _super);
        function UnFoldRecursivelyAction() {
            return _super.call(this, {
                id: 'editor.unfoldRecursively',
                label: nls.localize(1, null),
                alias: 'Unfold Recursively',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 89 /* US_CLOSE_SQUARE_BRACKET */)
                }
            }) || this;
        }
        UnFoldRecursivelyAction.prototype.invoke = function (foldingController, editor, args) {
            foldingController.foldUnfoldRecursively(false);
        };
        return UnFoldRecursivelyAction;
    }(FoldingAction));
    UnFoldRecursivelyAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnFoldRecursivelyAction);
    var FoldAction = (function (_super) {
        __extends(FoldAction, _super);
        function FoldAction() {
            return _super.call(this, {
                id: 'editor.fold',
                label: nls.localize(2, null),
                alias: 'Fold',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 87 /* US_OPEN_SQUARE_BRACKET */,
                    mac: {
                        primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 87 /* US_OPEN_SQUARE_BRACKET */
                    }
                },
                description: {
                    description: 'Fold the content in the editor',
                    args: [
                        {
                            name: 'Fold editor argument',
                            description: "Property-value pairs that can be passed through this argument:\n\t\t\t\t\t\t\t* 'levels': Number of levels to fold\n\t\t\t\t\t\t\t* 'up': If 'true' folds given number of levels up otherwise folds down\n\t\t\t\t\t\t",
                            constraint: foldingArgumentsConstraint
                        }
                    ]
                }
            }) || this;
        }
        FoldAction.prototype.invoke = function (foldingController, editor, args) {
            args = args ? args : { levels: 1, direction: 'up' };
            foldingController.fold(args.levels || 1, args.direction === 'up');
        };
        return FoldAction;
    }(FoldingAction));
    FoldAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldAction);
    var FoldRecursivelyAction = (function (_super) {
        __extends(FoldRecursivelyAction, _super);
        function FoldRecursivelyAction() {
            return _super.call(this, {
                id: 'editor.foldRecursively',
                label: nls.localize(3, null),
                alias: 'Fold Recursively',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 87 /* US_OPEN_SQUARE_BRACKET */)
                }
            }) || this;
        }
        FoldRecursivelyAction.prototype.invoke = function (foldingController, editor) {
            foldingController.foldUnfoldRecursively(true);
        };
        return FoldRecursivelyAction;
    }(FoldingAction));
    FoldRecursivelyAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldRecursivelyAction);
    var FoldAllAction = (function (_super) {
        __extends(FoldAllAction, _super);
        function FoldAllAction() {
            return _super.call(this, {
                id: 'editor.foldAll',
                label: nls.localize(4, null),
                alias: 'Fold All',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 21 /* KEY_0 */)
                }
            }) || this;
        }
        FoldAllAction.prototype.invoke = function (foldingController, editor) {
            foldingController.foldAll();
        };
        return FoldAllAction;
    }(FoldingAction));
    FoldAllAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FoldAllAction);
    var UnfoldAllAction = (function (_super) {
        __extends(UnfoldAllAction, _super);
        function UnfoldAllAction() {
            return _super.call(this, {
                id: 'editor.unfoldAll',
                label: nls.localize(5, null),
                alias: 'Unfold All',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 40 /* KEY_J */)
                }
            }) || this;
        }
        UnfoldAllAction.prototype.invoke = function (foldingController, editor) {
            foldingController.unfoldAll();
        };
        return UnfoldAllAction;
    }(FoldingAction));
    UnfoldAllAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UnfoldAllAction);
    var FoldLevelAction = (function (_super) {
        __extends(FoldLevelAction, _super);
        function FoldLevelAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        FoldLevelAction.prototype.getFoldingLevel = function () {
            return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
        };
        FoldLevelAction.prototype.getSelectedLines = function (editor) {
            return editor.getSelections().map(function (s) { return s.startLineNumber; });
        };
        FoldLevelAction.prototype.invoke = function (foldingController, editor) {
            foldingController.foldLevel(this.getFoldingLevel(), this.getSelectedLines(editor));
        };
        return FoldLevelAction;
    }(FoldingAction));
    FoldLevelAction.ID_PREFIX = 'editor.foldLevel';
    FoldLevelAction.ID = function (level) { return FoldLevelAction.ID_PREFIX + level; };
    for (var i = 1; i <= 9; i++) {
        editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new FoldLevelAction({
            id: FoldLevelAction.ID(i),
            label: nls.localize(6, null, i),
            alias: "Fold Level " + i,
            precondition: null,
            kbOpts: {
                kbExpr: EditorContextKeys.TextFocus,
                primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | (21 /* KEY_0 */ + i))
            }
        }));
    }
    ;
    var FoldingController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[454/*vs/editor/contrib/format/common/format*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,28/*vs/base/common/arrays*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,43/*vs/editor/common/services/modelService*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, uri_1, arrays_1, winjs_base_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getDocumentRangeFormattingEdits(model, range, options) {
        var providers = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model);
        if (providers.length === 0) {
            return winjs_base_1.TPromise.as(undefined);
        }
        var result;
        return async_1.sequence(providers.map(function (provider) {
            if (arrays_1.isFalsyOrEmpty(result)) {
                return function () {
                    return async_1.asWinJsPromise(function (token) { return provider.provideDocumentRangeFormattingEdits(model, range, options, token); }).then(function (value) {
                        result = value;
                    }, errors_1.onUnexpectedExternalError);
                };
            }
        })).then(function () { return result; });
    }
    exports.getDocumentRangeFormattingEdits = getDocumentRangeFormattingEdits;
    function getDocumentFormattingEdits(model, options) {
        var providers = modes_1.DocumentFormattingEditProviderRegistry.ordered(model);
        // try range formatters when no document formatter is registered
        if (providers.length === 0) {
            return getDocumentRangeFormattingEdits(model, model.getFullModelRange(), options);
        }
        var result;
        return async_1.sequence(providers.map(function (provider) {
            if (arrays_1.isFalsyOrEmpty(result)) {
                return function () {
                    return async_1.asWinJsPromise(function (token) { return provider.provideDocumentFormattingEdits(model, options, token); }).then(function (value) {
                        result = value;
                    }, errors_1.onUnexpectedExternalError);
                };
            }
        })).then(function () { return result; });
    }
    exports.getDocumentFormattingEdits = getDocumentFormattingEdits;
    function getOnTypeFormattingEdits(model, position, ch, options) {
        var support = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        if (support.autoFormatTriggerCharacters.indexOf(ch) < 0) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return async_1.asWinJsPromise(function (token) {
            return support.provideOnTypeFormattingEdits(model, position, ch, options, token);
        }).then(function (r) { return r; }, errors_1.onUnexpectedExternalError);
    }
    exports.getOnTypeFormattingEdits = getOnTypeFormattingEdits;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {
        var resource = args.resource, range = args.range, options = args.options;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentRangeFormattingEdits(model, range_1.Range.lift(range), options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {
        var resource = args.resource, options = args.options;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentFormattingEdits(model, options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeFormatOnTypeProvider', function (model, position, args) {
        var ch = args.ch, options = args.options;
        if (typeof ch !== 'string') {
            throw errors_1.illegalArgument('ch');
        }
        return getOnTypeFormattingEdits(model, position, ch, options);
    });
});















define(__m[455/*vs/editor/contrib/format/common/formatActions*/], __M([1/*require*/,0/*exports*/,287/*vs/nls!vs/editor/contrib/format/common/formatActions*/,28/*vs/base/common/arrays*/,32/*vs/base/common/keyCodes*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,2/*vs/editor/common/editorCommon*/,18/*vs/platform/contextkey/common/contextkey*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,454/*vs/editor/contrib/format/common/format*/,224/*vs/editor/contrib/format/common/formatCommand*/,22/*vs/platform/commands/common/commands*/,45/*vs/editor/common/services/codeEditorService*/,52/*vs/editor/common/services/editorWorkerService*/,65/*vs/editor/common/core/characterClassifier*/]), function (require, exports, nls, arrays_1, keyCodes_1, lifecycle_1, winjs_base_1, editorCommon, contextkey_1, editorCommonExtensions_1, modes_1, format_1, formatCommand_1, commands_1, codeEditorService_1, editorWorkerService_1, characterClassifier_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModeContextKeys = editorCommon.ModeContextKeys;
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var FormatOnType = FormatOnType_1 = (function () {
        function FormatOnType(editor, workerService) {
            var _this = this;
            this.editor = editor;
            this.workerService = workerService;
            this.callOnDispose = [];
            this.callOnModel = [];
            this.callOnDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModelLanguage(function () { return _this.update(); }));
            this.callOnDispose.push(modes_1.OnTypeFormattingEditProviderRegistry.onDidChange(this.update, this));
        }
        FormatOnType.prototype.update = function () {
            var _this = this;
            // clean up
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
            // we are disabled
            if (!this.editor.getConfiguration().contribInfo.formatOnType) {
                return;
            }
            // no model
            if (!this.editor.getModel()) {
                return;
            }
            var model = this.editor.getModel();
            // no support
            var support = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model)[0];
            if (!support || !support.autoFormatTriggerCharacters) {
                return;
            }
            // register typing listeners that will trigger the format
            var triggerChars = new characterClassifier_1.CharacterSet();
            for (var _i = 0, _a = support.autoFormatTriggerCharacters; _i < _a.length; _i++) {
                var ch = _a[_i];
                triggerChars.add(ch.charCodeAt(0));
            }
            this.callOnModel.push(this.editor.onDidType(function (text) {
                var lastCharCode = text.charCodeAt(text.length - 1);
                if (triggerChars.has(lastCharCode)) {
                    _this.trigger(String.fromCharCode(lastCharCode));
                }
            }));
        };
        FormatOnType.prototype.trigger = function (ch) {
            var _this = this;
            if (this.editor.getSelections().length > 1) {
                return;
            }
            var model = this.editor.getModel(), position = this.editor.getPosition(), canceled = false;
            // install a listener that checks if edits happens before the
            // position on which we format right now. If so, we won't
            // apply the format edits
            var unbind = this.editor.onDidChangeModelRawContent(function (e) {
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    canceled = true;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLineChanged) {
                    var changedLine = e.lineNumber;
                    canceled = changedLine <= position.lineNumber;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesInserted) {
                    var insertLine = e.fromLineNumber;
                    canceled = insertLine <= position.lineNumber;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesDeleted) {
                    var deleteLine2 = e.toLineNumber;
                    canceled = deleteLine2 <= position.lineNumber;
                }
                if (canceled) {
                    // cancel only once
                    unbind.dispose();
                }
            });
            var modelOpts = model.getOptions();
            format_1.getOnTypeFormattingEdits(model, position, ch, {
                tabSize: modelOpts.tabSize,
                insertSpaces: modelOpts.insertSpaces
            }).then(function (edits) {
                return _this.workerService.computeMoreMinimalEdits(model.uri, edits, []);
            }).then(function (edits) {
                unbind.dispose();
                if (canceled || arrays_1.isFalsyOrEmpty(edits)) {
                    return;
                }
                _this.editor.executeCommand(_this.getId(), new formatCommand_1.EditOperationsCommand(edits, _this.editor.getSelection()));
            }, function (err) {
                unbind.dispose();
                throw err;
            });
        };
        FormatOnType.prototype.getId = function () {
            return FormatOnType_1.ID;
        };
        FormatOnType.prototype.dispose = function () {
            this.callOnDispose = lifecycle_1.dispose(this.callOnDispose);
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
        };
        return FormatOnType;
    }());
    FormatOnType.ID = 'editor.contrib.autoFormat';
    FormatOnType = FormatOnType_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, editorWorkerService_1.IEditorWorkerService)
    ], FormatOnType);
    var AbstractFormatAction = (function (_super) {
        __extends(AbstractFormatAction, _super);
        function AbstractFormatAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbstractFormatAction.prototype.run = function (accessor, editor) {
            var _this = this;
            var workerService = accessor.get(editorWorkerService_1.IEditorWorkerService);
            var formattingPromise = this._getFormattingEdits(editor);
            if (!formattingPromise) {
                return winjs_base_1.TPromise.as(void 0);
            }
            // Capture the state of the editor
            var state = editor.captureState(editorCommon.CodeEditorStateFlag.Value, editorCommon.CodeEditorStateFlag.Position);
            // Receive formatted value from worker
            return formattingPromise.then(function (edits) { return workerService.computeMoreMinimalEdits(editor.getModel().uri, edits, editor.getSelections()); }).then(function (edits) {
                if (!state.validate(editor) || arrays_1.isFalsyOrEmpty(edits)) {
                    return;
                }
                var command = new formatCommand_1.EditOperationsCommand(edits, editor.getSelection());
                editor.executeCommand(_this.id, command);
                editor.focus();
            });
        };
        return AbstractFormatAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.AbstractFormatAction = AbstractFormatAction;
    var FormatDocumentAction = (function (_super) {
        __extends(FormatDocumentAction, _super);
        function FormatDocumentAction() {
            return _super.call(this, {
                id: 'editor.action.formatDocument',
                label: nls.localize(0, null),
                alias: 'Format Document',
                precondition: contextkey_1.ContextKeyExpr.and(EditorContextKeys.Writable, ModeContextKeys.hasDocumentFormattingProvider),
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 36 /* KEY_F */,
                    // secondary: [KeyChord(KeyMod.CtrlCmd | KeyCode.KEY_K, KeyMod.CtrlCmd | KeyCode.KEY_D)],
                    linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 39 /* KEY_I */ }
                },
                menuOpts: {
                    group: '1_modification',
                    order: 1.3
                }
            }) || this;
        }
        FormatDocumentAction.prototype._getFormattingEdits = function (editor) {
            var model = editor.getModel();
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            return format_1.getDocumentFormattingEdits(model, { tabSize: tabSize, insertSpaces: insertSpaces });
        };
        return FormatDocumentAction;
    }(AbstractFormatAction));
    FormatDocumentAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FormatDocumentAction);
    exports.FormatDocumentAction = FormatDocumentAction;
    var FormatSelectionAction = (function (_super) {
        __extends(FormatSelectionAction, _super);
        function FormatSelectionAction() {
            return _super.call(this, {
                id: 'editor.action.formatSelection',
                label: nls.localize(1, null),
                alias: 'Format Code',
                precondition: contextkey_1.ContextKeyExpr.and(EditorContextKeys.Writable, ModeContextKeys.hasDocumentSelectionFormattingProvider, EditorContextKeys.HasNonEmptySelection),
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 36 /* KEY_F */)
                },
                menuOpts: {
                    group: '1_modification',
                    order: 1.31
                }
            }) || this;
        }
        FormatSelectionAction.prototype._getFormattingEdits = function (editor) {
            var model = editor.getModel();
            var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
            return format_1.getDocumentRangeFormattingEdits(model, editor.getSelection(), { tabSize: tabSize, insertSpaces: insertSpaces });
        };
        return FormatSelectionAction;
    }(AbstractFormatAction));
    FormatSelectionAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], FormatSelectionAction);
    exports.FormatSelectionAction = FormatSelectionAction;
    // this is the old format action that does both (format document OR format selection)
    // and we keep it here such that existing keybinding configurations etc will still work
    commands_1.CommandsRegistry.registerCommand('editor.action.format', function (accessor) {
        var editor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (editor) {
            return new (function (_super) {
                __extends(class_1, _super);
                function class_1() {
                    return _super.call(this, {}) || this;
                }
                class_1.prototype._getFormattingEdits = function (editor) {
                    var model = editor.getModel();
                    var editorSelection = editor.getSelection();
                    var _a = model.getOptions(), tabSize = _a.tabSize, insertSpaces = _a.insertSpaces;
                    return editorSelection.isEmpty()
                        ? format_1.getDocumentFormattingEdits(model, { tabSize: tabSize, insertSpaces: insertSpaces })
                        : format_1.getDocumentRangeFormattingEdits(model, editorSelection, { tabSize: tabSize, insertSpaces: insertSpaces });
                };
                return class_1;
            }(AbstractFormatAction))().run(accessor, editor);
        }
    });
    var FormatOnType_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[456/*vs/editor/contrib/goToDeclaration/common/goToDeclaration*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function outputResults(promises) {
        return winjs_base_1.TPromise.join(promises).then(function (allReferences) {
            var result = [];
            for (var _i = 0, allReferences_1 = allReferences; _i < allReferences_1.length; _i++) {
                var references = allReferences_1[_i];
                if (Array.isArray(references)) {
                    result.push.apply(result, references);
                }
                else if (references) {
                    result.push(references);
                }
            }
            return result;
        });
    }
    function getDeclarationsAtPosition(model, position) {
        var provider = modes_1.DefinitionProviderRegistry.ordered(model);
        // get results
        var promises = provider.map(function (provider, idx) {
            return async_1.asWinJsPromise(function (token) {
                return provider.provideDefinition(model, position, token);
            }).then(function (result) {
                return result;
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return outputResults(promises);
    }
    exports.getDeclarationsAtPosition = getDeclarationsAtPosition;
    function getTypeDefinitionAtPosition(model, position) {
        var provider = modes_1.TypeDefinitionProviderRegistry.ordered(model);
        // get results
        var promises = provider.map(function (provider, idx) {
            return async_1.asWinJsPromise(function (token) {
                return provider.provideTypeDefinition(model, position, token);
            }).then(function (result) {
                return result;
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return outputResults(promises);
    }
    exports.getTypeDefinitionAtPosition = getTypeDefinitionAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDefinitionProvider', getDeclarationsAtPosition);
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeTypeDefinitionProvider', getTypeDefinitionAtPosition);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[457/*vs/editor/contrib/gotoError/browser/gotoError*/], __M([1/*require*/,0/*exports*/,289/*vs/nls!vs/editor/contrib/gotoError/browser/gotoError*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,30/*vs/base/common/severity*/,11/*vs/base/browser/dom*/,22/*vs/platform/commands/common/commands*/,18/*vs/platform/contextkey/common/contextkey*/,72/*vs/platform/markers/common/markers*/,53/*vs/platform/telemetry/common/telemetry*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,160/*vs/editor/contrib/zoneWidget/browser/zoneWidget*/,368/*vs/css!vs/editor/contrib/gotoError/browser/gotoError*/]), function (require, exports, nls, event_1, lifecycle_1, severity_1, dom, commands_1, contextkey_1, markers_1, telemetry_1, position_1, range_1, editorCommon, editorCommonExtensions_1, editorBrowserExtensions_1, zoneWidget_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var MarkerModel = (function () {
        function MarkerModel(editor, markers) {
            var _this = this;
            this._editor = editor;
            this._markers = null;
            this._nextIdx = -1;
            this._toUnbind = [];
            this._ignoreSelectionChange = false;
            this._onCurrentMarkerChanged = new event_1.Emitter();
            this._onMarkerSetChanged = new event_1.Emitter();
            this.setMarkers(markers);
            // listen on editor
            this._toUnbind.push(this._editor.onDidDispose(function () { return _this.dispose(); }));
            this._toUnbind.push(this._editor.onDidChangeCursorPosition(function () {
                if (!_this._ignoreSelectionChange) {
                    _this._nextIdx = -1;
                }
            }));
        }
        Object.defineProperty(MarkerModel.prototype, "onCurrentMarkerChanged", {
            get: function () {
                return this._onCurrentMarkerChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MarkerModel.prototype, "onMarkerSetChanged", {
            get: function () {
                return this._onMarkerSetChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        MarkerModel.prototype.setMarkers = function (markers) {
            // assign
            this._markers = markers || [];
            // sort markers
            this._markers.sort(function (left, right) { return severity_1.default.compare(left.severity, right.severity) || range_1.Range.compareRangesUsingStarts(left, right); });
            this._nextIdx = -1;
            this._onMarkerSetChanged.fire(this);
        };
        MarkerModel.prototype.withoutWatchingEditorPosition = function (callback) {
            this._ignoreSelectionChange = true;
            try {
                callback();
            }
            finally {
                this._ignoreSelectionChange = false;
            }
        };
        MarkerModel.prototype._initIdx = function (fwd) {
            var found = false;
            var position = this._editor.getPosition();
            for (var i = 0; i < this._markers.length; i++) {
                if (range_1.Range.containsPosition(this._markers[i], position)) {
                    this._nextIdx = i + (fwd ? 0 : -1);
                    found = true;
                    break;
                }
            }
            if (!found) {
                // after the last change
                this._nextIdx = fwd ? 0 : this._markers.length - 1;
            }
            if (this._nextIdx < 0) {
                this._nextIdx = this._markers.length - 1;
            }
        };
        MarkerModel.prototype.move = function (fwd) {
            if (!this.canNavigate()) {
                this._onCurrentMarkerChanged.fire(undefined);
                return;
            }
            if (this._nextIdx === -1) {
                this._initIdx(fwd);
            }
            else if (fwd) {
                this._nextIdx += 1;
                if (this._nextIdx >= this._markers.length) {
                    this._nextIdx = 0;
                }
            }
            else {
                this._nextIdx -= 1;
                if (this._nextIdx < 0) {
                    this._nextIdx = this._markers.length - 1;
                }
            }
            var marker = this._markers[this._nextIdx];
            this._onCurrentMarkerChanged.fire(marker);
        };
        MarkerModel.prototype.canNavigate = function () {
            return this._markers.length > 0;
        };
        MarkerModel.prototype.next = function () {
            this.move(true);
        };
        MarkerModel.prototype.previous = function () {
            this.move(false);
        };
        MarkerModel.prototype.findMarkerAtPosition = function (pos) {
            for (var _i = 0, _a = this._markers; _i < _a.length; _i++) {
                var marker = _a[_i];
                if (range_1.Range.containsPosition(marker, pos)) {
                    return marker;
                }
            }
        };
        Object.defineProperty(MarkerModel.prototype, "total", {
            get: function () {
                return this._markers.length;
            },
            enumerable: true,
            configurable: true
        });
        MarkerModel.prototype.indexOf = function (marker) {
            return 1 + this._markers.indexOf(marker);
        };
        MarkerModel.prototype.reveal = function () {
            var _this = this;
            if (this._nextIdx === -1) {
                return;
            }
            this.withoutWatchingEditorPosition(function () {
                var pos = new position_1.Position(_this._markers[_this._nextIdx].startLineNumber, _this._markers[_this._nextIdx].startColumn);
                _this._editor.setPosition(pos);
                _this._editor.revealPositionInCenter(pos);
            });
        };
        MarkerModel.prototype.dispose = function () {
            this._toUnbind = lifecycle_1.dispose(this._toUnbind);
        };
        return MarkerModel;
    }());
    var MessageWidget = (function () {
        function MessageWidget(container) {
            this.lines = 0;
            this.domNode = document.createElement('div');
            this.domNode.className = 'block descriptioncontainer';
            this.domNode.setAttribute('aria-live', 'assertive');
            this.domNode.setAttribute('role', 'alert');
            container.appendChild(this.domNode);
        }
        MessageWidget.prototype.update = function (_a) {
            var _this = this;
            var source = _a.source, message = _a.message;
            this.lines = 1;
            if (source) {
                var indent_1 = new Array(source.length + 3 + 1).join(' ');
                message = "[" + source + "] " + message.replace(/\r\n|\r|\n/g, function () {
                    _this.lines += 1;
                    return '\n' + indent_1;
                });
            }
            this.domNode.innerText = message;
        };
        return MessageWidget;
    }());
    var MarkerNavigationWidget = (function (_super) {
        __extends(MarkerNavigationWidget, _super);
        function MarkerNavigationWidget(editor, _model, _commandService) {
            var _this = _super.call(this, editor, { showArrow: true, showFrame: true, isAccessible: true }) || this;
            _this._model = _model;
            _this._commandService = _commandService;
            _this._callOnDispose = [];
            _this.create();
            _this._wireModelAndView();
            return _this;
        }
        MarkerNavigationWidget.prototype.dispose = function () {
            this._callOnDispose = lifecycle_1.dispose(this._callOnDispose);
            _super.prototype.dispose.call(this);
        };
        MarkerNavigationWidget.prototype.focus = function () {
            this._parentContainer.focus();
        };
        MarkerNavigationWidget.prototype._fillContainer = function (container) {
            this._parentContainer = container;
            dom.addClass(container, 'marker-widget');
            this._parentContainer.tabIndex = 0;
            this._parentContainer.setAttribute('role', 'tooltip');
            this._container = document.createElement('div');
            container.appendChild(this._container);
            this._title = document.createElement('div');
            this._title.className = 'block title';
            this._container.appendChild(this._title);
            this._message = new MessageWidget(this._container);
            this.editor.applyFontInfo(this._message.domNode);
        };
        MarkerNavigationWidget.prototype.show = function (where, heightInLines) {
            _super.prototype.show.call(this, where, heightInLines);
            this.focus();
        };
        MarkerNavigationWidget.prototype._wireModelAndView = function () {
            // listen to events
            this._model.onCurrentMarkerChanged(this.showAtMarker, this, this._callOnDispose);
            this._model.onMarkerSetChanged(this._onMarkersChanged, this, this._callOnDispose);
        };
        MarkerNavigationWidget.prototype.showAtMarker = function (marker) {
            var _this = this;
            if (!marker) {
                return;
            }
            // update:
            // * title
            // * message
            this._container.classList.remove('stale');
            this._title.innerHTML = nls.localize(0, null, this._model.indexOf(marker), this._model.total);
            this._message.update(marker);
            this._model.withoutWatchingEditorPosition(function () {
                // update frame color (only applied on 'show')
                switch (marker.severity) {
                    case severity_1.default.Error:
                        _this.options.frameColor = '#ff5a5a';
                        break;
                    case severity_1.default.Warning:
                    case severity_1.default.Info:
                        _this.options.frameColor = '#5aac5a';
                        break;
                }
                _this.show({
                    lineNumber: marker.startLineNumber,
                    column: marker.startColumn
                }, _this.computeRequiredHeight());
            });
        };
        MarkerNavigationWidget.prototype._onMarkersChanged = function () {
            var marker = this._model.findMarkerAtPosition(this.position);
            if (marker) {
                this._container.classList.remove('stale');
                this._message.update(marker);
            }
            else {
                this._container.classList.add('stale');
            }
            this._relayout();
        };
        MarkerNavigationWidget.prototype._relayout = function () {
            _super.prototype._relayout.call(this, this.computeRequiredHeight());
        };
        MarkerNavigationWidget.prototype.computeRequiredHeight = function () {
            return 1 + this._message.lines;
        };
        return MarkerNavigationWidget;
    }(zoneWidget_1.ZoneWidget));
    var MarkerNavigationAction = (function (_super) {
        __extends(MarkerNavigationAction, _super);
        function MarkerNavigationAction(next, opts) {
            var _this = _super.call(this, opts) || this;
            _this._isNext = next;
            return _this;
        }
        MarkerNavigationAction.prototype.run = function (accessor, editor) {
            var telemetryService = accessor.get(telemetry_1.ITelemetryService);
            var controller = MarkerController.get(editor);
            if (!controller) {
                return;
            }
            var model = controller.getOrCreateModel();
            telemetryService.publicLog('zoneWidgetShown', { mode: 'go to error' });
            if (model) {
                if (this._isNext) {
                    model.next();
                }
                else {
                    model.previous();
                }
                model.reveal();
            }
        };
        return MarkerNavigationAction;
    }(editorCommonExtensions_1.EditorAction));
    var MarkerController = MarkerController_1 = (function () {
        function MarkerController(editor, _markerService, _contextKeyService, _commandService) {
            this._markerService = _markerService;
            this._contextKeyService = _contextKeyService;
            this._commandService = _commandService;
            this._callOnClose = [];
            this._editor = editor;
            this._markersNavigationVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
        }
        MarkerController.get = function (editor) {
            return editor.getContribution(MarkerController_1.ID);
        };
        MarkerController.prototype.getId = function () {
            return MarkerController_1.ID;
        };
        MarkerController.prototype.dispose = function () {
            this._cleanUp();
        };
        MarkerController.prototype._cleanUp = function () {
            this._markersNavigationVisible.reset();
            this._callOnClose = lifecycle_1.dispose(this._callOnClose);
            this._zone = null;
            this._model = null;
        };
        MarkerController.prototype.getOrCreateModel = function () {
            var _this = this;
            if (this._model) {
                return this._model;
            }
            var markers = this._getMarkers();
            this._model = new MarkerModel(this._editor, markers);
            this._zone = new MarkerNavigationWidget(this._editor, this._model, this._commandService);
            this._markersNavigationVisible.set(true);
            this._callOnClose.push(this._model);
            this._callOnClose.push(this._zone);
            this._callOnClose.push(this._editor.onDidChangeModel(function () { return _this._cleanUp(); }));
            this._model.onCurrentMarkerChanged(function (marker) { return !marker && _this._cleanUp(); }, undefined, this._callOnClose);
            this._markerService.onMarkerChanged(this._onMarkerChanged, this, this._callOnClose);
            return this._model;
        };
        MarkerController.prototype.closeMarkersNavigation = function () {
            this._cleanUp();
            this._editor.focus();
        };
        MarkerController.prototype._onMarkerChanged = function (changedResources) {
            var _this = this;
            if (!changedResources.some(function (r) { return _this._editor.getModel().uri.toString() === r.toString(); })) {
                return;
            }
            this._model.setMarkers(this._getMarkers());
        };
        MarkerController.prototype._getMarkers = function () {
            return this._markerService.read({ resource: this._editor.getModel().uri });
        };
        return MarkerController;
    }());
    MarkerController.ID = 'editor.contrib.markerController';
    MarkerController = MarkerController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, markers_1.IMarkerService),
        __param(2, contextkey_1.IContextKeyService),
        __param(3, commands_1.ICommandService)
    ], MarkerController);
    var NextMarkerAction = (function (_super) {
        __extends(NextMarkerAction, _super);
        function NextMarkerAction() {
            return _super.call(this, true, {
                id: 'editor.action.marker.next',
                label: nls.localize(1, null),
                alias: 'Go to Next Error or Warning',
                precondition: EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 66 /* F8 */
                }
            }) || this;
        }
        return NextMarkerAction;
    }(MarkerNavigationAction));
    NextMarkerAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], NextMarkerAction);
    var PrevMarkerAction = (function (_super) {
        __extends(PrevMarkerAction, _super);
        function PrevMarkerAction() {
            return _super.call(this, false, {
                id: 'editor.action.marker.prev',
                label: nls.localize(2, null),
                alias: 'Go to Previous Error or Warning',
                precondition: EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 1024 /* Shift */ | 66 /* F8 */
                }
            }) || this;
        }
        return PrevMarkerAction;
    }(MarkerNavigationAction));
    PrevMarkerAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], PrevMarkerAction);
    var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new contextkey_1.RawContextKey('markersNavigationVisible', false);
    var MarkerCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(MarkerController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new MarkerCommand({
        id: 'closeMarkersNavigation',
        precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
        handler: function (x) { return x.closeMarkersNavigation(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50),
            kbExpr: EditorContextKeys.Focus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    var MarkerController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[458/*vs/editor/contrib/hover/common/hover*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,10/*vs/base/common/errors*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/]), function (require, exports, arrays_1, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function getHover(model, position) {
        var supports = modes_1.HoverProviderRegistry.ordered(model);
        var values = [];
        var promises = supports.map(function (support, idx) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideHover(model, position, token);
            }).then(function (result) {
                if (result) {
                    var hasRange = (typeof result.range !== 'undefined');
                    var hasHtmlContent = (typeof result.contents !== 'undefined' && result.contents && result.contents.length > 0);
                    if (hasRange && hasHtmlContent) {
                        values[idx] = result;
                    }
                }
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return arrays_1.coalesce(values); });
    }
    exports.getHover = getHover;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeHoverProvider', getHover);
});






define(__m[459/*vs/editor/contrib/hover/browser/modesContentHover*/], __M([1/*require*/,0/*exports*/,291/*vs/nls!vs/editor/contrib/hover/browser/modesContentHover*/,27/*vs/base/common/uri*/,10/*vs/base/common/errors*/,11/*vs/base/browser/dom*/,6/*vs/base/common/winjs.base*/,103/*vs/base/browser/htmlContentRenderer*/,71/*vs/platform/opener/common/opener*/,4/*vs/editor/common/core/range*/,16/*vs/editor/common/core/position*/,15/*vs/editor/common/modes*/,133/*vs/editor/common/modes/textToHtmlTokenizer*/,458/*vs/editor/contrib/hover/common/hover*/,153/*vs/editor/contrib/hover/browser/hoverOperation*/,154/*vs/editor/contrib/hover/browser/hoverWidgets*/,109/*vs/base/common/htmlContent*/,127/*vs/css!vs/base/browser/ui/progressbar/progressbar*/]), function (require, exports, nls, uri_1, errors_1, dom_1, winjs_base_1, htmlContentRenderer_1, opener_1, range_1, position_1, modes_1, textToHtmlTokenizer_1, hover_1, hoverOperation_1, hoverWidgets_1, htmlContent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModesContentComputer = (function () {
        function ModesContentComputer(editor) {
            this._editor = editor;
            this._range = null;
        }
        ModesContentComputer.prototype.setRange = function (range) {
            this._range = range;
            this._result = [];
        };
        ModesContentComputer.prototype.clearResult = function () {
            this._result = [];
        };
        ModesContentComputer.prototype.computeAsync = function () {
            var model = this._editor.getModel();
            if (!modes_1.HoverProviderRegistry.has(model)) {
                return winjs_base_1.TPromise.as(null);
            }
            return hover_1.getHover(model, new position_1.Position(this._range.startLineNumber, this._range.startColumn));
        };
        ModesContentComputer.prototype.computeSync = function () {
            var _this = this;
            var lineNumber = this._range.startLineNumber;
            if (lineNumber > this._editor.getModel().getLineCount()) {
                // Illegal line number => no results
                return [];
            }
            var hasHoverContent = function (contents) {
                return contents && (!Array.isArray(contents) || contents.length > 0);
            };
            var maxColumn = this._editor.getModel().getLineMaxColumn(lineNumber);
            var lineDecorations = this._editor.getLineDecorations(lineNumber);
            var result = lineDecorations.map(function (d) {
                var startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;
                var endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;
                if (startColumn > _this._range.startColumn || _this._range.endColumn > endColumn || !hasHoverContent(d.options.hoverMessage)) {
                    return null;
                }
                var range = new range_1.Range(_this._range.startLineNumber, startColumn, _this._range.startLineNumber, endColumn);
                var contents;
                if (d.options.hoverMessage) {
                    if (Array.isArray(d.options.hoverMessage)) {
                        contents = d.options.hoverMessage.slice();
                    }
                    else {
                        contents = [d.options.hoverMessage];
                    }
                }
                return { contents: contents, range: range };
            });
            return result.filter(function (d) { return !!d; });
        };
        ModesContentComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
            // Always put synchronous messages before asynchronous ones
            if (isFromSynchronousComputation) {
                this._result = result.concat(this._result);
            }
            else {
                this._result = this._result.concat(result);
            }
        };
        ModesContentComputer.prototype.getResult = function () {
            return this._result.slice(0);
        };
        ModesContentComputer.prototype.getResultWithLoadingMessage = function () {
            return this._result.slice(0).concat([this._getLoadingMessage()]);
        };
        ModesContentComputer.prototype._getLoadingMessage = function () {
            return {
                range: this._range,
                contents: [htmlContent_1.textToMarkedString(nls.localize(0, null))]
            };
        };
        return ModesContentComputer;
    }());
    var ModesContentHoverWidget = (function (_super) {
        __extends(ModesContentHoverWidget, _super);
        function ModesContentHoverWidget(editor, openerService, modeService) {
            var _this = _super.call(this, ModesContentHoverWidget.ID, editor) || this;
            _this._computer = new ModesContentComputer(_this._editor);
            _this._highlightDecorations = [];
            _this._isChangingDecorations = false;
            _this._openerService = openerService || opener_1.NullOpenerService;
            _this._modeService = modeService;
            _this._hoverOperation = new hoverOperation_1.HoverOperation(_this._computer, function (result) { return _this._withResult(result, true); }, null, function (result) { return _this._withResult(result, false); });
            return _this;
        }
        ModesContentHoverWidget.prototype.dispose = function () {
            this._hoverOperation.cancel();
            _super.prototype.dispose.call(this);
        };
        ModesContentHoverWidget.prototype.onModelDecorationsChanged = function () {
            if (this._isChangingDecorations) {
                return;
            }
            if (this.isVisible) {
                // The decorations have changed and the hover is visible,
                // we need to recompute the displayed text
                this._hoverOperation.cancel();
                this._computer.clearResult();
                this._hoverOperation.start();
            }
        };
        ModesContentHoverWidget.prototype.startShowingAt = function (range, focus) {
            if (this._lastRange && this._lastRange.equalsRange(range)) {
                // We have to show the widget at the exact same range as before, so no work is needed
                return;
            }
            this._hoverOperation.cancel();
            if (this.isVisible) {
                // The range might have changed, but the hover is visible
                // Instead of hiding it completely, filter out messages that are still in the new range and
                // kick off a new computation
                if (this._showAtPosition.lineNumber !== range.startLineNumber) {
                    this.hide();
                }
                else {
                    var filteredMessages = [];
                    for (var i = 0, len = this._messages.length; i < len; i++) {
                        var msg = this._messages[i];
                        var rng = msg.range;
                        if (rng.startColumn <= range.startColumn && rng.endColumn >= range.endColumn) {
                            filteredMessages.push(msg);
                        }
                    }
                    if (filteredMessages.length > 0) {
                        this._renderMessages(range, filteredMessages);
                    }
                    else {
                        this.hide();
                    }
                }
            }
            this._lastRange = range;
            this._computer.setRange(range);
            this._shouldFocus = focus;
            this._hoverOperation.start();
        };
        ModesContentHoverWidget.prototype.hide = function () {
            this._lastRange = null;
            this._hoverOperation.cancel();
            _super.prototype.hide.call(this);
            this._isChangingDecorations = true;
            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
            this._isChangingDecorations = false;
        };
        ModesContentHoverWidget.prototype._withResult = function (result, complete) {
            this._messages = result;
            if (this._lastRange && this._messages.length > 0) {
                this._renderMessages(this._lastRange, this._messages);
            }
            else if (complete) {
                this.hide();
            }
        };
        ModesContentHoverWidget.prototype._renderMessages = function (renderRange, messages) {
            var _this = this;
            // update column from which to show
            var renderColumn = Number.MAX_VALUE, highlightRange = messages[0].range, fragment = document.createDocumentFragment();
            messages.forEach(function (msg) {
                if (!msg.range) {
                    return;
                }
                renderColumn = Math.min(renderColumn, msg.range.startColumn);
                highlightRange = range_1.Range.plusRange(highlightRange, msg.range);
                msg.contents
                    .filter(function (contents) { return !!contents; })
                    .forEach(function (contents) {
                    var renderedContents = htmlContentRenderer_1.renderMarkedString(contents, {
                        actionCallback: function (content) {
                            _this._openerService.open(uri_1.default.parse(content)).then(void 0, errors_1.onUnexpectedError);
                        },
                        codeBlockRenderer: function (languageAlias, value) {
                            // In markdown,
                            // it is possible that we stumble upon language aliases (e.g.js instead of javascript)
                            // it is possible no alias is given in which case we fall back to the current editor lang
                            var modeId = languageAlias
                                ? _this._modeService.getModeIdForLanguageName(languageAlias)
                                : _this._editor.getModel().getLanguageIdentifier().language;
                            return _this._modeService.getOrCreateMode(modeId).then(function (_) {
                                return "<div class=\"code\">" + textToHtmlTokenizer_1.tokenizeToString(value, modeId) + "</div>";
                            });
                        }
                    });
                    fragment.appendChild(dom_1.$('div.hover-row', null, renderedContents));
                });
            });
            // show
            this.showAt({
                lineNumber: renderRange.startLineNumber,
                column: renderColumn
            }, this._shouldFocus);
            this.updateContents(fragment);
            this._isChangingDecorations = true;
            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, [{
                    range: highlightRange,
                    options: {
                        className: 'hoverHighlight'
                    }
                }]);
            this._isChangingDecorations = false;
        };
        return ModesContentHoverWidget;
    }(hoverWidgets_1.ContentHoverWidget));
    ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';
    exports.ModesContentHoverWidget = ModesContentHoverWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[460/*vs/editor/contrib/hover/browser/hover*/], __M([1/*require*/,0/*exports*/,290/*vs/nls!vs/editor/contrib/hover/browser/hover*/,32/*vs/base/common/keyCodes*/,19/*vs/base/common/platform*/,71/*vs/platform/opener/common/opener*/,89/*vs/editor/common/services/modeService*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,459/*vs/editor/contrib/hover/browser/modesContentHover*/,415/*vs/editor/contrib/hover/browser/modesGlyphHover*/,3/*vs/base/common/lifecycle*/,369/*vs/css!vs/editor/contrib/hover/browser/hover*/]), function (require, exports, nls, keyCodes_1, platform, opener_1, modeService_1, range_1, editorCommon, editorCommonExtensions_1, editorBrowserExtensions_1, modesContentHover_1, modesGlyphHover_1, lifecycle_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var ModesHoverController = ModesHoverController_1 = (function () {
        function ModesHoverController(editor, openerService, modeService) {
            var _this = this;
            this._editor = editor;
            this._toUnhook = [];
            if (editor.getConfiguration().contribInfo.hover) {
                this._toUnhook.push(this._editor.onMouseDown(function (e) { return _this._onEditorMouseDown(e); }));
                this._toUnhook.push(this._editor.onMouseMove(function (e) { return _this._onEditorMouseMove(e); }));
                this._toUnhook.push(this._editor.onMouseLeave(function (e) { return _this._hideWidgets(); }));
                this._toUnhook.push(this._editor.onKeyDown(function (e) { return _this._onKeyDown(e); }));
                this._toUnhook.push(this._editor.onDidChangeModel(function () { return _this._hideWidgets(); }));
                this._toUnhook.push(this._editor.onDidChangeModelDecorations(function () { return _this._onModelDecorationsChanged(); }));
                this._toUnhook.push(this._editor.onDidScrollChange(function (e) {
                    if (e.scrollTopChanged || e.scrollLeftChanged) {
                        _this._hideWidgets();
                    }
                }));
                this._contentWidget = new modesContentHover_1.ModesContentHoverWidget(editor, openerService, modeService);
                this._glyphWidget = new modesGlyphHover_1.ModesGlyphHoverWidget(editor, openerService, modeService);
            }
        }
        ModesHoverController.get = function (editor) {
            return editor.getContribution(ModesHoverController_1.ID);
        };
        ModesHoverController.prototype._onModelDecorationsChanged = function () {
            this._contentWidget.onModelDecorationsChanged();
            this._glyphWidget.onModelDecorationsChanged();
        };
        ModesHoverController.prototype._onEditorMouseDown = function (mouseEvent) {
            var targetType = mouseEvent.target.type;
            if (targetType === editorCommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === modesContentHover_1.ModesContentHoverWidget.ID) {
                // mouse down on top of content hover widget
                return;
            }
            if (targetType === editorCommon.MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === modesGlyphHover_1.ModesGlyphHoverWidget.ID) {
                // mouse down on top of overlay hover widget
                return;
            }
            this._hideWidgets();
        };
        ModesHoverController.prototype._onEditorMouseMove = function (mouseEvent) {
            var targetType = mouseEvent.target.type;
            var stopKey = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
            if (targetType === editorCommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === modesContentHover_1.ModesContentHoverWidget.ID && !mouseEvent.event[stopKey]) {
                // mouse moved on top of content hover widget
                return;
            }
            if (targetType === editorCommon.MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === modesGlyphHover_1.ModesGlyphHoverWidget.ID && !mouseEvent.event[stopKey]) {
                // mouse moved on top of overlay hover widget
                return;
            }
            if (this._editor.getConfiguration().contribInfo.hover && targetType === editorCommon.MouseTargetType.CONTENT_TEXT) {
                this._glyphWidget.hide();
                this._contentWidget.startShowingAt(mouseEvent.target.range, false);
            }
            else if (targetType === editorCommon.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                this._contentWidget.hide();
                this._glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
            }
            else {
                this._hideWidgets();
            }
        };
        ModesHoverController.prototype._onKeyDown = function (e) {
            var stopKey = platform.isMacintosh ? 57 /* Meta */ : 5 /* Ctrl */;
            if (e.keyCode !== stopKey) {
                // Do not hide hover when Ctrl/Meta is pressed
                this._hideWidgets();
            }
        };
        ModesHoverController.prototype._hideWidgets = function () {
            this._glyphWidget.hide();
            this._contentWidget.hide();
        };
        ModesHoverController.prototype.showContentHover = function (range, focus) {
            this._contentWidget.startShowingAt(range, focus);
        };
        ModesHoverController.prototype.getId = function () {
            return ModesHoverController_1.ID;
        };
        ModesHoverController.prototype.dispose = function () {
            this._toUnhook = lifecycle_1.dispose(this._toUnhook);
            if (this._glyphWidget) {
                this._glyphWidget.dispose();
                this._glyphWidget = null;
            }
            if (this._contentWidget) {
                this._contentWidget.dispose();
                this._contentWidget = null;
            }
        };
        return ModesHoverController;
    }());
    ModesHoverController.ID = 'editor.contrib.hover';
    ModesHoverController = ModesHoverController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, opener_1.IOpenerService),
        __param(2, modeService_1.IModeService)
    ], ModesHoverController);
    var ShowHoverAction = (function (_super) {
        __extends(ShowHoverAction, _super);
        function ShowHoverAction() {
            return _super.call(this, {
                id: 'editor.action.showHover',
                label: nls.localize(0, null),
                alias: 'Show Hover',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 39 /* KEY_I */)
                }
            }) || this;
        }
        ShowHoverAction.prototype.run = function (accessor, editor) {
            var controller = ModesHoverController.get(editor);
            if (!controller) {
                return;
            }
            var position = editor.getPosition();
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            controller.showContentHover(range, true);
        };
        return ShowHoverAction;
    }(editorCommonExtensions_1.EditorAction));
    ShowHoverAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], ShowHoverAction);
    var ModesHoverController_1;
});















define(__m[461/*vs/editor/contrib/inPlaceReplace/common/inPlaceReplace*/], __M([1/*require*/,0/*exports*/,292/*vs/nls!vs/editor/contrib/inPlaceReplace/common/inPlaceReplace*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,52/*vs/editor/common/services/editorWorkerService*/,227/*vs/editor/contrib/inPlaceReplace/common/inPlaceReplaceCommand*/]), function (require, exports, nls, winjs_base_1, range_1, selection_1, editorCommon_1, editorCommonExtensions_1, editorWorkerService_1, inPlaceReplaceCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InPlaceReplaceController = InPlaceReplaceController_1 = (function () {
        function InPlaceReplaceController(editor, editorWorkerService) {
            this.editor = editor;
            this.editorWorkerService = editorWorkerService;
            this.requestIdPool = 0;
            this.currentRequest = winjs_base_1.TPromise.as(null);
            this.decorationRemover = winjs_base_1.TPromise.as(null);
            this.decorationIds = [];
        }
        InPlaceReplaceController.get = function (editor) {
            return editor.getContribution(InPlaceReplaceController_1.ID);
        };
        InPlaceReplaceController.prototype.dispose = function () {
        };
        InPlaceReplaceController.prototype.getId = function () {
            return InPlaceReplaceController_1.ID;
        };
        InPlaceReplaceController.prototype.run = function (source, up) {
            var _this = this;
            // cancel any pending request
            this.currentRequest.cancel();
            var selection = this.editor.getSelection(), model = this.editor.getModel(), modelURI = model.uri;
            if (selection.startLineNumber !== selection.endLineNumber) {
                // Can't accept multiline selection
                return null;
            }
            var state = this.editor.captureState(editorCommon_1.CodeEditorStateFlag.Value, editorCommon_1.CodeEditorStateFlag.Position);
            this.currentRequest = this.editorWorkerService.navigateValueSet(modelURI, selection, up);
            this.currentRequest = this.currentRequest.then(function (basicResult) {
                if (basicResult && basicResult.range && basicResult.value) {
                    return basicResult;
                }
                return null;
            });
            return this.currentRequest.then(function (result) {
                if (!result || !result.range || !result.value) {
                    // No proper result
                    return;
                }
                if (!state.validate(_this.editor)) {
                    // state has changed
                    return;
                }
                // Selection
                var editRange = range_1.Range.lift(result.range), highlightRange = result.range, diff = result.value.length - (selection.endColumn - selection.startColumn);
                // highlight
                highlightRange = {
                    startLineNumber: highlightRange.startLineNumber,
                    startColumn: highlightRange.startColumn,
                    endLineNumber: highlightRange.endLineNumber,
                    endColumn: highlightRange.startColumn + result.value.length
                };
                if (diff > 1) {
                    selection = new selection_1.Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
                }
                // Insert new text
                var command = new inPlaceReplaceCommand_1.InPlaceReplaceCommand(editRange, selection, result.value);
                _this.editor.executeCommand(source, command);
                // add decoration
                _this.decorationIds = _this.editor.deltaDecorations(_this.decorationIds, [{
                        range: highlightRange,
                        options: InPlaceReplaceController_1.DECORATION
                    }]);
                // remove decoration after delay
                _this.decorationRemover.cancel();
                _this.decorationRemover = winjs_base_1.TPromise.timeout(350);
                _this.decorationRemover.then(function () {
                    _this.editor.changeDecorations(function (accessor) {
                        _this.decorationIds = accessor.deltaDecorations(_this.decorationIds, []);
                    });
                });
            });
        };
        return InPlaceReplaceController;
    }());
    InPlaceReplaceController.ID = 'editor.contrib.inPlaceReplaceController';
    InPlaceReplaceController.DECORATION = {
        className: 'valueSetReplacement'
    };
    InPlaceReplaceController = InPlaceReplaceController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, editorWorkerService_1.IEditorWorkerService)
    ], InPlaceReplaceController);
    var InPlaceReplaceUp = (function (_super) {
        __extends(InPlaceReplaceUp, _super);
        function InPlaceReplaceUp() {
            return _super.call(this, {
                id: 'editor.action.inPlaceReplace.up',
                label: nls.localize(0, null),
                alias: 'Replace with Previous Value',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 82 /* US_COMMA */
                }
            }) || this;
        }
        InPlaceReplaceUp.prototype.run = function (accessor, editor) {
            var controller = InPlaceReplaceController.get(editor);
            if (!controller) {
                return;
            }
            return controller.run(this.id, true);
        };
        return InPlaceReplaceUp;
    }(editorCommonExtensions_1.EditorAction));
    InPlaceReplaceUp = __decorate([
        editorCommonExtensions_1.editorAction
    ], InPlaceReplaceUp);
    var InPlaceReplaceDown = (function (_super) {
        __extends(InPlaceReplaceDown, _super);
        function InPlaceReplaceDown() {
            return _super.call(this, {
                id: 'editor.action.inPlaceReplace.down',
                label: nls.localize(1, null),
                alias: 'Replace with Next Value',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 84 /* US_DOT */
                }
            }) || this;
        }
        InPlaceReplaceDown.prototype.run = function (accessor, editor) {
            var controller = InPlaceReplaceController.get(editor);
            if (!controller) {
                return;
            }
            return controller.run(this.id, false);
        };
        return InPlaceReplaceDown;
    }(editorCommonExtensions_1.EditorAction));
    InPlaceReplaceDown = __decorate([
        editorCommonExtensions_1.editorAction
    ], InPlaceReplaceDown);
    var InPlaceReplaceController_1;
});















define(__m[462/*vs/editor/contrib/inspectTokens/browser/inspectTokens*/], __M([1/*require*/,0/*exports*/,293/*vs/nls!vs/editor/contrib/inspectTokens/browser/inspectTokens*/,3/*vs/base/common/lifecycle*/,9/*vs/base/common/strings*/,13/*vs/editor/common/editorCommonExtensions*/,21/*vs/editor/browser/editorBrowser*/,26/*vs/editor/browser/editorBrowserExtensions*/,89/*vs/editor/common/services/modeService*/,141/*vs/editor/common/model/tokensBinaryEncoding*/,15/*vs/editor/common/modes*/,78/*vs/editor/common/services/standaloneColorService*/,64/*vs/editor/common/modes/nullMode*/,381/*vs/css!vs/editor/contrib/inspectTokens/browser/inspectTokens*/]), function (require, exports, nls, lifecycle_1, strings_1, editorCommonExtensions_1, editorBrowser_1, editorBrowserExtensions_1, modeService_1, tokensBinaryEncoding_1, modes_1, standaloneColorService_1, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InspectTokensController = InspectTokensController_1 = (function (_super) {
        __extends(InspectTokensController, _super);
        function InspectTokensController(editor, standaloneColorService, modeService) {
            var _this = _super.call(this) || this;
            _this._editor = editor;
            _this._standaloneColorService = standaloneColorService;
            _this._modeService = modeService;
            _this._widget = null;
            _this._register(_this._editor.onDidChangeModel(function (e) { return _this.stop(); }));
            _this._register(_this._editor.onDidChangeModelLanguage(function (e) { return _this.stop(); }));
            _this._register(modes_1.TokenizationRegistry.onDidChange(function (e) { return _this.stop(); }));
            return _this;
        }
        InspectTokensController.get = function (editor) {
            return editor.getContribution(InspectTokensController_1.ID);
        };
        InspectTokensController.prototype.getId = function () {
            return InspectTokensController_1.ID;
        };
        InspectTokensController.prototype.dispose = function () {
            this.stop();
            _super.prototype.dispose.call(this);
        };
        InspectTokensController.prototype.launch = function () {
            if (this._widget) {
                return;
            }
            if (!this._editor.getModel()) {
                return;
            }
            this._widget = new InspectTokensWidget(this._editor, this._standaloneColorService, this._modeService);
        };
        InspectTokensController.prototype.stop = function () {
            if (this._widget) {
                this._widget.dispose();
                this._widget = null;
            }
        };
        return InspectTokensController;
    }(lifecycle_1.Disposable));
    InspectTokensController.ID = 'editor.contrib.inspectTokens';
    InspectTokensController = InspectTokensController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, standaloneColorService_1.IStandaloneColorService),
        __param(2, modeService_1.IModeService)
    ], InspectTokensController);
    var InspectTokens = (function (_super) {
        __extends(InspectTokens, _super);
        function InspectTokens() {
            return _super.call(this, {
                id: 'editor.action.inspectTokens',
                label: nls.localize(0, null),
                alias: 'Developer: Inspect Tokens',
                precondition: null
            }) || this;
        }
        InspectTokens.prototype.run = function (accessor, editor) {
            var controller = InspectTokensController.get(editor);
            if (controller) {
                controller.launch();
            }
        };
        return InspectTokens;
    }(editorCommonExtensions_1.EditorAction));
    InspectTokens = __decorate([
        editorCommonExtensions_1.editorAction
    ], InspectTokens);
    function renderTokenText(tokenText) {
        var result = '';
        for (var charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
            var charCode = tokenText.charCodeAt(charIndex);
            switch (charCode) {
                case 9 /* Tab */:
                    result += '&rarr;';
                    break;
                case 32 /* Space */:
                    result += '&middot;';
                    break;
                case 60 /* LessThan */:
                    result += '&lt;';
                    break;
                case 62 /* GreaterThan */:
                    result += '&gt;';
                    break;
                case 38 /* Ampersand */:
                    result += '&amp;';
                    break;
                default:
                    result += String.fromCharCode(charCode);
            }
        }
        return result;
    }
    function getSafeTokenizationSupport(languageIdentifier) {
        var tokenizationSupport = modes_1.TokenizationRegistry.get(languageIdentifier.language);
        if (tokenizationSupport) {
            return tokenizationSupport;
        }
        return {
            getInitialState: function () { return nullMode_1.NULL_STATE; },
            tokenize: function (line, state, deltaOffset) { return nullMode_1.nullTokenize(languageIdentifier.language, line, state, deltaOffset); },
            tokenize2: function (line, state, deltaOffset) { return nullMode_1.nullTokenize2(languageIdentifier.id, line, state, deltaOffset); }
        };
    }
    var InspectTokensWidget = (function (_super) {
        __extends(InspectTokensWidget, _super);
        function InspectTokensWidget(editor, standaloneColorService, modeService) {
            var _this = _super.call(this) || this;
            _this.allowEditorOverflow = true;
            _this._editor = editor;
            _this._standaloneColorService = standaloneColorService;
            _this._modeService = modeService;
            _this._model = _this._editor.getModel();
            _this._domNode = document.createElement('div');
            _this._domNode.className = 'tokens-inspect-widget';
            _this._tokenizationSupport = getSafeTokenizationSupport(_this._model.getLanguageIdentifier());
            _this._compute(_this._editor.getPosition());
            _this._register(_this._editor.onDidChangeCursorPosition(function (e) { return _this._compute(_this._editor.getPosition()); }));
            _this._editor.addContentWidget(_this);
            return _this;
        }
        InspectTokensWidget.prototype.dispose = function () {
            this._editor.removeContentWidget(this);
            _super.prototype.dispose.call(this);
        };
        InspectTokensWidget.prototype.getId = function () {
            return InspectTokensWidget._ID;
        };
        InspectTokensWidget.prototype._compute = function (position) {
            var data = this._getTokensAtLine(position.lineNumber);
            var token1Index = 0;
            for (var i = data.tokens1.length - 1; i >= 0; i--) {
                var t = data.tokens1[i];
                if (position.column - 1 >= t.offset) {
                    token1Index = i;
                    break;
                }
            }
            var token2Index = 0;
            for (var i = (data.tokens2.length >>> 1); i >= 0; i--) {
                if (position.column - 1 >= data.tokens2[(i << 1)]) {
                    token2Index = i;
                    break;
                }
            }
            var result = '';
            var lineContent = this._model.getLineContent(position.lineNumber);
            var tokenText = '';
            if (token1Index < data.tokens1.length) {
                var tokenStartIndex = data.tokens1[token1Index].offset;
                var tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
                tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
            }
            result += "<h2 class=\"tm-token\">" + renderTokenText(tokenText) + "<span class=\"tm-token-length\">(" + tokenText.length + " " + (tokenText.length === 1 ? 'char' : 'chars') + ")</span></h2>";
            result += "<hr style=\"clear:both\"/>";
            var metadata = this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]);
            result += "<table class=\"tm-metadata-table\"><tbody>";
            result += "<tr><td class=\"tm-metadata-key\">language</td><td class=\"tm-metadata-value\">" + strings_1.escape(metadata.languageIdentifier.language) + "</td>";
            result += "<tr><td class=\"tm-metadata-key\">token type</td><td class=\"tm-metadata-value\">" + this._tokenTypeToString(metadata.tokenType) + "</td>";
            result += "<tr><td class=\"tm-metadata-key\">font style</td><td class=\"tm-metadata-value\">" + this._fontStyleToString(metadata.fontStyle) + "</td>";
            result += "<tr><td class=\"tm-metadata-key\">foreground</td><td class=\"tm-metadata-value\">" + metadata.foreground + "</td>";
            result += "<tr><td class=\"tm-metadata-key\">background</td><td class=\"tm-metadata-value\">" + metadata.background + "</td>";
            result += "</tbody></table>";
            result += "<hr/>";
            if (token1Index < data.tokens1.length) {
                result += "<span class=\"tm-token-type\">" + strings_1.escape(data.tokens1[token1Index].type) + "</span>";
            }
            this._domNode.innerHTML = result;
            this._editor.layoutContentWidget(this);
        };
        InspectTokensWidget.prototype._decodeMetadata = function (metadata) {
            var colorMap = modes_1.TokenizationRegistry.getColorMap();
            var languageId = tokensBinaryEncoding_1.TokenMetadata.getLanguageId(metadata);
            var tokenType = tokensBinaryEncoding_1.TokenMetadata.getTokenType(metadata);
            var fontStyle = tokensBinaryEncoding_1.TokenMetadata.getFontStyle(metadata);
            var foreground = tokensBinaryEncoding_1.TokenMetadata.getForeground(metadata);
            var background = tokensBinaryEncoding_1.TokenMetadata.getBackground(metadata);
            return {
                languageIdentifier: this._modeService.getLanguageIdentifier(languageId),
                tokenType: tokenType,
                fontStyle: fontStyle,
                foreground: colorMap[foreground],
                background: colorMap[background]
            };
        };
        InspectTokensWidget.prototype._tokenTypeToString = function (tokenType) {
            switch (tokenType) {
                case 0 /* Other */: return 'Other';
                case 1 /* Comment */: return 'Comment';
                case 2 /* String */: return 'String';
                case 4 /* RegEx */: return 'RegEx';
            }
            return '??';
        };
        InspectTokensWidget.prototype._fontStyleToString = function (fontStyle) {
            var r = '';
            if (fontStyle & 1 /* Italic */) {
                r += 'italic ';
            }
            if (fontStyle & 2 /* Bold */) {
                r += 'bold ';
            }
            if (fontStyle & 4 /* Underline */) {
                r += 'underline ';
            }
            if (r.length === 0) {
                r = '---';
            }
            return r;
        };
        InspectTokensWidget.prototype._getTokensAtLine = function (lineNumber) {
            var stateBeforeLine = this._getStateBeforeLine(lineNumber);
            var tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
            var tokenizationResult2 = this._tokenizationSupport.tokenize2(this._model.getLineContent(lineNumber), stateBeforeLine, 0);
            return {
                startState: stateBeforeLine,
                tokens1: tokenizationResult1.tokens,
                tokens2: tokenizationResult2.tokens,
                endState: tokenizationResult1.endState
            };
        };
        InspectTokensWidget.prototype._getStateBeforeLine = function (lineNumber) {
            var state = this._tokenizationSupport.getInitialState();
            for (var i = 1; i < lineNumber; i++) {
                var tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), state, 0);
                state = tokenizationResult.endState;
            }
            return state;
        };
        InspectTokensWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        InspectTokensWidget.prototype.getPosition = function () {
            return {
                position: this._editor.getPosition(),
                preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE]
            };
        };
        return InspectTokensWidget;
    }(lifecycle_1.Disposable));
    InspectTokensWidget._ID = 'editor.contrib.inspectTokensWidget';
    var InspectTokensController_1;
});












define(__m[463/*vs/editor/contrib/linesOperations/common/linesOperations*/], __M([1/*require*/,0/*exports*/,294/*vs/nls!vs/editor/contrib/linesOperations/common/linesOperations*/,32/*vs/base/common/keyCodes*/,231/*vs/editor/contrib/linesOperations/common/sortLinesCommand*/,46/*vs/editor/common/core/editOperation*/,441/*vs/editor/common/commands/trimTrailingWhitespaceCommand*/,2/*vs/editor/common/editorCommon*/,62/*vs/editor/common/commands/replaceCommand*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,13/*vs/editor/common/editorCommonExtensions*/,228/*vs/editor/contrib/linesOperations/common/copyLinesCommand*/,229/*vs/editor/contrib/linesOperations/common/deleteLinesCommand*/,230/*vs/editor/contrib/linesOperations/common/moveLinesCommand*/]), function (require, exports, nls, keyCodes_1, sortLinesCommand_1, editOperation_1, trimTrailingWhitespaceCommand_1, editorCommon_1, replaceCommand_1, range_1, selection_1, editorCommonExtensions_1, copyLinesCommand_1, deleteLinesCommand_1, moveLinesCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // copy lines
    var AbstractCopyLinesAction = (function (_super) {
        __extends(AbstractCopyLinesAction, _super);
        function AbstractCopyLinesAction(down, opts) {
            var _this = _super.call(this, opts) || this;
            _this.down = down;
            return _this;
        }
        AbstractCopyLinesAction.prototype.run = function (accessor, editor) {
            var commands = [];
            var selections = editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new copyLinesCommand_1.CopyLinesCommand(selections[i], this.down));
            }
            editor.executeCommands(this.id, commands);
        };
        return AbstractCopyLinesAction;
    }(editorCommonExtensions_1.EditorAction));
    var CopyLinesUpAction = (function (_super) {
        __extends(CopyLinesUpAction, _super);
        function CopyLinesUpAction() {
            return _super.call(this, false, {
                id: 'editor.action.copyLinesUpAction',
                label: nls.localize(0, null),
                alias: 'Copy Line Up',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 512 /* Alt */ | 1024 /* Shift */ | 16 /* UpArrow */,
                    linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 1024 /* Shift */ | 16 /* UpArrow */ }
                }
            }) || this;
        }
        return CopyLinesUpAction;
    }(AbstractCopyLinesAction));
    CopyLinesUpAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], CopyLinesUpAction);
    var CopyLinesDownAction = (function (_super) {
        __extends(CopyLinesDownAction, _super);
        function CopyLinesDownAction() {
            return _super.call(this, true, {
                id: 'editor.action.copyLinesDownAction',
                label: nls.localize(1, null),
                alias: 'Copy Line Down',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 512 /* Alt */ | 1024 /* Shift */ | 18 /* DownArrow */,
                    linux: { primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 1024 /* Shift */ | 18 /* DownArrow */ }
                }
            }) || this;
        }
        return CopyLinesDownAction;
    }(AbstractCopyLinesAction));
    CopyLinesDownAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], CopyLinesDownAction);
    // move lines
    var AbstractMoveLinesAction = (function (_super) {
        __extends(AbstractMoveLinesAction, _super);
        function AbstractMoveLinesAction(down, opts) {
            var _this = _super.call(this, opts) || this;
            _this.down = down;
            return _this;
        }
        AbstractMoveLinesAction.prototype.run = function (accessor, editor) {
            var commands = [];
            var selections = editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new moveLinesCommand_1.MoveLinesCommand(selections[i], this.down));
            }
            editor.executeCommands(this.id, commands);
        };
        return AbstractMoveLinesAction;
    }(editorCommonExtensions_1.EditorAction));
    var MoveLinesUpAction = (function (_super) {
        __extends(MoveLinesUpAction, _super);
        function MoveLinesUpAction() {
            return _super.call(this, false, {
                id: 'editor.action.moveLinesUpAction',
                label: nls.localize(2, null),
                alias: 'Move Line Up',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 512 /* Alt */ | 16 /* UpArrow */,
                    linux: { primary: 512 /* Alt */ | 16 /* UpArrow */ }
                }
            }) || this;
        }
        return MoveLinesUpAction;
    }(AbstractMoveLinesAction));
    MoveLinesUpAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveLinesUpAction);
    var MoveLinesDownAction = (function (_super) {
        __extends(MoveLinesDownAction, _super);
        function MoveLinesDownAction() {
            return _super.call(this, true, {
                id: 'editor.action.moveLinesDownAction',
                label: nls.localize(3, null),
                alias: 'Move Line Down',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 512 /* Alt */ | 18 /* DownArrow */,
                    linux: { primary: 512 /* Alt */ | 18 /* DownArrow */ }
                }
            }) || this;
        }
        return MoveLinesDownAction;
    }(AbstractMoveLinesAction));
    MoveLinesDownAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], MoveLinesDownAction);
    var AbstractSortLinesAction = (function (_super) {
        __extends(AbstractSortLinesAction, _super);
        function AbstractSortLinesAction(descending, opts) {
            var _this = _super.call(this, opts) || this;
            _this.descending = descending;
            return _this;
        }
        AbstractSortLinesAction.prototype.run = function (accessor, editor) {
            if (!sortLinesCommand_1.SortLinesCommand.canRun(editor.getModel(), editor.getSelection(), this.descending)) {
                return;
            }
            var command = new sortLinesCommand_1.SortLinesCommand(editor.getSelection(), this.descending);
            editor.executeCommands(this.id, [command]);
        };
        return AbstractSortLinesAction;
    }(editorCommonExtensions_1.EditorAction));
    var SortLinesAscendingAction = (function (_super) {
        __extends(SortLinesAscendingAction, _super);
        function SortLinesAscendingAction() {
            return _super.call(this, false, {
                id: 'editor.action.sortLinesAscending',
                label: nls.localize(4, null),
                alias: 'Sort Lines Ascending',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        return SortLinesAscendingAction;
    }(AbstractSortLinesAction));
    SortLinesAscendingAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], SortLinesAscendingAction);
    var SortLinesDescendingAction = (function (_super) {
        __extends(SortLinesDescendingAction, _super);
        function SortLinesDescendingAction() {
            return _super.call(this, true, {
                id: 'editor.action.sortLinesDescending',
                label: nls.localize(5, null),
                alias: 'Sort Lines Descending',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        return SortLinesDescendingAction;
    }(AbstractSortLinesAction));
    SortLinesDescendingAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], SortLinesDescendingAction);
    var TrimTrailingWhitespaceAction = TrimTrailingWhitespaceAction_1 = (function (_super) {
        __extends(TrimTrailingWhitespaceAction, _super);
        function TrimTrailingWhitespaceAction() {
            return _super.call(this, {
                id: TrimTrailingWhitespaceAction_1.ID,
                label: nls.localize(6, null),
                alias: 'Trim Trailing Whitespace',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, 2048 /* CtrlCmd */ | 54 /* KEY_X */)
                }
            }) || this;
        }
        TrimTrailingWhitespaceAction.prototype.run = function (accessor, editor) {
            var command = new trimTrailingWhitespaceCommand_1.TrimTrailingWhitespaceCommand(editor.getSelection());
            editor.executeCommands(this.id, [command]);
        };
        return TrimTrailingWhitespaceAction;
    }(editorCommonExtensions_1.EditorAction));
    TrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';
    TrimTrailingWhitespaceAction = TrimTrailingWhitespaceAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], TrimTrailingWhitespaceAction);
    exports.TrimTrailingWhitespaceAction = TrimTrailingWhitespaceAction;
    var AbstractRemoveLinesAction = (function (_super) {
        __extends(AbstractRemoveLinesAction, _super);
        function AbstractRemoveLinesAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbstractRemoveLinesAction.prototype._getLinesToRemove = function (editor) {
            // Construct delete operations
            var operations = editor.getSelections().map(function (s) {
                var endLineNumber = s.endLineNumber;
                if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                    endLineNumber -= 1;
                }
                return {
                    startLineNumber: s.startLineNumber,
                    endLineNumber: endLineNumber,
                    positionColumn: s.positionColumn
                };
            });
            // Sort delete operations
            operations.sort(function (a, b) {
                return a.startLineNumber - b.startLineNumber;
            });
            // Merge delete operations on consecutive lines
            var mergedOperations = [];
            var previousOperation = operations[0];
            for (var i = 1; i < operations.length; i++) {
                if (previousOperation.endLineNumber + 1 === operations[i].startLineNumber) {
                    // Merge current operations into the previous one
                    previousOperation.endLineNumber = operations[i].endLineNumber;
                }
                else {
                    // Push previous operation
                    mergedOperations.push(previousOperation);
                    previousOperation = operations[i];
                }
            }
            // Push the last operation
            mergedOperations.push(previousOperation);
            return mergedOperations;
        };
        return AbstractRemoveLinesAction;
    }(editorCommonExtensions_1.EditorAction));
    var DeleteLinesAction = (function (_super) {
        __extends(DeleteLinesAction, _super);
        function DeleteLinesAction() {
            return _super.call(this, {
                id: 'editor.action.deleteLines',
                label: nls.localize(7, null),
                alias: 'Delete Line',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 41 /* KEY_K */
                }
            }) || this;
        }
        DeleteLinesAction.prototype.run = function (accessor, editor) {
            var ops = this._getLinesToRemove(editor);
            // Finally, construct the delete lines commands
            var commands = ops.map(function (op) {
                return new deleteLinesCommand_1.DeleteLinesCommand(op.startLineNumber, op.endLineNumber, op.positionColumn);
            });
            editor.executeCommands(this.id, commands);
        };
        return DeleteLinesAction;
    }(AbstractRemoveLinesAction));
    DeleteLinesAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], DeleteLinesAction);
    var IndentLinesAction = (function (_super) {
        __extends(IndentLinesAction, _super);
        function IndentLinesAction() {
            return _super.call(this, {
                id: 'editor.action.indentLines',
                label: nls.localize(8, null),
                alias: 'Indent Line',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                handlerId: editorCommon_1.Handler.Indent,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 89 /* US_CLOSE_SQUARE_BRACKET */
                }
            }) || this;
        }
        return IndentLinesAction;
    }(editorCommonExtensions_1.HandlerEditorAction));
    IndentLinesAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], IndentLinesAction);
    var OutdentLinesAction = (function (_super) {
        __extends(OutdentLinesAction, _super);
        function OutdentLinesAction() {
            return _super.call(this, {
                id: 'editor.action.outdentLines',
                label: nls.localize(9, null),
                alias: 'Outdent Line',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                handlerId: editorCommon_1.Handler.Outdent,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 87 /* US_OPEN_SQUARE_BRACKET */
                }
            }) || this;
        }
        return OutdentLinesAction;
    }(editorCommonExtensions_1.HandlerEditorAction));
    OutdentLinesAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], OutdentLinesAction);
    var InsertLineBeforeAction = (function (_super) {
        __extends(InsertLineBeforeAction, _super);
        function InsertLineBeforeAction() {
            return _super.call(this, {
                id: 'editor.action.insertLineBefore',
                label: nls.localize(10, null),
                alias: 'Insert Line Above',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                handlerId: editorCommon_1.Handler.LineInsertBefore,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 3 /* Enter */
                }
            }) || this;
        }
        return InsertLineBeforeAction;
    }(editorCommonExtensions_1.HandlerEditorAction));
    InsertLineBeforeAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], InsertLineBeforeAction);
    var InsertLineAfterAction = (function (_super) {
        __extends(InsertLineAfterAction, _super);
        function InsertLineAfterAction() {
            return _super.call(this, {
                id: 'editor.action.insertLineAfter',
                label: nls.localize(11, null),
                alias: 'Insert Line Below',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                handlerId: editorCommon_1.Handler.LineInsertAfter,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 3 /* Enter */
                }
            }) || this;
        }
        return InsertLineAfterAction;
    }(editorCommonExtensions_1.HandlerEditorAction));
    InsertLineAfterAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], InsertLineAfterAction);
    var AbstractDeleteAllToBoundaryAction = (function (_super) {
        __extends(AbstractDeleteAllToBoundaryAction, _super);
        function AbstractDeleteAllToBoundaryAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbstractDeleteAllToBoundaryAction.prototype.run = function (accessor, editor) {
            var primaryCursor = editor.getSelection();
            var rangesToDelete = this._getRangesToDelete(editor);
            // merge overlapping selections
            var effectiveRanges = [];
            for (var i = 0, count = rangesToDelete.length - 1; i < count; i++) {
                var range = rangesToDelete[i];
                var nextRange = rangesToDelete[i + 1];
                if (range_1.Range.intersectRanges(range, nextRange) === null) {
                    effectiveRanges.push(range);
                }
                else {
                    rangesToDelete[i + 1] = range_1.Range.plusRange(range, nextRange);
                }
            }
            effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
            var endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
            var edits = effectiveRanges.map(function (range) {
                endCursorState.push(new selection_1.Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn));
                return editOperation_1.EditOperation.replace(range, '');
            });
            editor.executeEdits(this.id, edits, endCursorState);
        };
        return AbstractDeleteAllToBoundaryAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.AbstractDeleteAllToBoundaryAction = AbstractDeleteAllToBoundaryAction;
    var DeleteAllLeftAction = (function (_super) {
        __extends(DeleteAllLeftAction, _super);
        function DeleteAllLeftAction() {
            return _super.call(this, {
                id: 'deleteAllLeft',
                label: nls.localize(12, null),
                alias: 'Delete All Left',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: null,
                    mac: { primary: 2048 /* CtrlCmd */ | 1 /* Backspace */ }
                }
            }) || this;
        }
        DeleteAllLeftAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {
            var endPrimaryCursor;
            var endCursorState = [];
            for (var i = 0, len = rangesToDelete.length; i < len; i++) {
                var range = rangesToDelete[i];
                var endCursor = new selection_1.Selection(rangesToDelete[i].startLineNumber, rangesToDelete[i].startColumn, rangesToDelete[i].startLineNumber, rangesToDelete[i].startColumn);
                if (range.intersectRanges(primaryCursor)) {
                    endPrimaryCursor = endCursor;
                }
                else {
                    endCursorState.push(endCursor);
                }
            }
            if (endPrimaryCursor) {
                endCursorState.unshift(endPrimaryCursor);
            }
            return endCursorState;
        };
        DeleteAllLeftAction.prototype._getRangesToDelete = function (editor) {
            var rangesToDelete = editor.getSelections();
            rangesToDelete.sort(range_1.Range.compareRangesUsingStarts);
            rangesToDelete = rangesToDelete.map(function (selection) {
                if (selection.isEmpty()) {
                    return new range_1.Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
                }
                else {
                    return selection;
                }
            });
            return rangesToDelete;
        };
        return DeleteAllLeftAction;
    }(AbstractDeleteAllToBoundaryAction));
    DeleteAllLeftAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], DeleteAllLeftAction);
    exports.DeleteAllLeftAction = DeleteAllLeftAction;
    var DeleteAllRightAction = (function (_super) {
        __extends(DeleteAllRightAction, _super);
        function DeleteAllRightAction() {
            return _super.call(this, {
                id: 'deleteAllRight',
                label: nls.localize(13, null),
                alias: 'Delete All Right',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: null,
                    mac: { primary: 256 /* WinCtrl */ | 41 /* KEY_K */, secondary: [2048 /* CtrlCmd */ | 20 /* Delete */] }
                }
            }) || this;
        }
        DeleteAllRightAction.prototype._getEndCursorState = function (primaryCursor, rangesToDelete) {
            var endPrimaryCursor;
            var endCursorState = [];
            for (var i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
                var range = rangesToDelete[i];
                var endCursor = new selection_1.Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
                if (range.intersectRanges(primaryCursor)) {
                    endPrimaryCursor = endCursor;
                }
                else {
                    endCursorState.push(endCursor);
                }
            }
            if (endPrimaryCursor) {
                endCursorState.unshift(endPrimaryCursor);
            }
            return endCursorState;
        };
        DeleteAllRightAction.prototype._getRangesToDelete = function (editor) {
            var model = editor.getModel();
            var rangesToDelete = editor.getSelections().map(function (sel) {
                if (sel.isEmpty()) {
                    var maxColumn = model.getLineMaxColumn(sel.startLineNumber);
                    if (sel.startColumn === maxColumn) {
                        return new range_1.Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
                    }
                    else {
                        return new range_1.Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
                    }
                }
                return sel;
            });
            rangesToDelete.sort(range_1.Range.compareRangesUsingStarts);
            return rangesToDelete;
        };
        return DeleteAllRightAction;
    }(AbstractDeleteAllToBoundaryAction));
    DeleteAllRightAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], DeleteAllRightAction);
    exports.DeleteAllRightAction = DeleteAllRightAction;
    var JoinLinesAction = (function (_super) {
        __extends(JoinLinesAction, _super);
        function JoinLinesAction() {
            return _super.call(this, {
                id: 'editor.action.joinLines',
                label: nls.localize(14, null),
                alias: 'Join Lines',
                precondition: editorCommon_1.EditorContextKeys.Writable,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 0,
                    mac: { primary: 256 /* WinCtrl */ | 40 /* KEY_J */ }
                }
            }) || this;
        }
        JoinLinesAction.prototype.run = function (accessor, editor) {
            var selections = editor.getSelections();
            var primaryCursor = editor.getSelection();
            selections.sort(range_1.Range.compareRangesUsingStarts);
            var reducedSelections = [];
            var lastSelection = selections.reduce(function (previousValue, currentValue) {
                if (previousValue.isEmpty()) {
                    if (previousValue.endLineNumber === currentValue.startLineNumber) {
                        if (primaryCursor.equalsSelection(previousValue)) {
                            primaryCursor = currentValue;
                        }
                        return currentValue;
                    }
                    if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
                        reducedSelections.push(previousValue);
                        return currentValue;
                    }
                    else {
                        return new selection_1.Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
                    }
                }
                else {
                    if (currentValue.startLineNumber > previousValue.endLineNumber) {
                        reducedSelections.push(previousValue);
                        return currentValue;
                    }
                    else {
                        return new selection_1.Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
                    }
                }
            });
            reducedSelections.push(lastSelection);
            var model = editor.getModel();
            var edits = [];
            var endCursorState = [];
            var endPrimaryCursor = primaryCursor;
            var lineOffset = 0;
            for (var i = 0, len = reducedSelections.length; i < len; i++) {
                var selection = reducedSelections[i];
                var startLineNumber = selection.startLineNumber;
                var startColumn = 1;
                var endLineNumber = void 0, endColumn = void 0, columnDeltaOffset = void 0;
                var selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
                if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
                    var position = selection.getStartPosition();
                    if (position.lineNumber < model.getLineCount()) {
                        endLineNumber = startLineNumber + 1;
                        endColumn = model.getLineMaxColumn(endLineNumber);
                    }
                    else {
                        endLineNumber = position.lineNumber;
                        endColumn = model.getLineMaxColumn(position.lineNumber);
                    }
                }
                else {
                    endLineNumber = selection.endLineNumber;
                    endColumn = model.getLineMaxColumn(endLineNumber);
                }
                var trimmedLinesContent = model.getLineContent(startLineNumber);
                for (var i_1 = startLineNumber + 1; i_1 <= endLineNumber; i_1++) {
                    var lineText = model.getLineContent(i_1);
                    var firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i_1);
                    if (firstNonWhitespaceIdx >= 1) {
                        var insertSpace = true;
                        if (trimmedLinesContent === '') {
                            insertSpace = false;
                        }
                        if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === ' ' ||
                            trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === '\t')) {
                            insertSpace = false;
                            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, ' ');
                        }
                        var lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
                        trimmedLinesContent += (insertSpace ? ' ' : '') + lineTextWithoutIndent;
                        if (insertSpace) {
                            columnDeltaOffset = lineTextWithoutIndent.length + 1;
                        }
                        else {
                            columnDeltaOffset = lineTextWithoutIndent.length;
                        }
                    }
                    else {
                        columnDeltaOffset = 0;
                    }
                }
                var deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
                if (!deleteSelection.isEmpty()) {
                    var resultSelection = void 0;
                    if (selection.isEmpty()) {
                        edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));
                        resultSelection = new selection_1.Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
                    }
                    else {
                        if (selection.startLineNumber === selection.endLineNumber) {
                            edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));
                            resultSelection = new selection_1.Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
                        }
                        else {
                            edits.push(editOperation_1.EditOperation.replace(deleteSelection, trimmedLinesContent));
                            resultSelection = new selection_1.Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
                        }
                    }
                    if (range_1.Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
                        endPrimaryCursor = resultSelection;
                    }
                    else {
                        endCursorState.push(resultSelection);
                    }
                }
                lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
            }
            endCursorState.unshift(endPrimaryCursor);
            editor.executeEdits(this.id, edits, endCursorState);
        };
        return JoinLinesAction;
    }(editorCommonExtensions_1.EditorAction));
    JoinLinesAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], JoinLinesAction);
    exports.JoinLinesAction = JoinLinesAction;
    var TransposeAction = (function (_super) {
        __extends(TransposeAction, _super);
        function TransposeAction() {
            return _super.call(this, {
                id: 'editor.action.transpose',
                label: nls.localize(15, null),
                alias: 'Transpose characters around the cursor',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        TransposeAction.prototype.run = function (accessor, editor) {
            var selections = editor.getSelections();
            var model = editor.getModel();
            var commands = [];
            for (var i = 0, len = selections.length; i < len; i++) {
                var selection = selections[i];
                if (!selection.isEmpty()) {
                    continue;
                }
                var cursor = selection.getStartPosition();
                var maxColumn = model.getLineMaxColumn(cursor.lineNumber);
                if (cursor.column >= maxColumn) {
                    if (cursor.lineNumber === model.getLineCount()) {
                        continue;
                    }
                    // The cursor is at the end of current line and current line is not empty
                    // then we transpose the character before the cursor and the line break if there is any following line.
                    var deleteSelection = new range_1.Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
                    var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');
                    commands.push(new replaceCommand_1.ReplaceCommand(new selection_1.Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
                }
                else {
                    var deleteSelection = new range_1.Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
                    var chars = model.getValueInRange(deleteSelection).split('').reverse().join('');
                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(deleteSelection, chars, new selection_1.Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
                }
            }
            editor.executeCommands(this.id, commands);
        };
        return TransposeAction;
    }(editorCommonExtensions_1.EditorAction));
    TransposeAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], TransposeAction);
    exports.TransposeAction = TransposeAction;
    var AbstractCaseAction = (function (_super) {
        __extends(AbstractCaseAction, _super);
        function AbstractCaseAction() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        AbstractCaseAction.prototype.run = function (accessor, editor) {
            var selections = editor.getSelections();
            var model = editor.getModel();
            var commands = [];
            for (var i = 0, len = selections.length; i < len; i++) {
                var selection = selections[i];
                if (selection.isEmpty()) {
                    var cursor = selection.getStartPosition();
                    var word = model.getWordAtPosition(cursor);
                    if (!word) {
                        continue;
                    }
                    var wordRange = new range_1.Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
                    var text = model.getValueInRange(wordRange);
                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(wordRange, this._modifyText(text), new selection_1.Selection(cursor.lineNumber, cursor.column, cursor.lineNumber, cursor.column)));
                }
                else {
                    var text = model.getValueInRange(selection);
                    commands.push(new replaceCommand_1.ReplaceCommandThatPreservesSelection(selection, this._modifyText(text), selection));
                }
            }
            editor.executeCommands(this.id, commands);
        };
        return AbstractCaseAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.AbstractCaseAction = AbstractCaseAction;
    var UpperCaseAction = (function (_super) {
        __extends(UpperCaseAction, _super);
        function UpperCaseAction() {
            return _super.call(this, {
                id: 'editor.action.transformToUppercase',
                label: nls.localize(16, null),
                alias: 'Transform to Uppercase',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        UpperCaseAction.prototype._modifyText = function (text) {
            return text.toLocaleUpperCase();
        };
        return UpperCaseAction;
    }(AbstractCaseAction));
    UpperCaseAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], UpperCaseAction);
    exports.UpperCaseAction = UpperCaseAction;
    var LowerCaseAction = (function (_super) {
        __extends(LowerCaseAction, _super);
        function LowerCaseAction() {
            return _super.call(this, {
                id: 'editor.action.transformToLowercase',
                label: nls.localize(17, null),
                alias: 'Transform to Lowercase',
                precondition: editorCommon_1.EditorContextKeys.Writable
            }) || this;
        }
        LowerCaseAction.prototype._modifyText = function (text) {
            return text.toLocaleLowerCase();
        };
        return LowerCaseAction;
    }(AbstractCaseAction));
    LowerCaseAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], LowerCaseAction);
    exports.LowerCaseAction = LowerCaseAction;
    var TrimTrailingWhitespaceAction_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[464/*vs/editor/contrib/links/browser/links*/], __M([1/*require*/,0/*exports*/,295/*vs/nls!vs/editor/contrib/links/browser/links*/,10/*vs/base/common/errors*/,19/*vs/base/common/platform*/,30/*vs/base/common/severity*/,6/*vs/base/common/winjs.base*/,49/*vs/platform/message/common/message*/,71/*vs/platform/opener/common/opener*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,52/*vs/editor/common/services/editorWorkerService*/,330/*vs/editor/contrib/links/common/links*/,3/*vs/base/common/lifecycle*/,26/*vs/editor/browser/editorBrowserExtensions*/,397/*vs/css!vs/editor/contrib/links/browser/links*/]), function (require, exports, nls, errors_1, platform, severity_1, winjs_base_1, message_1, opener_1, editorCommon, editorCommonExtensions_1, modes_1, editorWorkerService_1, links_1, lifecycle_1, editorBrowserExtensions_1) {
    'use strict';
    var LinkOccurence = (function () {
        function LinkOccurence(link, decorationId /*, changeAccessor:editorCommon.IModelDecorationsChangeAccessor*/) {
            this.link = link;
            this.decorationId = decorationId;
        }
        LinkOccurence.decoration = function (link) {
            return {
                range: {
                    startLineNumber: link.range.startLineNumber,
                    startColumn: link.range.startColumn,
                    endLineNumber: link.range.endLineNumber,
                    endColumn: link.range.endColumn
                },
                options: LinkOccurence._getOptions(link, false)
            };
        };
        LinkOccurence._getOptions = function (link, isActive) {
            var result = '';
            if (isActive) {
                result += LinkDetector.CLASS_NAME_ACTIVE;
            }
            else {
                result += LinkDetector.CLASS_NAME;
            }
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                inlineClassName: result,
                hoverMessage: LinkDetector.HOVER_MESSAGE_GENERAL
            };
        };
        LinkOccurence.prototype.activate = function (changeAccessor) {
            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurence._getOptions(this.link, true));
        };
        LinkOccurence.prototype.deactivate = function (changeAccessor) {
            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurence._getOptions(this.link, false));
        };
        return LinkOccurence;
    }());
    var LinkDetector = LinkDetector_1 = (function () {
        function LinkDetector(editor, openerService, messageService, editorWorkerService) {
            var _this = this;
            this.editor = editor;
            this.openerService = openerService;
            this.messageService = messageService;
            this.editorWorkerService = editorWorkerService;
            this.listenersToRemove = [];
            this.listenersToRemove.push(editor.onDidChangeModelContent(function (e) { return _this.onChange(); }));
            this.listenersToRemove.push(editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
            this.listenersToRemove.push(editor.onDidChangeModelLanguage(function (e) { return _this.onModelModeChanged(); }));
            this.listenersToRemove.push(modes_1.LinkProviderRegistry.onDidChange(function (e) { return _this.onModelModeChanged(); }));
            this.listenersToRemove.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.listenersToRemove.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
            this.listenersToRemove.push(this.editor.onKeyDown(function (e) { return _this.onEditorKeyDown(e); }));
            this.listenersToRemove.push(this.editor.onKeyUp(function (e) { return _this.onEditorKeyUp(e); }));
            this.timeoutPromise = null;
            this.computePromise = null;
            this.currentOccurences = {};
            this.activeLinkDecorationId = null;
            this.beginCompute();
        }
        LinkDetector.get = function (editor) {
            return editor.getContribution(LinkDetector_1.ID);
        };
        LinkDetector.prototype.getId = function () {
            return LinkDetector_1.ID;
        };
        LinkDetector.prototype.isComputing = function () {
            return winjs_base_1.TPromise.is(this.computePromise);
        };
        LinkDetector.prototype.onModelChanged = function () {
            this.lastMouseEvent = null;
            this.currentOccurences = {};
            this.activeLinkDecorationId = null;
            this.stop();
            this.beginCompute();
        };
        LinkDetector.prototype.onModelModeChanged = function () {
            this.stop();
            this.beginCompute();
        };
        LinkDetector.prototype.onChange = function () {
            var _this = this;
            if (!this.timeoutPromise) {
                this.timeoutPromise = winjs_base_1.TPromise.timeout(LinkDetector_1.RECOMPUTE_TIME);
                this.timeoutPromise.then(function () {
                    _this.timeoutPromise = null;
                    _this.beginCompute();
                });
            }
        };
        LinkDetector.prototype.beginCompute = function () {
            var _this = this;
            if (!this.editor.getModel()) {
                return;
            }
            if (!modes_1.LinkProviderRegistry.has(this.editor.getModel())) {
                return;
            }
            this.computePromise = links_1.getLinks(this.editor.getModel()).then(function (links) {
                _this.updateDecorations(links);
                _this.computePromise = null;
            });
        };
        LinkDetector.prototype.updateDecorations = function (links) {
            var _this = this;
            this.editor.changeDecorations(function (changeAccessor) {
                var oldDecorations = [];
                var keys = Object.keys(_this.currentOccurences);
                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {
                    var decorationId = keys[i_1];
                    var occurance_1 = _this.currentOccurences[decorationId];
                    oldDecorations.push(occurance_1.decorationId);
                }
                var newDecorations = [];
                if (links) {
                    // Not sure why this is sometimes null
                    for (var i = 0; i < links.length; i++) {
                        newDecorations.push(LinkOccurence.decoration(links[i]));
                    }
                }
                var decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
                _this.currentOccurences = {};
                _this.activeLinkDecorationId = null;
                for (var i_2 = 0, len = decorations.length; i_2 < len; i_2++) {
                    var occurance = new LinkOccurence(links[i_2], decorations[i_2]);
                    _this.currentOccurences[occurance.decorationId] = occurance;
                }
            });
        };
        LinkDetector.prototype.onEditorKeyDown = function (e) {
            if (e.keyCode === LinkDetector_1.TRIGGER_KEY_VALUE && this.lastMouseEvent) {
                this.onEditorMouseMove(this.lastMouseEvent, e);
            }
        };
        LinkDetector.prototype.onEditorKeyUp = function (e) {
            if (e.keyCode === LinkDetector_1.TRIGGER_KEY_VALUE) {
                this.cleanUpActiveLinkDecoration();
            }
        };
        LinkDetector.prototype.onEditorMouseMove = function (mouseEvent, withKey) {
            var _this = this;
            this.lastMouseEvent = mouseEvent;
            if (this.isEnabled(mouseEvent, withKey)) {
                this.cleanUpActiveLinkDecoration(); // always remove previous link decoration as their can only be one
                var occurence = this.getLinkOccurence(mouseEvent.target.position);
                if (occurence) {
                    this.editor.changeDecorations(function (changeAccessor) {
                        occurence.activate(changeAccessor);
                        _this.activeLinkDecorationId = occurence.decorationId;
                    });
                }
            }
            else {
                this.cleanUpActiveLinkDecoration();
            }
        };
        LinkDetector.prototype.cleanUpActiveLinkDecoration = function () {
            if (this.activeLinkDecorationId) {
                var occurence = this.currentOccurences[this.activeLinkDecorationId];
                if (occurence) {
                    this.editor.changeDecorations(function (changeAccessor) {
                        occurence.deactivate(changeAccessor);
                    });
                }
                this.activeLinkDecorationId = null;
            }
        };
        LinkDetector.prototype.onEditorMouseUp = function (mouseEvent) {
            if (!this.isEnabled(mouseEvent)) {
                return;
            }
            var occurence = this.getLinkOccurence(mouseEvent.target.position);
            if (!occurence) {
                return;
            }
            this.openLinkOccurence(occurence, mouseEvent.event.altKey);
        };
        LinkDetector.prototype.openLinkOccurence = function (occurence, openToSide) {
            var _this = this;
            if (!this.openerService) {
                return;
            }
            var link = occurence.link;
            link.resolve().then(function (uri) {
                // open the uri
                return _this.openerService.open(uri, { openToSide: openToSide });
            }, function (err) {
                // different error cases
                if (err === 'invalid') {
                    _this.messageService.show(severity_1.default.Warning, nls.localize(2, null, link.url));
                }
                else if (err === 'missing') {
                    _this.messageService.show(severity_1.default.Warning, nls.localize(3, null));
                }
                else {
                    errors_1.onUnexpectedError(err);
                }
            }).done(null, errors_1.onUnexpectedError);
        };
        LinkDetector.prototype.getLinkOccurence = function (position) {
            var decorations = this.editor.getModel().getDecorationsInRange({
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            }, 0, true);
            for (var i = 0; i < decorations.length; i++) {
                var decoration = decorations[i];
                var currentOccurence = this.currentOccurences[decoration.id];
                if (currentOccurence) {
                    return currentOccurence;
                }
            }
            return null;
        };
        LinkDetector.prototype.isEnabled = function (mouseEvent, withKey) {
            return mouseEvent.target.type === editorCommon.MouseTargetType.CONTENT_TEXT &&
                (mouseEvent.event[LinkDetector_1.TRIGGER_MODIFIER] || (withKey && withKey.keyCode === LinkDetector_1.TRIGGER_KEY_VALUE));
        };
        LinkDetector.prototype.stop = function () {
            if (this.timeoutPromise) {
                this.timeoutPromise.cancel();
                this.timeoutPromise = null;
            }
            if (this.computePromise) {
                this.computePromise.cancel();
                this.computePromise = null;
            }
        };
        LinkDetector.prototype.dispose = function () {
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.stop();
        };
        return LinkDetector;
    }());
    LinkDetector.ID = 'editor.linkDetector';
    LinkDetector.RECOMPUTE_TIME = 1000; // ms
    LinkDetector.TRIGGER_KEY_VALUE = platform.isMacintosh ? 57 /* Meta */ : 5 /* Ctrl */;
    LinkDetector.TRIGGER_MODIFIER = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
    LinkDetector.HOVER_MESSAGE_GENERAL = platform.isMacintosh ? nls.localize(0, null) : nls.localize(1, null);
    LinkDetector.CLASS_NAME = 'detected-link';
    LinkDetector.CLASS_NAME_ACTIVE = 'detected-link-active';
    LinkDetector = LinkDetector_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, opener_1.IOpenerService),
        __param(2, message_1.IMessageService),
        __param(3, editorWorkerService_1.IEditorWorkerService)
    ], LinkDetector);
    var OpenLinkAction = (function (_super) {
        __extends(OpenLinkAction, _super);
        function OpenLinkAction() {
            return _super.call(this, {
                id: 'editor.action.openLink',
                label: nls.localize(4, null),
                alias: 'Open Link',
                precondition: null
            }) || this;
        }
        OpenLinkAction.prototype.run = function (accessor, editor) {
            var linkDetector = LinkDetector.get(editor);
            if (!linkDetector) {
                return;
            }
            var link = linkDetector.getLinkOccurence(editor.getPosition());
            if (link) {
                linkDetector.openLinkOccurence(link, false);
            }
        };
        return OpenLinkAction;
    }(editorCommonExtensions_1.EditorAction));
    OpenLinkAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], OpenLinkAction);
    var LinkDetector_1;
});












define(__m[465/*vs/editor/contrib/multicursor/common/multicursor*/], __M([1/*require*/,0/*exports*/,296/*vs/nls!vs/editor/contrib/multicursor/common/multicursor*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/]), function (require, exports, nls, editorCommon_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InsertCursorAbove = (function (_super) {
        __extends(InsertCursorAbove, _super);
        function InsertCursorAbove() {
            return _super.call(this, {
                id: 'editor.action.insertCursorAbove',
                label: nls.localize(0, null),
                alias: 'Add Cursor Above',
                precondition: null,
                handlerId: editorCommon_1.Handler.AddCursorUp,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 16 /* UpArrow */,
                    linux: {
                        primary: 1024 /* Shift */ | 512 /* Alt */ | 16 /* UpArrow */,
                        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 16 /* UpArrow */]
                    }
                }
            }) || this;
        }
        return InsertCursorAbove;
    }(editorCommonExtensions_1.HandlerEditorAction));
    InsertCursorAbove = __decorate([
        editorCommonExtensions_1.editorAction
    ], InsertCursorAbove);
    var InsertCursorBelow = (function (_super) {
        __extends(InsertCursorBelow, _super);
        function InsertCursorBelow() {
            return _super.call(this, {
                id: 'editor.action.insertCursorBelow',
                label: nls.localize(1, null),
                alias: 'Add Cursor Below',
                precondition: null,
                handlerId: editorCommon_1.Handler.AddCursorDown,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 512 /* Alt */ | 18 /* DownArrow */,
                    linux: {
                        primary: 1024 /* Shift */ | 512 /* Alt */ | 18 /* DownArrow */,
                        secondary: [2048 /* CtrlCmd */ | 1024 /* Shift */ | 18 /* DownArrow */]
                    }
                }
            }) || this;
        }
        return InsertCursorBelow;
    }(editorCommonExtensions_1.HandlerEditorAction));
    InsertCursorBelow = __decorate([
        editorCommonExtensions_1.editorAction
    ], InsertCursorBelow);
    var InsertCursorAtEndOfEachLineSelected = (function (_super) {
        __extends(InsertCursorAtEndOfEachLineSelected, _super);
        function InsertCursorAtEndOfEachLineSelected() {
            return _super.call(this, {
                id: 'editor.action.insertCursorAtEndOfEachLineSelected',
                label: nls.localize(2, null),
                alias: 'Create Multiple Cursors from Selected Lines',
                precondition: null,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 39 /* KEY_I */
                }
            }) || this;
        }
        InsertCursorAtEndOfEachLineSelected.prototype.run = function (accessor, editor) {
            var selection = editor.getSelection();
            if (selection.isEmpty()) {
                return;
            }
            var model = editor.getModel();
            var newSelections = new Array();
            var selectionStart = selection.getStartPosition();
            var selectionEnd = selection.getEndPosition();
            for (var i = selectionStart.lineNumber; i <= selectionEnd.lineNumber; i++) {
                if (i !== selectionEnd.lineNumber) {
                    var currentLineMaxColumn = model.getLineMaxColumn(i);
                    newSelections.push({
                        selectionStartLineNumber: i,
                        selectionStartColumn: currentLineMaxColumn,
                        positionLineNumber: i,
                        positionColumn: currentLineMaxColumn
                    });
                }
                else if (selectionEnd.column > 0) {
                    newSelections.push({
                        selectionStartLineNumber: selectionEnd.lineNumber,
                        selectionStartColumn: selectionEnd.column,
                        positionLineNumber: selectionEnd.lineNumber,
                        positionColumn: selectionEnd.column
                    });
                }
            }
            editor.setSelections(newSelections);
        };
        return InsertCursorAtEndOfEachLineSelected;
    }(editorCommonExtensions_1.EditorAction));
    InsertCursorAtEndOfEachLineSelected = __decorate([
        editorCommonExtensions_1.editorAction
    ], InsertCursorAtEndOfEachLineSelected);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[163/*vs/editor/contrib/parameterHints/common/parameterHints*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/,18/*vs/platform/contextkey/common/contextkey*/]), function (require, exports, errors_1, editorCommonExtensions_1, modes_1, async_1, contextkey_1) {
    'use strict';
    exports.Context = {
        Visible: new contextkey_1.RawContextKey('parameterHintsVisible', false),
        MultipleSignatures: new contextkey_1.RawContextKey('parameterHintsMultipleSignatures', false),
    };
    function provideSignatureHelp(model, position) {
        var supports = modes_1.SignatureHelpProviderRegistry.ordered(model);
        var result;
        return async_1.sequence(supports.map(function (support) { return function () {
            if (result) {
                // stop when there is a result
                return;
            }
            return async_1.asWinJsPromise(function (token) { return support.provideSignatureHelp(model, position, token); }).then(function (thisResult) {
                result = thisResult;
            }, errors_1.onUnexpectedExternalError);
        }; })).then(function () { return result; });
    }
    exports.provideSignatureHelp = provideSignatureHelp;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeSignatureHelpProvider', provideSignatureHelp);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[467/*vs/editor/contrib/parameterHints/browser/parameterHintsWidget*/], __M([1/*require*/,0/*exports*/,298/*vs/nls!vs/editor/contrib/parameterHints/browser/parameterHintsWidget*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,11/*vs/base/browser/dom*/,99/*vs/base/browser/ui/aria/aria*/,15/*vs/editor/common/modes*/,21/*vs/editor/browser/editorBrowser*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,12/*vs/base/common/event*/,121/*vs/base/browser/event*/,18/*vs/platform/contextkey/common/contextkey*/,163/*vs/editor/contrib/parameterHints/common/parameterHints*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,65/*vs/editor/common/core/characterClassifier*/,400/*vs/css!vs/editor/contrib/parameterHints/browser/parameterHints*/]), function (require, exports, nls, lifecycle_1, winjs_base_1, dom, aria, modes_1, editorBrowser_1, async_1, errors_1, event_1, event_2, contextkey_1, parameterHints_1, scrollableElement_1, characterClassifier_1) {
    'use strict';
    var $ = dom.$;
    var ParameterHintsModel = (function (_super) {
        __extends(ParameterHintsModel, _super);
        function ParameterHintsModel(editor) {
            var _this = _super.call(this) || this;
            _this._onHint = _this._register(new event_1.Emitter());
            _this.onHint = _this._onHint.event;
            _this._onCancel = _this._register(new event_1.Emitter());
            _this.onCancel = _this._onCancel.event;
            _this.editor = editor;
            _this.enabled = false;
            _this.triggerCharactersListeners = [];
            _this.throttledDelayer = new async_1.RunOnceScheduler(function () { return _this.doTrigger(); }, ParameterHintsModel.DELAY);
            _this.active = false;
            _this._register(_this.editor.onDidChangeConfiguration(function () { return _this.onEditorConfigurationChange(); }));
            _this._register(_this.editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
            _this._register(_this.editor.onDidChangeModelLanguage(function (_) { return _this.onModelChanged(); }));
            _this._register(_this.editor.onDidChangeCursorSelection(function (e) { return _this.onCursorChange(e); }));
            _this._register(modes_1.SignatureHelpProviderRegistry.onDidChange(_this.onModelChanged, _this));
            _this.onEditorConfigurationChange();
            _this.onModelChanged();
            return _this;
        }
        ParameterHintsModel.prototype.cancel = function (silent) {
            if (silent === void 0) { silent = false; }
            this.active = false;
            this.throttledDelayer.cancel();
            if (!silent) {
                this._onCancel.fire(void 0);
            }
        };
        ParameterHintsModel.prototype.trigger = function (delay) {
            if (delay === void 0) { delay = ParameterHintsModel.DELAY; }
            if (!this.enabled || !modes_1.SignatureHelpProviderRegistry.has(this.editor.getModel())) {
                return;
            }
            this.cancel(true);
            return this.throttledDelayer.schedule(delay);
        };
        ParameterHintsModel.prototype.doTrigger = function () {
            var _this = this;
            parameterHints_1.provideSignatureHelp(this.editor.getModel(), this.editor.getPosition())
                .then(null, errors_1.onUnexpectedError)
                .then(function (result) {
                if (!result || result.signatures.length === 0) {
                    _this.cancel();
                    _this._onCancel.fire(void 0);
                    return false;
                }
                _this.active = true;
                var event = { hints: result };
                _this._onHint.fire(event);
                return true;
            });
        };
        ParameterHintsModel.prototype.isTriggered = function () {
            return this.active || this.throttledDelayer.isScheduled();
        };
        ParameterHintsModel.prototype.onModelChanged = function () {
            var _this = this;
            if (this.active) {
                this.cancel();
            }
            this.triggerCharactersListeners = lifecycle_1.dispose(this.triggerCharactersListeners);
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var triggerChars = new characterClassifier_1.CharacterSet();
            for (var _i = 0, _a = modes_1.SignatureHelpProviderRegistry.ordered(model); _i < _a.length; _i++) {
                var support = _a[_i];
                if (Array.isArray(support.signatureHelpTriggerCharacters)) {
                    for (var _b = 0, _c = support.signatureHelpTriggerCharacters; _b < _c.length; _b++) {
                        var ch = _c[_b];
                        triggerChars.add(ch.charCodeAt(0));
                    }
                }
            }
            this.triggerCharactersListeners.push(this.editor.onDidType(function (text) {
                var lastCharCode = text.charCodeAt(text.length - 1);
                if (triggerChars.has(lastCharCode)) {
                    _this.trigger();
                }
            }));
        };
        ParameterHintsModel.prototype.onCursorChange = function (e) {
            if (e.source === 'mouse') {
                this.cancel();
            }
            else if (this.isTriggered()) {
                this.trigger();
            }
        };
        ParameterHintsModel.prototype.onEditorConfigurationChange = function () {
            this.enabled = this.editor.getConfiguration().contribInfo.parameterHints;
            if (!this.enabled) {
                this.cancel();
            }
        };
        ParameterHintsModel.prototype.dispose = function () {
            this.cancel(true);
            this.triggerCharactersListeners = lifecycle_1.dispose(this.triggerCharactersListeners);
            _super.prototype.dispose.call(this);
        };
        return ParameterHintsModel;
    }(lifecycle_1.Disposable));
    ParameterHintsModel.DELAY = 120; // ms
    exports.ParameterHintsModel = ParameterHintsModel;
    var ParameterHintsWidget = (function () {
        function ParameterHintsWidget(editor, contextKeyService) {
            var _this = this;
            this.editor = editor;
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this.model = new ParameterHintsModel(editor);
            this.keyVisible = parameterHints_1.Context.Visible.bindTo(contextKeyService);
            this.keyMultipleSignatures = parameterHints_1.Context.MultipleSignatures.bindTo(contextKeyService);
            this.visible = false;
            this.disposables = [];
            this.disposables.push(this.model.onHint(function (e) {
                _this.show();
                _this.hints = e.hints;
                _this.currentSignature = e.hints.activeSignature;
                _this.render();
            }));
            this.disposables.push(this.model.onCancel(function () {
                _this.hide();
            }));
            this.element = $('.editor-widget.parameter-hints-widget');
            var wrapper = dom.append(this.element, $('.wrapper'));
            var onClick = event_2.stop(event_2.domEvent(this.element, 'click'));
            onClick(this.next, this, this.disposables);
            var buttons = dom.append(wrapper, $('.buttons'));
            var previous = dom.append(buttons, $('.button.previous'));
            var next = dom.append(buttons, $('.button.next'));
            var onPreviousClick = event_2.stop(event_2.domEvent(previous, 'click'));
            onPreviousClick(this.previous, this, this.disposables);
            var onNextClick = event_2.stop(event_2.domEvent(next, 'click'));
            onNextClick(this.next, this, this.disposables);
            this.overloads = dom.append(wrapper, $('.overloads'));
            var body = $('.body');
            this.scrollbar = new scrollableElement_1.DomScrollableElement(body, { canUseTranslate3d: false });
            this.disposables.push(this.scrollbar);
            wrapper.appendChild(this.scrollbar.getDomNode());
            this.signature = dom.append(body, $('.signature'));
            this.docs = dom.append(body, $('.docs'));
            this.currentSignature = 0;
            this.editor.addContentWidget(this);
            this.hide();
            this.disposables.push(this.editor.onDidChangeCursorSelection(function (e) {
                if (_this.visible) {
                    _this.editor.layoutContentWidget(_this);
                }
            }));
            var updateFont = function () {
                var fontInfo = _this.editor.getConfiguration().fontInfo;
                _this.element.style.fontSize = fontInfo.fontSize + "px";
            };
            updateFont();
            event_1.chain(this.editor.onDidChangeConfiguration.bind(this.editor))
                .filter(function (e) { return e.fontInfo; })
                .on(updateFont, null, this.disposables);
            this.disposables.push(this.editor.onDidLayoutChange(function (e) { return _this.updateMaxHeight(); }));
            this.updateMaxHeight();
        }
        ParameterHintsWidget.prototype.show = function () {
            var _this = this;
            if (!this.model || this.visible) {
                return;
            }
            this.keyVisible.set(true);
            this.visible = true;
            winjs_base_1.TPromise.timeout(100).done(function () { return dom.addClass(_this.element, 'visible'); });
            this.editor.layoutContentWidget(this);
        };
        ParameterHintsWidget.prototype.hide = function () {
            if (!this.model || !this.visible) {
                return;
            }
            this.keyVisible.reset();
            this.visible = false;
            this.hints = null;
            this.announcedLabel = null;
            dom.removeClass(this.element, 'visible');
            this.editor.layoutContentWidget(this);
        };
        ParameterHintsWidget.prototype.getPosition = function () {
            if (this.visible) {
                return {
                    position: this.editor.getPosition(),
                    preference: [editorBrowser_1.ContentWidgetPositionPreference.ABOVE, editorBrowser_1.ContentWidgetPositionPreference.BELOW]
                };
            }
            return null;
        };
        ParameterHintsWidget.prototype.render = function () {
            var multiple = this.hints.signatures.length > 1;
            dom.toggleClass(this.element, 'multiple', multiple);
            this.keyMultipleSignatures.set(multiple);
            this.signature.innerHTML = '';
            this.docs.innerHTML = '';
            var signature = this.hints.signatures[this.currentSignature];
            if (!signature) {
                return;
            }
            var code = dom.append(this.signature, $('.code'));
            var hasParameters = signature.parameters.length > 0;
            var fontInfo = this.editor.getConfiguration().fontInfo;
            code.style.fontSize = fontInfo.fontSize + "px";
            code.style.fontFamily = fontInfo.fontFamily;
            if (!hasParameters) {
                var label = dom.append(code, $('span'));
                label.textContent = signature.label;
            }
            else {
                this.renderParameters(code, signature, this.hints.activeParameter);
            }
            var activeParameter = signature.parameters[this.hints.activeParameter];
            if (activeParameter && activeParameter.documentation) {
                var documentation = $('span.documentation');
                documentation.textContent = activeParameter.documentation;
                dom.append(this.docs, $('p', null, documentation));
            }
            dom.toggleClass(this.signature, 'has-docs', !!signature.documentation);
            if (signature.documentation) {
                dom.append(this.docs, $('p', null, signature.documentation));
            }
            var currentOverload = String(this.currentSignature + 1);
            if (this.hints.signatures.length < 10) {
                currentOverload += "/" + this.hints.signatures.length;
            }
            this.overloads.textContent = currentOverload;
            if (activeParameter) {
                var labelToAnnounce = activeParameter.label;
                // Select method gets called on every user type while parameter hints are visible.
                // We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
                if (this.announcedLabel !== labelToAnnounce) {
                    aria.alert(nls.localize(0, null, labelToAnnounce));
                    this.announcedLabel = labelToAnnounce;
                }
            }
            this.editor.layoutContentWidget(this);
            this.scrollbar.scanDomNode();
        };
        ParameterHintsWidget.prototype.renderParameters = function (parent, signature, currentParameter) {
            var end = signature.label.length;
            var idx = 0;
            var element;
            for (var i = signature.parameters.length - 1; i >= 0; i--) {
                var parameter = signature.parameters[i];
                idx = signature.label.lastIndexOf(parameter.label, end);
                var signatureLabelOffset = 0;
                var signatureLabelEnd = 0;
                if (idx >= 0) {
                    signatureLabelOffset = idx;
                    signatureLabelEnd = idx + parameter.label.length;
                }
                // non parameter part
                element = document.createElement('span');
                element.textContent = signature.label.substring(signatureLabelEnd, end);
                dom.prepend(parent, element);
                // parameter part
                element = document.createElement('span');
                element.className = "parameter " + (i === currentParameter ? 'active' : '');
                element.textContent = signature.label.substring(signatureLabelOffset, signatureLabelEnd);
                dom.prepend(parent, element);
                end = signatureLabelOffset;
            }
            // non parameter part
            element = document.createElement('span');
            element.textContent = signature.label.substring(0, end);
            dom.prepend(parent, element);
        };
        // private select(position: number): void {
        // 	const signature = this.signatureViews[position];
        // 	if (!signature) {
        // 		return;
        // 	}
        // 	this.signatures.style.height = `${ signature.height }px`;
        // 	this.signatures.scrollTop = signature.top;
        // 	let overloads = '' + (position + 1);
        // 	if (this.signatureViews.length < 10) {
        // 		overloads += '/' + this.signatureViews.length;
        // 	}
        // 	this.overloads.textContent = overloads;
        // 	if (this.hints && this.hints.signatures[position].parameters[this.hints.activeParameter]) {
        // 		const labelToAnnounce = this.hints.signatures[position].parameters[this.hints.activeParameter].label;
        // 		// Select method gets called on every user type while parameter hints are visible.
        // 		// We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
        // 		if (this.announcedLabel !== labelToAnnounce) {
        // 			aria.alert(nls.localize('hint', "{0}, hint", labelToAnnounce));
        // 			this.announcedLabel = labelToAnnounce;
        // 		}
        // 	}
        // 	this.editor.layoutContentWidget(this);
        // }
        ParameterHintsWidget.prototype.next = function () {
            var length = this.hints.signatures.length;
            if (length < 2) {
                this.cancel();
                return false;
            }
            this.currentSignature = (this.currentSignature + 1) % length;
            this.render();
            return true;
        };
        ParameterHintsWidget.prototype.previous = function () {
            var length = this.hints.signatures.length;
            if (length < 2) {
                this.cancel();
                return false;
            }
            this.currentSignature = (this.currentSignature - 1 + length) % length;
            this.render();
            return true;
        };
        ParameterHintsWidget.prototype.cancel = function () {
            this.model.cancel();
        };
        ParameterHintsWidget.prototype.getDomNode = function () {
            return this.element;
        };
        ParameterHintsWidget.prototype.getId = function () {
            return ParameterHintsWidget.ID;
        };
        ParameterHintsWidget.prototype.trigger = function () {
            this.model.trigger(0);
        };
        ParameterHintsWidget.prototype.updateMaxHeight = function () {
            var height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
            this.element.style.maxHeight = height + "px";
        };
        ParameterHintsWidget.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            this.model = null;
        };
        return ParameterHintsWidget;
    }());
    ParameterHintsWidget.ID = 'editor.widget.parameterHintsWidget';
    ParameterHintsWidget = __decorate([
        __param(1, contextkey_1.IContextKeyService)
    ], ParameterHintsWidget);
    exports.ParameterHintsWidget = ParameterHintsWidget;
});















define(__m[468/*vs/editor/contrib/parameterHints/browser/parameterHints*/], __M([1/*require*/,0/*exports*/,297/*vs/nls!vs/editor/contrib/parameterHints/browser/parameterHints*/,3/*vs/base/common/lifecycle*/,14/*vs/platform/instantiation/common/instantiation*/,2/*vs/editor/common/editorCommon*/,18/*vs/platform/contextkey/common/contextkey*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,467/*vs/editor/contrib/parameterHints/browser/parameterHintsWidget*/,163/*vs/editor/contrib/parameterHints/common/parameterHints*/]), function (require, exports, nls, lifecycle_1, instantiation_1, editorCommon_1, contextkey_1, editorCommonExtensions_1, editorBrowserExtensions_1, parameterHintsWidget_1, parameterHints_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ParameterHintsController = ParameterHintsController_1 = (function () {
        function ParameterHintsController(editor, instantiationService) {
            this.editor = editor;
            this.widget = instantiationService.createInstance(parameterHintsWidget_1.ParameterHintsWidget, this.editor);
        }
        ParameterHintsController.get = function (editor) {
            return editor.getContribution(ParameterHintsController_1.ID);
        };
        ParameterHintsController.prototype.getId = function () {
            return ParameterHintsController_1.ID;
        };
        ParameterHintsController.prototype.cancel = function () {
            this.widget.cancel();
        };
        ParameterHintsController.prototype.previous = function () {
            this.widget.previous();
        };
        ParameterHintsController.prototype.next = function () {
            this.widget.next();
        };
        ParameterHintsController.prototype.trigger = function () {
            this.widget.trigger();
        };
        ParameterHintsController.prototype.dispose = function () {
            this.widget = lifecycle_1.dispose(this.widget);
        };
        return ParameterHintsController;
    }());
    ParameterHintsController.ID = 'editor.controller.parameterHints';
    ParameterHintsController = ParameterHintsController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, instantiation_1.IInstantiationService)
    ], ParameterHintsController);
    var TriggerParameterHintsAction = (function (_super) {
        __extends(TriggerParameterHintsAction, _super);
        function TriggerParameterHintsAction() {
            return _super.call(this, {
                id: 'editor.action.triggerParameterHints',
                label: nls.localize(0, null),
                alias: 'Trigger Parameter Hints',
                precondition: editorCommon_1.ModeContextKeys.hasSignatureHelpProvider,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 10 /* Space */
                }
            }) || this;
        }
        TriggerParameterHintsAction.prototype.run = function (accessor, editor) {
            var controller = ParameterHintsController.get(editor);
            if (controller) {
                controller.trigger();
            }
        };
        return TriggerParameterHintsAction;
    }(editorCommonExtensions_1.EditorAction));
    TriggerParameterHintsAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], TriggerParameterHintsAction);
    exports.TriggerParameterHintsAction = TriggerParameterHintsAction;
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(75);
    var ParameterHintsCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(ParameterHintsController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new ParameterHintsCommand({
        id: 'closeParameterHints',
        precondition: parameterHints_1.Context.Visible,
        handler: function (x) { return x.cancel(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new ParameterHintsCommand({
        id: 'showPrevParameterHint',
        precondition: contextkey_1.ContextKeyExpr.and(parameterHints_1.Context.Visible, parameterHints_1.Context.MultipleSignatures),
        handler: function (x) { return x.previous(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 16 /* UpArrow */,
            secondary: [512 /* Alt */ | 16 /* UpArrow */],
            mac: { primary: 16 /* UpArrow */, secondary: [512 /* Alt */ | 16 /* UpArrow */, 256 /* WinCtrl */ | 46 /* KEY_P */] }
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new ParameterHintsCommand({
        id: 'showNextParameterHint',
        precondition: contextkey_1.ContextKeyExpr.and(parameterHints_1.Context.Visible, parameterHints_1.Context.MultipleSignatures),
        handler: function (x) { return x.next(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 18 /* DownArrow */,
            secondary: [512 /* Alt */ | 18 /* DownArrow */],
            mac: { primary: 18 /* DownArrow */, secondary: [512 /* Alt */ | 18 /* DownArrow */, 256 /* WinCtrl */ | 44 /* KEY_N */] }
        }
    }));
    var ParameterHintsController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[469/*vs/editor/contrib/quickFix/common/quickFix*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,43/*vs/editor/common/services/modelService*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getCodeActions(model, range) {
        var allResults = [];
        var promises = modes_1.CodeActionProviderRegistry.all(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) { return support.provideCodeActions(model, range, token); }).then(function (result) {
                if (Array.isArray(result)) {
                    allResults.push.apply(allResults, result);
                }
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return allResults; });
    }
    exports.getCodeActions = getCodeActions;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeActionProvider', function (accessor, args) {
        var resource = args.resource, range = args.range;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        return getCodeActions(model, model.validateRange(range));
    });
});

define(__m[470/*vs/editor/contrib/quickFix/common/quickFixModel*/], __M([1/*require*/,0/*exports*/,28/*vs/base/common/arrays*/,12/*vs/base/common/event*/,30/*vs/base/common/severity*/,3/*vs/base/common/lifecycle*/,4/*vs/editor/common/core/range*/,15/*vs/editor/common/modes*/,469/*vs/editor/contrib/quickFix/common/quickFix*/]), function (require, exports, arrays, event_1, severity_1, lifecycle_1, range_1, modes_1, quickFix_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickFixOracle = (function () {
        function QuickFixOracle(_editor, _markerService, _signalChange) {
            var _this = this;
            this._editor = _editor;
            this._markerService = _markerService;
            this._signalChange = _signalChange;
            this._disposables = [];
            this._disposables.push(this._markerService.onMarkerChanged(function (e) { return _this._onMarkerChanges(e); }), this._editor.onDidChangeCursorPosition(function (e) { return _this._onCursorChange(); }));
        }
        QuickFixOracle.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        QuickFixOracle.prototype.trigger = function () {
            var _a = this._rangeAtPosition(), range = _a.range, severity = _a.severity;
            if (!range) {
                range = this._editor.getSelection();
            }
            this._signalChange({
                type: 'manual',
                severity: severity,
                range: range,
                position: this._editor.getPosition(),
                fixes: range && quickFix_1.getCodeActions(this._editor.getModel(), this._editor.getModel().validateRange(range))
            });
        };
        QuickFixOracle.prototype._onMarkerChanges = function (resources) {
            var uri = this._editor.getModel().uri;
            for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
                var resource = resources_1[_i];
                if (resource.toString() === uri.toString()) {
                    this._onCursorChange();
                    return;
                }
            }
        };
        QuickFixOracle.prototype._onCursorChange = function () {
            var _a = this._rangeAtPosition(), range = _a.range, severity = _a.severity;
            if (!range_1.Range.equalsRange(this._currentRange, range)) {
                this._currentRange = range;
                this._signalChange({
                    type: 'auto',
                    severity: severity,
                    range: range,
                    position: this._editor.getPosition(),
                    fixes: range && quickFix_1.getCodeActions(this._editor.getModel(), this._editor.getModel().validateRange(range))
                });
            }
        };
        QuickFixOracle.prototype._rangeAtPosition = function () {
            var range;
            var severity;
            var marker = this._markerAtPosition();
            if (marker) {
                range = range_1.Range.lift(marker);
                severity = marker.severity;
            }
            else {
                range = this._wordAtPosition();
                severity = severity_1.default.Info;
            }
            return { range: range, severity: severity };
        };
        QuickFixOracle.prototype._markerAtPosition = function () {
            var position = this._editor.getPosition();
            var uri = this._editor.getModel().uri;
            var markers = this._markerService.read({ resource: uri }).sort(range_1.Range.compareRangesUsingStarts);
            var idx = arrays.findFirst(markers, function (marker) { return marker.endLineNumber >= position.lineNumber; });
            while (idx < markers.length && markers[idx].endLineNumber >= position.lineNumber) {
                var marker = markers[idx];
                if (range_1.Range.containsPosition(marker, position)) {
                    return marker;
                }
                idx++;
            }
        };
        QuickFixOracle.prototype._wordAtPosition = function () {
            var _a = this._editor.getSelection(), positionLineNumber = _a.positionLineNumber, positionColumn = _a.positionColumn;
            var model = this._editor.getModel();
            var info = model.getWordAtPosition({ lineNumber: positionLineNumber, column: positionColumn });
            if (info) {
                return {
                    startLineNumber: positionLineNumber,
                    startColumn: info.startColumn,
                    endLineNumber: positionLineNumber,
                    endColumn: info.endColumn
                };
            }
        };
        return QuickFixOracle;
    }());
    exports.QuickFixOracle = QuickFixOracle;
    var QuickFixModel = (function () {
        function QuickFixModel(editor, markerService) {
            var _this = this;
            this._onDidChangeFixes = new event_1.Emitter();
            this._disposables = [];
            this._editor = editor;
            this._markerService = markerService;
            this._disposables.push(this._editor.onDidChangeModel(function () { return _this._update(); }));
            this._disposables.push(this._editor.onDidChangeModelLanguage(function () { return _this._update(); }));
            this._disposables.push(modes_1.CodeActionProviderRegistry.onDidChange(this._update, this));
            this._update();
        }
        QuickFixModel.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
            lifecycle_1.dispose(this._quickFixOracle);
        };
        Object.defineProperty(QuickFixModel.prototype, "onDidChangeFixes", {
            get: function () {
                return this._onDidChangeFixes.event;
            },
            enumerable: true,
            configurable: true
        });
        QuickFixModel.prototype._update = function () {
            var _this = this;
            if (this._quickFixOracle) {
                this._quickFixOracle.dispose();
                this._quickFixOracle = undefined;
                this._onDidChangeFixes.fire(undefined);
            }
            if (this._editor.getModel()
                && modes_1.CodeActionProviderRegistry.has(this._editor.getModel())
                && !this._editor.getConfiguration().readOnly) {
                this._quickFixOracle = new QuickFixOracle(this._editor, this._markerService, function (p) { return _this._onDidChangeFixes.fire(p); });
            }
        };
        QuickFixModel.prototype.triggerManual = function () {
            if (this._quickFixOracle) {
                this._quickFixOracle.trigger();
            }
        };
        return QuickFixModel;
    }());
    exports.QuickFixModel = QuickFixModel;
});















define(__m[471/*vs/editor/contrib/quickFix/browser/quickFix*/], __M([1/*require*/,0/*exports*/,299/*vs/nls!vs/editor/contrib/quickFix/browser/quickFix*/,3/*vs/base/common/lifecycle*/,22/*vs/platform/commands/common/commands*/,58/*vs/platform/contextview/browser/contextView*/,18/*vs/platform/contextkey/common/contextkey*/,42/*vs/platform/keybinding/common/keybinding*/,72/*vs/platform/markers/common/markers*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,232/*vs/editor/contrib/quickFix/browser/quickFixWidget*/,258/*vs/editor/contrib/quickFix/browser/lightBulbWidget*/,470/*vs/editor/contrib/quickFix/common/quickFixModel*/]), function (require, exports, nls, lifecycle_1, commands_1, contextView_1, contextkey_1, keybinding_1, markers_1, editorCommon_1, editorCommonExtensions_1, editorBrowserExtensions_1, quickFixWidget_1, lightBulbWidget_1, quickFixModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickFixController = QuickFixController_1 = (function () {
        function QuickFixController(editor, markerService, contextKeyService, commandService, contextMenuService, _keybindingService) {
            var _this = this;
            this._keybindingService = _keybindingService;
            this._disposables = [];
            this._editor = editor;
            this._model = new quickFixModel_1.QuickFixModel(this._editor, markerService);
            this._quickFixContextMenu = new quickFixWidget_1.QuickFixContextMenu(editor, contextMenuService, commandService);
            this._lightBulbWidget = new lightBulbWidget_1.LightBulbWidget(editor);
            this._updateLightBulbTitle();
            this._disposables.push(this._lightBulbWidget.onClick(this._handleLightBulbSelect, this), this._model.onDidChangeFixes(function (e) { return _this._onQuickFixEvent(e); }), this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitle, this));
        }
        QuickFixController.get = function (editor) {
            return editor.getContribution(QuickFixController_1.ID);
        };
        QuickFixController.prototype.dispose = function () {
            this._model.dispose();
            lifecycle_1.dispose(this._disposables);
        };
        QuickFixController.prototype._onQuickFixEvent = function (e) {
            if (e && e.type === 'manual') {
                this._quickFixContextMenu.show(e.fixes, e.position);
            }
            else if (e && e.fixes) {
                // auto magically triggered
                // * update an existing list of code actions
                // * manage light bulb
                if (this._quickFixContextMenu.isVisible) {
                    this._quickFixContextMenu.show(e.fixes, e.position);
                }
                else {
                    this._lightBulbWidget.model = e;
                }
            }
            else {
                this._lightBulbWidget.hide();
            }
        };
        QuickFixController.prototype.getId = function () {
            return QuickFixController_1.ID;
        };
        QuickFixController.prototype._handleLightBulbSelect = function (coords) {
            this._quickFixContextMenu.show(this._lightBulbWidget.model.fixes, coords);
        };
        QuickFixController.prototype.triggerFromEditorSelection = function () {
            this._model.triggerManual();
        };
        QuickFixController.prototype._updateLightBulbTitle = function () {
            var kb = this._keybindingService.lookupKeybindings(QuickFixAction.Id)[0];
            var title;
            if (kb) {
                title = nls.localize(0, null, this._keybindingService.getLabelFor(kb));
            }
            else {
                title = nls.localize(1, null);
            }
            this._lightBulbWidget.getDomNode().title = title;
        };
        return QuickFixController;
    }());
    QuickFixController.ID = 'editor.contrib.quickFixController';
    QuickFixController = QuickFixController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, markers_1.IMarkerService),
        __param(2, contextkey_1.IContextKeyService),
        __param(3, commands_1.ICommandService),
        __param(4, contextView_1.IContextMenuService),
        __param(5, keybinding_1.IKeybindingService)
    ], QuickFixController);
    exports.QuickFixController = QuickFixController;
    var QuickFixAction = QuickFixAction_1 = (function (_super) {
        __extends(QuickFixAction, _super);
        function QuickFixAction() {
            return _super.call(this, {
                id: QuickFixAction_1.Id,
                label: nls.localize(2, null),
                alias: 'Quick Fix',
                precondition: contextkey_1.ContextKeyExpr.and(editorCommon_1.EditorContextKeys.Writable, editorCommon_1.ModeContextKeys.hasCodeActionsProvider),
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 84 /* US_DOT */
                }
            }) || this;
        }
        QuickFixAction.prototype.run = function (accessor, editor) {
            var controller = QuickFixController.get(editor);
            if (controller) {
                controller.triggerFromEditorSelection();
            }
        };
        return QuickFixAction;
    }(editorCommonExtensions_1.EditorAction));
    QuickFixAction.Id = 'editor.action.quickFix';
    QuickFixAction = QuickFixAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], QuickFixAction);
    exports.QuickFixAction = QuickFixAction;
    var QuickFixController_1, QuickFixAction_1;
});












define(__m[118/*vs/editor/contrib/quickOpen/browser/editorQuickOpen*/], __M([1/*require*/,0/*exports*/,26/*vs/editor/browser/editorBrowserExtensions*/,266/*vs/editor/contrib/quickOpen/browser/quickOpenEditorWidget*/,13/*vs/editor/common/editorCommonExtensions*/]), function (require, exports, editorBrowserExtensions_1, quickOpenEditorWidget_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenController = QuickOpenController_1 = (function () {
        function QuickOpenController(editor) {
            this.editor = editor;
        }
        QuickOpenController.get = function (editor) {
            return editor.getContribution(QuickOpenController_1.ID);
        };
        QuickOpenController.prototype.getId = function () {
            return QuickOpenController_1.ID;
        };
        QuickOpenController.prototype.dispose = function () {
            // Dispose widget
            if (this.widget) {
                this.widget.destroy();
                this.widget = null;
            }
        };
        QuickOpenController.prototype.run = function (opts) {
            var _this = this;
            if (this.widget) {
                this.widget.destroy();
                this.widget = null;
            }
            // Create goto line widget
            var onClose = function (canceled) {
                // Clear Highlight Decorations if present
                _this.clearDecorations();
                // Restore selection if canceled
                if (canceled && _this.lastKnownEditorSelection) {
                    _this.editor.setSelection(_this.lastKnownEditorSelection);
                    _this.editor.revealRangeInCenterIfOutsideViewport(_this.lastKnownEditorSelection);
                }
                _this.lastKnownEditorSelection = null;
                _this.editor.focus();
            };
            this.widget = new quickOpenEditorWidget_1.QuickOpenEditorWidget(this.editor, function () { return onClose(false); }, function () { return onClose(true); }, function (value) {
                _this.widget.setInput(opts.getModel(value), opts.getAutoFocus(value));
            }, {
                inputAriaLabel: opts.inputAriaLabel
            });
            // Remember selection to be able to restore on cancel
            if (!this.lastKnownEditorSelection) {
                this.lastKnownEditorSelection = this.editor.getSelection();
            }
            // Show
            this.widget.show('');
        };
        QuickOpenController.prototype.decorateLine = function (range, editor) {
            var _this = this;
            editor.changeDecorations(function (changeAccessor) {
                var oldDecorations = [];
                if (_this.rangeHighlightDecorationId) {
                    oldDecorations.push(_this.rangeHighlightDecorationId);
                    _this.rangeHighlightDecorationId = null;
                }
                var newDecorations = [
                    {
                        range: range,
                        options: {
                            className: 'rangeHighlight',
                            isWholeLine: true
                        }
                    }
                ];
                var decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
                _this.rangeHighlightDecorationId = decorations[0];
            });
        };
        QuickOpenController.prototype.clearDecorations = function () {
            var _this = this;
            if (this.rangeHighlightDecorationId) {
                this.editor.changeDecorations(function (changeAccessor) {
                    changeAccessor.deltaDecorations([_this.rangeHighlightDecorationId], []);
                    _this.rangeHighlightDecorationId = null;
                });
            }
        };
        return QuickOpenController;
    }());
    QuickOpenController.ID = 'editor.controller.quickOpenController';
    QuickOpenController = QuickOpenController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution
    ], QuickOpenController);
    exports.QuickOpenController = QuickOpenController;
    /**
     * Base class for providing quick open in the editor.
     */
    var BaseEditorQuickOpenAction = (function (_super) {
        __extends(BaseEditorQuickOpenAction, _super);
        function BaseEditorQuickOpenAction(inputAriaLabel, opts) {
            var _this = _super.call(this, opts) || this;
            _this._inputAriaLabel = inputAriaLabel;
            return _this;
        }
        BaseEditorQuickOpenAction.prototype.getController = function (editor) {
            return QuickOpenController.get(editor);
        };
        BaseEditorQuickOpenAction.prototype._show = function (controller, opts) {
            controller.run({
                inputAriaLabel: this._inputAriaLabel,
                getModel: function (value) { return opts.getModel(value); },
                getAutoFocus: function (searchValue) { return opts.getAutoFocus(searchValue); }
            });
        };
        return BaseEditorQuickOpenAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.BaseEditorQuickOpenAction = BaseEditorQuickOpenAction;
    var QuickOpenController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[473/*vs/editor/contrib/quickOpen/browser/gotoLine*/], __M([1/*require*/,0/*exports*/,300/*vs/nls!vs/editor/contrib/quickOpen/browser/gotoLine*/,105/*vs/base/parts/quickopen/browser/quickOpenModel*/,84/*vs/base/parts/quickopen/common/quickOpen*/,2/*vs/editor/common/editorCommon*/,118/*vs/editor/contrib/quickOpen/browser/editorQuickOpen*/,13/*vs/editor/common/editorCommonExtensions*/,403/*vs/css!vs/editor/contrib/quickOpen/browser/gotoLine*/]), function (require, exports, nls, quickOpenModel_1, quickOpen_1, editorCommon, editorQuickOpen_1, editorCommonExtensions_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var GotoLineEntry = (function (_super) {
        __extends(GotoLineEntry, _super);
        function GotoLineEntry(line, editor, decorator) {
            var _this = _super.call(this) || this;
            _this.editor = editor;
            _this.decorator = decorator;
            _this._parseResult = _this._parseInput(line);
            return _this;
        }
        GotoLineEntry.prototype._parseInput = function (line) {
            var numbers = line.split(',').map(function (part) { return parseInt(part, 10); }).filter(function (part) { return !isNaN(part); }), position;
            if (numbers.length === 0) {
                position = { lineNumber: -1, column: -1 };
            }
            else if (numbers.length === 1) {
                position = { lineNumber: numbers[0], column: 1 };
            }
            else {
                position = { lineNumber: numbers[0], column: numbers[1] };
            }
            var editorType = this.editor.getEditorType(), model;
            switch (editorType) {
                case editorCommon.EditorType.IDiffEditor:
                    model = this.editor.getModel().modified;
                    break;
                case editorCommon.EditorType.ICodeEditor:
                    model = this.editor.getModel();
                    break;
                default:
                    throw new Error();
            }
            var isValid = model.validatePosition(position).equals(position), label;
            if (isValid) {
                if (position.column && position.column > 1) {
                    label = nls.localize(0, null, position.lineNumber, position.column);
                }
                else {
                    label = nls.localize(1, null, position.lineNumber, position.column);
                }
            }
            else if (position.lineNumber < 1 || position.lineNumber > model.getLineCount()) {
                label = nls.localize(2, null, model.getLineCount());
            }
            else {
                label = nls.localize(3, null, model.getLineMaxColumn(position.lineNumber));
            }
            return {
                position: position,
                isValid: isValid,
                label: label
            };
        };
        GotoLineEntry.prototype.getLabel = function () {
            return this._parseResult.label;
        };
        GotoLineEntry.prototype.getAriaLabel = function () {
            return nls.localize(4, null, this._parseResult.label);
        };
        GotoLineEntry.prototype.run = function (mode, context) {
            if (mode === quickOpen_1.Mode.OPEN) {
                return this.runOpen();
            }
            return this.runPreview();
        };
        GotoLineEntry.prototype.runOpen = function () {
            // No-op if range is not valid
            if (!this._parseResult.isValid) {
                return false;
            }
            // Apply selection and focus
            var range = this.toSelection();
            this.editor.setSelection(range);
            this.editor.revealRangeInCenter(range);
            this.editor.focus();
            return true;
        };
        GotoLineEntry.prototype.runPreview = function () {
            // No-op if range is not valid
            if (!this._parseResult.isValid) {
                this.decorator.clearDecorations();
                return false;
            }
            // Select Line Position
            var range = this.toSelection();
            this.editor.revealRangeInCenter(range);
            // Decorate if possible
            this.decorator.decorateLine(range, this.editor);
            return false;
        };
        GotoLineEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this._parseResult.position.lineNumber,
                startColumn: this._parseResult.position.column,
                endLineNumber: this._parseResult.position.lineNumber,
                endColumn: this._parseResult.position.column
            };
        };
        return GotoLineEntry;
    }(quickOpenModel_1.QuickOpenEntry));
    exports.GotoLineEntry = GotoLineEntry;
    var GotoLineAction = (function (_super) {
        __extends(GotoLineAction, _super);
        function GotoLineAction() {
            return _super.call(this, nls.localize(5, null), {
                id: 'editor.action.gotoLine',
                label: nls.localize(6, null),
                alias: 'Go to Line...',
                precondition: null,
                kbOpts: {
                    kbExpr: EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 37 /* KEY_G */,
                    mac: { primary: 256 /* WinCtrl */ | 37 /* KEY_G */ }
                }
            }) || this;
        }
        GotoLineAction.prototype.run = function (accessor, editor) {
            var _this = this;
            this._show(this.getController(editor), {
                getModel: function (value) {
                    return new quickOpenModel_1.QuickOpenModel([new GotoLineEntry(value, editor, _this.getController(editor))]);
                },
                getAutoFocus: function (searchValue) {
                    return {
                        autoFocusFirstEntry: searchValue.length > 0
                    };
                }
            });
        };
        return GotoLineAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    GotoLineAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], GotoLineAction);
    exports.GotoLineAction = GotoLineAction;
});












define(__m[474/*vs/editor/contrib/quickOpen/browser/quickCommand*/], __M([1/*require*/,0/*exports*/,301/*vs/nls!vs/editor/contrib/quickOpen/browser/quickCommand*/,10/*vs/base/common/errors*/,86/*vs/base/common/filters*/,6/*vs/base/common/winjs.base*/,105/*vs/base/parts/quickopen/browser/quickOpenModel*/,84/*vs/base/parts/quickopen/common/quickOpen*/,42/*vs/platform/keybinding/common/keybinding*/,2/*vs/editor/common/editorCommon*/,118/*vs/editor/contrib/quickOpen/browser/editorQuickOpen*/,13/*vs/editor/common/editorCommonExtensions*/,23/*vs/base/browser/browser*/]), function (require, exports, nls, errors_1, filters_1, winjs_base_1, quickOpenModel_1, quickOpen_1, keybinding_1, editorCommon_1, editorQuickOpen_1, editorCommonExtensions_1, browser) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorActionCommandEntry = (function (_super) {
        __extends(EditorActionCommandEntry, _super);
        function EditorActionCommandEntry(key, highlights, action, editor) {
            var _this = _super.call(this) || this;
            _this.key = key;
            _this.setHighlights(highlights);
            _this.action = action;
            _this.editor = editor;
            return _this;
        }
        EditorActionCommandEntry.prototype.getLabel = function () {
            return this.action.label;
        };
        EditorActionCommandEntry.prototype.getAriaLabel = function () {
            return nls.localize(0, null, this.getLabel());
        };
        EditorActionCommandEntry.prototype.getGroupLabel = function () {
            return this.key;
        };
        EditorActionCommandEntry.prototype.run = function (mode, context) {
            var _this = this;
            if (mode === quickOpen_1.Mode.OPEN) {
                // Use a timeout to give the quick open widget a chance to close itself first
                winjs_base_1.TPromise.timeout(50).done(function () {
                    // Some actions are enabled only when editor has focus
                    _this.editor.focus();
                    try {
                        var promise = _this.action.run() || winjs_base_1.TPromise.as(null);
                        promise.done(null, errors_1.onUnexpectedError);
                    }
                    catch (error) {
                        errors_1.onUnexpectedError(error);
                    }
                }, errors_1.onUnexpectedError);
                return true;
            }
            return false;
        };
        return EditorActionCommandEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.EditorActionCommandEntry = EditorActionCommandEntry;
    var QuickCommandAction = (function (_super) {
        __extends(QuickCommandAction, _super);
        function QuickCommandAction() {
            return _super.call(this, nls.localize(1, null), {
                id: 'editor.action.quickCommand',
                label: nls.localize(2, null),
                alias: 'Command Palette',
                precondition: null,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.Focus,
                    primary: (browser.isIE ? 512 /* Alt */ | 59 /* F1 */ : 59 /* F1 */)
                },
                menuOpts: {}
            }) || this;
        }
        QuickCommandAction.prototype.run = function (accessor, editor) {
            var _this = this;
            var keybindingService = accessor.get(keybinding_1.IKeybindingService);
            this._show(this.getController(editor), {
                getModel: function (value) {
                    return new quickOpenModel_1.QuickOpenModel(_this._editorActionsToEntries(keybindingService, editor, value));
                },
                getAutoFocus: function (searchValue) {
                    return {
                        autoFocusFirstEntry: true,
                        autoFocusPrefixMatch: searchValue
                    };
                }
            });
        };
        QuickCommandAction.prototype._sort = function (elementA, elementB) {
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            return elementAName.localeCompare(elementBName);
        };
        QuickCommandAction.prototype._editorActionsToEntries = function (keybindingService, editor, searchValue) {
            var actions = editor.getSupportedActions();
            var entries = [];
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                var keys = keybindingService.lookupKeybindings(action.id).map(function (k) { return keybindingService.getLabelFor(k); });
                if (action.label) {
                    var highlights = filters_1.matchesFuzzy(searchValue, action.label);
                    if (highlights) {
                        entries.push(new EditorActionCommandEntry(keys.length > 0 ? keys.join(', ') : '', highlights, action, editor));
                    }
                }
            }
            // Sort by name
            entries = entries.sort(this._sort);
            return entries;
        };
        return QuickCommandAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    QuickCommandAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], QuickCommandAction);
    exports.QuickCommandAction = QuickCommandAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[475/*vs/editor/contrib/quickOpen/common/quickOpen*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,4/*vs/editor/common/core/range*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,43/*vs/editor/common/services/modelService*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getDocumentSymbols(model) {
        var entries = [];
        var promises = modes_1.DocumentSymbolProviderRegistry.all(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideDocumentSymbols(model, token);
            }).then(function (result) {
                if (Array.isArray(result)) {
                    entries.push.apply(entries, result);
                }
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () {
            var flatEntries = [];
            flatten(flatEntries, entries, '');
            flatEntries.sort(compareEntriesUsingStart);
            return {
                entries: flatEntries,
            };
        });
    }
    exports.getDocumentSymbols = getDocumentSymbols;
    function compareEntriesUsingStart(a, b) {
        return range_1.Range.compareRangesUsingStarts(range_1.Range.lift(a.location.range), range_1.Range.lift(b.location.range));
    }
    function flatten(bucket, entries, overrideContainerLabel) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            bucket.push({
                kind: entry.kind,
                location: entry.location,
                name: entry.name,
                containerName: entry.containerName || overrideContainerLabel
            });
        }
    }
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeDocumentSymbolProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentSymbols(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/











define(__m[476/*vs/editor/contrib/quickOpen/browser/quickOutline*/], __M([1/*require*/,0/*exports*/,302/*vs/nls!vs/editor/contrib/quickOpen/browser/quickOutline*/,86/*vs/base/common/filters*/,9/*vs/base/common/strings*/,105/*vs/base/parts/quickopen/browser/quickOpenModel*/,84/*vs/base/parts/quickopen/common/quickOpen*/,2/*vs/editor/common/editorCommon*/,15/*vs/editor/common/modes*/,118/*vs/editor/contrib/quickOpen/browser/editorQuickOpen*/,475/*vs/editor/contrib/quickOpen/common/quickOpen*/,13/*vs/editor/common/editorCommonExtensions*/,407/*vs/css!vs/editor/contrib/quickOpen/browser/quickOutline*/]), function (require, exports, nls, filters_1, strings, quickOpenModel_1, quickOpen_1, editorCommon_1, modes_1, editorQuickOpen_1, quickOpen_2, editorCommonExtensions_1) {
    'use strict';
    var SCOPE_PREFIX = ':';
    var SymbolEntry = (function (_super) {
        __extends(SymbolEntry, _super);
        function SymbolEntry(name, type, description, range, highlights, editor, decorator) {
            var _this = _super.call(this) || this;
            _this.name = name;
            _this.type = type;
            _this.description = description;
            _this.range = range;
            _this.setHighlights(highlights);
            _this.editor = editor;
            _this.decorator = decorator;
            return _this;
        }
        SymbolEntry.prototype.getLabel = function () {
            return this.name;
        };
        SymbolEntry.prototype.getAriaLabel = function () {
            return nls.localize(0, null, this.name);
        };
        SymbolEntry.prototype.getIcon = function () {
            return this.type;
        };
        SymbolEntry.prototype.getDescription = function () {
            return this.description;
        };
        SymbolEntry.prototype.getType = function () {
            return this.type;
        };
        SymbolEntry.prototype.getRange = function () {
            return this.range;
        };
        SymbolEntry.prototype.run = function (mode, context) {
            if (mode === quickOpen_1.Mode.OPEN) {
                return this.runOpen(context);
            }
            return this.runPreview();
        };
        SymbolEntry.prototype.runOpen = function (context) {
            // Apply selection and focus
            var range = this.toSelection();
            this.editor.setSelection(range);
            this.editor.revealRangeInCenter(range);
            this.editor.focus();
            return true;
        };
        SymbolEntry.prototype.runPreview = function () {
            // Select Outline Position
            var range = this.toSelection();
            this.editor.revealRangeInCenter(range);
            // Decorate if possible
            this.decorator.decorateLine(this.range, this.editor);
            return false;
        };
        SymbolEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this.range.startLineNumber,
                startColumn: this.range.startColumn || 1,
                endLineNumber: this.range.startLineNumber,
                endColumn: this.range.startColumn || 1
            };
        };
        return SymbolEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    var QuickOutlineAction = (function (_super) {
        __extends(QuickOutlineAction, _super);
        function QuickOutlineAction() {
            return _super.call(this, nls.localize(1, null), {
                id: 'editor.action.quickOutline',
                label: nls.localize(2, null),
                alias: 'Go to Symbol...',
                precondition: editorCommon_1.ModeContextKeys.hasDocumentSymbolProvider,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.Focus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 45 /* KEY_O */
                },
                menuOpts: {
                    group: 'navigation',
                    order: 3
                }
            }) || this;
        }
        QuickOutlineAction.prototype.run = function (accessor, editor) {
            var _this = this;
            var model = editor.getModel();
            if (!modes_1.DocumentSymbolProviderRegistry.has(model)) {
                return null;
            }
            // Resolve outline
            return quickOpen_2.getDocumentSymbols(model).then(function (result) {
                if (result.entries.length === 0) {
                    return;
                }
                _this._run(editor, result.entries);
            });
        };
        QuickOutlineAction.prototype._run = function (editor, result) {
            var _this = this;
            this._show(this.getController(editor), {
                getModel: function (value) {
                    return new quickOpenModel_1.QuickOpenModel(_this.toQuickOpenEntries(editor, result, value));
                },
                getAutoFocus: function (searchValue) {
                    // Remove any type pattern (:) from search value as needed
                    if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                        searchValue = searchValue.substr(SCOPE_PREFIX.length);
                    }
                    return {
                        autoFocusPrefixMatch: searchValue,
                        autoFocusFirstEntry: !!searchValue
                    };
                }
            });
        };
        QuickOutlineAction.prototype.toQuickOpenEntries = function (editor, flattened, searchValue) {
            var controller = this.getController(editor);
            var results = [];
            // Convert to Entries
            var normalizedSearchValue = searchValue;
            if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                normalizedSearchValue = normalizedSearchValue.substr(SCOPE_PREFIX.length);
            }
            for (var i = 0; i < flattened.length; i++) {
                var element = flattened[i];
                var label = strings.trim(element.name);
                // Check for meatch
                var highlights = filters_1.matchesFuzzy(normalizedSearchValue, label);
                if (highlights) {
                    // Show parent scope as description
                    var description = null;
                    if (element.containerName) {
                        description = element.containerName;
                    }
                    // Add
                    results.push(new SymbolEntry(label, modes_1.SymbolKind.from(element.kind), description, element.location.range, highlights, editor, controller));
                }
            }
            // Sort properly if actually searching
            if (searchValue) {
                if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                    results = results.sort(this.sortScoped.bind(this, searchValue.toLowerCase()));
                }
                else {
                    results = results.sort(this.sortNormal.bind(this, searchValue.toLowerCase()));
                }
            }
            // Mark all type groups
            if (results.length > 0 && searchValue.indexOf(SCOPE_PREFIX) === 0) {
                var currentType = null;
                var currentResult = null;
                var typeCounter = 0;
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    // Found new type
                    if (currentType !== result.getType()) {
                        // Update previous result with count
                        if (currentResult) {
                            currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
                        }
                        currentType = result.getType();
                        currentResult = result;
                        typeCounter = 1;
                        result.setShowBorder(i > 0);
                    }
                    else {
                        typeCounter++;
                    }
                }
                // Update previous result with count
                if (currentResult) {
                    currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
                }
            }
            else if (results.length > 0) {
                results[0].setGroupLabel(nls.localize(3, null, results.length));
            }
            return results;
        };
        QuickOutlineAction.prototype.typeToLabel = function (type, count) {
            switch (type) {
                case 'module': return nls.localize(4, null, count);
                case 'class': return nls.localize(5, null, count);
                case 'interface': return nls.localize(6, null, count);
                case 'method': return nls.localize(7, null, count);
                case 'function': return nls.localize(8, null, count);
                case 'property': return nls.localize(9, null, count);
                case 'variable': return nls.localize(10, null, count);
                case 'var': return nls.localize(11, null, count);
                case 'constructor': return nls.localize(12, null, count);
                case 'call': return nls.localize(13, null, count);
            }
            return type;
        };
        QuickOutlineAction.prototype.sortNormal = function (searchValue, elementA, elementB) {
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            // Compare by name
            var r = elementAName.localeCompare(elementBName);
            if (r !== 0) {
                return r;
            }
            // If name identical sort by range instead
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        QuickOutlineAction.prototype.sortScoped = function (searchValue, elementA, elementB) {
            // Remove scope char
            searchValue = searchValue.substr(SCOPE_PREFIX.length);
            // Sort by type first if scoped search
            var elementAType = elementA.getType();
            var elementBType = elementB.getType();
            var r = elementAType.localeCompare(elementBType);
            if (r !== 0) {
                return r;
            }
            // Special sort when searching in scoped mode
            if (searchValue) {
                var elementAName = elementA.getLabel().toLowerCase();
                var elementBName = elementB.getLabel().toLowerCase();
                // Compare by name
                var r_1 = elementAName.localeCompare(elementBName);
                if (r_1 !== 0) {
                    return r_1;
                }
            }
            // Default to sort by range
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        return QuickOutlineAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    QuickOutlineAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], QuickOutlineAction);
    exports.QuickOutlineAction = QuickOutlineAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[477/*vs/editor/contrib/referenceSearch/common/referenceSearch*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,17/*vs/base/common/async*/]), function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function provideReferences(model, position) {
        // collect references from all providers
        var promises = modes_1.ReferenceProviderRegistry.ordered(model).map(function (provider) {
            return async_1.asWinJsPromise(function (token) {
                return provider.provideReferences(model, position, { includeDeclaration: true }, token);
            }).then(function (result) {
                if (Array.isArray(result)) {
                    return result;
                }
            }, function (err) {
                errors_1.onUnexpectedExternalError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (references) {
            var result = [];
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var ref = references_1[_i];
                if (ref) {
                    result.push.apply(result, ref);
                }
            }
            return result;
        });
    }
    exports.provideReferences = provideReferences;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeReferenceProvider', provideReferences);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[478/*vs/editor/contrib/rename/common/rename*/], __M([1/*require*/,0/*exports*/,309/*vs/nls!vs/editor/contrib/rename/common/rename*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/]), function (require, exports, nls_1, async_1, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1) {
    'use strict';
    function rename(model, position, newName) {
        var supports = modes_1.RenameProviderRegistry.ordered(model);
        var rejects = [];
        var hasResult = false;
        var factory = supports.map(function (support) {
            return function () {
                if (!hasResult) {
                    return async_1.asWinJsPromise(function (token) {
                        return support.provideRenameEdits(model, position, newName, token);
                    }).then(function (result) {
                        if (!result) {
                        }
                        else if (!result.rejectReason) {
                            hasResult = true;
                            return result;
                        }
                        else {
                            rejects.push(result.rejectReason);
                        }
                    }, function (err) {
                        errors_1.onUnexpectedExternalError(err);
                        return winjs_base_1.TPromise.wrapError('provider failed');
                    });
                }
            };
        });
        return async_1.sequence(factory).then(function (values) {
            var result = values[0];
            if (rejects.length > 0) {
                return {
                    edits: undefined,
                    rejectReason: rejects.join('\n')
                };
            }
            else if (!result) {
                return {
                    edits: undefined,
                    rejectReason: nls_1.localize(0, null)
                };
            }
            else {
                return result;
            }
        });
    }
    exports.rename = rename;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentRenameProvider', function (model, position, args) {
        var newName = args.newName;
        if (typeof newName !== 'string') {
            throw errors_1.illegalArgument('newName');
        }
        return rename(model, position, newName);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[479/*vs/editor/contrib/rename/browser/rename*/], __M([1/*require*/,0/*exports*/,306/*vs/nls!vs/editor/contrib/rename/browser/rename*/,10/*vs/base/common/errors*/,30/*vs/base/common/severity*/,6/*vs/base/common/winjs.base*/,402/*vs/platform/files/common/files*/,18/*vs/platform/contextkey/common/contextkey*/,49/*vs/platform/message/common/message*/,158/*vs/platform/progress/common/progress*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,2/*vs/editor/common/editorCommon*/,276/*vs/editor/common/services/bulkEdit*/,478/*vs/editor/contrib/rename/common/rename*/,308/*vs/editor/contrib/rename/browser/renameInputField*/,66/*vs/editor/common/services/resolverService*/,14/*vs/platform/instantiation/common/instantiation*/]), function (require, exports, nls, errors_1, severity_1, winjs_base_1, files_1, contextkey_1, message_1, progress_1, editorCommonExtensions_1, editorBrowserExtensions_1, editorCommon_1, bulkEdit_1, rename_1, renameInputField_1, resolverService_1, instantiation_1) {
    'use strict';
    // ---  register actions and commands
    var CONTEXT_RENAME_INPUT_VISIBLE = new contextkey_1.RawContextKey('renameInputVisible', false);
    var RenameController = RenameController_1 = (function () {
        function RenameController(editor, _messageService, _textModelResolverService, _progressService, contextKeyService, _fileService) {
            this.editor = editor;
            this._messageService = _messageService;
            this._textModelResolverService = _textModelResolverService;
            this._progressService = _progressService;
            this._fileService = _fileService;
            this._renameInputField = new renameInputField_1.default(editor);
            this._renameInputVisible = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
        }
        RenameController.get = function (editor) {
            return editor.getContribution(RenameController_1.ID);
        };
        RenameController.prototype.dispose = function () {
            this._renameInputField.dispose();
        };
        RenameController.prototype.getId = function () {
            return RenameController_1.ID;
        };
        RenameController.prototype.run = function () {
            var _this = this;
            var selection = this.editor.getSelection(), word = this.editor.getModel().getWordAtPosition(selection.getStartPosition());
            if (!word) {
                return;
            }
            var lineNumber = selection.startLineNumber, selectionStart = 0, selectionEnd = word.word.length, wordRange;
            wordRange = {
                startLineNumber: lineNumber,
                startColumn: word.startColumn,
                endLineNumber: lineNumber,
                endColumn: word.endColumn
            };
            if (!selection.isEmpty() && selection.startLineNumber === selection.endLineNumber) {
                selectionStart = Math.max(0, selection.startColumn - word.startColumn);
                selectionEnd = Math.min(word.endColumn, selection.endColumn) - word.startColumn;
            }
            this._renameInputVisible.set(true);
            return this._renameInputField.getInput(wordRange, word.word, selectionStart, selectionEnd).then(function (newName) {
                _this._renameInputVisible.reset();
                _this.editor.focus();
                var renameOperation = _this._prepareRename(newName).then(function (edit) {
                    return edit.finish().then(function (selection) {
                        if (selection) {
                            _this.editor.setSelection(selection);
                        }
                    });
                }, function (err) {
                    if (typeof err === 'string') {
                        _this._messageService.show(severity_1.default.Info, err);
                    }
                    else {
                        _this._messageService.show(severity_1.default.Error, nls.localize(0, null));
                        return winjs_base_1.TPromise.wrapError(err);
                    }
                });
                _this._progressService.showWhile(renameOperation, 250);
                return renameOperation;
            }, function (err) {
                _this._renameInputVisible.reset();
                _this.editor.focus();
                if (!errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
        };
        RenameController.prototype.acceptRenameInput = function () {
            this._renameInputField.acceptInput();
        };
        RenameController.prototype.cancelRenameInput = function () {
            this._renameInputField.cancelInput();
        };
        RenameController.prototype._prepareRename = function (newName) {
            // start recording of file changes so that we can figure out if a file that
            // is to be renamed conflicts with another (concurrent) modification
            var edit = bulkEdit_1.createBulkEdit(this._textModelResolverService, this.editor, this._fileService);
            return rename_1.rename(this.editor.getModel(), this.editor.getPosition(), newName).then(function (result) {
                if (result.rejectReason) {
                    return winjs_base_1.TPromise.wrapError(result.rejectReason);
                }
                edit.add(result.edits);
                return edit;
            });
        };
        return RenameController;
    }());
    RenameController.ID = 'editor.contrib.renameController';
    RenameController = RenameController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, message_1.IMessageService),
        __param(2, resolverService_1.ITextModelResolverService),
        __param(3, progress_1.IProgressService),
        __param(4, contextkey_1.IContextKeyService),
        __param(5, instantiation_1.optional(files_1.IFileService))
    ], RenameController);
    // ---- action implementation
    var RenameAction = (function (_super) {
        __extends(RenameAction, _super);
        function RenameAction() {
            return _super.call(this, {
                id: 'editor.action.rename',
                label: nls.localize(1, null),
                alias: 'Rename Symbol',
                precondition: contextkey_1.ContextKeyExpr.and(editorCommon_1.EditorContextKeys.Writable, editorCommon_1.ModeContextKeys.hasRenameProvider),
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 60 /* F2 */
                },
                menuOpts: {
                    group: '1_modification',
                    order: 1.1
                }
            }) || this;
        }
        RenameAction.prototype.run = function (accessor, editor) {
            var controller = RenameController.get(editor);
            if (controller) {
                return controller.run();
            }
        };
        return RenameAction;
    }(editorCommonExtensions_1.EditorAction));
    RenameAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], RenameAction);
    exports.RenameAction = RenameAction;
    var RenameCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(RenameController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new RenameCommand({
        id: 'acceptRenameInput',
        precondition: CONTEXT_RENAME_INPUT_VISIBLE,
        handler: function (x) { return x.acceptRenameInput(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(99),
            kbExpr: editorCommon_1.EditorContextKeys.Focus,
            primary: 3 /* Enter */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new RenameCommand({
        id: 'cancelRenameInput',
        precondition: CONTEXT_RENAME_INPUT_VISIBLE,
        handler: function (x) { return x.cancelRenameInput(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(99),
            kbExpr: editorCommon_1.EditorContextKeys.Focus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    var RenameController_1;
});















define(__m[480/*vs/editor/contrib/smartSelect/common/smartSelect*/], __M([1/*require*/,0/*exports*/,310/*vs/nls!vs/editor/contrib/smartSelect/common/smartSelect*/,28/*vs/base/common/arrays*/,6/*vs/base/common/winjs.base*/,14/*vs/platform/instantiation/common/instantiation*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,328/*vs/editor/contrib/smartSelect/common/tokenSelectionSupport*/]), function (require, exports, nls, arrays, winjs_base_1, instantiation_1, range_1, editorCommon_1, editorCommonExtensions_1, tokenSelectionSupport_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- selection state machine
    var State = (function () {
        function State(editor) {
            this.editor = editor;
            this.next = null;
            this.previous = null;
            this.selection = editor.getSelection();
        }
        return State;
    }());
    // --- shared state between grow and shrink actions
    var state = null;
    var ignoreSelection = false;
    // -- action implementation
    var SmartSelectController = SmartSelectController_1 = (function () {
        function SmartSelectController(editor, instantiationService) {
            this.editor = editor;
            this._tokenSelectionSupport = instantiationService.createInstance(tokenSelectionSupport_1.TokenSelectionSupport);
        }
        SmartSelectController.get = function (editor) {
            return editor.getContribution(SmartSelectController_1.ID);
        };
        SmartSelectController.prototype.dispose = function () {
        };
        SmartSelectController.prototype.getId = function () {
            return SmartSelectController_1.ID;
        };
        SmartSelectController.prototype.run = function (forward) {
            var _this = this;
            var selection = this.editor.getSelection();
            var model = this.editor.getModel();
            // forget about current state
            if (state) {
                if (state.editor !== this.editor) {
                    state = null;
                }
            }
            var promise = winjs_base_1.TPromise.as(null);
            if (!state) {
                promise = this._tokenSelectionSupport.getRangesToPosition(model.uri, selection.getStartPosition()).then(function (elements) {
                    if (arrays.isFalsyOrEmpty(elements)) {
                        return;
                    }
                    var lastState;
                    elements.filter(function (element) {
                        // filter ranges inside the selection
                        var selection = _this.editor.getSelection();
                        var range = new range_1.Range(element.range.startLineNumber, element.range.startColumn, element.range.endLineNumber, element.range.endColumn);
                        return range.containsPosition(selection.getStartPosition()) && range.containsPosition(selection.getEndPosition());
                    }).forEach(function (element) {
                        // create ranges
                        var range = element.range;
                        var state = new State(_this.editor);
                        state.selection = new range_1.Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
                        if (lastState) {
                            state.next = lastState;
                            lastState.previous = state;
                        }
                        lastState = state;
                    });
                    // insert current selection
                    var editorState = new State(_this.editor);
                    editorState.next = lastState;
                    if (lastState) {
                        lastState.previous = editorState;
                    }
                    state = editorState;
                    // listen to caret move and forget about state
                    var unhook = _this.editor.onDidChangeCursorPosition(function (e) {
                        if (ignoreSelection) {
                            return;
                        }
                        state = null;
                        unhook.dispose();
                    });
                });
            }
            return promise.then(function () {
                if (!state) {
                    return;
                }
                state = forward ? state.next : state.previous;
                if (!state) {
                    return;
                }
                ignoreSelection = true;
                try {
                    _this.editor.setSelection(state.selection);
                }
                finally {
                    ignoreSelection = false;
                }
                return;
            });
        };
        return SmartSelectController;
    }());
    SmartSelectController.ID = 'editor.contrib.smartSelectController';
    SmartSelectController = SmartSelectController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, instantiation_1.IInstantiationService)
    ], SmartSelectController);
    var AbstractSmartSelect = (function (_super) {
        __extends(AbstractSmartSelect, _super);
        function AbstractSmartSelect(forward, opts) {
            var _this = _super.call(this, opts) || this;
            _this._forward = forward;
            return _this;
        }
        AbstractSmartSelect.prototype.run = function (accessor, editor) {
            var controller = SmartSelectController.get(editor);
            if (controller) {
                return controller.run(this._forward);
            }
        };
        return AbstractSmartSelect;
    }(editorCommonExtensions_1.EditorAction));
    var GrowSelectionAction = (function (_super) {
        __extends(GrowSelectionAction, _super);
        function GrowSelectionAction() {
            return _super.call(this, true, {
                id: 'editor.action.smartSelect.grow',
                label: nls.localize(0, null),
                alias: 'Expand Select',
                precondition: null,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 17 /* RightArrow */,
                    mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 1024 /* Shift */ | 17 /* RightArrow */ }
                }
            }) || this;
        }
        return GrowSelectionAction;
    }(AbstractSmartSelect));
    GrowSelectionAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], GrowSelectionAction);
    var ShrinkSelectionAction = (function (_super) {
        __extends(ShrinkSelectionAction, _super);
        function ShrinkSelectionAction() {
            return _super.call(this, false, {
                id: 'editor.action.smartSelect.shrink',
                label: nls.localize(1, null),
                alias: 'Shrink Select',
                precondition: null,
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 512 /* Alt */ | 15 /* LeftArrow */,
                    mac: { primary: 2048 /* CtrlCmd */ | 256 /* WinCtrl */ | 1024 /* Shift */ | 15 /* LeftArrow */ }
                }
            }) || this;
        }
        return ShrinkSelectionAction;
    }(AbstractSmartSelect));
    ShrinkSelectionAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], ShrinkSelectionAction);
    var SmartSelectController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[165/*vs/editor/contrib/snippet/common/snippetController*/], __M([1/*require*/,0/*exports*/,9/*vs/base/common/strings*/,28/*vs/base/common/arrays*/,18/*vs/platform/contextkey/common/contextkey*/,46/*vs/editor/common/core/editOperation*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,3/*vs/base/common/lifecycle*/,93/*vs/editor/contrib/snippet/common/snippet*/,238/*vs/editor/contrib/snippet/common/snippetVariables*/]), function (require, exports, strings, arrays_1, contextkey_1, editOperation_1, range_1, selection_1, editorCommon, editorCommonExtensions_1, lifecycle_1, snippet_1, snippetVariables_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var InsertSnippetController = (function () {
        function InsertSnippetController(editor, adaptedSnippet, startLineNumber, initialAlternativeVersionId, onStop) {
            this.editor = editor;
            this._onStop = onStop;
            this.model = editor.getModel();
            this.finishPlaceHolderIndex = adaptedSnippet.finishPlaceHolderIndex;
            this.trackedPlaceHolders = [];
            this.placeHolderDecorations = [];
            this.currentPlaceHolderIndex = 0;
            this.highlightDecorationId = null;
            this.isFinished = false;
            this._initialAlternativeVersionId = initialAlternativeVersionId;
            this.initialize(adaptedSnippet, startLineNumber);
        }
        InsertSnippetController.prototype.dispose = function () {
            this.stopAll();
        };
        InsertSnippetController.prototype.initialize = function (adaptedSnippet, startLineNumber) {
            var _this = this;
            // sorted list of all placeholder occurences for subsequent lockups
            var sortedOccurrences = [];
            for (var _i = 0, _a = adaptedSnippet.placeHolders; _i < _a.length; _i++) {
                var occurences = _a[_i].occurences;
                for (var _b = 0, occurences_1 = occurences; _b < occurences_1.length; _b++) {
                    var range = occurences_1[_b];
                    sortedOccurrences.push(range);
                }
            }
            sortedOccurrences.sort(range_1.Range.compareRangesUsingStarts);
            // track each occurence
            this.model.changeDecorations(function (changeAccessor) {
                for (var i = 0; i < adaptedSnippet.placeHolders.length; i++) {
                    var occurences = adaptedSnippet.placeHolders[i].occurences;
                    var trackedRanges = [];
                    for (var _i = 0, occurences_2 = occurences; _i < occurences_2.length; _i++) {
                        var range = occurences_2[_i];
                        var stickiness = editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
                        if (i === adaptedSnippet.finishPlaceHolderIndex) {
                            // final tab stop decoration never grows
                            stickiness = editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges;
                        }
                        else {
                            // Check if the previous range ends exactly where this range starts
                            // and iff so change the stickiness to avoid conflicts
                            var idx = arrays_1.binarySearch(sortedOccurrences, range, range_1.Range.compareRangesUsingStarts);
                            if (idx > 0
                                && sortedOccurrences[idx - 1].endLineNumber === range.startLineNumber
                                && sortedOccurrences[idx - 1].endColumn === range.startColumn) {
                                stickiness = editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter;
                            }
                        }
                        trackedRanges.push(changeAccessor.addDecoration(range, {
                            stickiness: stickiness
                        }));
                    }
                    _this.trackedPlaceHolders.push({
                        ranges: trackedRanges
                    });
                }
            });
            this.editor.changeDecorations(function (changeAccessor) {
                var newDecorations = [];
                var endLineNumber = startLineNumber + adaptedSnippet.lines.length - 1;
                var endLineNumberMaxColumn = _this.model.getLineMaxColumn(endLineNumber);
                newDecorations.push({
                    range: new range_1.Range(startLineNumber, 1, endLineNumber, endLineNumberMaxColumn),
                    options: {
                        className: 'new-snippet',
                        isWholeLine: true
                    }
                });
                for (var i = 0, len = _this.trackedPlaceHolders.length; i < len; i++) {
                    var className = (i === _this.finishPlaceHolderIndex) ? 'finish-snippet-placeholder' : 'snippet-placeholder';
                    newDecorations.push({
                        range: _this.model.getDecorationRange(_this.trackedPlaceHolders[i].ranges[0]),
                        options: {
                            stickiness: _this.model.getDecorationOptions(_this.trackedPlaceHolders[i].ranges[0]).stickiness,
                            className: className
                        }
                    });
                }
                var decorations = changeAccessor.deltaDecorations([], newDecorations);
                _this.highlightDecorationId = decorations[0];
                _this.placeHolderDecorations = decorations.slice(1);
            });
            // let print = () => {
            // 	console.log('trackedPlaceHolders: ' + this.trackedPlaceHolders.map((placeholder, index) => 'placeHolder index ' + index + ': ' + placeholder.ranges.map(id => id + '(' + this.model.getDecorationRange(id) + ')').join(', ')).join('\n'));
            // 	console.log('highlightDecoration: ' + this.highlightDecorationId + '(' + this.model.getDecorationRange(this.highlightDecorationId) + ')');
            // 	console.log('placeHolderDecorations: ' + this.placeHolderDecorations.map(id => id + '(' + this.model.getDecorationRange(id) + ')').join(', '));
            // };
            // print();
            this.listenersToRemove = [];
            this.listenersToRemove.push(this.editor.onDidChangeModelRawContent(function (e) {
                // console.log('-------MODEL CHANGED');
                // print();
                if (_this.isFinished) {
                    return;
                }
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    _this.stopAll();
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLineChanged) {
                    var changedLine = e.lineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    if (changedLine < highlightRange.startLineNumber || changedLine > highlightRange.endLineNumber) {
                        _this.stopAll();
                    }
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesInserted) {
                    var insertLine = e.fromLineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    if (insertLine < highlightRange.startLineNumber || insertLine > highlightRange.endLineNumber) {
                        _this.stopAll();
                    }
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesDeleted) {
                    var deleteLine1 = e.fromLineNumber;
                    var deleteLine2 = e.toLineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    var deletedLinesAbove = (deleteLine2 < highlightRange.startLineNumber);
                    var deletedLinesBelow = (deleteLine1 > highlightRange.endLineNumber);
                    if (deletedLinesAbove || deletedLinesBelow) {
                        _this.stopAll();
                    }
                }
                var newAlternateVersionId = _this.editor.getModel().getAlternativeVersionId();
                if (_this._initialAlternativeVersionId === newAlternateVersionId) {
                    // We executed undo until we reached the same version we started with
                    _this.stopAll();
                }
            }));
            this.listenersToRemove.push(this.editor.onDidChangeCursorPosition(function (e) {
                if (_this.isFinished) {
                    return;
                }
                var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                var lineNumber = e.position.lineNumber;
                if (lineNumber < highlightRange.startLineNumber || lineNumber > highlightRange.endLineNumber) {
                    _this.stopAll();
                }
            }));
            this.listenersToRemove.push(this.editor.onDidChangeModel(function () {
                _this.stopAll();
            }));
            var blurTimeout = -1;
            this.listenersToRemove.push(this.editor.onDidBlurEditor(function () {
                // Blur if within 100ms we do not focus back
                blurTimeout = setTimeout(function () {
                    _this.stopAll();
                }, 100);
            }));
            this.listenersToRemove.push(this.editor.onDidFocusEditor(function () {
                // Cancel the blur timeout (if any)
                if (blurTimeout !== -1) {
                    clearTimeout(blurTimeout);
                    blurTimeout = -1;
                }
            }));
            this.listenersToRemove.push(this.model.onDidChangeDecorations(function (e) {
                if (_this.isFinished) {
                    return;
                }
                var modelEditableRange = _this.model.getEditableRange(), previousRange = null, allCollapsed = true, allEqualToEditableRange = true;
                for (var i = 0; (allCollapsed || allEqualToEditableRange) && i < _this.trackedPlaceHolders.length; i++) {
                    var ranges = _this.trackedPlaceHolders[i].ranges;
                    for (var j = 0; (allCollapsed || allEqualToEditableRange) && j < ranges.length; j++) {
                        var range = _this.model.getDecorationRange(ranges[j]);
                        if (allCollapsed) {
                            if (!range.isEmpty()) {
                                allCollapsed = false;
                            }
                            else if (previousRange === null) {
                                previousRange = range;
                            }
                            else if (!previousRange.equalsRange(range)) {
                                allCollapsed = false;
                            }
                        }
                        if (allEqualToEditableRange && !modelEditableRange.equalsRange(range)) {
                            allEqualToEditableRange = false;
                        }
                    }
                }
                if (allCollapsed || allEqualToEditableRange) {
                    _this.stopAll();
                }
                else {
                    if (_this.finishPlaceHolderIndex !== -1) {
                        var finishPlaceHolderDecorationId = _this.placeHolderDecorations[_this.finishPlaceHolderIndex];
                        var finishPlaceHolderRange = _this.model.getDecorationRange(finishPlaceHolderDecorationId);
                        var finishPlaceHolderOptions = _this.model.getDecorationOptions(finishPlaceHolderDecorationId);
                        var finishPlaceHolderRangeIsEmpty = finishPlaceHolderRange.isEmpty();
                        var finishPlaceHolderClassNameIsForEmpty = (finishPlaceHolderOptions.className === 'finish-snippet-placeholder');
                        // Remember xor? :)
                        var needsChanging = Number(finishPlaceHolderRangeIsEmpty) ^ Number(finishPlaceHolderClassNameIsForEmpty);
                        if (needsChanging) {
                            _this.editor.changeDecorations(function (changeAccessor) {
                                var className = finishPlaceHolderRangeIsEmpty ? 'finish-snippet-placeholder' : 'snippet-placeholder';
                                changeAccessor.changeDecorationOptions(finishPlaceHolderDecorationId, {
                                    className: className
                                });
                            });
                        }
                    }
                }
            }));
            this.doLinkEditing();
        };
        InsertSnippetController.prototype.onNextPlaceHolder = function () {
            return this.changePlaceHolder(true);
        };
        InsertSnippetController.prototype.onPrevPlaceHolder = function () {
            return this.changePlaceHolder(false);
        };
        InsertSnippetController.prototype.changePlaceHolder = function (goToNext) {
            if (this.isFinished) {
                return false;
            }
            var oldPlaceHolderIndex = this.currentPlaceHolderIndex;
            var oldRange = this.model.getDecorationRange(this.trackedPlaceHolders[oldPlaceHolderIndex].ranges[0]);
            var sameRange = true;
            do {
                if (goToNext) {
                    this.currentPlaceHolderIndex = (this.currentPlaceHolderIndex + 1) % this.trackedPlaceHolders.length;
                }
                else {
                    this.currentPlaceHolderIndex = (this.trackedPlaceHolders.length + this.currentPlaceHolderIndex - 1) % this.trackedPlaceHolders.length;
                }
                var newRange = this.model.getDecorationRange(this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges[0]);
                sameRange = oldRange.equalsRange(newRange);
            } while (this.currentPlaceHolderIndex !== oldPlaceHolderIndex && sameRange);
            this.doLinkEditing();
            return true;
        };
        InsertSnippetController.prototype.onAccept = function () {
            if (this.isFinished) {
                return false;
            }
            if (this.finishPlaceHolderIndex !== -1) {
                var finishRange = this.model.getDecorationRange(this.trackedPlaceHolders[this.finishPlaceHolderIndex].ranges[0]);
                // Let's just position cursor at the end of the finish range
                this.editor.setPosition({
                    lineNumber: finishRange.endLineNumber,
                    column: finishRange.endColumn
                });
            }
            this.stopAll();
            return true;
        };
        InsertSnippetController.prototype.onEscape = function () {
            if (this.isFinished) {
                return false;
            }
            this.stopAll();
            // Cancel multi-cursor
            this.editor.setSelections([this.editor.getSelections()[0]]);
            return true;
        };
        InsertSnippetController.prototype.doLinkEditing = function () {
            var selections = [];
            for (var i = 0, len = this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges.length; i < len; i++) {
                var range = this.model.getDecorationRange(this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges[i]);
                selections.push({
                    selectionStartLineNumber: range.startLineNumber,
                    selectionStartColumn: range.startColumn,
                    positionLineNumber: range.endLineNumber,
                    positionColumn: range.endColumn
                });
            }
            this.editor.setSelections(selections);
            this.editor.revealRangeInCenterIfOutsideViewport(this.editor.getSelection());
        };
        InsertSnippetController.prototype.stopAll = function () {
            var _this = this;
            if (this.isFinished) {
                return;
            }
            this.isFinished = true;
            this._onStop();
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.model.changeDecorations(function (changeAccessor) {
                for (var i = 0; i < _this.trackedPlaceHolders.length; i++) {
                    var ranges = _this.trackedPlaceHolders[i].ranges;
                    for (var j = 0; j < ranges.length; j++) {
                        changeAccessor.removeDecoration(ranges[j]);
                    }
                }
            });
            this.trackedPlaceHolders = [];
            this.editor.changeDecorations(function (changeAccessor) {
                var toRemove = [];
                toRemove.push(_this.highlightDecorationId);
                for (var i = 0; i < _this.placeHolderDecorations.length; i++) {
                    toRemove.push(_this.placeHolderDecorations[i]);
                }
                changeAccessor.deltaDecorations(toRemove, []);
                _this.placeHolderDecorations = [];
                _this.highlightDecorationId = null;
            });
        };
        return InsertSnippetController;
    }());
    exports.InsertSnippetController = InsertSnippetController;
    var BeforeAfterData = (function () {
        function BeforeAfterData(_model, _contentBefore, _contentAfter, overwriteBefore, overwriteAfter) {
            this._model = _model;
            this._contentBefore = _contentBefore;
            this._contentAfter = _contentAfter;
            this.overwriteBefore = overwriteBefore;
            this.overwriteAfter = overwriteAfter;
            //
        }
        BeforeAfterData.create = function (model, selection, overwriteBefore, overwriteAfter) {
            var contentBefore = '';
            if (overwriteBefore > 0) {
                contentBefore = model.getLineContent(selection.startLineNumber).substring(selection.startColumn - 1 - overwriteBefore, selection.startColumn - 1);
            }
            var contentAfter = '';
            if (overwriteAfter > 0) {
                contentAfter = model.getLineContent(selection.endLineNumber).substring(selection.endColumn - 1, selection.endColumn - 1 + overwriteAfter);
            }
            return new BeforeAfterData(model, contentBefore, contentAfter, overwriteBefore, overwriteAfter);
        };
        BeforeAfterData.prototype.next = function (selection) {
            var data = BeforeAfterData.create(this._model, selection, this.overwriteBefore, this.overwriteAfter);
            var overwriteBefore = data.overwriteBefore, overwriteAfter = data.overwriteAfter;
            if (data._contentBefore !== this._contentBefore) {
                overwriteBefore = 0;
            }
            if (data._contentAfter !== this._contentAfter) {
                overwriteAfter = 0;
            }
            return new BeforeAfterData(this._model, null, null, overwriteBefore, overwriteAfter);
        };
        return BeforeAfterData;
    }());
    var SnippetController = SnippetController_1 = (function () {
        function SnippetController(editor, contextKeyService) {
            this._editor = editor;
            this._variableResolver = new snippetVariables_1.SnippetVariablesResolver(editor);
            this._currentController = null;
            this._inSnippetMode = exports.CONTEXT_SNIPPET_MODE.bindTo(contextKeyService);
        }
        SnippetController.get = function (editor) {
            return editor.getContribution(SnippetController_1.ID);
        };
        SnippetController.prototype.dispose = function () {
            if (this._currentController) {
                this._currentController.dispose();
                this._currentController = null;
            }
        };
        SnippetController.prototype.getId = function () {
            return SnippetController_1.ID;
        };
        SnippetController.prototype.insertSnippet = function (template, overwriteBefore, overwriteAfter) {
            var snippet = snippet_1.CodeSnippet.fromTextmate(template, this._variableResolver);
            this.run(snippet, overwriteBefore, overwriteAfter);
        };
        SnippetController.prototype.run = function (snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            var _this = this;
            this._runAndRestoreController(function () {
                if (snippet.isInsertOnly || snippet.isSingleTabstopOnly) {
                    // Only inserts text, not placeholders, tabstops etc
                    // Only cursor endposition
                    _this._runForAllSelections(snippet, overwriteBefore, overwriteAfter, stripPrefix);
                }
                else {
                    var prepared = SnippetController_1._prepareSnippet(_this._editor, _this._editor.getSelection(), snippet, overwriteBefore, overwriteAfter, stripPrefix);
                    _this._runPreparedSnippetForPrimarySelection(prepared, true);
                }
            });
        };
        /**
         * Inserts once `snippet` at the start of `replaceRange`, after deleting `replaceRange`.
         */
        SnippetController.prototype.runWithReplaceRange = function (snippet, replaceRange) {
            var _this = this;
            this._runAndRestoreController(function () {
                _this._runPreparedSnippetForPrimarySelection({
                    typeRange: replaceRange,
                    adaptedSnippet: SnippetController_1._getAdaptedSnippet(_this._editor.getModel(), snippet, replaceRange)
                }, false);
            });
        };
        SnippetController.prototype._runAndRestoreController = function (callback) {
            var prevController = this._currentController;
            this._currentController = null;
            callback();
            if (!this._currentController) {
                // we didn't end up in snippet mode again => restore previous controller
                this._currentController = prevController;
            }
            else {
                // we ended up in snippet mode => dispose previous controller if necessary
                if (prevController) {
                    prevController.dispose();
                }
            }
        };
        SnippetController._addCommandForSnippet = function (model, adaptedSnippet, typeRange, out) {
            var insertText = adaptedSnippet.lines.join('\n');
            var currentText = model.getValueInRange(typeRange, editorCommon.EndOfLinePreference.LF);
            if (insertText !== currentText) {
                out.push(editOperation_1.EditOperation.replaceMove(typeRange, insertText));
            }
        };
        SnippetController.prototype._runPreparedSnippetForPrimarySelection = function (prepared, undoStops) {
            var _this = this;
            var initialAlternativeVersionId = this._editor.getModel().getAlternativeVersionId();
            var edits = [];
            SnippetController_1._addCommandForSnippet(this._editor.getModel(), prepared.adaptedSnippet, prepared.typeRange, edits);
            if (edits.length > 0) {
                if (undoStops) {
                    this._editor.pushUndoStop();
                }
                this._editor.executeEdits('editor.contrib.insertSnippetHelper', edits);
                if (undoStops) {
                    this._editor.pushUndoStop();
                }
            }
            var cursorOnly = SnippetController_1._getSnippetCursorOnly(prepared.adaptedSnippet);
            if (cursorOnly) {
                this._editor.setSelection(new selection_1.Selection(cursorOnly.lineNumber, cursorOnly.column, cursorOnly.lineNumber, cursorOnly.column));
            }
            else if (prepared.adaptedSnippet.placeHolders.length > 0) {
                this._inSnippetMode.set(true);
                this._currentController = new InsertSnippetController(this._editor, prepared.adaptedSnippet, prepared.typeRange.startLineNumber, initialAlternativeVersionId, function () {
                    _this._inSnippetMode.reset();
                    if (_this._currentController) {
                        _this._currentController.dispose();
                        _this._currentController = null;
                    }
                });
            }
        };
        SnippetController.prototype._runForAllSelections = function (snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            var edits = [];
            var selections = this._editor.getSelections();
            var model = this._editor.getModel();
            var primaryBeforeAfter = BeforeAfterData.create(model, selections[0], overwriteBefore, overwriteAfter);
            var totalDelta = 0;
            var newSelections = [];
            // sort selections by start position but remember where
            // each selection came from
            var selectionEntries = selections
                .map(function (selection, i) { return ({ selection: selection, i: i }); })
                .sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.selection, b.selection); });
            for (var _i = 0, selectionEntries_1 = selectionEntries; _i < selectionEntries_1.length; _i++) {
                var _a = selectionEntries_1[_i], selection = _a.selection, i = _a.i;
                // only use overwrite[Before|After] for secondary cursors
                // when the same text as with the primary cursor is selected
                var beforeAfter = i !== 0 ? primaryBeforeAfter.next(selection) : primaryBeforeAfter;
                var _b = SnippetController_1._prepareSnippet(this._editor, selection, snippet, beforeAfter.overwriteBefore, beforeAfter.overwriteAfter, stripPrefix), adaptedSnippet = _b.adaptedSnippet, typeRange = _b.typeRange;
                SnippetController_1._addCommandForSnippet(this._editor.getModel(), adaptedSnippet, typeRange, edits);
                // compute new selection offset
                // * get current offset
                // * get length of snippet that we insert
                // * get final cursor position of snippet that we insert (might not exist)
                // * NEW selection offset is current + final cursor pos + inserts_until_here
                var offset = model.getOffsetAt(typeRange.getStartPosition());
                // inserts until here
                offset += totalDelta;
                // each snippet has a different length (because of whitespace changes)
                var snippetLength = (adaptedSnippet.lines.length - 1) * model.getEOL().length;
                for (var _c = 0, _d = adaptedSnippet.lines; _c < _d.length; _c++) {
                    var line = _d[_c];
                    snippetLength += line.length;
                }
                // each snippet has a different cursor offset
                var finalCursorPos = SnippetController_1._getSnippetCursorOnly(adaptedSnippet);
                if (finalCursorPos) {
                    var finalCursorOffset = void 0;
                    if (finalCursorPos.lineNumber === typeRange.startLineNumber) {
                        finalCursorOffset = finalCursorPos.column - typeRange.startColumn;
                    }
                    else {
                        finalCursorOffset = finalCursorPos.column - 1;
                        for (var i_1 = 0, lineNumber = typeRange.startLineNumber; lineNumber < finalCursorPos.lineNumber; i_1++, lineNumber++) {
                            finalCursorOffset += adaptedSnippet.lines[i_1].length + model.getEOL().length;
                        }
                    }
                    offset += finalCursorOffset;
                }
                else {
                    offset += snippetLength;
                }
                newSelections.push({ offset: offset, i: i });
                totalDelta += (snippetLength - model.getValueLengthInRange(typeRange));
            }
            if (edits.length === 0) {
                return;
            }
            var cursorStateComputer = function () {
                // create new selections from the new selection offsets
                // and restore the order we had at the beginning
                var result = [];
                for (var _i = 0, newSelections_1 = newSelections; _i < newSelections_1.length; _i++) {
                    var _a = newSelections_1[_i], offset = _a.offset, i = _a.i;
                    var pos = model.getPositionAt(offset);
                    result[i] = new selection_1.Selection(pos.lineNumber, pos.column, pos.lineNumber, pos.column);
                }
                return result;
            };
            model.pushStackElement();
            this._editor.setSelections(model.pushEditOperations(selections, edits, cursorStateComputer));
            model.pushStackElement();
        };
        SnippetController._prepareSnippet = function (editor, selection, snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            if (stripPrefix === void 0) { stripPrefix = true; }
            var model = editor.getModel();
            var typeRange = SnippetController_1._getTypeRangeForSelection(model, selection, overwriteBefore, overwriteAfter);
            if (snippet.lines.length === 1) {
                var nextTextOnLine = model.getLineContent(typeRange.endLineNumber).substr(typeRange.endColumn - 1);
                var nextInSnippet = snippet.lines[0].substr(overwriteBefore);
                var commonPrefix = strings.commonPrefixLength(nextTextOnLine, nextInSnippet);
                if (commonPrefix > 0 && stripPrefix) {
                    typeRange = typeRange.setEndPosition(typeRange.endLineNumber, typeRange.endColumn + commonPrefix);
                }
            }
            var adaptedSnippet = SnippetController_1._getAdaptedSnippet(model, snippet, typeRange);
            return {
                typeRange: typeRange,
                adaptedSnippet: adaptedSnippet
            };
        };
        SnippetController._getTypeRangeForSelection = function (model, selection, overwriteBefore, overwriteAfter) {
            var typeRange;
            if (overwriteBefore || overwriteAfter) {
                typeRange = model.validateRange(range_1.Range.plusRange(selection, {
                    startLineNumber: selection.positionLineNumber,
                    startColumn: selection.positionColumn - overwriteBefore,
                    endLineNumber: selection.positionLineNumber,
                    endColumn: selection.positionColumn + overwriteAfter
                }));
            }
            else {
                typeRange = selection;
            }
            return typeRange;
        };
        SnippetController._getAdaptedSnippet = function (model, snippet, typeRange) {
            return snippet.bind(model.getLineContent(typeRange.startLineNumber), typeRange.startLineNumber - 1, typeRange.startColumn - 1, model);
        };
        SnippetController._getSnippetCursorOnly = function (snippet) {
            if (snippet.placeHolders.length !== 1) {
                return null;
            }
            var placeHolder = snippet.placeHolders[0];
            if (placeHolder.value !== '' || placeHolder.occurences.length !== 1) {
                return null;
            }
            var placeHolderRange = placeHolder.occurences[0];
            if (!range_1.Range.isEmpty(placeHolderRange)) {
                return null;
            }
            return {
                lineNumber: placeHolderRange.startLineNumber,
                column: placeHolderRange.startColumn
            };
        };
        SnippetController.prototype.jumpToNextPlaceholder = function () {
            if (this._currentController) {
                this._currentController.onNextPlaceHolder();
            }
        };
        SnippetController.prototype.jumpToPrevPlaceholder = function () {
            if (this._currentController) {
                this._currentController.onPrevPlaceHolder();
            }
        };
        SnippetController.prototype.acceptSnippet = function () {
            if (this._currentController) {
                this._currentController.onAccept();
            }
        };
        SnippetController.prototype.leaveSnippet = function () {
            if (this._currentController) {
                this._currentController.onEscape();
            }
        };
        return SnippetController;
    }());
    SnippetController.ID = 'editor.contrib.snippetController';
    SnippetController = SnippetController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, contextkey_1.IContextKeyService)
    ], SnippetController);
    exports.SnippetController = SnippetController;
    exports.CONTEXT_SNIPPET_MODE = new contextkey_1.RawContextKey('inSnippetMode', false);
    var SnippetCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(SnippetController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SnippetCommand({
        id: 'jumpToNextSnippetPlaceholder',
        precondition: exports.CONTEXT_SNIPPET_MODE,
        handler: function (x) { return x.jumpToNextPlaceholder(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(30),
            kbExpr: EditorContextKeys.TextFocus,
            primary: 2 /* Tab */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SnippetCommand({
        id: 'jumpToPrevSnippetPlaceholder',
        precondition: exports.CONTEXT_SNIPPET_MODE,
        handler: function (x) { return x.jumpToPrevPlaceholder(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(30),
            kbExpr: EditorContextKeys.TextFocus,
            primary: 1024 /* Shift */ | 2 /* Tab */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SnippetCommand({
        id: 'acceptSnippet',
        precondition: exports.CONTEXT_SNIPPET_MODE,
        handler: function (x) { return x.acceptSnippet(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(30),
            kbExpr: EditorContextKeys.TextFocus,
            primary: 3 /* Enter */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SnippetCommand({
        id: 'leaveSnippet',
        precondition: exports.CONTEXT_SNIPPET_MODE,
        handler: function (x) { return x.leaveSnippet(); },
        kbOpts: {
            weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(30),
            kbExpr: EditorContextKeys.TextFocus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    var SnippetController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[482/*vs/editor/contrib/suggest/browser/tabCompletion*/], __M([1/*require*/,0/*exports*/,18/*vs/platform/contextkey/common/contextkey*/,68/*vs/platform/keybinding/common/keybindingsRegistry*/,149/*vs/editor/common/modes/snippetsRegistry*/,35/*vs/platform/platform*/,9/*vs/base/common/strings*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,165/*vs/editor/contrib/snippet/common/snippetController*/]), function (require, exports, contextkey_1, keybindingsRegistry_1, snippetsRegistry_1, platform_1, strings_1, editorCommon, editorCommonExtensions_1, snippetController_1) {
    'use strict';
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var snippetsRegistry = platform_1.Registry.as(snippetsRegistry_1.Extensions.Snippets);
    var TabCompletionController = TabCompletionController_1 = (function () {
        function TabCompletionController(editor, contextKeyService) {
            var _this = this;
            this._currentSnippets = [];
            this._snippetController = snippetController_1.SnippetController.get(editor);
            var hasSnippets = TabCompletionController_1.ContextKey.bindTo(contextKeyService);
            this._cursorChangeSubscription = editor.onDidChangeCursorSelection(function (e) {
                _this._currentSnippets.length = 0;
                var selectFn;
                if (e.selection.isEmpty()) {
                    // empty selection -> real text (no whitespace) left of cursor
                    var prefix_1 = snippetsRegistry_1.getNonWhitespacePrefix(editor.getModel(), editor.getPosition());
                    selectFn = prefix_1 && (function (snippet) { return strings_1.endsWith(prefix_1, snippet.prefix); });
                }
                else {
                    // actual selection -> snippet must be a full match
                    var selected_1 = editor.getModel().getValueInRange(e.selection);
                    selectFn = function (snippet) { return selected_1 === snippet.prefix; };
                }
                if (selectFn) {
                    snippetsRegistry.visitSnippets(editor.getModel().getLanguageIdentifier().id, function (s) {
                        if (selectFn(s)) {
                            _this._currentSnippets.push(s);
                        }
                        return true;
                    });
                }
                hasSnippets.set(_this._currentSnippets.length === 1); //todo@joh make it work with N
            });
        }
        TabCompletionController.get = function (editor) {
            return editor.getContribution(TabCompletionController_1.ID);
        };
        TabCompletionController.prototype.dispose = function () {
            this._cursorChangeSubscription.dispose();
        };
        TabCompletionController.prototype.performSnippetCompletions = function () {
            if (this._currentSnippets.length === 1) {
                var snippet = this._currentSnippets[0];
                this._snippetController.insertSnippet(snippet.codeSnippet, snippet.prefix.length, 0);
            }
        };
        TabCompletionController.prototype.getId = function () {
            return TabCompletionController_1.ID;
        };
        return TabCompletionController;
    }());
    TabCompletionController.ID = 'editor.tabCompletionController';
    TabCompletionController.ContextKey = new contextkey_1.RawContextKey('hasSnippetCompletions', undefined);
    TabCompletionController = TabCompletionController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, contextkey_1.IContextKeyService)
    ], TabCompletionController);
    exports.TabCompletionController = TabCompletionController;
    var TabCompletionCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(TabCompletionController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new TabCompletionCommand({
        id: 'insertSnippet',
        precondition: TabCompletionController.ContextKey,
        handler: function (x) { return x.performSnippetCompletions(); },
        kbOpts: {
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(),
            kbExpr: contextkey_1.ContextKeyExpr.and(EditorContextKeys.TextFocus, EditorContextKeys.TabDoesNotMoveFocus, snippetController_1.CONTEXT_SNIPPET_MODE.toNegated(), contextkey_1.ContextKeyExpr.has('config.editor.tabCompletion')),
            primary: 2 /* Tab */
        }
    }));
    var TabCompletionController_1;
});

define(__m[119/*vs/editor/contrib/suggest/common/suggest*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,28/*vs/base/common/arrays*/,9/*vs/base/common/strings*/,36/*vs/base/common/objects*/,10/*vs/base/common/errors*/,6/*vs/base/common/winjs.base*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,149/*vs/editor/common/modes/snippetsRegistry*/,35/*vs/platform/platform*/,18/*vs/platform/contextkey/common/contextkey*/,44/*vs/editor/common/config/defaultConfig*/]), function (require, exports, async_1, arrays_1, strings_1, objects_1, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, snippetsRegistry_1, platform_1, contextkey_1, defaultConfig_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Context = {
        Visible: new contextkey_1.RawContextKey('suggestWidgetVisible', false),
        MultipleSuggestions: new contextkey_1.RawContextKey('suggestWidgetMultipleSuggestions', false),
        AcceptOnKey: new contextkey_1.RawContextKey('suggestionSupportsAcceptOnKey', true),
        AcceptSuggestionsOnEnter: new contextkey_1.RawContextKey('acceptSuggestionOnEnter', defaultConfig_1.DefaultConfig.editor.acceptSuggestionOnEnter)
    };
    // add suggestions from snippet registry.
    exports.snippetSuggestSupport = {
        triggerCharacters: [],
        provideCompletionItems: function (model, position) {
            var suggestions = platform_1.Registry.as(snippetsRegistry_1.Extensions.Snippets).getSnippetCompletions(model, position);
            if (suggestions) {
                return { suggestions: suggestions };
            }
        }
    };
    function provideSuggestionItems(model, position, snippetConfig, onlyFrom) {
        if (snippetConfig === void 0) { snippetConfig = 'bottom'; }
        var allSuggestions = [];
        var acceptSuggestion = createSuggesionFilter(snippetConfig);
        position = position.clone();
        // get provider groups, always add snippet suggestion provider
        var supports = modes_1.SuggestRegistry.orderedGroups(model);
        // add snippets provider unless turned off
        if (snippetConfig !== 'none') {
            supports.unshift([exports.snippetSuggestSupport]);
        }
        // add suggestions from contributed providers - providers are ordered in groups of
        // equal score and once a group produces a result the process stops
        var hasResult = false;
        var factory = supports.map(function (supports) {
            return function () {
                // stop when we have a result
                if (hasResult) {
                    return;
                }
                // for each support in the group ask for suggestions
                return winjs_base_1.TPromise.join(supports.map(function (support) {
                    if (!arrays_1.isFalsyOrEmpty(onlyFrom) && onlyFrom.indexOf(support) < 0) {
                        return;
                    }
                    return async_1.asWinJsPromise(function (token) { return support.provideCompletionItems(model, position, token); }).then(function (container) {
                        var len = allSuggestions.length;
                        if (container && !arrays_1.isFalsyOrEmpty(container.suggestions)) {
                            for (var _i = 0, _a = container.suggestions; _i < _a.length; _i++) {
                                var suggestion = _a[_i];
                                if (acceptSuggestion(suggestion)) {
                                    fixOverwriteBeforeAfter(suggestion, container);
                                    allSuggestions.push({
                                        position: position,
                                        container: container,
                                        suggestion: suggestion,
                                        support: support,
                                        resolve: createSuggestionResolver(support, suggestion, model, position)
                                    });
                                }
                            }
                        }
                        if (len !== allSuggestions.length && support !== exports.snippetSuggestSupport) {
                            hasResult = true;
                        }
                    }, errors_1.onUnexpectedExternalError);
                }));
            };
        });
        var result = async_1.sequence(factory).then(function () { return allSuggestions.sort(getSuggestionComparator(snippetConfig)); });
        // result.then(items => {
        // 	console.log(model.getWordUntilPosition(position), items.map(item => `${item.suggestion.label}, type=${item.suggestion.type}, incomplete?${item.container.incomplete}, overwriteBefore=${item.suggestion.overwriteBefore}`));
        // 	return items;
        // }, err => {
        // 	console.warn(model.getWordUntilPosition(position), err);
        // });
        return result;
    }
    exports.provideSuggestionItems = provideSuggestionItems;
    function fixOverwriteBeforeAfter(suggestion, container) {
        if (typeof suggestion.overwriteBefore !== 'number') {
            suggestion.overwriteBefore = 0;
        }
        if (typeof suggestion.overwriteAfter !== 'number' || suggestion.overwriteAfter < 0) {
            suggestion.overwriteAfter = 0;
        }
    }
    function createSuggestionResolver(provider, suggestion, model, position) {
        return function () {
            if (typeof provider.resolveCompletionItem === 'function') {
                return async_1.asWinJsPromise(function (token) { return provider.resolveCompletionItem(model, position, suggestion, token); })
                    .then(function (value) { objects_1.assign(suggestion, value); });
            }
            return winjs_base_1.TPromise.as(void 0);
        };
    }
    function createSuggesionFilter(snippetConfig) {
        if (snippetConfig === 'none') {
            return function (suggestion) { return suggestion.type !== 'snippet'; };
        }
        else {
            return function () { return true; };
        }
    }
    function getSuggestionComparator(snippetConfig) {
        function defaultComparator(a, b) {
            var ret = 0;
            // check with 'sortText'
            if (typeof a.suggestion.sortText === 'string' && typeof b.suggestion.sortText === 'string') {
                ret = strings_1.compare(a.suggestion.sortText.toLowerCase(), b.suggestion.sortText.toLowerCase());
            }
            // check with 'label'
            if (!ret) {
                ret = strings_1.compare(a.suggestion.label.toLowerCase(), b.suggestion.label.toLowerCase());
            }
            // check with 'type' and lower snippets
            if (!ret && a.suggestion.type !== b.suggestion.type) {
                if (a.suggestion.type === 'snippet') {
                    ret = 1;
                }
                else if (b.suggestion.type === 'snippet') {
                    ret = -1;
                }
            }
            return ret;
        }
        function snippetUpComparator(a, b) {
            if (a.suggestion.type !== b.suggestion.type) {
                if (a.suggestion.type === 'snippet') {
                    return -1;
                }
                else if (b.suggestion.type === 'snippet') {
                    return 1;
                }
            }
            return defaultComparator(a, b);
        }
        function snippetDownComparator(a, b) {
            if (a.suggestion.type !== b.suggestion.type) {
                if (a.suggestion.type === 'snippet') {
                    return 1;
                }
                else if (b.suggestion.type === 'snippet') {
                    return -1;
                }
            }
            return defaultComparator(a, b);
        }
        if (snippetConfig === 'top') {
            return snippetUpComparator;
        }
        else if (snippetConfig === 'bottom') {
            return snippetDownComparator;
        }
        else {
            return defaultComparator;
        }
    }
    exports.getSuggestionComparator = getSuggestionComparator;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeCompletionItemProvider', function (model, position, args) {
        var result = {
            incomplete: false,
            suggestions: []
        };
        return provideSuggestionItems(model, position).then(function (items) {
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var _a = items_1[_i], container = _a.container, suggestion = _a.suggestion;
                result.incomplete = result.incomplete || container.incomplete;
                result.suggestions.push(suggestion);
            }
            return result;
        });
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[484/*vs/editor/contrib/suggest/browser/suggestWidget*/], __M([1/*require*/,0/*exports*/,312/*vs/nls!vs/editor/contrib/suggest/browser/suggestWidget*/,9/*vs/base/common/strings*/,12/*vs/base/common/event*/,6/*vs/base/common/winjs.base*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,11/*vs/base/browser/dom*/,110/*vs/base/browser/ui/highlightedlabel/highlightedLabel*/,263/*vs/base/browser/ui/list/listWidget*/,60/*vs/base/browser/ui/scrollbar/scrollableElement*/,14/*vs/platform/instantiation/common/instantiation*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,21/*vs/editor/browser/editorBrowser*/,119/*vs/editor/contrib/suggest/common/suggest*/,99/*vs/base/browser/ui/aria/aria*/,53/*vs/platform/telemetry/common/telemetry*/,414/*vs/css!vs/editor/contrib/suggest/browser/suggest*/]), function (require, exports, nls, strings, event_1, winjs_base_1, errors_1, lifecycle_1, dom_1, highlightedLabel_1, listWidget_1, scrollableElement_1, instantiation_1, keybinding_1, contextkey_1, editorBrowser_1, suggest_1, aria_1, telemetry_1) {
    'use strict';
    var sticky = false; // for development purposes
    var colorRegExp = /^(#([\da-f]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))$/i;
    function matchesColor(text) {
        return text && text.match(colorRegExp) ? text : null;
    }
    function canExpandCompletionItem(item) {
        var suggestion = item.suggestion;
        if (suggestion.documentation) {
            return true;
        }
        return (suggestion.detail || '').indexOf('\n') >= 0;
    }
    var Renderer = (function () {
        function Renderer(widget, editor, keybindingService) {
            this.widget = widget;
            this.editor = editor;
            var keybindings = keybindingService.lookupKeybindings('editor.action.triggerSuggest');
            this.triggerKeybindingLabel = keybindings.length === 0 ? '' : " (" + keybindingService.getLabelFor(keybindings[0]) + ")";
        }
        Object.defineProperty(Renderer.prototype, "templateId", {
            get: function () {
                return 'suggestion';
            },
            enumerable: true,
            configurable: true
        });
        Renderer.prototype.renderTemplate = function (container) {
            var _this = this;
            var data = Object.create(null);
            data.disposables = [];
            data.root = container;
            data.icon = dom_1.append(container, dom_1.$('.icon'));
            data.colorspan = dom_1.append(data.icon, dom_1.$('span.colorspan'));
            var text = dom_1.append(container, dom_1.$('.contents'));
            var main = dom_1.append(text, dom_1.$('.main'));
            data.highlightedLabel = new highlightedLabel_1.HighlightedLabel(main);
            data.disposables.push(data.highlightedLabel);
            data.typeLabel = dom_1.append(main, dom_1.$('span.type-label'));
            var docs = dom_1.append(text, dom_1.$('.docs'));
            data.documentation = dom_1.append(docs, dom_1.$('span.docs-text'));
            data.documentationDetails = dom_1.append(docs, dom_1.$('span.docs-details'));
            data.documentationDetails.title = nls.localize(0, null, this.triggerKeybindingLabel);
            var configureFont = function () {
                var configuration = _this.editor.getConfiguration();
                var fontFamily = configuration.fontInfo.fontFamily;
                var fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;
                var lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
                var fontSizePx = fontSize + "px";
                var lineHeightPx = lineHeight + "px";
                data.root.style.fontSize = fontSizePx;
                main.style.fontFamily = fontFamily;
                main.style.lineHeight = lineHeightPx;
                data.icon.style.height = lineHeightPx;
                data.icon.style.width = lineHeightPx;
                data.documentationDetails.style.height = lineHeightPx;
                data.documentationDetails.style.width = lineHeightPx;
            };
            configureFont();
            event_1.chain(this.editor.onDidChangeConfiguration.bind(this.editor))
                .filter(function (e) { return e.fontInfo || e.contribInfo; })
                .on(configureFont, null, data.disposables);
            return data;
        };
        Renderer.prototype.renderElement = function (element, index, templateData) {
            var _this = this;
            var data = templateData;
            var suggestion = element.suggestion;
            if (canExpandCompletionItem(element)) {
                data.root.setAttribute('aria-label', nls.localize(1, null, suggestion.label));
            }
            else {
                data.root.setAttribute('aria-label', nls.localize(2, null, suggestion.label));
            }
            data.icon.className = 'icon ' + suggestion.type;
            data.colorspan.style.backgroundColor = '';
            if (suggestion.type === 'color') {
                var color = matchesColor(suggestion.label) || matchesColor(suggestion.documentation);
                if (color) {
                    data.icon.className = 'icon customcolor';
                    data.colorspan.style.backgroundColor = color;
                }
            }
            data.highlightedLabel.set(suggestion.label, element.highlights);
            data.typeLabel.textContent = (suggestion.detail || '').replace(/\n.*$/m, '');
            data.documentation.textContent = suggestion.documentation || '';
            if (canExpandCompletionItem(element)) {
                dom_1.show(data.documentationDetails);
                data.documentationDetails.onmousedown = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                };
                data.documentationDetails.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    _this.widget.toggleDetails();
                };
            }
            else {
                dom_1.hide(data.documentationDetails);
                data.documentationDetails.onmousedown = null;
                data.documentationDetails.onclick = null;
            }
        };
        Renderer.prototype.disposeTemplate = function (templateData) {
            templateData.highlightedLabel.dispose();
            templateData.disposables = lifecycle_1.dispose(templateData.disposables);
        };
        return Renderer;
    }());
    Renderer = __decorate([
        __param(2, keybinding_1.IKeybindingService)
    ], Renderer);
    var State;
    (function (State) {
        State[State["Hidden"] = 0] = "Hidden";
        State[State["Loading"] = 1] = "Loading";
        State[State["Empty"] = 2] = "Empty";
        State[State["Open"] = 3] = "Open";
        State[State["Frozen"] = 4] = "Frozen";
        State[State["Details"] = 5] = "Details";
    })(State || (State = {}));
    var SuggestionDetails = (function () {
        function SuggestionDetails(container, widget, editor) {
            var _this = this;
            this.widget = widget;
            this.editor = editor;
            this.disposables = [];
            this.el = dom_1.append(container, dom_1.$('.details'));
            this.disposables.push(lifecycle_1.toDisposable(function () { return container.removeChild(_this.el); }));
            var header = dom_1.append(this.el, dom_1.$('.header'));
            this.title = dom_1.append(header, dom_1.$('span.title'));
            this.titleLabel = new highlightedLabel_1.HighlightedLabel(this.title);
            this.disposables.push(this.titleLabel);
            this.back = dom_1.append(header, dom_1.$('span.go-back'));
            this.back.title = nls.localize(3, null);
            this.body = dom_1.$('.body');
            this.scrollbar = new scrollableElement_1.DomScrollableElement(this.body, { canUseTranslate3d: false });
            dom_1.append(this.el, this.scrollbar.getDomNode());
            this.disposables.push(this.scrollbar);
            this.type = dom_1.append(this.body, dom_1.$('p.type'));
            this.docs = dom_1.append(this.body, dom_1.$('p.docs'));
            this.ariaLabel = null;
            this.configureFont();
            event_1.chain(this.editor.onDidChangeConfiguration.bind(this.editor))
                .filter(function (e) { return e.fontInfo; })
                .on(this.configureFont, this, this.disposables);
        }
        Object.defineProperty(SuggestionDetails.prototype, "element", {
            get: function () {
                return this.el;
            },
            enumerable: true,
            configurable: true
        });
        SuggestionDetails.prototype.render = function (item) {
            var _this = this;
            if (!item) {
                this.titleLabel.set('');
                this.type.textContent = '';
                this.docs.textContent = '';
                this.ariaLabel = null;
                return;
            }
            this.titleLabel.set(item.suggestion.label, item.highlights);
            this.type.innerText = item.suggestion.detail || '';
            this.docs.textContent = item.suggestion.documentation;
            this.back.onmousedown = function (e) {
                e.preventDefault();
                e.stopPropagation();
            };
            this.back.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.widget.toggleDetails();
            };
            this.body.scrollTop = 0;
            this.scrollbar.scanDomNode();
            this.ariaLabel = strings.format('{0}\n{1}\n{2}', item.suggestion.label || '', item.suggestion.detail || '', item.suggestion.documentation || '');
        };
        SuggestionDetails.prototype.getAriaLabel = function () {
            return this.ariaLabel;
        };
        SuggestionDetails.prototype.scrollDown = function (much) {
            if (much === void 0) { much = 8; }
            this.body.scrollTop += much;
        };
        SuggestionDetails.prototype.scrollUp = function (much) {
            if (much === void 0) { much = 8; }
            this.body.scrollTop -= much;
        };
        SuggestionDetails.prototype.pageDown = function () {
            this.scrollDown(80);
        };
        SuggestionDetails.prototype.pageUp = function () {
            this.scrollUp(80);
        };
        SuggestionDetails.prototype.configureFont = function () {
            var configuration = this.editor.getConfiguration();
            var fontFamily = configuration.fontInfo.fontFamily;
            var fontSize = configuration.contribInfo.suggestFontSize || configuration.fontInfo.fontSize;
            var lineHeight = configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
            var fontSizePx = fontSize + "px";
            var lineHeightPx = lineHeight + "px";
            this.el.style.fontSize = fontSizePx;
            this.title.style.fontFamily = fontFamily;
            this.type.style.fontFamily = fontFamily;
            this.back.style.height = lineHeightPx;
            this.back.style.width = lineHeightPx;
        };
        SuggestionDetails.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return SuggestionDetails;
    }());
    var SuggestWidget = (function () {
        function SuggestWidget(editor, telemetryService, contextKeyService, instantiationService) {
            var _this = this;
            this.editor = editor;
            this.telemetryService = telemetryService;
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this.onDidSelectEmitter = new event_1.Emitter();
            this.onDidFocusEmitter = new event_1.Emitter();
            this.onDidHideEmitter = new event_1.Emitter();
            this.onDidShowEmitter = new event_1.Emitter();
            this.onDidSelect = this.onDidSelectEmitter.event;
            this.onDidFocus = this.onDidFocusEmitter.event;
            this.onDidHide = this.onDidHideEmitter.event;
            this.onDidShow = this.onDidShowEmitter.event;
            this.isAuto = false;
            this.focusedItem = null;
            this.element = dom_1.$('.editor-widget.suggest-widget');
            if (!this.editor.getConfiguration().contribInfo.iconsInSuggestions) {
                dom_1.addClass(this.element, 'no-icons');
            }
            this.messageElement = dom_1.append(this.element, dom_1.$('.message'));
            this.listElement = dom_1.append(this.element, dom_1.$('.tree'));
            this.details = new SuggestionDetails(this.element, this, this.editor);
            var renderer = instantiationService.createInstance(Renderer, this, this.editor);
            this.list = new listWidget_1.List(this.listElement, this, [renderer], { useShadows: false });
            this.toDispose = [
                editor.onDidBlurEditorText(function () { return _this.onEditorBlur(); }),
                this.list.onSelectionChange(function (e) { return _this.onListSelection(e); }),
                this.list.onFocusChange(function (e) { return _this.onListFocus(e); }),
                this.editor.onDidChangeCursorSelection(function () { return _this.onCursorSelectionChanged(); })
            ];
            this.suggestWidgetVisible = suggest_1.Context.Visible.bindTo(contextKeyService);
            this.suggestWidgetMultipleSuggestions = suggest_1.Context.MultipleSuggestions.bindTo(contextKeyService);
            this.suggestionSupportsAutoAccept = suggest_1.Context.AcceptOnKey.bindTo(contextKeyService);
            this.editor.addContentWidget(this);
            this.setState(0 /* Hidden */);
            // TODO@Alex: this is useful, but spammy
            // var isVisible = false;
            // this.onDidVisibilityChange((newIsVisible) => {
            // 	if (isVisible === newIsVisible) {
            // 		return;
            // 	}
            // 	isVisible = newIsVisible;
            // 	if (isVisible) {
            // 		alert(nls.localize('suggestWidgetAriaVisible', "Suggestions opened"));
            // 	} else {
            // 		alert(nls.localize('suggestWidgetAriaInvisible', "Suggestions closed"));
            // 	}
            // });
        }
        SuggestWidget.prototype.onCursorSelectionChanged = function () {
            if (this.state === 0 /* Hidden */) {
                return;
            }
            this.editor.layoutContentWidget(this);
        };
        SuggestWidget.prototype.onEditorBlur = function () {
            var _this = this;
            if (sticky) {
                return;
            }
            this.editorBlurTimeout = winjs_base_1.TPromise.timeout(150).then(function () {
                if (!_this.editor.isFocused()) {
                    _this.setState(0 /* Hidden */);
                }
            });
        };
        SuggestWidget.prototype.onListSelection = function (e) {
            if (!e.elements.length) {
                return;
            }
            var item = e.elements[0];
            this.onDidSelectEmitter.fire(item);
            aria_1.alert(nls.localize(6, null, item.suggestion.label));
            this.editor.focus();
        };
        SuggestWidget.prototype._getSuggestionAriaAlertLabel = function (item) {
            if (canExpandCompletionItem(item)) {
                return nls.localize(7, null, item.suggestion.label);
            }
            else {
                return nls.localize(8, null, item.suggestion.label);
            }
        };
        SuggestWidget.prototype._ariaAlert = function (newAriaAlertLabel) {
            if (this._lastAriaAlertLabel === newAriaAlertLabel) {
                return;
            }
            this._lastAriaAlertLabel = newAriaAlertLabel;
            if (this._lastAriaAlertLabel) {
                aria_1.alert(this._lastAriaAlertLabel);
            }
        };
        SuggestWidget.prototype.onListFocus = function (e) {
            var _this = this;
            if (!e.elements.length) {
                if (this.currentSuggestionDetails) {
                    this.currentSuggestionDetails.cancel();
                    this.currentSuggestionDetails = null;
                    this.focusedItem = null;
                }
                this._ariaAlert(null);
                // TODO@Alex: Chromium bug
                // this.editor.setAriaActiveDescendant(null);
                return;
            }
            var item = e.elements[0];
            this._ariaAlert(this._getSuggestionAriaAlertLabel(item));
            // TODO@Alex: Chromium bug
            // // TODO@Alex: the list is not done rendering...
            // setTimeout(() => {
            // 	this.editor.setAriaActiveDescendant(this.list.getElementId(e.indexes[0]));
            // }, 100);
            if (item === this.focusedItem) {
                return;
            }
            if (this.currentSuggestionDetails) {
                this.currentSuggestionDetails.cancel();
                this.currentSuggestionDetails = null;
            }
            var index = e.indexes[0];
            this.suggestionSupportsAutoAccept.set(!item.suggestion.noAutoAccept);
            this.focusedItem = item;
            this.updateWidgetHeight();
            this.list.reveal(index);
            this.currentSuggestionDetails = item.resolve()
                .then(function () {
                _this.list.setFocus([index]);
                _this.updateWidgetHeight();
                _this.list.reveal(index);
                _this._ariaAlert(_this._getSuggestionAriaAlertLabel(item));
            })
                .then(null, function (err) { return !errors_1.isPromiseCanceledError(err) && errors_1.onUnexpectedError(err); })
                .then(function () { return _this.currentSuggestionDetails = null; });
            // emit an event
            this.onDidFocusEmitter.fire(item);
        };
        SuggestWidget.prototype.setState = function (state) {
            if (!this.element) {
                return;
            }
            var stateChanged = this.state !== state;
            this.state = state;
            dom_1.toggleClass(this.element, 'frozen', state === 4 /* Frozen */);
            switch (state) {
                case 0 /* Hidden */:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.hide();
                    if (stateChanged) {
                        this.list.splice(0, this.list.length);
                    }
                    break;
                case 1 /* Loading */:
                    this.messageElement.textContent = SuggestWidget.LOADING_MESSAGE;
                    dom_1.hide(this.listElement, this.details.element);
                    dom_1.show(this.messageElement);
                    this.show();
                    break;
                case 2 /* Empty */:
                    this.messageElement.textContent = SuggestWidget.NO_SUGGESTIONS_MESSAGE;
                    dom_1.hide(this.listElement, this.details.element);
                    dom_1.show(this.messageElement);
                    this.show();
                    break;
                case 3 /* Open */:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.show();
                    break;
                case 4 /* Frozen */:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.show();
                    break;
                case 5 /* Details */:
                    dom_1.hide(this.messageElement, this.listElement);
                    dom_1.show(this.details.element);
                    this.show();
                    this._ariaAlert(this.details.getAriaLabel());
                    break;
            }
            if (stateChanged) {
                this.editor.layoutContentWidget(this);
            }
        };
        SuggestWidget.prototype.showTriggered = function (auto) {
            var _this = this;
            if (this.state !== 0 /* Hidden */) {
                return;
            }
            this.isAuto = !!auto;
            if (!this.isAuto) {
                this.loadingTimeout = setTimeout(function () {
                    _this.loadingTimeout = null;
                    _this.setState(1 /* Loading */);
                }, 50);
            }
        };
        SuggestWidget.prototype.showSuggestions = function (completionModel, isFrozen, isAuto) {
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
            this.completionModel = completionModel;
            if (isFrozen && this.state !== 2 /* Empty */) {
                this.setState(4 /* Frozen */);
                return;
            }
            var visibleCount = this.completionModel.items.length;
            var isEmpty = visibleCount === 0;
            this.suggestWidgetMultipleSuggestions.set(visibleCount > 1);
            if (isEmpty) {
                if (isAuto) {
                    this.setState(0 /* Hidden */);
                }
                else {
                    this.setState(2 /* Empty */);
                }
                this.completionModel = null;
            }
            else {
                var stats = this.completionModel.stats;
                stats['wasAutomaticallyTriggered'] = !!isAuto;
                this.telemetryService.publicLog('suggestWidget', stats);
                this.list.splice(0, this.list.length, this.completionModel.items);
                this.list.setFocus([this.completionModel.topScoreIdx]);
                this.list.reveal(this.completionModel.topScoreIdx, 0);
                this.setState(3 /* Open */);
            }
        };
        SuggestWidget.prototype.selectNextPage = function () {
            switch (this.state) {
                case 0 /* Hidden */:
                    return false;
                case 5 /* Details */:
                    this.details.pageDown();
                    return true;
                case 1 /* Loading */:
                    return !this.isAuto;
                default:
                    this.list.focusNextPage();
                    return true;
            }
        };
        SuggestWidget.prototype.selectNext = function () {
            switch (this.state) {
                case 0 /* Hidden */:
                    return false;
                case 5 /* Details */:
                    this.list.focusNext(1, true);
                    this.renderDetails();
                    return true;
                case 1 /* Loading */:
                    return !this.isAuto;
                default:
                    this.list.focusNext(1, true);
                    return true;
            }
        };
        SuggestWidget.prototype.selectPreviousPage = function () {
            switch (this.state) {
                case 0 /* Hidden */:
                    return false;
                case 5 /* Details */:
                    this.details.pageUp();
                    return true;
                case 1 /* Loading */:
                    return !this.isAuto;
                default:
                    this.list.focusPreviousPage();
                    return true;
            }
        };
        SuggestWidget.prototype.selectPrevious = function () {
            switch (this.state) {
                case 0 /* Hidden */:
                    return false;
                case 5 /* Details */:
                    this.list.focusPrevious(1, true);
                    this.renderDetails();
                    return true;
                case 1 /* Loading */:
                    return !this.isAuto;
                default:
                    this.list.focusPrevious(1, true);
                    return false;
            }
        };
        SuggestWidget.prototype.getFocusedItem = function () {
            if (this.state !== 0 /* Hidden */
                && this.state !== 2 /* Empty */
                && this.state !== 1 /* Loading */) {
                return this.list.getFocusedElements()[0];
            }
        };
        SuggestWidget.prototype.toggleDetails = function () {
            if (this.state === 5 /* Details */) {
                this.setState(3 /* Open */);
                this.editor.focus();
                return;
            }
            if (this.state !== 3 /* Open */) {
                return;
            }
            var item = this.list.getFocusedElements()[0];
            if (!item || !canExpandCompletionItem(item)) {
                return;
            }
            this.setState(5 /* Details */);
            this.editor.focus();
            this.telemetryService.publicLog('suggestWidget:toggleDetails');
        };
        SuggestWidget.prototype.show = function () {
            var _this = this;
            this.updateWidgetHeight();
            this.suggestWidgetVisible.set(true);
            this.renderDetails();
            this.showTimeout = winjs_base_1.TPromise.timeout(100).then(function () {
                dom_1.addClass(_this.element, 'visible');
                _this.onDidShowEmitter.fire(_this);
            });
        };
        SuggestWidget.prototype.hide = function () {
            this.suggestWidgetVisible.reset();
            this.suggestWidgetMultipleSuggestions.reset();
            dom_1.removeClass(this.element, 'visible');
        };
        SuggestWidget.prototype.hideWidget = function () {
            clearTimeout(this.loadingTimeout);
            this.setState(0 /* Hidden */);
            this.onDidHideEmitter.fire(this);
        };
        SuggestWidget.prototype.hideDetailsOrHideWidget = function () {
            if (this.state === 5 /* Details */) {
                this.toggleDetails();
            }
            else {
                this.hideWidget();
            }
        };
        SuggestWidget.prototype.getPosition = function () {
            if (this.state === 0 /* Hidden */) {
                return null;
            }
            return {
                position: this.editor.getPosition(),
                preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE]
            };
        };
        SuggestWidget.prototype.getDomNode = function () {
            return this.element;
        };
        SuggestWidget.prototype.getId = function () {
            return SuggestWidget.ID;
        };
        SuggestWidget.prototype.updateWidgetHeight = function () {
            var height = 0;
            if (this.state === 2 /* Empty */ || this.state === 1 /* Loading */) {
                height = this.unfocusedHeight;
            }
            else if (this.state === 5 /* Details */) {
                height = 12 * this.unfocusedHeight;
            }
            else {
                var focus_1 = this.list.getFocusedElements()[0];
                var focusHeight = focus_1 ? this.getHeight(focus_1) : this.unfocusedHeight;
                height = focusHeight;
                var suggestionCount = (this.list.contentHeight - focusHeight) / this.unfocusedHeight;
                height += Math.min(suggestionCount, 11) * this.unfocusedHeight;
            }
            this.element.style.lineHeight = this.unfocusedHeight + "px";
            this.element.style.height = height + "px";
            this.list.layout(height);
            this.editor.layoutContentWidget(this);
            return height;
        };
        SuggestWidget.prototype.renderDetails = function () {
            if (this.state !== 5 /* Details */) {
                this.details.render(null);
            }
            else {
                this.details.render(this.list.getFocusedElements()[0]);
            }
        };
        Object.defineProperty(SuggestWidget.prototype, "focusHeight", {
            // Heights
            get: function () {
                return this.unfocusedHeight * 2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestWidget.prototype, "unfocusedHeight", {
            get: function () {
                var configuration = this.editor.getConfiguration();
                return configuration.contribInfo.suggestLineHeight || configuration.fontInfo.lineHeight;
            },
            enumerable: true,
            configurable: true
        });
        // IDelegate
        SuggestWidget.prototype.getHeight = function (element) {
            var focus = this.list.getFocusedElements()[0];
            if (canExpandCompletionItem(element) && element === focus) {
                return this.focusHeight;
            }
            return this.unfocusedHeight;
        };
        SuggestWidget.prototype.getTemplateId = function (element) {
            return 'suggestion';
        };
        SuggestWidget.prototype.dispose = function () {
            this.state = null;
            this.suggestionSupportsAutoAccept = null;
            this.currentSuggestionDetails = null;
            this.focusedItem = null;
            this.element = null;
            this.messageElement = null;
            this.listElement = null;
            this.details.dispose();
            this.details = null;
            this.list.dispose();
            this.list = null;
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
            if (this.editorBlurTimeout) {
                this.editorBlurTimeout.cancel();
                this.editorBlurTimeout = null;
            }
            if (this.showTimeout) {
                this.showTimeout.cancel();
                this.showTimeout = null;
            }
        };
        return SuggestWidget;
    }());
    SuggestWidget.ID = 'editor.widget.suggestWidget';
    SuggestWidget.LOADING_MESSAGE = nls.localize(4, null);
    SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls.localize(5, null);
    SuggestWidget = __decorate([
        __param(1, telemetry_1.ITelemetryService),
        __param(2, contextkey_1.IContextKeyService),
        __param(3, instantiation_1.IInstantiationService)
    ], SuggestWidget);
    exports.SuggestWidget = SuggestWidget;
});

define(__m[485/*vs/editor/contrib/suggest/common/suggestModel*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,28/*vs/base/common/arrays*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,6/*vs/base/common/winjs.base*/,2/*vs/editor/common/editorCommon*/,15/*vs/editor/common/modes*/,119/*vs/editor/contrib/suggest/common/suggest*/,239/*vs/editor/contrib/suggest/common/completionModel*/]), function (require, exports, errors_1, arrays_1, event_1, lifecycle_1, winjs_base_1, editorCommon_1, modes_1, suggest_1, completionModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineContext = (function () {
        function LineContext(model, position, auto) {
            this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
            this.leadingWord = model.getWordUntilPosition(position);
            this.lineNumber = position.lineNumber;
            this.column = position.column;
            this.auto = auto;
        }
        LineContext.shouldAutoTrigger = function (editor) {
            var model = editor.getModel();
            if (!model) {
                return false;
            }
            var pos = editor.getPosition();
            var word = model.getWordAtPosition(pos);
            if (!word) {
                return false;
            }
            if (word.endColumn !== pos.column) {
                return false;
            }
            if (!isNaN(Number(word.word))) {
                return false;
            }
            return true;
        };
        LineContext.isInEditableRange = function (editor) {
            var model = editor.getModel();
            var position = editor.getPosition();
            if (model.hasEditableRange()) {
                var editableRange = model.getEditableRange();
                if (!editableRange.containsPosition(position)) {
                    return false;
                }
            }
            return true;
        };
        return LineContext;
    }());
    exports.LineContext = LineContext;
    var State;
    (function (State) {
        State[State["Idle"] = 0] = "Idle";
        State[State["Manual"] = 1] = "Manual";
        State[State["Auto"] = 2] = "Auto";
    })(State || (State = {}));
    var SuggestModel = (function () {
        function SuggestModel(editor) {
            var _this = this;
            this.editor = editor;
            this.toDispose = [];
            this._onDidCancel = new event_1.Emitter();
            this._onDidTrigger = new event_1.Emitter();
            this._onDidSuggest = new event_1.Emitter();
            this.state = 0 /* Idle */;
            this.triggerAutoSuggestPromise = null;
            this.requestPromise = null;
            this.completionModel = null;
            this.context = null;
            // wire up various listeners
            this.toDispose.push(this.editor.onDidChangeModel(function () {
                _this.updateTriggerCharacters();
                _this.cancel();
            }));
            this.toDispose.push(editor.onDidChangeModelLanguage(function () {
                _this.updateTriggerCharacters();
                _this.cancel();
            }));
            this.toDispose.push(this.editor.onDidChangeConfiguration(function () {
                _this.updateTriggerCharacters();
                _this.updateQuickSuggest();
            }));
            this.toDispose.push(modes_1.SuggestRegistry.onDidChange(function () {
                _this.updateTriggerCharacters();
                _this.updateActiveSuggestSession();
            }));
            this.toDispose.push(this.editor.onDidChangeCursorSelection(function (e) {
                _this.onCursorChange(e);
            }));
            this.updateTriggerCharacters();
            this.updateQuickSuggest();
        }
        Object.defineProperty(SuggestModel.prototype, "onDidCancel", {
            get: function () { return this._onDidCancel.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestModel.prototype, "onDidTrigger", {
            get: function () { return this._onDidTrigger.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestModel.prototype, "onDidSuggest", {
            get: function () { return this._onDidSuggest.event; },
            enumerable: true,
            configurable: true
        });
        SuggestModel.prototype.dispose = function () {
            lifecycle_1.dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this.triggerCharacterListener]);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this.cancel();
        };
        // --- handle configuration & precondition changes
        SuggestModel.prototype.updateQuickSuggest = function () {
            this.quickSuggestDelay = this.editor.getConfiguration().contribInfo.quickSuggestionsDelay;
            if (isNaN(this.quickSuggestDelay) || (!this.quickSuggestDelay && this.quickSuggestDelay !== 0) || this.quickSuggestDelay < 0) {
                this.quickSuggestDelay = 10;
            }
        };
        SuggestModel.prototype.updateTriggerCharacters = function () {
            var _this = this;
            lifecycle_1.dispose(this.triggerCharacterListener);
            if (this.editor.getConfiguration().readOnly
                || !this.editor.getModel()
                || !this.editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {
                return;
            }
            var supportsByTriggerCharacter = Object.create(null);
            for (var _i = 0, _a = modes_1.SuggestRegistry.all(this.editor.getModel()); _i < _a.length; _i++) {
                var support = _a[_i];
                if (arrays_1.isFalsyOrEmpty(support.triggerCharacters)) {
                    continue;
                }
                for (var _b = 0, _c = support.triggerCharacters; _b < _c.length; _b++) {
                    var ch = _c[_b];
                    var array = supportsByTriggerCharacter[ch];
                    if (!array) {
                        supportsByTriggerCharacter[ch] = [support];
                    }
                    else {
                        array.push(support);
                    }
                }
            }
            this.triggerCharacterListener = this.editor.onDidType(function (text) {
                var lastChar = text.charAt(text.length - 1);
                var supports = supportsByTriggerCharacter[lastChar];
                if (supports) {
                    _this.trigger(true, false, supports);
                }
            });
        };
        // --- trigger/retrigger/cancel suggest
        SuggestModel.prototype.cancel = function (retrigger) {
            if (retrigger === void 0) { retrigger = false; }
            if (this.triggerAutoSuggestPromise) {
                this.triggerAutoSuggestPromise.cancel();
                this.triggerAutoSuggestPromise = null;
            }
            if (this.requestPromise) {
                this.requestPromise.cancel();
                this.requestPromise = null;
            }
            this.state = 0 /* Idle */;
            this.completionModel = null;
            this.context = null;
            this._onDidCancel.fire({ retrigger: retrigger });
        };
        SuggestModel.prototype.updateActiveSuggestSession = function () {
            if (this.state !== 0 /* Idle */) {
                if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
                    this.cancel();
                }
                else {
                    this.trigger(this.state === 2 /* Auto */, true);
                }
            }
        };
        SuggestModel.prototype.onCursorChange = function (e) {
            var _this = this;
            if (!e.selection.isEmpty()
                || e.source !== 'keyboard'
                || e.reason !== editorCommon_1.CursorChangeReason.NotSet) {
                this.cancel();
                return;
            }
            if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
                return;
            }
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            if (this.state === 0 /* Idle */) {
                if (this.editor.getConfiguration().contribInfo.quickSuggestions) {
                    // trigger 24x7 IntelliSense when idle and enabled
                    this.cancel();
                    if (LineContext.shouldAutoTrigger(this.editor)) {
                        this.triggerAutoSuggestPromise = winjs_base_1.TPromise.timeout(this.quickSuggestDelay);
                        this.triggerAutoSuggestPromise.then(function () {
                            _this.triggerAutoSuggestPromise = null;
                            _this.trigger(true);
                        });
                    }
                }
            }
            else {
                // refine active suggestion
                var ctx = new LineContext(model, this.editor.getPosition(), this.state === 2 /* Auto */);
                this.onNewContext(ctx);
            }
        };
        SuggestModel.prototype.trigger = function (auto, retrigger, onlyFrom, existingItems) {
            var _this = this;
            if (retrigger === void 0) { retrigger = false; }
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var ctx = new LineContext(model, this.editor.getPosition(), auto);
            if (!LineContext.isInEditableRange(this.editor)) {
                return;
            }
            // Cancel previous requests, change state & update UI
            this.cancel(retrigger);
            this.state = auto ? 2 /* Auto */ : 1 /* Manual */;
            this._onDidTrigger.fire({ auto: auto });
            // Capture context when request was sent
            this.context = ctx;
            this.requestPromise = suggest_1.provideSuggestionItems(model, this.editor.getPosition(), this.editor.getConfiguration().contribInfo.snippetSuggestions, onlyFrom).then(function (items) {
                _this.requestPromise = null;
                if (_this.state === 0 /* Idle */) {
                    return;
                }
                var model = _this.editor.getModel();
                if (!model) {
                    return;
                }
                if (!arrays_1.isFalsyOrEmpty(existingItems)) {
                    var cmpFn = suggest_1.getSuggestionComparator(_this.editor.getConfiguration().contribInfo.snippetSuggestions);
                    items = items.concat(existingItems).sort(cmpFn);
                }
                var ctx = new LineContext(model, _this.editor.getPosition(), auto);
                _this.completionModel = new completionModel_1.CompletionModel(items, _this.context.column, {
                    leadingLineContent: ctx.leadingLineContent,
                    characterCountDelta: _this.context ? ctx.column - _this.context.column : 0
                });
                _this.onNewContext(ctx);
            }).then(null, errors_1.onUnexpectedError);
        };
        SuggestModel.prototype.onNewContext = function (ctx) {
            if (!this.context) {
                // happens when 24x7 IntelliSense is enabled and still in its delay
                return;
            }
            if (ctx.lineNumber !== this.context.lineNumber) {
                // e.g. happens when pressing Enter while IntelliSense is computed
                this.cancel();
                return;
            }
            if (ctx.column < this.context.column) {
                // typed -> moved cursor LEFT -> retrigger if still on a word
                if (ctx.leadingWord.word) {
                    this.trigger(this.context.auto, true);
                }
                return;
            }
            if (!this.completionModel) {
                // happens when IntelliSense is not yet computed
                return;
            }
            if (ctx.column > this.context.column && this.completionModel.incomplete) {
                // typed -> moved cursor RIGHT & incomple model -> retrigger
                var _a = this.completionModel.resolveIncompleteInfo(), complete = _a.complete, incomplete = _a.incomplete;
                this.trigger(this.state === 2 /* Auto */, true, incomplete, complete);
            }
            else {
                // typed -> moved cursor RIGHT -> update UI
                var oldLineContext = this.completionModel.lineContext;
                var isFrozen = false;
                this.completionModel.lineContext = {
                    leadingLineContent: ctx.leadingLineContent,
                    characterCountDelta: ctx.column - this.context.column
                };
                if (this.completionModel.items.length === 0) {
                    if (LineContext.shouldAutoTrigger(this.editor) && this.context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
                        // retrigger when heading into a new word
                        this.trigger(this.context.auto, true);
                        return;
                    }
                    if (!this.context.auto) {
                        // freeze when IntelliSense was manually requested
                        this.completionModel.lineContext = oldLineContext;
                        isFrozen = this.completionModel.items.length > 0;
                    }
                }
                this._onDidSuggest.fire({
                    completionModel: this.completionModel,
                    auto: this.context.auto,
                    isFrozen: isFrozen,
                });
            }
        };
        return SuggestModel;
    }());
    exports.SuggestModel = SuggestModel;
});















define(__m[486/*vs/editor/contrib/suggest/browser/suggestController*/], __M([1/*require*/,0/*exports*/,311/*vs/nls!vs/editor/contrib/suggest/browser/suggestController*/,10/*vs/base/common/errors*/,28/*vs/base/common/arrays*/,3/*vs/base/common/lifecycle*/,14/*vs/platform/instantiation/common/instantiation*/,53/*vs/platform/telemetry/common/telemetry*/,18/*vs/platform/contextkey/common/contextkey*/,22/*vs/platform/commands/common/commands*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/,46/*vs/editor/common/core/editOperation*/,4/*vs/editor/common/core/range*/,93/*vs/editor/contrib/snippet/common/snippet*/,165/*vs/editor/contrib/snippet/common/snippetController*/,119/*vs/editor/contrib/suggest/common/suggest*/,485/*vs/editor/contrib/suggest/common/suggestModel*/,484/*vs/editor/contrib/suggest/browser/suggestWidget*/]), function (require, exports, nls, errors_1, arrays_1, lifecycle_1, instantiation_1, telemetry_1, contextkey_1, commands_1, editorCommon_1, editorCommonExtensions_1, editorBrowserExtensions_1, editOperation_1, range_1, snippet_1, snippetController_1, suggest_1, suggestModel_1, suggestWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AcceptOnCharacterOracle = (function () {
        function AcceptOnCharacterOracle(editor, widget, accept) {
            var _this = this;
            this._disposables = [];
            this._activeAcceptCharacters = new Set();
            this._disposables.push(widget.onDidShow(function () { return _this._onItem(widget.getFocusedItem()); }));
            this._disposables.push(widget.onDidFocus(this._onItem, this));
            this._disposables.push(widget.onDidHide(this.reset, this));
            this._disposables.push(editor.onWillType(function (text) {
                if (_this._activeItem) {
                    var ch = text[text.length - 1];
                    if (_this._activeAcceptCharacters.has(ch) && editor.getConfiguration().contribInfo.acceptSuggestionOnCommitCharacter) {
                        accept(_this._activeItem);
                    }
                }
            }));
        }
        AcceptOnCharacterOracle.prototype._onItem = function (item) {
            if (!item || arrays_1.isFalsyOrEmpty(item.suggestion.commitCharacters)) {
                this.reset();
                return;
            }
            this._activeItem = item;
            this._activeAcceptCharacters.clear();
            for (var _i = 0, _a = item.suggestion.commitCharacters; _i < _a.length; _i++) {
                var ch = _a[_i];
                if (ch.length > 0) {
                    this._activeAcceptCharacters.add(ch[0]);
                }
            }
        };
        AcceptOnCharacterOracle.prototype.reset = function () {
            this._activeItem = undefined;
        };
        AcceptOnCharacterOracle.prototype.dispose = function () {
            lifecycle_1.dispose(this._disposables);
        };
        return AcceptOnCharacterOracle;
    }());
    var SuggestController = SuggestController_1 = (function () {
        function SuggestController(editor, commandService, telemetryService, contextKeyService, instantiationService) {
            var _this = this;
            this.editor = editor;
            this.commandService = commandService;
            this.telemetryService = telemetryService;
            this.toDispose = [];
            this.model = new suggestModel_1.SuggestModel(this.editor);
            this.toDispose.push(this.model.onDidTrigger(function (e) { return _this.widget.showTriggered(e.auto); }));
            this.toDispose.push(this.model.onDidSuggest(function (e) { return _this.widget.showSuggestions(e.completionModel, e.isFrozen, e.auto); }));
            this.toDispose.push(this.model.onDidCancel(function (e) { return !e.retrigger && _this.widget.hideWidget(); }));
            // Manage the acceptSuggestionsOnEnter context key
            var acceptSuggestionsOnEnter = suggest_1.Context.AcceptSuggestionsOnEnter.bindTo(contextKeyService);
            var updateFromConfig = function () {
                acceptSuggestionsOnEnter.set(_this.editor.getConfiguration().contribInfo.acceptSuggestionOnEnter);
            };
            this.toDispose.push(this.editor.onDidChangeConfiguration(function (e) { return updateFromConfig(); }));
            updateFromConfig();
            this.widget = instantiationService.createInstance(suggestWidget_1.SuggestWidget, this.editor);
            this.toDispose.push(this.widget.onDidSelect(this.onDidSelectItem, this));
            // Wire up logic to accept a suggestion on certain characters
            var autoAcceptOracle = new AcceptOnCharacterOracle(editor, this.widget, function (item) { return _this.onDidSelectItem(item); });
            this.toDispose.push(autoAcceptOracle, this.model.onDidSuggest(function (e) {
                if (e.completionModel.items.length === 0) {
                    autoAcceptOracle.reset();
                }
            }));
        }
        SuggestController.get = function (editor) {
            return editor.getContribution(SuggestController_1.ID);
        };
        SuggestController.prototype.getId = function () {
            return SuggestController_1.ID;
        };
        SuggestController.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            if (this.widget) {
                this.widget.dispose();
                this.widget = null;
            }
            if (this.model) {
                this.model.dispose();
                this.model = null;
            }
        };
        SuggestController.prototype.onDidSelectItem = function (item) {
            if (item) {
                var suggestion = item.suggestion, position = item.position;
                var columnDelta = this.editor.getPosition().column - position.column;
                if (Array.isArray(suggestion.additionalTextEdits)) {
                    this.editor.pushUndoStop();
                    this.editor.executeEdits('suggestController.additionalTextEdits', suggestion.additionalTextEdits.map(function (edit) { return editOperation_1.EditOperation.replace(range_1.Range.lift(edit.range), edit.text); }));
                    this.editor.pushUndoStop();
                }
                if (suggestion.snippetType === 'textmate') {
                    snippetController_1.SnippetController.get(this.editor).insertSnippet(suggestion.insertText, suggestion.overwriteBefore + columnDelta, suggestion.overwriteAfter);
                }
                else {
                    snippetController_1.SnippetController.get(this.editor).run(snippet_1.CodeSnippet.fromInternal(suggestion.insertText), suggestion.overwriteBefore + columnDelta, suggestion.overwriteAfter);
                }
                if (suggestion.command) {
                    (_a = this.commandService).executeCommand.apply(_a, [suggestion.command.id].concat(suggestion.command.arguments)).done(undefined, errors_1.onUnexpectedError);
                }
            }
            this.model.cancel();
            var _a;
        };
        SuggestController.prototype.triggerSuggest = function () {
            this.model.trigger(false, false);
            this.editor.revealLine(this.editor.getPosition().lineNumber);
            this.editor.focus();
        };
        SuggestController.prototype.acceptSelectedSuggestion = function () {
            if (this.widget) {
                var item = this.widget.getFocusedItem();
                this.onDidSelectItem(item);
            }
        };
        SuggestController.prototype.cancelSuggestWidget = function () {
            if (this.widget) {
                this.model.cancel();
                this.widget.hideDetailsOrHideWidget();
            }
        };
        SuggestController.prototype.selectNextSuggestion = function () {
            if (this.widget) {
                this.widget.selectNext();
            }
        };
        SuggestController.prototype.selectNextPageSuggestion = function () {
            if (this.widget) {
                this.widget.selectNextPage();
            }
        };
        SuggestController.prototype.selectPrevSuggestion = function () {
            if (this.widget) {
                this.widget.selectPrevious();
            }
        };
        SuggestController.prototype.selectPrevPageSuggestion = function () {
            if (this.widget) {
                this.widget.selectPreviousPage();
            }
        };
        SuggestController.prototype.toggleSuggestionDetails = function () {
            if (this.widget) {
                this.widget.toggleDetails();
            }
        };
        return SuggestController;
    }());
    SuggestController.ID = 'editor.contrib.suggestController';
    SuggestController = SuggestController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, commands_1.ICommandService),
        __param(2, telemetry_1.ITelemetryService),
        __param(3, contextkey_1.IContextKeyService),
        __param(4, instantiation_1.IInstantiationService)
    ], SuggestController);
    exports.SuggestController = SuggestController;
    var TriggerSuggestAction = (function (_super) {
        __extends(TriggerSuggestAction, _super);
        function TriggerSuggestAction() {
            return _super.call(this, {
                id: 'editor.action.triggerSuggest',
                label: nls.localize(0, null),
                alias: 'Trigger Suggest',
                precondition: contextkey_1.ContextKeyExpr.and(editorCommon_1.EditorContextKeys.Writable, editorCommon_1.ModeContextKeys.hasCompletionItemProvider),
                kbOpts: {
                    kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 10 /* Space */,
                    mac: { primary: 256 /* WinCtrl */ | 10 /* Space */ }
                }
            }) || this;
        }
        TriggerSuggestAction.prototype.run = function (accessor, editor) {
            SuggestController.get(editor).triggerSuggest();
        };
        return TriggerSuggestAction;
    }(editorCommonExtensions_1.EditorAction));
    TriggerSuggestAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], TriggerSuggestAction);
    exports.TriggerSuggestAction = TriggerSuggestAction;
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(90);
    var SuggestCommand = editorCommonExtensions_1.EditorCommand.bindToContribution(SuggestController.get);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'acceptSelectedSuggestion',
        precondition: suggest_1.Context.Visible,
        handler: function (x) { return x.acceptSelectedSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 2 /* Tab */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'acceptSelectedSuggestionOnEnter',
        precondition: suggest_1.Context.Visible,
        handler: function (x) { return x.acceptSelectedSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: contextkey_1.ContextKeyExpr.and(editorCommon_1.EditorContextKeys.TextFocus, suggest_1.Context.AcceptSuggestionsOnEnter),
            primary: 3 /* Enter */
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'hideSuggestWidget',
        precondition: suggest_1.Context.Visible,
        handler: function (x) { return x.cancelSuggestWidget(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 9 /* Escape */,
            secondary: [1024 /* Shift */ | 9 /* Escape */]
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'selectNextSuggestion',
        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),
        handler: function (c) { return c.selectNextSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 18 /* DownArrow */,
            secondary: [512 /* Alt */ | 18 /* DownArrow */],
            mac: { primary: 18 /* DownArrow */, secondary: [512 /* Alt */ | 18 /* DownArrow */, 256 /* WinCtrl */ | 44 /* KEY_N */] }
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'selectNextPageSuggestion',
        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),
        handler: function (c) { return c.selectNextPageSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 12 /* PageDown */,
            secondary: [512 /* Alt */ | 12 /* PageDown */]
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'selectPrevSuggestion',
        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),
        handler: function (c) { return c.selectPrevSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 16 /* UpArrow */,
            secondary: [512 /* Alt */ | 16 /* UpArrow */],
            mac: { primary: 16 /* UpArrow */, secondary: [512 /* Alt */ | 16 /* UpArrow */, 256 /* WinCtrl */ | 46 /* KEY_P */] }
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'selectPrevPageSuggestion',
        precondition: contextkey_1.ContextKeyExpr.and(suggest_1.Context.Visible, suggest_1.Context.MultipleSuggestions),
        handler: function (c) { return c.selectPrevPageSuggestion(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 11 /* PageUp */,
            secondary: [512 /* Alt */ | 11 /* PageUp */]
        }
    }));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(new SuggestCommand({
        id: 'toggleSuggestionDetails',
        precondition: suggest_1.Context.Visible,
        handler: function (x) { return x.toggleSuggestionDetails(); },
        kbOpts: {
            weight: weight,
            kbExpr: editorCommon_1.EditorContextKeys.TextFocus,
            primary: 2048 /* CtrlCmd */ | 10 /* Space */,
            mac: { primary: 256 /* WinCtrl */ | 10 /* Space */ }
        }
    }));
    var SuggestController_1;
});












define(__m[487/*vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode*/], __M([1/*require*/,0/*exports*/,313/*vs/nls!vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode*/,13/*vs/editor/common/editorCommonExtensions*/,112/*vs/editor/common/config/commonEditorConfig*/]), function (require, exports, nls, editorCommonExtensions_1, commonEditorConfig_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ToggleTabFocusModeAction = ToggleTabFocusModeAction_1 = (function (_super) {
        __extends(ToggleTabFocusModeAction, _super);
        function ToggleTabFocusModeAction() {
            return _super.call(this, {
                id: ToggleTabFocusModeAction_1.ID,
                label: nls.localize(0, null),
                alias: 'Toggle Tab Key Moves Focus',
                precondition: null,
                kbOpts: {
                    kbExpr: null,
                    primary: 2048 /* CtrlCmd */ | 43 /* KEY_M */,
                    mac: { primary: 256 /* WinCtrl */ | 1024 /* Shift */ | 43 /* KEY_M */ }
                }
            }) || this;
        }
        ToggleTabFocusModeAction.prototype.run = function (accessor, editor) {
            var oldValue = commonEditorConfig_1.TabFocus.getTabFocusMode();
            commonEditorConfig_1.TabFocus.setTabFocusMode(!oldValue);
        };
        return ToggleTabFocusModeAction;
    }(editorCommonExtensions_1.EditorAction));
    ToggleTabFocusModeAction.ID = 'editor.action.toggleTabFocusMode';
    ToggleTabFocusModeAction = ToggleTabFocusModeAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], ToggleTabFocusModeAction);
    exports.ToggleTabFocusModeAction = ToggleTabFocusModeAction;
    var ToggleTabFocusModeAction_1;
});







define(__m[488/*vs/editor/contrib/wordHighlighter/common/wordHighlighter*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,3/*vs/base/common/lifecycle*/]), function (require, exports, async_1, errors_1, range_1, editorCommon, editorCommonExtensions_1, modes_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function getOccurrencesAtPosition(model, position) {
        var orderedByScore = modes_1.DocumentHighlightProviderRegistry.ordered(model);
        var foundResult = false;
        // in order of score ask the occurrences provider
        // until someone response with a good result
        // (good = none empty array)
        return async_1.sequence(orderedByScore.map(function (provider) {
            return function () {
                if (!foundResult) {
                    return async_1.asWinJsPromise(function (token) {
                        return provider.provideDocumentHighlights(model, position, token);
                    }).then(function (data) {
                        if (Array.isArray(data) && data.length > 0) {
                            foundResult = true;
                            return data;
                        }
                    }, function (err) {
                        errors_1.onUnexpectedExternalError(err);
                    });
                }
            };
        })).then(function (values) {
            return values[0];
        });
    }
    exports.getOccurrencesAtPosition = getOccurrencesAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentHighlights', getOccurrencesAtPosition);
    var WordHighlighter = (function () {
        function WordHighlighter(editor) {
            var _this = this;
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.workerRequestValue = [];
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
            this.editor = editor;
            this.model = this.editor.getModel();
            this.toUnhook = [];
            this.toUnhook.push(editor.onDidChangeCursorPosition(function (e) {
                _this._onPositionChanged(e);
            }));
            this.toUnhook.push(editor.onDidChangeModel(function (e) {
                _this._stopAll();
                _this.model = _this.editor.getModel();
            }));
            this.toUnhook.push(editor.onDidChangeModelContent(function (e) {
                _this._stopAll();
            }));
            this._lastWordRange = null;
            this._decorationIds = [];
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
        }
        WordHighlighter.prototype._removeDecorations = function () {
            if (this._decorationIds.length > 0) {
                // remove decorations
                this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
            }
        };
        WordHighlighter.prototype._stopAll = function () {
            this._lastWordRange = null;
            // Remove any existing decorations
            this._removeDecorations();
            // Cancel any renderDecorationsTimer
            if (this.renderDecorationsTimer !== -1) {
                clearTimeout(this.renderDecorationsTimer);
                this.renderDecorationsTimer = -1;
            }
            // Cancel any worker request
            if (this.workerRequest !== null) {
                this.workerRequest.cancel();
                this.workerRequest = null;
            }
            // Invalidate any worker request callback
            if (!this.workerRequestCompleted) {
                this.workerRequestTokenId++;
                this.workerRequestCompleted = true;
            }
        };
        WordHighlighter.prototype._onPositionChanged = function (e) {
            var _this = this;
            // ignore typing & other
            if (e.reason !== editorCommon.CursorChangeReason.Explicit) {
                this._stopAll();
                return;
            }
            // no providers for this model
            if (!modes_1.DocumentHighlightProviderRegistry.has(this.model)) {
                this._stopAll();
                return;
            }
            var editorSelection = this.editor.getSelection();
            // ignore multiline selection
            if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
                this._stopAll();
                return;
            }
            var lineNumber = editorSelection.startLineNumber;
            var startColumn = editorSelection.startColumn;
            var endColumn = editorSelection.endColumn;
            var word = this.model.getWordAtPosition({
                lineNumber: lineNumber,
                column: startColumn
            });
            // The selection must be inside a word or surround one word at most
            if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
                this._stopAll();
                return;
            }
            // All the effort below is trying to achieve this:
            // - when cursor is moved to a word, trigger immediately a findOccurences request
            // - 250ms later after the last cursor move event, render the occurences
            // - no flickering!
            var currentWordRange = new range_1.Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
            var workerRequestIsValid = this._lastWordRange && this._lastWordRange.equalsRange(currentWordRange);
            // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid
            // (Same symbol)
            for (var i = 0, len = this._decorationIds.length; !workerRequestIsValid && i < len; i++) {
                var range = this.model.getDecorationRange(this._decorationIds[i]);
                if (range && range.startLineNumber === lineNumber) {
                    if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
                        workerRequestIsValid = true;
                    }
                }
            }
            // There are 4 cases:
            // a) old workerRequest is valid & completed, renderDecorationsTimer fired
            // b) old workerRequest is valid & completed, renderDecorationsTimer not fired
            // c) old workerRequest is valid, but not completed
            // d) old workerRequest is not valid
            // For a) no action is needed
            // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed
            this.lastCursorPositionChangeTime = (new Date()).getTime();
            if (workerRequestIsValid) {
                if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
                    // case b)
                    // Delay the firing of renderDecorationsTimer by an extra 250 ms
                    clearTimeout(this.renderDecorationsTimer);
                    this.renderDecorationsTimer = -1;
                    this._beginRenderDecorations();
                }
            }
            else {
                // case d)
                // Stop all previous actions and start fresh
                this._stopAll();
                var myRequestId = ++this.workerRequestTokenId;
                this.workerRequestCompleted = false;
                this.workerRequest = getOccurrencesAtPosition(this.model, this.editor.getPosition());
                this.workerRequest.then(function (data) {
                    if (myRequestId === _this.workerRequestTokenId) {
                        _this.workerRequestCompleted = true;
                        _this.workerRequestValue = data || [];
                        _this._beginRenderDecorations();
                    }
                }).done();
            }
            this._lastWordRange = currentWordRange;
        };
        WordHighlighter.prototype._beginRenderDecorations = function () {
            var _this = this;
            var currentTime = (new Date()).getTime();
            var minimumRenderTime = this.lastCursorPositionChangeTime + 250;
            if (currentTime >= minimumRenderTime) {
                // Synchronous
                this.renderDecorationsTimer = -1;
                this.renderDecorations();
            }
            else {
                // Asyncrhonous
                this.renderDecorationsTimer = setTimeout(function () {
                    _this.renderDecorations();
                }, (minimumRenderTime - currentTime));
            }
        };
        WordHighlighter.prototype.renderDecorations = function () {
            this.renderDecorationsTimer = -1;
            var decorations = [];
            for (var i = 0, len = this.workerRequestValue.length; i < len; i++) {
                var info = this.workerRequestValue[i];
                var color = '#A0A0A0';
                var className = void 0;
                if (info.kind === modes_1.DocumentHighlightKind.Write) {
                    className = 'wordHighlightStrong';
                }
                else if (info.kind === modes_1.DocumentHighlightKind.Text) {
                    className = 'selectionHighlight';
                }
                else {
                    className = 'wordHighlight';
                }
                decorations.push({
                    range: info.range,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: className,
                        overviewRuler: {
                            color: color,
                            darkColor: color,
                            position: editorCommon.OverviewRulerLane.Center
                        }
                    }
                });
            }
            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
        };
        WordHighlighter.prototype.dispose = function () {
            this._stopAll();
            this.toUnhook = lifecycle_1.dispose(this.toUnhook);
        };
        return WordHighlighter;
    }());
    var WordHighlighterContribution = WordHighlighterContribution_1 = (function () {
        function WordHighlighterContribution(editor) {
            this.wordHighligher = new WordHighlighter(editor);
        }
        WordHighlighterContribution.prototype.getId = function () {
            return WordHighlighterContribution_1.ID;
        };
        WordHighlighterContribution.prototype.dispose = function () {
            this.wordHighligher.dispose();
        };
        return WordHighlighterContribution;
    }());
    WordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';
    WordHighlighterContribution = WordHighlighterContribution_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution
    ], WordHighlighterContribution);
    var WordHighlighterContribution_1;
});










define(__m[489/*vs/platform/contextview/browser/contextViewService*/], __M([1/*require*/,0/*exports*/,171/*vs/base/browser/ui/contextview/contextview*/,53/*vs/platform/telemetry/common/telemetry*/,49/*vs/platform/message/common/message*/]), function (require, exports, contextview_1, telemetry_1, message_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextViewService = (function () {
        function ContextViewService(container, telemetryService, messageService) {
            this.contextView = new contextview_1.ContextView(container);
        }
        ContextViewService.prototype.dispose = function () {
            this.contextView.dispose();
        };
        // ContextView
        ContextViewService.prototype.setContainer = function (container) {
            this.contextView.setContainer(container);
        };
        ContextViewService.prototype.showContextView = function (delegate) {
            this.contextView.show(delegate);
        };
        ContextViewService.prototype.layout = function () {
            this.contextView.layout();
        };
        ContextViewService.prototype.hideContextView = function (data) {
            this.contextView.hide(data);
        };
        return ContextViewService;
    }());
    ContextViewService = __decorate([
        __param(1, telemetry_1.ITelemetryService),
        __param(2, message_1.IMessageService)
    ], ContextViewService);
    exports.ContextViewService = ContextViewService;
});

define(__m[490/*vs/platform/theme/common/themes*/], __M([1/*require*/,0/*exports*/]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isLightTheme(themeId) {
        return /vs($| )/.test(themeId);
    }
    exports.isLightTheme = isLightTheme;
    function isDarkTheme(themeId) {
        return /vs-dark($| )/.test(themeId);
    }
    exports.isDarkTheme = isDarkTheme;
    function getSyntaxThemeId(themeId) {
        return themeId.split(' ')[1];
    }
    exports.getSyntaxThemeId = getSyntaxThemeId;
    function getBaseThemeId(themeId) {
        return themeId.split(' ')[0];
    }
    exports.getBaseThemeId = getBaseThemeId;
});






define(__m[491/*vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler*/], __M([1/*require*/,0/*exports*/,490/*vs/platform/theme/common/themes*/,2/*vs/editor/common/editorCommon*/,31/*vs/editor/browser/view/viewPart*/,129/*vs/editor/browser/viewParts/overviewRuler/overviewRulerImpl*/]), function (require, exports, themes, editorCommon, viewPart_1, overviewRulerImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DecorationsOverviewRuler = (function (_super) {
        __extends(DecorationsOverviewRuler, _super);
        function DecorationsOverviewRuler(context, scrollHeight, getVerticalOffsetForLine) {
            var _this = _super.call(this, context) || this;
            _this._overviewRuler = new overviewRulerImpl_1.OverviewRulerImpl(1, 'decorationsOverviewRuler', scrollHeight, _this._context.configuration.editor.lineHeight, _this._context.configuration.editor.viewInfo.canUseTranslate3d, DecorationsOverviewRuler.MIN_DECORATION_HEIGHT, DecorationsOverviewRuler.MAX_DECORATION_HEIGHT, getVerticalOffsetForLine);
            _this._overviewRuler.setLanesCount(_this._context.configuration.editor.viewInfo.overviewRulerLanes, false);
            var theme = _this._context.configuration.editor.viewInfo.theme;
            _this._overviewRuler.setUseDarkColor(!themes.isLightTheme(theme), false);
            _this._shouldUpdateDecorations = true;
            _this._zonesFromDecorations = [];
            _this._shouldUpdateCursorPosition = true;
            _this._hideCursor = _this._context.configuration.editor.viewInfo.hideCursorInOverviewRuler;
            _this._zonesFromCursors = [];
            _this._cursorPositions = [];
            return _this;
        }
        DecorationsOverviewRuler.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._overviewRuler.dispose();
        };
        // ---- begin view event handlers
        DecorationsOverviewRuler.prototype.onCursorPositionChanged = function (e) {
            this._shouldUpdateCursorPosition = true;
            this._cursorPositions = [e.position];
            this._cursorPositions = this._cursorPositions.concat(e.secondaryPositions);
            return true;
        };
        DecorationsOverviewRuler.prototype.onConfigurationChanged = function (e) {
            var prevLanesCount = this._overviewRuler.getLanesCount();
            var newLanesCount = this._context.configuration.editor.viewInfo.overviewRulerLanes;
            var shouldRender = false;
            if (e.lineHeight) {
                this._overviewRuler.setLineHeight(this._context.configuration.editor.lineHeight, false);
                shouldRender = true;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._overviewRuler.setCanUseTranslate3d(this._context.configuration.editor.viewInfo.canUseTranslate3d, false);
                shouldRender = true;
            }
            if (prevLanesCount !== newLanesCount) {
                this._overviewRuler.setLanesCount(newLanesCount, false);
                shouldRender = true;
            }
            if (e.viewInfo.hideCursorInOverviewRuler) {
                this._hideCursor = this._context.configuration.editor.viewInfo.hideCursorInOverviewRuler;
                this._shouldUpdateCursorPosition = true;
                shouldRender = true;
            }
            if (e.viewInfo.theme) {
                var theme = this._context.configuration.editor.viewInfo.theme;
                this._overviewRuler.setUseDarkColor(!themes.isLightTheme(theme), false);
                shouldRender = true;
            }
            return shouldRender;
        };
        DecorationsOverviewRuler.prototype.onLayoutChanged = function (layoutInfo) {
            this._overviewRuler.setLayout(layoutInfo.overviewRuler, false);
            return true;
        };
        DecorationsOverviewRuler.prototype.onZonesChanged = function () {
            return true;
        };
        DecorationsOverviewRuler.prototype.onModelFlushed = function () {
            this._shouldUpdateCursorPosition = true;
            this._shouldUpdateDecorations = true;
            return true;
        };
        DecorationsOverviewRuler.prototype.onModelDecorationsChanged = function (e) {
            this._shouldUpdateDecorations = true;
            return true;
        };
        DecorationsOverviewRuler.prototype.onScrollChanged = function (e) {
            this._overviewRuler.setScrollHeight(e.scrollHeight, false);
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        // ---- end view event handlers
        DecorationsOverviewRuler.prototype.getDomNode = function () {
            return this._overviewRuler.getDomNode();
        };
        DecorationsOverviewRuler.prototype._createZonesFromDecorations = function () {
            var decorations = this._context.model.getAllOverviewRulerDecorations();
            var zones = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var dec = decorations[i];
                var ovewviewRuler = dec.source.options.overviewRuler;
                zones.push(new editorCommon.OverviewRulerZone(dec.range.startLineNumber, dec.range.endLineNumber, ovewviewRuler.position, 0, ovewviewRuler.color, ovewviewRuler.darkColor));
            }
            return zones;
        };
        DecorationsOverviewRuler.prototype._createZonesFromCursors = function () {
            var zones = [];
            for (var i = 0, len = this._cursorPositions.length; i < len; i++) {
                var cursor = this._cursorPositions[i];
                zones.push(new editorCommon.OverviewRulerZone(cursor.lineNumber, cursor.lineNumber, editorCommon.OverviewRulerLane.Full, 2, DecorationsOverviewRuler._CURSOR_COLOR, DecorationsOverviewRuler._CURSOR_COLOR_DARK));
            }
            return zones;
        };
        DecorationsOverviewRuler.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        DecorationsOverviewRuler.prototype.render = function (ctx) {
            if (this._shouldUpdateDecorations || this._shouldUpdateCursorPosition) {
                if (this._shouldUpdateDecorations) {
                    this._shouldUpdateDecorations = false;
                    this._zonesFromDecorations = this._createZonesFromDecorations();
                }
                if (this._shouldUpdateCursorPosition) {
                    this._shouldUpdateCursorPosition = false;
                    if (this._hideCursor) {
                        this._zonesFromCursors = [];
                    }
                    else {
                        this._zonesFromCursors = this._createZonesFromCursors();
                    }
                }
                var allZones = [];
                allZones = allZones.concat(this._zonesFromCursors);
                allZones = allZones.concat(this._zonesFromDecorations);
                this._overviewRuler.setZones(allZones, false);
            }
            var hasRendered = this._overviewRuler.render(false);
            if (hasRendered && this._overviewRuler.getLanesCount() > 0 && (this._zonesFromDecorations.length > 0 || this._zonesFromCursors.length > 0)) {
                var ctx2 = this._overviewRuler.getDomNode().getContext('2d');
                ctx2.beginPath();
                ctx2.lineWidth = 1;
                ctx2.strokeStyle = 'rgba(197,197,197,0.8)';
                ctx2.moveTo(0, 0);
                ctx2.lineTo(0, this._overviewRuler.getPixelHeight());
                ctx2.stroke();
                ctx2.moveTo(0, 0);
                ctx2.lineTo(this._overviewRuler.getPixelWidth(), 0);
                ctx2.stroke();
            }
        };
        return DecorationsOverviewRuler;
    }(viewPart_1.ViewPart));
    DecorationsOverviewRuler.MIN_DECORATION_HEIGHT = 6;
    DecorationsOverviewRuler.MAX_DECORATION_HEIGHT = 60;
    DecorationsOverviewRuler._CURSOR_COLOR = 'rgba(0, 0, 102, 0.8)';
    DecorationsOverviewRuler._CURSOR_COLOR_DARK = 'rgba(152, 152, 152, 0.8)';
    exports.DecorationsOverviewRuler = DecorationsOverviewRuler;
});






define(__m[492/*vs/editor/browser/view/viewImpl*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,29/*vs/base/browser/styleMutator*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,47/*vs/editor/common/viewModel/viewEventHandler*/,430/*vs/editor/browser/controller/keyboardHandler*/,372/*vs/editor/browser/controller/pointerHandler*/,21/*vs/editor/browser/editorBrowser*/,337/*vs/editor/browser/view/viewController*/,436/*vs/editor/browser/view/viewEventDispatcher*/,431/*vs/editor/browser/view/viewOverlays*/,376/*vs/editor/browser/viewLayout/layoutProvider*/,377/*vs/editor/browser/viewParts/contentWidgets/contentWidgets*/,378/*vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight*/,379/*vs/editor/browser/viewParts/currentLineMarginHighlight/currentLineMarginHighlight*/,380/*vs/editor/browser/viewParts/decorations/decorations*/,101/*vs/editor/browser/viewParts/glyphMargin/glyphMargin*/,383/*vs/editor/browser/viewParts/lineNumbers/lineNumbers*/,382/*vs/editor/browser/viewParts/indentGuides/indentGuides*/,432/*vs/editor/browser/viewParts/lines/viewLines*/,385/*vs/editor/browser/viewParts/margin/margin*/,384/*vs/editor/browser/viewParts/linesDecorations/linesDecorations*/,386/*vs/editor/browser/viewParts/marginDecorations/marginDecorations*/,387/*vs/editor/browser/viewParts/overlayWidgets/overlayWidgets*/,491/*vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler*/,388/*vs/editor/browser/viewParts/overviewRuler/overviewRuler*/,389/*vs/editor/browser/viewParts/rulers/rulers*/,390/*vs/editor/browser/viewParts/scrollDecoration/scrollDecoration*/,391/*vs/editor/browser/viewParts/selections/selections*/,434/*vs/editor/browser/viewParts/viewCursors/viewCursors*/,392/*vs/editor/browser/viewParts/viewZones/viewZones*/,31/*vs/editor/browser/view/viewPart*/,202/*vs/editor/common/view/viewContext*/,83/*vs/editor/common/view/renderingContext*/,374/*vs/editor/browser/view/viewOutgoingEvents*/]), function (require, exports, errors_1, lifecycle_1, browser, dom, styleMutator_1, range_1, editorCommon, viewEventHandler_1, keyboardHandler_1, pointerHandler_1, editorBrowser, viewController_1, viewEventDispatcher_1, viewOverlays_1, layoutProvider_1, contentWidgets_1, currentLineHighlight_1, currentLineMarginHighlight_1, decorations_1, glyphMargin_1, lineNumbers_1, indentGuides_1, viewLines_1, margin_1, linesDecorations_1, marginDecorations_1, overlayWidgets_1, decorationsOverviewRuler_1, overviewRuler_1, rulers_1, scrollDecoration_1, selections_1, viewCursors_1, viewZones_1, viewPart_1, viewContext_1, renderingContext_1, viewOutgoingEvents_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var View = (function (_super) {
        __extends(View, _super);
        function View(commandService, configuration, model, triggerCursorHandler) {
            var _this = _super.call(this) || this;
            _this.triggerCursorHandler = triggerCursorHandler;
            _this._isDisposed = false;
            _this._renderAnimationFrame = null;
            _this.outgoingEvents = new viewOutgoingEvents_1.ViewOutgoingEvents(model);
            var viewController = new viewController_1.ViewController(model, triggerCursorHandler, _this.outgoingEvents, commandService);
            _this.listenersToRemove = [];
            _this.listenersToDispose = [];
            // The event dispatcher will always go through _renderOnce before dispatching any events
            _this.eventDispatcher = new viewEventDispatcher_1.ViewEventDispatcher(function (callback) { return _this._renderOnce(callback); });
            // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)
            _this.linesContent = document.createElement('div');
            _this.linesContent.className = editorBrowser.ClassNames.LINES_CONTENT + ' monaco-editor-background';
            _this.linesContent.style.position = 'absolute';
            _this.domNode = document.createElement('div');
            _this.domNode.className = configuration.editor.viewInfo.editorClassName;
            _this.overflowGuardContainer = document.createElement('div');
            viewPart_1.PartFingerprints.write(_this.overflowGuardContainer, 3 /* OverflowGuard */);
            _this.overflowGuardContainer.className = editorBrowser.ClassNames.OVERFLOW_GUARD;
            // The layout provider has such responsibilities as:
            // - scrolling (i.e. viewport / full size) & co.
            // - whitespaces (a.k.a. view zones) management & co.
            // - line heights updating & co.
            _this.layoutProvider = new layoutProvider_1.LayoutProvider(configuration, model, _this.eventDispatcher, _this.linesContent, _this.domNode, _this.overflowGuardContainer);
            _this.eventDispatcher.addEventHandler(_this.layoutProvider);
            // The view context is passed on to most classes (basically to reduce param. counts in ctors)
            _this._context = new viewContext_1.ViewContext(configuration, model, _this.eventDispatcher, function (eventHandler) { return _this.eventDispatcher.addEventHandler(eventHandler); }, function (eventHandler) { return _this.eventDispatcher.removeEventHandler(eventHandler); });
            _this.createTextArea();
            _this.createViewParts();
            // Keyboard handler
            _this.keyboardHandler = new keyboardHandler_1.KeyboardHandler(_this._context, viewController, _this.createKeyboardHandlerHelper());
            // Pointer handler
            _this.pointerHandler = new pointerHandler_1.PointerHandler(_this._context, viewController, _this.createPointerHandlerHelper());
            _this.hasFocus = false;
            _this.codeEditorHelper = null;
            _this.eventDispatcher.addEventHandler(_this);
            // The view lines rendering calls model.getLineTokens() that might emit events that its tokens have changed.
            // This delayed processing of incoming model events acts as a guard against undesired/unexpected recursion.
            _this.handleAccumulatedModelEventsTimeout = -1;
            _this.accumulatedModelEvents = [];
            _this.listenersToRemove.push(model.addBulkListener2(function (events) {
                _this.accumulatedModelEvents = _this.accumulatedModelEvents.concat(events);
                if (_this.handleAccumulatedModelEventsTimeout === -1) {
                    _this.handleAccumulatedModelEventsTimeout = setTimeout(function () {
                        _this.handleAccumulatedModelEventsTimeout = -1;
                        _this._flushAnyAccumulatedEvents();
                    });
                }
            }));
            return _this;
        }
        View.prototype._flushAnyAccumulatedEvents = function () {
            var toEmit = this.accumulatedModelEvents;
            this.accumulatedModelEvents = [];
            if (toEmit.length > 0) {
                this.eventDispatcher.emitMany(toEmit);
            }
        };
        View.prototype.createTextArea = function () {
            var _this = this;
            // Text Area (The focus will always be in the textarea when the cursor is blinking)
            this.textArea = document.createElement('textarea');
            viewPart_1.PartFingerprints.write(this.textArea, 6 /* TextArea */);
            this.textArea.className = editorBrowser.ClassNames.TEXTAREA;
            this.textArea.setAttribute('wrap', 'off');
            this.textArea.setAttribute('autocorrect', 'off');
            this.textArea.setAttribute('autocapitalize', 'off');
            this.textArea.setAttribute('spellcheck', 'false');
            this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
            this.textArea.setAttribute('role', 'textbox');
            this.textArea.setAttribute('aria-multiline', 'true');
            this.textArea.setAttribute('aria-haspopup', 'false');
            this.textArea.setAttribute('aria-autocomplete', 'both');
            styleMutator_1.StyleMutator.setTop(this.textArea, 0);
            styleMutator_1.StyleMutator.setLeft(this.textArea, 0);
            this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'focus', function () { return _this._setHasFocus(true); }));
            this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'blur', function () { return _this._setHasFocus(false); }));
            // On top of the text area, we position a dom node to cover it up
            // (there have been reports of tiny blinking cursors)
            // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)
            this.textAreaCover = document.createElement('div');
            if (this._context.configuration.editor.viewInfo.glyphMargin) {
                this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.GLYPH_MARGIN + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
            }
            else {
                if (this._context.configuration.editor.viewInfo.renderLineNumbers) {
                    this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.LINE_NUMBERS + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
                }
                else {
                    this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.TEXTAREA_COVER;
                }
            }
            this.textAreaCover.style.position = 'absolute';
            styleMutator_1.StyleMutator.setWidth(this.textAreaCover, 1);
            styleMutator_1.StyleMutator.setHeight(this.textAreaCover, 1);
            styleMutator_1.StyleMutator.setTop(this.textAreaCover, 0);
            styleMutator_1.StyleMutator.setLeft(this.textAreaCover, 0);
        };
        View.prototype.createViewParts = function () {
            var _this = this;
            this.viewParts = [];
            // View Lines
            this.viewLines = new viewLines_1.ViewLines(this._context, this.layoutProvider);
            // View Zones
            this.viewZones = new viewZones_1.ViewZones(this._context, this.layoutProvider);
            this.viewParts.push(this.viewZones);
            // Decorations overview ruler
            var decorationsOverviewRuler = new decorationsOverviewRuler_1.DecorationsOverviewRuler(this._context, this.layoutProvider.getScrollHeight(), function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
            this.viewParts.push(decorationsOverviewRuler);
            var scrollDecoration = new scrollDecoration_1.ScrollDecorationViewPart(this._context);
            this.viewParts.push(scrollDecoration);
            var contentViewOverlays = new viewOverlays_1.ContentViewOverlays(this._context, this.layoutProvider);
            this.viewParts.push(contentViewOverlays);
            contentViewOverlays.addDynamicOverlay(new currentLineHighlight_1.CurrentLineHighlightOverlay(this._context, this.layoutProvider));
            contentViewOverlays.addDynamicOverlay(new selections_1.SelectionsOverlay(this._context));
            contentViewOverlays.addDynamicOverlay(new decorations_1.DecorationsOverlay(this._context));
            contentViewOverlays.addDynamicOverlay(new indentGuides_1.IndentGuidesOverlay(this._context));
            var marginViewOverlays = new viewOverlays_1.MarginViewOverlays(this._context, this.layoutProvider);
            this.viewParts.push(marginViewOverlays);
            marginViewOverlays.addDynamicOverlay(new currentLineMarginHighlight_1.CurrentLineMarginHighlightOverlay(this._context, this.layoutProvider));
            marginViewOverlays.addDynamicOverlay(new glyphMargin_1.GlyphMarginOverlay(this._context));
            marginViewOverlays.addDynamicOverlay(new marginDecorations_1.MarginViewLineDecorationsOverlay(this._context));
            marginViewOverlays.addDynamicOverlay(new linesDecorations_1.LinesDecorationsOverlay(this._context));
            marginViewOverlays.addDynamicOverlay(new lineNumbers_1.LineNumbersOverlay(this._context));
            var margin = new margin_1.Margin(this._context, this.layoutProvider);
            margin.domNode.appendChild(this.viewZones.marginDomNode);
            margin.domNode.appendChild(marginViewOverlays.getDomNode());
            this.viewParts.push(margin);
            // Content widgets
            this.contentWidgets = new contentWidgets_1.ViewContentWidgets(this._context, this.domNode);
            this.viewParts.push(this.contentWidgets);
            this.viewCursors = new viewCursors_1.ViewCursors(this._context);
            this.viewParts.push(this.viewCursors);
            // Overlay widgets
            this.overlayWidgets = new overlayWidgets_1.ViewOverlayWidgets(this._context);
            this.viewParts.push(this.overlayWidgets);
            var rulers = new rulers_1.Rulers(this._context, this.layoutProvider);
            this.viewParts.push(rulers);
            // -------------- Wire dom nodes up
            this.linesContentContainer = this.layoutProvider.getScrollbarContainerDomNode();
            this.linesContentContainer.style.position = 'absolute';
            if (decorationsOverviewRuler) {
                var overviewRulerData = this.layoutProvider.getOverviewRulerInsertData();
                overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
            }
            this.linesContent.appendChild(contentViewOverlays.getDomNode());
            this.linesContent.appendChild(rulers.domNode);
            this.linesContent.appendChild(this.viewZones.domNode);
            this.linesContent.appendChild(this.viewLines.getDomNode());
            this.linesContent.appendChild(this.contentWidgets.domNode);
            this.linesContent.appendChild(this.viewCursors.getDomNode());
            this.overflowGuardContainer.appendChild(margin.domNode);
            this.overflowGuardContainer.appendChild(this.linesContentContainer);
            this.overflowGuardContainer.appendChild(scrollDecoration.getDomNode());
            this.overflowGuardContainer.appendChild(this.overlayWidgets.domNode);
            this.overflowGuardContainer.appendChild(this.textArea);
            this.overflowGuardContainer.appendChild(this.textAreaCover);
            this.domNode.appendChild(this.overflowGuardContainer);
            this.domNode.appendChild(this.contentWidgets.overflowingContentWidgetsDomNode);
        };
        View.prototype._flushAccumulatedAndRenderNow = function () {
            this._flushAnyAccumulatedEvents();
            this._renderNow();
        };
        View.prototype.createPointerHandlerHelper = function () {
            var _this = this;
            return {
                viewDomNode: this.domNode,
                linesContentDomNode: this.linesContent,
                focusTextArea: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.focusTextArea: View is disposed');
                    }
                    _this.focus();
                },
                isDirty: function () {
                    return (_this.accumulatedModelEvents.length > 0);
                },
                getScrollLeft: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getScrollLeft: View is disposed');
                    }
                    return _this.layoutProvider.getScrollLeft();
                },
                getScrollTop: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getScrollTop: View is disposed');
                    }
                    return _this.layoutProvider.getScrollTop();
                },
                setScrollPosition: function (position) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.setScrollPosition: View is disposed');
                    }
                    _this.layoutProvider.setScrollPosition(position);
                },
                isAfterLines: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.isAfterLines: View is disposed');
                    }
                    return _this.layoutProvider.isAfterLines(verticalOffset);
                },
                getLineNumberAtVerticalOffset: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getLineNumberAtVerticalOffset: View is disposed');
                    }
                    return _this.layoutProvider.getLineNumberAtVerticalOffset(verticalOffset);
                },
                getVerticalOffsetForLineNumber: function (lineNumber) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getVerticalOffsetForLineNumber: View is disposed');
                    }
                    return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
                },
                getWhitespaceAtVerticalOffset: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getWhitespaceAtVerticalOffset: View is disposed');
                    }
                    return _this.layoutProvider.getWhitespaceAtVerticalOffset(verticalOffset);
                },
                getLastViewCursorsRenderData: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getLastViewCursorsRenderData: View is disposed');
                    }
                    return _this.viewCursors.getLastRenderData() || [];
                },
                shouldSuppressMouseDownOnViewZone: function (viewZoneId) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnViewZone: View is disposed');
                    }
                    return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
                },
                shouldSuppressMouseDownOnWidget: function (widgetId) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnWidget: View is disposed');
                    }
                    return _this.contentWidgets.shouldSuppressMouseDownOnWidget(widgetId);
                },
                getPositionFromDOMInfo: function (spanNode, offset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getPositionFromDOMInfo: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);
                },
                visibleRangeForPosition2: function (lineNumber, column) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.visibleRangeForPosition2: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), 0);
                    if (!visibleRanges) {
                        return null;
                    }
                    return visibleRanges[0];
                },
                getLineWidth: function (lineNumber) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getLineWidth: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    return _this.viewLines.getLineWidth(lineNumber);
                }
            };
        };
        View.prototype.createKeyboardHandlerHelper = function () {
            var _this = this;
            return {
                viewDomNode: this.domNode,
                textArea: this.textArea,
                visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.keyboardHandler.visibleRangeForPositionRelativeToEditor: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    var linesViewPortData = _this.layoutProvider.getLinesViewportData();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), linesViewPortData.visibleRangesDeltaTop);
                    if (!visibleRanges) {
                        return null;
                    }
                    return visibleRanges[0];
                },
                flushAnyAccumulatedEvents: function () {
                    _this._flushAnyAccumulatedEvents();
                }
            };
        };
        View.prototype.setAriaActiveDescendant = function (id) {
            if (id) {
                this.textArea.setAttribute('role', 'combobox');
                if (this.textArea.getAttribute('aria-activedescendant') !== id) {
                    this.textArea.setAttribute('aria-haspopup', 'true');
                    this.textArea.setAttribute('aria-activedescendant', id);
                }
            }
            else {
                this.textArea.setAttribute('role', 'textbox');
                this.textArea.removeAttribute('aria-activedescendant');
                this.textArea.removeAttribute('aria-haspopup');
            }
        };
        // --- begin event handlers
        View.prototype.onLayoutChanged = function (layoutInfo) {
            if (browser.isChrome) {
                /* tslint:disable:no-unused-variable */
                // Access overflowGuardContainer.clientWidth to prevent relayouting bug in Chrome
                // See Bug 19676: Editor misses a layout event
                var clientWidth = this.overflowGuardContainer.clientWidth + 'px';
            }
            styleMutator_1.StyleMutator.setWidth(this.domNode, layoutInfo.width);
            styleMutator_1.StyleMutator.setHeight(this.domNode, layoutInfo.height);
            styleMutator_1.StyleMutator.setWidth(this.overflowGuardContainer, layoutInfo.width);
            styleMutator_1.StyleMutator.setHeight(this.overflowGuardContainer, layoutInfo.height);
            styleMutator_1.StyleMutator.setWidth(this.linesContent, 1000000);
            styleMutator_1.StyleMutator.setHeight(this.linesContent, 1000000);
            styleMutator_1.StyleMutator.setLeft(this.linesContentContainer, layoutInfo.contentLeft);
            styleMutator_1.StyleMutator.setWidth(this.linesContentContainer, layoutInfo.contentWidth);
            styleMutator_1.StyleMutator.setHeight(this.linesContentContainer, layoutInfo.contentHeight);
            this.outgoingEvents.emitViewLayoutChanged(layoutInfo);
            return false;
        };
        View.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.editorClassName) {
                this.domNode.className = this._context.configuration.editor.viewInfo.editorClassName;
            }
            if (e.viewInfo.ariaLabel) {
                this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
            }
            return false;
        };
        View.prototype.onScrollChanged = function (e) {
            this.outgoingEvents.emitScrollChanged(e);
            return false;
        };
        View.prototype.onViewFocusChanged = function (isFocused) {
            dom.toggleClass(this.domNode, 'focused', isFocused);
            if (isFocused) {
                this.outgoingEvents.emitViewFocusGained();
            }
            else {
                this.outgoingEvents.emitViewFocusLost();
            }
            return false;
        };
        View.prototype.onCursorRevealRange = function (e) {
            return e.revealCursor ? this.revealCursor() : false;
        };
        View.prototype.onCursorScrollRequest = function (e) {
            return e.revealCursor ? this.revealCursor() : false;
        };
        View.prototype.revealCursor = function () {
            this.triggerCursorHandler('revealCursor', editorCommon.Handler.CursorMove, { to: editorCommon.CursorMovePosition.ViewPortIfOutside });
            return false;
        };
        // --- end event handlers
        View.prototype.dispose = function () {
            this._isDisposed = true;
            if (this.handleAccumulatedModelEventsTimeout !== -1) {
                clearTimeout(this.handleAccumulatedModelEventsTimeout);
                this.handleAccumulatedModelEventsTimeout = -1;
            }
            if (this._renderAnimationFrame !== null) {
                this._renderAnimationFrame.dispose();
                this._renderAnimationFrame = null;
            }
            this.accumulatedModelEvents = [];
            this.eventDispatcher.removeEventHandler(this);
            this.outgoingEvents.dispose();
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.listenersToDispose = lifecycle_1.dispose(this.listenersToDispose);
            this.keyboardHandler.dispose();
            this.pointerHandler.dispose();
            this.viewLines.dispose();
            // Destroy IViewPart second
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                this.viewParts[i].dispose();
            }
            this.viewParts = [];
            this.layoutProvider.dispose();
        };
        View.prototype.getCodeEditorHelper = function () {
            var _this = this;
            if (!this.codeEditorHelper) {
                this.codeEditorHelper = {
                    getScrollWidth: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollWidth: View is disposed');
                        }
                        return _this.layoutProvider.getScrollWidth();
                    },
                    getScrollLeft: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollLeft: View is disposed');
                        }
                        return _this.layoutProvider.getScrollLeft();
                    },
                    getScrollHeight: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollHeight: View is disposed');
                        }
                        return _this.layoutProvider.getScrollHeight();
                    },
                    getScrollTop: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollTop: View is disposed');
                        }
                        return _this.layoutProvider.getScrollTop();
                    },
                    setScrollPosition: function (position) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.setScrollPosition: View is disposed');
                        }
                        _this.layoutProvider.setScrollPosition(position);
                    },
                    getVerticalOffsetForPosition: function (modelLineNumber, modelColumn) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getVerticalOffsetForPosition: View is disposed');
                        }
                        var modelPosition = _this._context.model.validateModelPosition({
                            lineNumber: modelLineNumber,
                            column: modelColumn
                        });
                        var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                        return _this.layoutProvider.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
                    },
                    delegateVerticalScrollbarMouseDown: function (browserEvent) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.delegateVerticalScrollbarMouseDown: View is disposed');
                        }
                        _this.layoutProvider.delegateVerticalScrollbarMouseDown(browserEvent);
                    },
                    getOffsetForColumn: function (modelLineNumber, modelColumn) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getOffsetForColumn: View is disposed');
                        }
                        var modelPosition = _this._context.model.validateModelPosition({
                            lineNumber: modelLineNumber,
                            column: modelColumn
                        });
                        var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                        _this._flushAccumulatedAndRenderNow();
                        var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column), 0);
                        if (!visibleRanges) {
                            return -1;
                        }
                        return visibleRanges[0].left;
                    },
                    getTargetAtClientPoint: function (clientX, clientY) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getTargetAtClientPoint: View is disposed');
                        }
                        return _this.pointerHandler.getTargetAtClientPoint(clientX, clientY);
                    }
                };
            }
            return this.codeEditorHelper;
        };
        View.prototype.getCenteredRangeInViewport = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getCenteredRangeInViewport: View is disposed');
            }
            var viewLineNumber = this.layoutProvider.getCenteredViewLineNumberInViewport();
            var viewModel = this._context.model;
            var currentCenteredViewRange = new range_1.Range(viewLineNumber, 1, viewLineNumber, viewModel.getLineMaxColumn(viewLineNumber));
            return viewModel.convertViewRangeToModelRange(currentCenteredViewRange);
        };
        View.prototype.getCompletelyVisibleLinesRangeInViewport = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getVisibleRangeInViewportExcludingPartialRenderedLines: View is disposed');
            }
            var completelyVisibleLinesRange = this.layoutProvider.getLinesViewportData().completelyVisibleLinesRange;
            return this._context.model.convertViewRangeToModelRange(completelyVisibleLinesRange);
        };
        //	public getLineInfoProvider():view.ILineInfoProvider {
        //		return this.viewLines;
        //	}
        View.prototype.getInternalEventBus = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getInternalEventBus: View is disposed');
            }
            return this.outgoingEvents.getInternalEventBus();
        };
        View.prototype.saveState = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.saveState: View is disposed');
            }
            return this.layoutProvider.saveState();
        };
        View.prototype.restoreState = function (state) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.restoreState: View is disposed');
            }
            this._flushAnyAccumulatedEvents();
            return this.layoutProvider.restoreState(state);
        };
        View.prototype.focus = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.focus: View is disposed');
            }
            this.keyboardHandler.focusTextArea();
            // IE does not trigger the focus event immediately, so we must help it a little bit
            if (document.activeElement === this.textArea) {
                this._setHasFocus(true);
            }
        };
        View.prototype.isFocused = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.isFocused: View is disposed');
            }
            return this.hasFocus;
        };
        View.prototype.createOverviewRuler = function (cssClassName, minimumHeight, maximumHeight) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.createOverviewRuler: View is disposed');
            }
            return new overviewRuler_1.OverviewRuler(this._context, cssClassName, this.layoutProvider.getScrollHeight(), minimumHeight, maximumHeight, function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
        };
        View.prototype.change = function (callback) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.change: View is disposed');
            }
            var zonesHaveChanged = false;
            this._renderOnce(function () {
                // Handle events to avoid "adjusting" newly inserted view zones
                _this._flushAnyAccumulatedEvents();
                var changeAccessor = {
                    addZone: function (zone) {
                        zonesHaveChanged = true;
                        return _this.viewZones.addZone(zone);
                    },
                    removeZone: function (id) {
                        if (!id) {
                            return;
                        }
                        zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;
                    },
                    layoutZone: function (id) {
                        if (!id) {
                            return;
                        }
                        zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;
                    }
                };
                var r = safeInvoke1Arg(callback, changeAccessor);
                // Invalidate changeAccessor
                changeAccessor.addZone = null;
                changeAccessor.removeZone = null;
                if (zonesHaveChanged) {
                    _this._context.privateViewEventBus.emit(editorCommon.EventType.ViewZonesChanged, null);
                }
                return r;
            });
            return zonesHaveChanged;
        };
        View.prototype.getWhitespaces = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getWhitespaces: View is disposed');
            }
            return this.layoutProvider.getWhitespaces();
        };
        View.prototype.addContentWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.addContentWidget: View is disposed');
            }
            this.contentWidgets.addWidget(widgetData.widget);
            this.layoutContentWidget(widgetData);
            this._scheduleRender();
        };
        View.prototype.layoutContentWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.layoutContentWidget: View is disposed');
            }
            var newPosition = widgetData.position ? widgetData.position.position : null;
            var newPreference = widgetData.position ? widgetData.position.preference : null;
            this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newPreference);
            this._scheduleRender();
        };
        View.prototype.removeContentWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.removeContentWidget: View is disposed');
            }
            this.contentWidgets.removeWidget(widgetData.widget);
            this._scheduleRender();
        };
        View.prototype.addOverlayWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.addOverlayWidget: View is disposed');
            }
            this.overlayWidgets.addWidget(widgetData.widget);
            this.layoutOverlayWidget(widgetData);
            this._scheduleRender();
        };
        View.prototype.layoutOverlayWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.layoutOverlayWidget: View is disposed');
            }
            var newPreference = widgetData.position ? widgetData.position.preference : null;
            var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
            if (shouldRender) {
                this._scheduleRender();
            }
        };
        View.prototype.removeOverlayWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.removeOverlayWidget: View is disposed');
            }
            this.overlayWidgets.removeWidget(widgetData.widget);
            this._scheduleRender();
        };
        View.prototype.render = function (now, everything) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.render: View is disposed');
            }
            if (everything) {
                // Force a render with a layout event
                this.layoutProvider.emitLayoutChangedEvent();
            }
            if (now) {
                this._flushAccumulatedAndRenderNow();
            }
        };
        // --- end Code Editor APIs
        View.prototype._renderOnce = function (callback) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl._renderOnce: View is disposed');
            }
            return this.outgoingEvents.deferredEmit(function () {
                var r = safeInvokeNoArg(callback);
                _this._scheduleRender();
                return r;
            });
        };
        View.prototype._scheduleRender = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl._scheduleRender: View is disposed');
            }
            if (this._renderAnimationFrame === null) {
                this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
            }
        };
        View.prototype._onRenderScheduled = function () {
            this._renderAnimationFrame = null;
            this._flushAccumulatedAndRenderNow();
        };
        View.prototype._renderNow = function () {
            var _this = this;
            safeInvokeNoArg(function () { return _this._actualRender(); });
        };
        View.prototype._getViewPartsToRender = function () {
            var result = [];
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                var viewPart = this.viewParts[i];
                if (viewPart.shouldRender()) {
                    result.push(viewPart);
                }
            }
            return result;
        };
        View.prototype._actualRender = function () {
            var _this = this;
            if (!dom.isInDOM(this.domNode)) {
                return;
            }
            var viewPartsToRender = this._getViewPartsToRender();
            if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {
                // Nothing to render
                this.keyboardHandler.writeToTextArea();
                return;
            }
            var linesViewportData = this.layoutProvider.getLinesViewportData();
            if (this.viewLines.shouldRender()) {
                this.viewLines.renderText(linesViewportData, function () {
                    _this.keyboardHandler.writeToTextArea();
                });
                this.viewLines.onDidRender();
                // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again
                viewPartsToRender = this._getViewPartsToRender();
            }
            else {
                this.keyboardHandler.writeToTextArea();
            }
            var renderingContext = new renderingContext_1.RenderingContext(this.viewLines, this.layoutProvider, linesViewportData);
            // Render the rest of the parts
            for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
                var viewPart = viewPartsToRender[i];
                viewPart.prepareRender(renderingContext);
            }
            for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
                var viewPart = viewPartsToRender[i];
                viewPart.render(renderingContext);
                viewPart.onDidRender();
            }
            // Render the scrollbar
            this.layoutProvider.renderScrollbar();
        };
        View.prototype._setHasFocus = function (newHasFocus) {
            if (this.hasFocus !== newHasFocus) {
                this.hasFocus = newHasFocus;
                this._context.privateViewEventBus.emit(editorCommon.EventType.ViewFocusChanged, this.hasFocus);
            }
        };
        return View;
    }(viewEventHandler_1.ViewEventHandler));
    exports.View = View;
    function safeInvokeNoArg(func) {
        try {
            return func();
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
    }
    function safeInvoke1Arg(func, arg1) {
        try {
            return func(arg1);
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
    }
});















define(__m[167/*vs/editor/browser/widget/codeEditorWidget*/], __M([1/*require*/,0/*exports*/,10/*vs/base/common/errors*/,23/*vs/base/browser/browser*/,11/*vs/base/browser/dom*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/,18/*vs/platform/contextkey/common/contextkey*/,404/*vs/editor/common/commonCodeEditor*/,4/*vs/editor/common/core/range*/,20/*vs/editor/common/core/selection*/,2/*vs/editor/common/editorCommon*/,45/*vs/editor/common/services/codeEditorService*/,55/*vs/editor/browser/config/configuration*/,144/*vs/editor/browser/standalone/colorizer*/,492/*vs/editor/browser/view/viewImpl*/,3/*vs/base/common/lifecycle*/,12/*vs/base/common/event*/,161/*vs/editor/common/editorAction*/,349/*vs/css!vs/editor/browser/widget/media/editor*/,350/*vs/css!vs/editor/browser/widget/media/tokens*/]), function (require, exports, errors_1, browser, dom, instantiation_1, commands_1, contextkey_1, commonCodeEditor_1, range_1, selection_1, editorCommon, codeEditorService_1, configuration_1, colorizer_1, viewImpl_1, lifecycle_1, event_1, editorAction_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CodeEditorWidget = (function (_super) {
        __extends(CodeEditorWidget, _super);
        function CodeEditorWidget(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService) {
            var _this = _super.call(this, domElement, options, instantiationService, contextKeyService) || this;
            _this.onMouseUp = event_1.fromEventEmitter(_this, editorCommon.EventType.MouseUp);
            _this.onMouseDown = event_1.fromEventEmitter(_this, editorCommon.EventType.MouseDown);
            _this.onContextMenu = event_1.fromEventEmitter(_this, editorCommon.EventType.ContextMenu);
            _this.onMouseMove = event_1.fromEventEmitter(_this, editorCommon.EventType.MouseMove);
            _this.onMouseLeave = event_1.fromEventEmitter(_this, editorCommon.EventType.MouseLeave);
            _this.onKeyUp = event_1.fromEventEmitter(_this, editorCommon.EventType.KeyUp);
            _this.onKeyDown = event_1.fromEventEmitter(_this, editorCommon.EventType.KeyDown);
            _this.onDidLayoutChange = event_1.fromEventEmitter(_this, editorCommon.EventType.EditorLayout);
            _this.onDidScrollChange = event_1.fromEventEmitter(_this, 'scroll');
            _this._codeEditorService = codeEditorService;
            _this._commandService = commandService;
            _this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);
            _this._focusTracker.onChage(function () {
                var hasFocus = _this._focusTracker.hasFocus();
                if (hasFocus) {
                    _this.emit(editorCommon.EventType.EditorFocus, {});
                }
                else {
                    _this.emit(editorCommon.EventType.EditorBlur, {});
                }
            });
            _this.contentWidgets = {};
            _this.overlayWidgets = {};
            var contributions = _this._getContributions();
            for (var i = 0, len = contributions.length; i < len; i++) {
                var ctor = contributions[i];
                try {
                    var contribution = _this._instantiationService.createInstance(ctor, _this);
                    _this._contributions[contribution.getId()] = contribution;
                }
                catch (err) {
                    errors_1.onUnexpectedError(err);
                }
            }
            _this._getActions().forEach(function (action) {
                var internalAction = new editorAction_1.InternalEditorAction(action, _this, _this._instantiationService, _this._contextKeyService);
                _this._actions[internalAction.id] = internalAction;
            });
            _this._codeEditorService.addCodeEditor(_this);
            return _this;
        }
        CodeEditorWidget.prototype._createConfiguration = function (options) {
            return new configuration_1.Configuration(options, this.domElement);
        };
        CodeEditorWidget.prototype.dispose = function () {
            this._codeEditorService.removeCodeEditor(this);
            this.contentWidgets = {};
            this.overlayWidgets = {};
            this._focusTracker.dispose();
            _super.prototype.dispose.call(this);
        };
        CodeEditorWidget.prototype.updateOptions = function (newOptions) {
            var oldTheme = this._configuration.editor.viewInfo.theme;
            _super.prototype.updateOptions.call(this, newOptions);
            var newTheme = this._configuration.editor.viewInfo.theme;
            if (oldTheme !== newTheme) {
                this.render();
            }
        };
        CodeEditorWidget.prototype.colorizeModelLine = function (lineNumber, model) {
            if (model === void 0) { model = this.model; }
            if (!model) {
                return '';
            }
            var content = model.getLineContent(lineNumber);
            var tokens = model.getLineTokens(lineNumber, false);
            var inflatedTokens = tokens.inflate();
            var tabSize = model.getOptions().tabSize;
            return colorizer_1.Colorizer.colorizeLine(content, model.mightContainRTL(), inflatedTokens, tabSize);
        };
        CodeEditorWidget.prototype.getView = function () {
            return this._view;
        };
        CodeEditorWidget.prototype.getDomNode = function () {
            if (!this.hasView) {
                return null;
            }
            return this._view.domNode;
        };
        CodeEditorWidget.prototype.getCenteredRangeInViewport = function () {
            if (!this.hasView) {
                return null;
            }
            return this._view.getCenteredRangeInViewport();
        };
        CodeEditorWidget.prototype.getCompletelyVisibleLinesRangeInViewport = function () {
            if (!this.hasView) {
                return null;
            }
            return this._view.getCompletelyVisibleLinesRangeInViewport();
        };
        CodeEditorWidget.prototype.getScrollWidth = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollWidth();
        };
        CodeEditorWidget.prototype.getScrollLeft = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollLeft();
        };
        CodeEditorWidget.prototype.getScrollHeight = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollHeight();
        };
        CodeEditorWidget.prototype.getScrollTop = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollTop();
        };
        CodeEditorWidget.prototype.setScrollLeft = function (newScrollLeft) {
            if (!this.hasView) {
                return;
            }
            if (typeof newScrollLeft !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._view.getCodeEditorHelper().setScrollPosition({
                scrollLeft: newScrollLeft
            });
        };
        CodeEditorWidget.prototype.setScrollTop = function (newScrollTop) {
            if (!this.hasView) {
                return;
            }
            if (typeof newScrollTop !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._view.getCodeEditorHelper().setScrollPosition({
                scrollTop: newScrollTop
            });
        };
        CodeEditorWidget.prototype.setScrollPosition = function (position) {
            if (!this.hasView) {
                return;
            }
            this._view.getCodeEditorHelper().setScrollPosition(position);
        };
        CodeEditorWidget.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            if (!this.hasView) {
                return;
            }
            this._view.getCodeEditorHelper().delegateVerticalScrollbarMouseDown(browserEvent);
        };
        CodeEditorWidget.prototype.saveViewState = function () {
            if (!this.cursor || !this.hasView) {
                return null;
            }
            var contributionsState = {};
            var keys = Object.keys(this._contributions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var contribution = this._contributions[id];
                if (typeof contribution.saveViewState === 'function') {
                    contributionsState[id] = contribution.saveViewState();
                }
            }
            var cursorState = this.cursor.saveState();
            var viewState = this._view.saveState();
            return {
                cursorState: cursorState,
                viewState: viewState,
                contributionsState: contributionsState
            };
        };
        CodeEditorWidget.prototype.restoreViewState = function (s) {
            if (!this.cursor || !this.hasView) {
                return;
            }
            if (s && s.cursorState && s.viewState) {
                var codeEditorState = s;
                var cursorState = codeEditorState.cursorState;
                if (Array.isArray(cursorState)) {
                    this.cursor.restoreState(cursorState);
                }
                else {
                    // Backwards compatibility
                    this.cursor.restoreState([cursorState]);
                }
                this._view.restoreState(codeEditorState.viewState);
                var contributionsState = s.contributionsState || {};
                var keys = Object.keys(this._contributions);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var id = keys[i];
                    var contribution = this._contributions[id];
                    if (typeof contribution.restoreViewState === 'function') {
                        contribution.restoreViewState(contributionsState[id]);
                    }
                }
            }
        };
        CodeEditorWidget.prototype.layout = function (dimension) {
            this._configuration.observeReferenceElement(dimension);
            this.render();
        };
        CodeEditorWidget.prototype.focus = function () {
            if (!this.hasView) {
                return;
            }
            this._view.focus();
        };
        CodeEditorWidget.prototype.isFocused = function () {
            return this.hasView && this._view.isFocused();
        };
        CodeEditorWidget.prototype.hasWidgetFocus = function () {
            return this._focusTracker && this._focusTracker.hasFocus();
        };
        CodeEditorWidget.prototype.addContentWidget = function (widget) {
            var widgetData = {
                widget: widget,
                position: widget.getPosition()
            };
            if (this.contentWidgets.hasOwnProperty(widget.getId())) {
                console.warn('Overwriting a content widget with the same id.');
            }
            this.contentWidgets[widget.getId()] = widgetData;
            if (this.hasView) {
                this._view.addContentWidget(widgetData);
            }
        };
        CodeEditorWidget.prototype.layoutContentWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.contentWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.contentWidgets[widgetId];
                widgetData.position = widget.getPosition();
                if (this.hasView) {
                    this._view.layoutContentWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.removeContentWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.contentWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.contentWidgets[widgetId];
                delete this.contentWidgets[widgetId];
                if (this.hasView) {
                    this._view.removeContentWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.addOverlayWidget = function (widget) {
            var widgetData = {
                widget: widget,
                position: widget.getPosition()
            };
            if (this.overlayWidgets.hasOwnProperty(widget.getId())) {
                console.warn('Overwriting an overlay widget with the same id.');
            }
            this.overlayWidgets[widget.getId()] = widgetData;
            if (this.hasView) {
                this._view.addOverlayWidget(widgetData);
            }
        };
        CodeEditorWidget.prototype.layoutOverlayWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.overlayWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.overlayWidgets[widgetId];
                widgetData.position = widget.getPosition();
                if (this.hasView) {
                    this._view.layoutOverlayWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.removeOverlayWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.overlayWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.overlayWidgets[widgetId];
                delete this.overlayWidgets[widgetId];
                if (this.hasView) {
                    this._view.removeOverlayWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.changeViewZones = function (callback) {
            if (!this.hasView) {
                //			console.warn('Cannot change view zones on editor that is not attached to a model, since there is no view.');
                return;
            }
            var hasChanges = this._view.change(callback);
            if (hasChanges) {
                this.emit(editorCommon.EventType.ViewZonesChanged);
            }
        };
        CodeEditorWidget.prototype.getWhitespaces = function () {
            if (!this.hasView) {
                return [];
            }
            return this._view.getWhitespaces();
        };
        CodeEditorWidget.prototype.getTopForLineNumber = function (lineNumber) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getVerticalOffsetForPosition(lineNumber, 1);
        };
        CodeEditorWidget.prototype.getTopForPosition = function (lineNumber, column) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getVerticalOffsetForPosition(lineNumber, column);
        };
        CodeEditorWidget.prototype.getTargetAtClientPoint = function (clientX, clientY) {
            if (!this.hasView) {
                return null;
            }
            return this._view.getCodeEditorHelper().getTargetAtClientPoint(clientX, clientY);
        };
        CodeEditorWidget.prototype.getScrolledVisiblePosition = function (rawPosition) {
            if (!this.hasView) {
                return null;
            }
            var position = this.model.validatePosition(rawPosition);
            var helper = this._view.getCodeEditorHelper();
            var layoutInfo = this._configuration.editor.layoutInfo;
            var top = helper.getVerticalOffsetForPosition(position.lineNumber, position.column) - helper.getScrollTop();
            var left = helper.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - helper.getScrollLeft();
            return {
                top: top,
                left: left,
                height: this._configuration.editor.lineHeight
            };
        };
        CodeEditorWidget.prototype.getOffsetForColumn = function (lineNumber, column) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getOffsetForColumn(lineNumber, column);
        };
        CodeEditorWidget.prototype.render = function () {
            if (!this.hasView) {
                return;
            }
            this._view.render(true, false);
        };
        CodeEditorWidget.prototype.setHiddenAreas = function (ranges) {
            if (this.viewModel) {
                this.viewModel.setHiddenAreas(ranges);
            }
        };
        CodeEditorWidget.prototype.setAriaActiveDescendant = function (id) {
            if (!this.hasView) {
                return;
            }
            this._view.setAriaActiveDescendant(id);
        };
        CodeEditorWidget.prototype.applyFontInfo = function (target) {
            configuration_1.Configuration.applyFontInfoSlow(target, this._configuration.editor.fontInfo);
        };
        CodeEditorWidget.prototype._attachModel = function (model) {
            this._view = null;
            _super.prototype._attachModel.call(this, model);
            if (this._view) {
                this.domElement.appendChild(this._view.domNode);
                var keys = Object.keys(this.contentWidgets);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var widgetId = keys[i];
                    this._view.addContentWidget(this.contentWidgets[widgetId]);
                }
                keys = Object.keys(this.overlayWidgets);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var widgetId = keys[i];
                    this._view.addOverlayWidget(this.overlayWidgets[widgetId]);
                }
                this._view.render(false, true);
                this.hasView = true;
            }
        };
        CodeEditorWidget.prototype._enableEmptySelectionClipboard = function () {
            return browser.enableEmptySelectionClipboard;
        };
        CodeEditorWidget.prototype._createView = function () {
            var _this = this;
            this._view = new viewImpl_1.View(this._commandService, this._configuration, this.viewModel, function (source, handlerId, payload) {
                if (!_this.cursor) {
                    return;
                }
                _this.cursor.trigger(source, handlerId, payload);
            });
        };
        CodeEditorWidget.prototype._getViewInternalEventBus = function () {
            return this._view.getInternalEventBus();
        };
        CodeEditorWidget.prototype._detachModel = function () {
            var removeDomNode = null;
            if (this._view) {
                this._view.dispose();
                removeDomNode = this._view.domNode;
                this._view = null;
            }
            var result = _super.prototype._detachModel.call(this);
            if (removeDomNode) {
                this.domElement.removeChild(removeDomNode);
            }
            return result;
        };
        // BEGIN decorations
        CodeEditorWidget.prototype._registerDecorationType = function (key, options, parentTypeKey) {
            this._codeEditorService.registerDecorationType(key, options, parentTypeKey);
        };
        CodeEditorWidget.prototype._removeDecorationType = function (key) {
            this._codeEditorService.removeDecorationType(key);
        };
        CodeEditorWidget.prototype._resolveDecorationOptions = function (typeKey, writable) {
            return this._codeEditorService.resolveDecorationOptions(typeKey, writable);
        };
        return CodeEditorWidget;
    }(commonCodeEditor_1.CommonCodeEditor));
    CodeEditorWidget = __decorate([
        __param(2, instantiation_1.IInstantiationService),
        __param(3, codeEditorService_1.ICodeEditorService),
        __param(4, commands_1.ICommandService),
        __param(5, contextkey_1.IContextKeyService)
    ], CodeEditorWidget);
    exports.CodeEditorWidget = CodeEditorWidget;
    var CodeEditorWidgetFocusTracker = (function (_super) {
        __extends(CodeEditorWidgetFocusTracker, _super);
        function CodeEditorWidgetFocusTracker(domElement) {
            var _this = _super.call(this) || this;
            _this._onChange = _this._register(new event_1.Emitter());
            _this.onChage = _this._onChange.event;
            _this._hasFocus = false;
            _this._domFocusTracker = _this._register(dom.trackFocus(domElement));
            _this._domFocusTracker.addFocusListener(function () {
                _this._hasFocus = true;
                _this._onChange.fire(void 0);
            });
            _this._domFocusTracker.addBlurListener(function () {
                _this._hasFocus = false;
                _this._onChange.fire(void 0);
            });
            return _this;
        }
        CodeEditorWidgetFocusTracker.prototype.hasFocus = function () {
            return this._hasFocus;
        };
        return CodeEditorWidgetFocusTracker;
    }(lifecycle_1.Disposable));
    var OverlayWidget2 = (function () {
        function OverlayWidget2(id, position) {
            this._id = id;
            this._position = position;
            this._domNode = document.createElement('div');
            this._domNode.className = this._id.replace(/\./g, '-').replace(/[^a-z0-9\-]/, '');
        }
        OverlayWidget2.prototype.getId = function () {
            return this._id;
        };
        OverlayWidget2.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverlayWidget2.prototype.getPosition = function () {
            return this._position;
        };
        return OverlayWidget2;
    }());
    var EditCursorState;
    (function (EditCursorState) {
        EditCursorState[EditCursorState["EndOfLastEditOperation"] = 0] = "EndOfLastEditOperation";
    })(EditCursorState = exports.EditCursorState || (exports.EditCursorState = {}));
    var SingleEditOperation = (function () {
        function SingleEditOperation(source) {
            this.range = new range_1.Range(source.range.startLineNumber, source.range.startColumn, source.range.endLineNumber, source.range.endColumn);
            this.text = source.text;
            this.forceMoveMarkers = source.forceMoveMarkers || false;
        }
        return SingleEditOperation;
    }());
    var CommandRunner = (function () {
        function CommandRunner(ops, editCursorState) {
            this._ops = ops.map(function (op) { return new SingleEditOperation(op); });
            this._editCursorState = editCursorState;
        }
        CommandRunner.prototype.getEditOperations = function (model, builder) {
            if (this._ops.length === 0) {
                return;
            }
            // Sort them in ascending order by range starts
            this._ops.sort(function (o1, o2) {
                return range_1.Range.compareRangesUsingStarts(o1.range, o2.range);
            });
            // Merge operations that touch each other
            var resultOps = [];
            var previousOp = this._ops[0];
            for (var i = 1; i < this._ops.length; i++) {
                if (previousOp.range.endLineNumber === this._ops[i].range.startLineNumber && previousOp.range.endColumn === this._ops[i].range.startColumn) {
                    // These operations are one after another and can be merged
                    previousOp.range = range_1.Range.plusRange(previousOp.range, this._ops[i].range);
                    previousOp.text = previousOp.text + this._ops[i].text;
                }
                else {
                    resultOps.push(previousOp);
                    previousOp = this._ops[i];
                }
            }
            resultOps.push(previousOp);
            for (var i = 0; i < resultOps.length; i++) {
                builder.addEditOperation(range_1.Range.lift(resultOps[i].range), resultOps[i].text);
            }
        };
        CommandRunner.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[inverseEditOperations.length - 1].range;
            return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
        };
        return CommandRunner;
    }());
    exports.CommandRunner = CommandRunner;
});















define(__m[120/*vs/editor/browser/codeEditor*/], __M([1/*require*/,0/*exports*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/,18/*vs/platform/contextkey/common/contextkey*/,45/*vs/editor/common/services/codeEditorService*/,167/*vs/editor/browser/widget/codeEditorWidget*/,13/*vs/editor/common/editorCommonExtensions*/,26/*vs/editor/browser/editorBrowserExtensions*/]), function (require, exports, instantiation_1, commands_1, contextkey_1, codeEditorService_1, codeEditorWidget_1, editorCommonExtensions_1, editorBrowserExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CodeEditor = (function (_super) {
        __extends(CodeEditor, _super);
        function CodeEditor(domElement, options, instantiationService, codeEditorService, commandService, contextKeyService) {
            return _super.call(this, domElement, options, instantiationService, codeEditorService, commandService, contextKeyService) || this;
        }
        CodeEditor.prototype._getContributions = function () {
            return [].concat(editorBrowserExtensions_1.EditorBrowserRegistry.getEditorContributions()).concat(editorCommonExtensions_1.CommonEditorRegistry.getEditorContributions());
        };
        CodeEditor.prototype._getActions = function () {
            return editorCommonExtensions_1.CommonEditorRegistry.getEditorActions();
        };
        return CodeEditor;
    }(codeEditorWidget_1.CodeEditorWidget));
    CodeEditor = __decorate([
        __param(2, instantiation_1.IInstantiationService),
        __param(3, codeEditorService_1.ICodeEditorService),
        __param(4, commands_1.ICommandService),
        __param(5, contextkey_1.IContextKeyService)
    ], CodeEditor);
    exports.CodeEditor = CodeEditor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[169/*vs/editor/browser/widget/diffEditorWidget*/], __M([1/*require*/,0/*exports*/,17/*vs/base/common/async*/,25/*vs/base/common/eventEmitter*/,3/*vs/base/common/lifecycle*/,36/*vs/base/common/objects*/,11/*vs/base/browser/dom*/,29/*vs/base/browser/styleMutator*/,98/*vs/base/browser/ui/sash/sash*/,14/*vs/platform/instantiation/common/instantiation*/,18/*vs/platform/contextkey/common/contextkey*/,44/*vs/editor/common/config/defaultConfig*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,52/*vs/editor/common/services/editorWorkerService*/,116/*vs/editor/common/viewLayout/viewLineParts*/,117/*vs/editor/common/viewLayout/viewLineRenderer*/,120/*vs/editor/browser/codeEditor*/,77/*vs/editor/common/core/viewLineToken*/,55/*vs/editor/browser/config/configuration*/,146/*vs/editor/common/viewModel/viewModel*/,347/*vs/css!vs/editor/browser/widget/media/diffEditor*/]), function (require, exports, async_1, eventEmitter_1, lifecycle_1, objects, dom, styleMutator_1, sash_1, instantiation_1, contextkey_1, defaultConfig_1, range_1, editorCommon, editorWorkerService_1, viewLineParts_1, viewLineRenderer_1, codeEditor_1, viewLineToken_1, configuration_1, viewModel_1) {
    'use strict';
    var VisualEditorState = (function () {
        function VisualEditorState() {
            this._zones = [];
            this._zonesMap = {};
            this._decorations = [];
        }
        VisualEditorState.prototype.getForeignViewZones = function (allViewZones) {
            var _this = this;
            return allViewZones.filter(function (z) { return !_this._zonesMap[String(z.id)]; });
        };
        VisualEditorState.prototype.clean = function (editor) {
            var _this = this;
            // (1) View zones
            if (this._zones.length > 0) {
                editor.changeViewZones(function (viewChangeAccessor) {
                    for (var i = 0, length_1 = _this._zones.length; i < length_1; i++) {
                        viewChangeAccessor.removeZone(_this._zones[i]);
                    }
                });
            }
            this._zones = [];
            this._zonesMap = {};
            // (2) Model decorations
            if (this._decorations.length > 0) {
                editor.changeDecorations(function (changeAccessor) {
                    changeAccessor.deltaDecorations(_this._decorations, []);
                });
            }
            this._decorations = [];
        };
        VisualEditorState.prototype.apply = function (editor, overviewRuler, newDecorations) {
            var _this = this;
            // view zones
            editor.changeViewZones(function (viewChangeAccessor) {
                for (var i = 0, length_2 = _this._zones.length; i < length_2; i++) {
                    viewChangeAccessor.removeZone(_this._zones[i]);
                }
                _this._zones = [];
                _this._zonesMap = {};
                for (var i = 0, length_3 = newDecorations.zones.length; i < length_3; i++) {
                    newDecorations.zones[i].suppressMouseDown = true;
                    var zoneId = viewChangeAccessor.addZone(newDecorations.zones[i]);
                    _this._zones.push(zoneId);
                    _this._zonesMap[String(zoneId)] = true;
                }
            });
            // decorations
            this._decorations = editor.deltaDecorations(this._decorations, newDecorations.decorations);
            // overview ruler
            if (overviewRuler) {
                overviewRuler.setZones(newDecorations.overviewZones);
            }
        };
        return VisualEditorState;
    }());
    var DIFF_EDITOR_ID = 0;
    var DiffEditorWidget = (function (_super) {
        __extends(DiffEditorWidget, _super);
        function DiffEditorWidget(domElement, options, editorWorkerService, contextKeyService, instantiationService) {
            var _this = _super.call(this) || this;
            _this._editorWorkerService = editorWorkerService;
            _this._contextKeyService = contextKeyService;
            _this.id = (++DIFF_EDITOR_ID);
            _this._domElement = domElement;
            options = options || {};
            _this._theme = options.theme || defaultConfig_1.DefaultConfig.editor.theme;
            // renderSideBySide
            _this._renderSideBySide = true;
            if (typeof options.renderSideBySide !== 'undefined') {
                _this._renderSideBySide = options.renderSideBySide;
            }
            // ignoreTrimWhitespace
            _this._ignoreTrimWhitespace = true;
            if (typeof options.ignoreTrimWhitespace !== 'undefined') {
                _this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;
            }
            // renderIndicators
            _this._renderIndicators = true;
            if (typeof options.renderIndicators !== 'undefined') {
                _this._renderIndicators = options.renderIndicators;
            }
            _this._originalIsEditable = false;
            if (typeof options.originalEditable !== 'undefined') {
                _this._originalIsEditable = Boolean(options.originalEditable);
            }
            _this._updateDecorationsRunner = new async_1.RunOnceScheduler(function () { return _this._updateDecorations(); }, 0);
            _this._toDispose = [];
            _this._toDispose.push(_this._updateDecorationsRunner);
            _this._containerDomElement = document.createElement('div');
            _this._containerDomElement.className = DiffEditorWidget._getClassName(_this._theme, _this._renderSideBySide);
            _this._containerDomElement.style.position = 'relative';
            _this._containerDomElement.style.height = '100%';
            _this._domElement.appendChild(_this._containerDomElement);
            _this._overviewViewportDomElement = document.createElement('div');
            _this._overviewViewportDomElement.className = 'diffViewport';
            _this._overviewViewportDomElement.style.position = 'absolute';
            _this._overviewDomElement = document.createElement('div');
            _this._overviewDomElement.className = 'diffOverview';
            _this._overviewDomElement.style.position = 'absolute';
            _this._overviewDomElement.style.height = '100%';
            _this._overviewDomElement.appendChild(_this._overviewViewportDomElement);
            _this._toDispose.push(dom.addDisposableListener(_this._overviewDomElement, 'mousedown', function (e) {
                _this.modifiedEditor.delegateVerticalScrollbarMouseDown(e);
            }));
            _this._containerDomElement.appendChild(_this._overviewDomElement);
            _this._createLeftHandSide();
            _this._createRightHandSide();
            _this._beginUpdateDecorationsTimeout = -1;
            _this._currentlyChangingViewZones = false;
            _this._diffComputationToken = 0;
            _this._originalEditorState = new VisualEditorState();
            _this._modifiedEditorState = new VisualEditorState();
            _this._isVisible = true;
            _this._isHandlingScrollEvent = false;
            _this._width = 0;
            _this._height = 0;
            _this._lineChanges = null;
            _this._createLeftHandSideEditor(options, instantiationService);
            _this._createRightHandSideEditor(options, instantiationService);
            if (options.automaticLayout) {
                _this._measureDomElementToken = window.setInterval(function () { return _this._measureDomElement(false); }, 100);
            }
            // enableSplitViewResizing
            _this._enableSplitViewResizing = true;
            if (typeof options.enableSplitViewResizing !== 'undefined') {
                _this._enableSplitViewResizing = options.enableSplitViewResizing;
            }
            if (_this._renderSideBySide) {
                _this._setStrategy(new DiffEdtorWidgetSideBySide(_this._createDataSource(), _this._enableSplitViewResizing));
            }
            else {
                _this._setStrategy(new DiffEdtorWidgetInline(_this._createDataSource(), _this._enableSplitViewResizing));
            }
            return _this;
        }
        DiffEditorWidget.prototype.onDidChangeModelRawContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelRawContentChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelContentChanged2, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelLanguage = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelLanguageChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelOptions = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelOptionsChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeConfiguration = function (listener) {
            return this.addListener2(editorCommon.EventType.ConfigurationChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeCursorPosition = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorPositionChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeCursorSelection = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorSelectionChanged, listener);
        };
        DiffEditorWidget.prototype.onDidDispose = function (listener) {
            return this.addListener2(editorCommon.EventType.Disposed, listener);
        };
        DiffEditorWidget.prototype.onDidUpdateDiff = function (listener) {
            return this.addListener2(editorCommon.EventType.DiffUpdated, listener);
        };
        Object.defineProperty(DiffEditorWidget.prototype, "ignoreTrimWhitespace", {
            get: function () {
                return this._ignoreTrimWhitespace;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DiffEditorWidget.prototype, "renderSideBySide", {
            get: function () {
                return this._renderSideBySide;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DiffEditorWidget.prototype, "renderIndicators", {
            get: function () {
                return this._renderIndicators;
            },
            enumerable: true,
            configurable: true
        });
        DiffEditorWidget._getClassName = function (theme, renderSideBySide) {
            var result = 'monaco-diff-editor monaco-editor-background ';
            if (renderSideBySide) {
                result += 'side-by-side ';
            }
            result += theme;
            return result;
        };
        DiffEditorWidget.prototype._recreateOverviewRulers = function () {
            if (this._originalOverviewRuler) {
                this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
                this._originalOverviewRuler.dispose();
            }
            this._originalOverviewRuler = this.originalEditor.getView().createOverviewRuler('original diffOverviewRuler', 4, Number.MAX_VALUE);
            this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());
            if (this._modifiedOverviewRuler) {
                this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
                this._modifiedOverviewRuler.dispose();
            }
            this._modifiedOverviewRuler = this.modifiedEditor.getView().createOverviewRuler('modified diffOverviewRuler', 4, Number.MAX_VALUE);
            this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());
            this._layoutOverviewRulers();
        };
        DiffEditorWidget.prototype._createLeftHandSide = function () {
            this._originalDomNode = document.createElement('div');
            this._originalDomNode.className = 'editor original';
            this._originalDomNode.style.position = 'absolute';
            this._originalDomNode.style.height = '100%';
            this._containerDomElement.appendChild(this._originalDomNode);
        };
        DiffEditorWidget.prototype._createRightHandSide = function () {
            this._modifiedDomNode = document.createElement('div');
            this._modifiedDomNode.className = 'editor modified';
            this._modifiedDomNode.style.position = 'absolute';
            this._modifiedDomNode.style.height = '100%';
            this._containerDomElement.appendChild(this._modifiedDomNode);
        };
        DiffEditorWidget.prototype._createLeftHandSideEditor = function (options, instantiationService) {
            var _this = this;
            this.originalEditor = instantiationService.createInstance(codeEditor_1.CodeEditor, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable));
            this._toDispose.push(this.originalEditor.addBulkListener2(function (events) { return _this._onOriginalEditorEvents(events); }));
            this._toDispose.push(this.addEmitter2(this.originalEditor));
        };
        DiffEditorWidget.prototype._createRightHandSideEditor = function (options, instantiationService) {
            var _this = this;
            this.modifiedEditor = instantiationService.createInstance(codeEditor_1.CodeEditor, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options));
            this._toDispose.push(this.modifiedEditor.addBulkListener2(function (events) { return _this._onModifiedEditorEvents(events); }));
            this._toDispose.push(this.addEmitter2(this.modifiedEditor));
        };
        DiffEditorWidget.prototype.destroy = function () {
            this.dispose();
        };
        DiffEditorWidget.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
            window.clearInterval(this._measureDomElementToken);
            this._cleanViewZonesAndDecorations();
            this._originalOverviewRuler.dispose();
            this._modifiedOverviewRuler.dispose();
            this.originalEditor.dispose();
            this.modifiedEditor.dispose();
            this._strategy.dispose();
            this.emit(editorCommon.EventType.Disposed);
            _super.prototype.dispose.call(this);
        };
        //------------ begin IDiffEditor methods
        DiffEditorWidget.prototype.getId = function () {
            return this.getEditorType() + ':' + this.id;
        };
        DiffEditorWidget.prototype.getEditorType = function () {
            return editorCommon.EditorType.IDiffEditor;
        };
        DiffEditorWidget.prototype.getLineChanges = function () {
            return this._lineChanges;
        };
        DiffEditorWidget.prototype.getOriginalEditor = function () {
            return this.originalEditor;
        };
        DiffEditorWidget.prototype.getModifiedEditor = function () {
            return this.modifiedEditor;
        };
        DiffEditorWidget.prototype.updateOptions = function (newOptions) {
            // Handle new theme
            this._theme = newOptions && newOptions.theme ? newOptions.theme : this._theme;
            // Handle side by side
            var renderSideBySideChanged = false;
            if (typeof newOptions.renderSideBySide !== 'undefined') {
                if (this._renderSideBySide !== newOptions.renderSideBySide) {
                    this._renderSideBySide = newOptions.renderSideBySide;
                    renderSideBySideChanged = true;
                }
            }
            var beginUpdateDecorations = false;
            if (typeof newOptions.ignoreTrimWhitespace !== 'undefined') {
                if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {
                    this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;
                    // Begin comparing
                    beginUpdateDecorations = true;
                }
            }
            if (typeof newOptions.renderIndicators !== 'undefined') {
                if (this._renderIndicators !== newOptions.renderIndicators) {
                    this._renderIndicators = newOptions.renderIndicators;
                    beginUpdateDecorations = true;
                }
            }
            if (beginUpdateDecorations) {
                this._beginUpdateDecorations();
            }
            if (typeof newOptions.originalEditable !== 'undefined') {
                this._originalIsEditable = Boolean(newOptions.originalEditable);
            }
            // Update class name
            this._containerDomElement.className = DiffEditorWidget._getClassName(this._theme, this._renderSideBySide);
            this.modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions));
            this.originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions, this._originalIsEditable));
            // enableSplitViewResizing
            if (typeof newOptions.enableSplitViewResizing !== 'undefined') {
                this._enableSplitViewResizing = newOptions.enableSplitViewResizing;
            }
            this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);
            // renderSideBySide
            if (renderSideBySideChanged) {
                if (this._renderSideBySide) {
                    this._setStrategy(new DiffEdtorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
                }
                else {
                    this._setStrategy(new DiffEdtorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
                }
            }
        };
        DiffEditorWidget.prototype.getValue = function (options) {
            if (options === void 0) { options = null; }
            return this.modifiedEditor.getValue(options);
        };
        DiffEditorWidget.prototype.getModel = function () {
            return {
                original: this.originalEditor.getModel(),
                modified: this.modifiedEditor.getModel()
            };
        };
        DiffEditorWidget.prototype.setModel = function (model) {
            // Guard us against partial null model
            if (model && (!model.original || !model.modified)) {
                throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');
            }
            // Remove all view zones & decorations
            this._cleanViewZonesAndDecorations();
            // Update code editor models
            this.originalEditor.setModel(model ? model.original : null);
            this.modifiedEditor.setModel(model ? model.modified : null);
            this._updateDecorationsRunner.cancel();
            if (model) {
                this.originalEditor.setScrollTop(0);
                this.modifiedEditor.setScrollTop(0);
            }
            // Disable any diff computations that will come in
            this._lineChanges = null;
            this._diffComputationToken++;
            if (model) {
                this._recreateOverviewRulers();
                // Begin comparing
                this._beginUpdateDecorations();
            }
            else {
                this._lineChanges = null;
            }
            this._layoutOverviewViewport();
        };
        DiffEditorWidget.prototype.getDomNode = function () {
            return this._domElement;
        };
        DiffEditorWidget.prototype.getVisibleColumnFromPosition = function (position) {
            return this.modifiedEditor.getVisibleColumnFromPosition(position);
        };
        DiffEditorWidget.prototype.getPosition = function () {
            return this.modifiedEditor.getPosition();
        };
        DiffEditorWidget.prototype.setPosition = function (position, reveal, revealVerticalInCenter, revealHorizontal) {
            this.modifiedEditor.setPosition(position, reveal, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealLine = function (lineNumber) {
            this.modifiedEditor.revealLine(lineNumber);
        };
        DiffEditorWidget.prototype.revealLineInCenter = function (lineNumber) {
            this.modifiedEditor.revealLineInCenter(lineNumber);
        };
        DiffEditorWidget.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber) {
            this.modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber);
        };
        DiffEditorWidget.prototype.revealPosition = function (position, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            this.modifiedEditor.revealPosition(position, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealPositionInCenter = function (position) {
            this.modifiedEditor.revealPositionInCenter(position);
        };
        DiffEditorWidget.prototype.revealPositionInCenterIfOutsideViewport = function (position) {
            this.modifiedEditor.revealPositionInCenterIfOutsideViewport(position);
        };
        DiffEditorWidget.prototype.getSelection = function () {
            return this.modifiedEditor.getSelection();
        };
        DiffEditorWidget.prototype.getSelections = function () {
            return this.modifiedEditor.getSelections();
        };
        DiffEditorWidget.prototype.setSelection = function (something, reveal, revealVerticalInCenter, revealHorizontal) {
            this.modifiedEditor.setSelection(something, reveal, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.setSelections = function (ranges) {
            this.modifiedEditor.setSelections(ranges);
        };
        DiffEditorWidget.prototype.revealLines = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLines(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealRange = function (range, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = true; }
            this.modifiedEditor.revealRange(range, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealRangeInCenter = function (range) {
            this.modifiedEditor.revealRangeInCenter(range);
        };
        DiffEditorWidget.prototype.revealRangeInCenterIfOutsideViewport = function (range) {
            this.modifiedEditor.revealRangeInCenterIfOutsideViewport(range);
        };
        DiffEditorWidget.prototype._addAction = function (descriptor) {
            return this.modifiedEditor._addAction(descriptor);
        };
        DiffEditorWidget.prototype.getActions = function () {
            return this.modifiedEditor.getActions();
        };
        DiffEditorWidget.prototype.getSupportedActions = function () {
            return this.modifiedEditor.getSupportedActions();
        };
        DiffEditorWidget.prototype.getAction = function (id) {
            return this.modifiedEditor.getAction(id);
        };
        DiffEditorWidget.prototype.saveViewState = function () {
            var originalViewState = this.originalEditor.saveViewState();
            var modifiedViewState = this.modifiedEditor.saveViewState();
            return {
                original: originalViewState,
                modified: modifiedViewState
            };
        };
        DiffEditorWidget.prototype.restoreViewState = function (s) {
            if (s.original && s.original) {
                var diffEditorState = s;
                this.originalEditor.restoreViewState(diffEditorState.original);
                this.modifiedEditor.restoreViewState(diffEditorState.modified);
            }
        };
        DiffEditorWidget.prototype.layout = function (dimension) {
            this._measureDomElement(false, dimension);
        };
        DiffEditorWidget.prototype.focus = function () {
            this.modifiedEditor.focus();
        };
        DiffEditorWidget.prototype.isFocused = function () {
            return this.originalEditor.isFocused() || this.modifiedEditor.isFocused();
        };
        DiffEditorWidget.prototype.onVisible = function () {
            this._isVisible = true;
            this.originalEditor.onVisible();
            this.modifiedEditor.onVisible();
            // Begin comparing
            this._beginUpdateDecorations();
        };
        DiffEditorWidget.prototype.onHide = function () {
            this._isVisible = false;
            this.originalEditor.onHide();
            this.modifiedEditor.onHide();
            // Remove all view zones & decorations
            this._cleanViewZonesAndDecorations();
        };
        DiffEditorWidget.prototype.trigger = function (source, handlerId, payload) {
            this.modifiedEditor.trigger(source, handlerId, payload);
        };
        DiffEditorWidget.prototype.changeDecorations = function (callback) {
            return this.modifiedEditor.changeDecorations(callback);
        };
        //------------ end IDiffEditor methods
        //------------ begin layouting methods
        DiffEditorWidget.prototype._measureDomElement = function (forceDoLayoutCall, dimensions) {
            dimensions = dimensions || {
                width: this._containerDomElement.clientWidth,
                height: this._containerDomElement.clientHeight
            };
            if (dimensions.width <= 0) {
                this._width = 0;
                this._height = 0;
                return;
            }
            if (!forceDoLayoutCall && dimensions.width === this._width && dimensions.height === this._height) {
                // Nothing has changed
                return;
            }
            this._width = dimensions.width;
            this._height = dimensions.height;
            this._doLayout();
        };
        DiffEditorWidget.prototype._layoutOverviewRulers = function () {
            var freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;
            var layoutInfo = this.modifiedEditor.getLayoutInfo();
            if (layoutInfo) {
                this._originalOverviewRuler.setLayout(new editorCommon.OverviewRulerPosition({
                    top: 0,
                    width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    height: this._height
                }));
                this._modifiedOverviewRuler.setLayout(new editorCommon.OverviewRulerPosition({
                    top: 0,
                    right: 0,
                    width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    height: this._height
                }));
            }
        };
        //------------ end layouting methods
        DiffEditorWidget.prototype._recomputeIfNecessary = function (events) {
            var _this = this;
            var changed = false;
            for (var i = 0; !changed && i < events.length; i++) {
                var type = events[i].getType();
                changed = changed || type === editorCommon.EventType.ModelRawContentChanged;
            }
            if (changed && this._isVisible) {
                // Clear previous timeout if necessary
                if (this._beginUpdateDecorationsTimeout !== -1) {
                    window.clearTimeout(this._beginUpdateDecorationsTimeout);
                    this._beginUpdateDecorationsTimeout = -1;
                }
                this._beginUpdateDecorationsTimeout = window.setTimeout(function () { return _this._beginUpdateDecorations(); }, DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);
            }
        };
        DiffEditorWidget.prototype._onOriginalEditorEvents = function (events) {
            for (var i = 0; i < events.length; i++) {
                var type = events[i].getType();
                var data = events[i].getData();
                if (type === 'scroll') {
                    this._onOriginalEditorScroll(data);
                }
                if (type === editorCommon.EventType.ViewZonesChanged) {
                    this._onViewZonesChanged();
                }
                if (type === editorCommon.EventType.ConfigurationChanged) {
                    var isViewportWrapping = this.originalEditor.getConfiguration().wrappingInfo.isViewportWrapping;
                    if (isViewportWrapping) {
                        // oh no, you didn't!
                        this.originalEditor.updateOptions({ wrappingColumn: -1 });
                    }
                }
            }
            this._recomputeIfNecessary(events);
        };
        DiffEditorWidget.prototype._onModifiedEditorEvents = function (events) {
            for (var i = 0; i < events.length; i++) {
                var type = events[i].getType();
                var data = events[i].getData();
                if (type === 'scroll') {
                    this._onModifiedEditorScroll(data);
                    this._layoutOverviewViewport();
                }
                if (type === 'viewLayoutChanged') {
                    this._layoutOverviewViewport();
                }
                if (type === editorCommon.EventType.ViewZonesChanged) {
                    this._onViewZonesChanged();
                }
                if (type === editorCommon.EventType.ConfigurationChanged) {
                    var e = data;
                    var isViewportWrapping = this.modifiedEditor.getConfiguration().wrappingInfo.isViewportWrapping;
                    if (isViewportWrapping) {
                        // oh no, you didn't!
                        this.modifiedEditor.updateOptions({ wrappingColumn: -1 });
                    }
                    if (e.fontInfo && this.modifiedEditor.getModel()) {
                        this._onViewZonesChanged();
                    }
                }
            }
            this._recomputeIfNecessary(events);
        };
        DiffEditorWidget.prototype._onViewZonesChanged = function () {
            if (this._currentlyChangingViewZones) {
                return;
            }
            this._updateDecorationsRunner.schedule();
        };
        DiffEditorWidget.prototype._beginUpdateDecorations = function () {
            var _this = this;
            this._beginUpdateDecorationsTimeout = -1;
            if (!this.modifiedEditor.getModel()) {
                return;
            }
            // Prevent old diff requests to come if a new request has been initiated
            // The best method would be to call cancel on the Promise, but this is not
            // yet supported, so using tokens for now.
            this._diffComputationToken++;
            var currentToken = this._diffComputationToken;
            var currentOriginalModel = this.originalEditor.getModel();
            var currentModifiedModel = this.modifiedEditor.getModel();
            this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace).then(function (result) {
                if (currentToken === _this._diffComputationToken
                    && currentOriginalModel === _this.originalEditor.getModel()
                    && currentModifiedModel === _this.modifiedEditor.getModel()) {
                    _this._lineChanges = result;
                    _this._updateDecorationsRunner.schedule();
                    _this.emit(editorCommon.EventType.DiffUpdated, {});
                }
            }, function (error) {
                if (currentToken === _this._diffComputationToken
                    && currentOriginalModel === _this.originalEditor.getModel()
                    && currentModifiedModel === _this.modifiedEditor.getModel()) {
                    _this._lineChanges = null;
                    _this._updateDecorationsRunner.schedule();
                }
            });
        };
        DiffEditorWidget.prototype._cleanViewZonesAndDecorations = function () {
            this._originalEditorState.clean(this.originalEditor);
            this._modifiedEditorState.clean(this.modifiedEditor);
        };
        DiffEditorWidget.prototype._updateDecorations = function () {
            if (!this.originalEditor.getModel() || !this.modifiedEditor.getModel()) {
                return;
            }
            var lineChanges = this._lineChanges || [];
            var foreignOriginal = this._originalEditorState.getForeignViewZones(this.originalEditor.getWhitespaces());
            var foreignModified = this._modifiedEditorState.getForeignViewZones(this.modifiedEditor.getWhitespaces());
            var diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, this._renderIndicators, foreignOriginal, foreignModified, this.originalEditor, this.modifiedEditor);
            try {
                this._currentlyChangingViewZones = true;
                this._originalEditorState.apply(this.originalEditor, this._originalOverviewRuler, diffDecorations.original);
                this._modifiedEditorState.apply(this.modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified);
            }
            finally {
                this._currentlyChangingViewZones = false;
            }
        };
        DiffEditorWidget.prototype._adjustOptionsForSubEditor = function (options) {
            var clonedOptions = objects.clone(options || {});
            clonedOptions.wrappingColumn = -1;
            clonedOptions.automaticLayout = false;
            clonedOptions.scrollbar = clonedOptions.scrollbar || {};
            clonedOptions.scrollbar.vertical = 'visible';
            clonedOptions.folding = false;
            clonedOptions.codeLens = false;
            clonedOptions.fixedOverflowWidgets = true;
            clonedOptions.lineDecorationsWidth = '2ch';
            return clonedOptions;
        };
        DiffEditorWidget.prototype._adjustOptionsForLeftHandSide = function (options, isEditable) {
            var result = this._adjustOptionsForSubEditor(options);
            result.readOnly = !isEditable;
            result.overviewRulerLanes = 1;
            result.theme = this._theme + ' original-in-monaco-diff-editor';
            return result;
        };
        DiffEditorWidget.prototype._adjustOptionsForRightHandSide = function (options) {
            var result = this._adjustOptionsForSubEditor(options);
            result.revealHorizontalRightPadding = defaultConfig_1.DefaultConfig.editor.revealHorizontalRightPadding + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            result.scrollbar.verticalHasArrows = false;
            result.theme = this._theme + ' modified-in-monaco-diff-editor';
            return result;
        };
        DiffEditorWidget.prototype._onOriginalEditorScroll = function (e) {
            if (!e.scrollTopChanged && !e.scrollLeftChanged) {
                return;
            }
            if (this._isHandlingScrollEvent) {
                return;
            }
            this._isHandlingScrollEvent = true;
            this.modifiedEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            this._isHandlingScrollEvent = false;
        };
        DiffEditorWidget.prototype._onModifiedEditorScroll = function (e) {
            if (!e.scrollTopChanged && !e.scrollLeftChanged) {
                return;
            }
            if (this._isHandlingScrollEvent) {
                return;
            }
            this._isHandlingScrollEvent = true;
            this.originalEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            this._isHandlingScrollEvent = false;
        };
        DiffEditorWidget.prototype._doLayout = function () {
            var splitPoint = this._strategy.layout();
            this._originalDomNode.style.width = splitPoint + 'px';
            this._originalDomNode.style.left = '0px';
            this._modifiedDomNode.style.width = (this._width - splitPoint) + 'px';
            this._modifiedDomNode.style.left = splitPoint + 'px';
            this._overviewDomElement.style.top = '0px';
            this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';
            this._overviewDomElement.style.left = (this._width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';
            this._overviewViewportDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';
            this._overviewViewportDomElement.style.height = '30px';
            this.originalEditor.layout({ width: splitPoint, height: this._height });
            this.modifiedEditor.layout({ width: this._width - splitPoint - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH, height: this._height });
            if (this._originalOverviewRuler || this._modifiedOverviewRuler) {
                this._layoutOverviewRulers();
            }
            this._layoutOverviewViewport();
        };
        DiffEditorWidget.prototype._layoutOverviewViewport = function () {
            var layout = this._computeOverviewViewport();
            if (!layout) {
                styleMutator_1.StyleMutator.setTop(this._overviewViewportDomElement, 0);
                styleMutator_1.StyleMutator.setHeight(this._overviewViewportDomElement, 0);
            }
            else {
                styleMutator_1.StyleMutator.setTop(this._overviewViewportDomElement, layout.top);
                styleMutator_1.StyleMutator.setHeight(this._overviewViewportDomElement, layout.height);
            }
        };
        DiffEditorWidget.prototype._computeOverviewViewport = function () {
            var layoutInfo = this.modifiedEditor.getLayoutInfo();
            if (!layoutInfo) {
                return null;
            }
            var scrollTop = this.modifiedEditor.getScrollTop();
            var scrollHeight = this.modifiedEditor.getScrollHeight();
            var computedAvailableSize = Math.max(0, layoutInfo.contentHeight);
            var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);
            var computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;
            var computedSliderSize = Math.max(1, Math.floor(layoutInfo.contentHeight * computedRatio));
            var computedSliderPosition = Math.floor(scrollTop * computedRatio);
            return {
                height: computedSliderSize,
                top: computedSliderPosition
            };
        };
        DiffEditorWidget.prototype._createDataSource = function () {
            var _this = this;
            return {
                getWidth: function () {
                    return _this._width;
                },
                getHeight: function () {
                    return _this._height;
                },
                getContainerDomNode: function () {
                    return _this._containerDomElement;
                },
                relayoutEditors: function () {
                    _this._doLayout();
                },
                getOriginalEditor: function () {
                    return _this.originalEditor;
                },
                getModifiedEditor: function () {
                    return _this.modifiedEditor;
                }
            };
        };
        DiffEditorWidget.prototype._setStrategy = function (newStrategy) {
            if (this._strategy) {
                this._strategy.dispose();
            }
            this._strategy = newStrategy;
            if (this._lineChanges) {
                this._updateDecorations();
            }
            // Just do a layout, the strategy might need it
            this._measureDomElement(true);
        };
        DiffEditorWidget.prototype._getLineChangeAtOrBeforeLineNumber = function (lineNumber, startLineNumberExtractor) {
            if (this._lineChanges.length === 0 || lineNumber < startLineNumberExtractor(this._lineChanges[0])) {
                // There are no changes or `lineNumber` is before the first change
                return null;
            }
            var min = 0, max = this._lineChanges.length - 1;
            while (min < max) {
                var mid = Math.floor((min + max) / 2);
                var midStart = startLineNumberExtractor(this._lineChanges[mid]);
                var midEnd = (mid + 1 <= max ? startLineNumberExtractor(this._lineChanges[mid + 1]) : Number.MAX_VALUE);
                if (lineNumber < midStart) {
                    max = mid - 1;
                }
                else if (lineNumber >= midEnd) {
                    min = mid + 1;
                }
                else {
                    // HIT!
                    min = mid;
                    max = mid;
                }
            }
            return this._lineChanges[min];
        };
        DiffEditorWidget.prototype._getEquivalentLineForOriginalLineNumber = function (lineNumber) {
            var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.originalStartLineNumber; });
            if (!lineChange) {
                return lineNumber;
            }
            var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
            var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
            var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
            var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
            var delta = lineNumber - originalEquivalentLineNumber;
            if (delta <= lineChangeOriginalLength) {
                return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);
            }
            return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;
        };
        DiffEditorWidget.prototype._getEquivalentLineForModifiedLineNumber = function (lineNumber) {
            var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.modifiedStartLineNumber; });
            if (!lineChange) {
                return lineNumber;
            }
            var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
            var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
            var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
            var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
            var delta = lineNumber - modifiedEquivalentLineNumber;
            if (delta <= lineChangeModifiedLength) {
                return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);
            }
            return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;
        };
        DiffEditorWidget.prototype.getDiffLineInformationForOriginal = function (lineNumber) {
            if (!this._lineChanges) {
                // Cannot answer that which I don't know
                return null;
            }
            return {
                equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)
            };
        };
        DiffEditorWidget.prototype.getDiffLineInformationForModified = function (lineNumber) {
            if (!this._lineChanges) {
                // Cannot answer that which I don't know
                return null;
            }
            return {
                equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)
            };
        };
        return DiffEditorWidget;
    }(eventEmitter_1.EventEmitter));
    DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
    DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
    DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms
    DiffEditorWidget = __decorate([
        __param(2, editorWorkerService_1.IEditorWorkerService),
        __param(3, contextkey_1.IContextKeyService),
        __param(4, instantiation_1.IInstantiationService)
    ], DiffEditorWidget);
    exports.DiffEditorWidget = DiffEditorWidget;
    var DiffEditorWidgetStyle = (function () {
        function DiffEditorWidgetStyle(dataSource) {
            this._dataSource = dataSource;
        }
        DiffEditorWidgetStyle.prototype.getEditorsDiffDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor) {
            // Get view zones
            modifiedWhitespaces = modifiedWhitespaces.sort(function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            });
            originalWhitespaces = originalWhitespaces.sort(function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            });
            var zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor, renderIndicators);
            // Get decorations & overview ruler zones
            var originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
            var modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor);
            return {
                original: {
                    decorations: originalDecorations.decorations,
                    overviewZones: originalDecorations.overviewZones,
                    zones: zones.original
                },
                modified: {
                    decorations: modifiedDecorations.decorations,
                    overviewZones: modifiedDecorations.overviewZones,
                    zones: zones.modified
                }
            };
        };
        DiffEditorWidgetStyle.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
            return null;
        };
        DiffEditorWidgetStyle.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            return null;
        };
        DiffEditorWidgetStyle.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            return null;
        };
        return DiffEditorWidgetStyle;
    }());
    var ForeignViewZonesIterator = (function () {
        function ForeignViewZonesIterator(source) {
            this._source = source;
            this._index = -1;
            this.advance();
        }
        ForeignViewZonesIterator.prototype.advance = function () {
            this._index++;
            if (this._index < this._source.length) {
                this.current = this._source[this._index];
            }
            else {
                this.current = null;
            }
        };
        return ForeignViewZonesIterator;
    }());
    var ViewZonesComputer = (function () {
        function ViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
            this.lineChanges = lineChanges;
            this.originalForeignVZ = originalForeignVZ;
            this.modifiedForeignVZ = modifiedForeignVZ;
        }
        ViewZonesComputer.prototype.getViewZones = function () {
            var result = {
                original: [],
                modified: []
            };
            var lineChangeModifiedLength = 0;
            var lineChangeOriginalLength = 0;
            var originalEquivalentLineNumber = 0;
            var modifiedEquivalentLineNumber = 0;
            var originalEndEquivalentLineNumber = 0;
            var modifiedEndEquivalentLineNumber = 0;
            var sortMyViewZones = function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            };
            var addAndCombineIfPossible = function (destination, item) {
                if (item.domNode === null && destination.length > 0) {
                    var lastItem = destination[destination.length - 1];
                    if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {
                        lastItem.heightInLines += item.heightInLines;
                        return;
                    }
                }
                destination.push(item);
            };
            var modifiedForeignVZ = new ForeignViewZonesIterator(this.modifiedForeignVZ);
            var originalForeignVZ = new ForeignViewZonesIterator(this.originalForeignVZ);
            // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array
            for (var i = 0, length_4 = this.lineChanges.length; i <= length_4; i++) {
                var lineChange = (i < length_4 ? this.lineChanges[i] : null);
                if (lineChange !== null) {
                    originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
                    modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
                    lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
                    lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
                    originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
                    modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
                }
                else {
                    // Increase to very large value to get the producing tests of foreign view zones running
                    originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;
                    modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;
                    originalEndEquivalentLineNumber = originalEquivalentLineNumber;
                    modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;
                }
                // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases
                var stepOriginal = [];
                var stepModified = [];
                // ---------------------------- PRODUCE VIEW ZONES
                // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side
                while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {
                    var viewZoneLineNumber = void 0;
                    if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {
                        viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;
                    }
                    else {
                        viewZoneLineNumber = originalEndEquivalentLineNumber;
                    }
                    stepOriginal.push({
                        afterLineNumber: viewZoneLineNumber,
                        heightInLines: modifiedForeignVZ.current.heightInLines,
                        domNode: null
                    });
                    modifiedForeignVZ.advance();
                }
                // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side
                while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {
                    var viewZoneLineNumber = void 0;
                    if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {
                        viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;
                    }
                    else {
                        viewZoneLineNumber = modifiedEndEquivalentLineNumber;
                    }
                    stepModified.push({
                        afterLineNumber: viewZoneLineNumber,
                        heightInLines: originalForeignVZ.current.heightInLines,
                        domNode: null
                    });
                    originalForeignVZ.advance();
                }
                if (lineChange !== null && isChangeOrInsert(lineChange)) {
                    var r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                    if (r) {
                        stepOriginal.push(r);
                    }
                }
                if (lineChange !== null && isChangeOrDelete(lineChange)) {
                    var r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                    if (r) {
                        stepModified.push(r);
                    }
                }
                // ---------------------------- END PRODUCE VIEW ZONES
                // ---------------------------- EMIT MINIMAL VIEW ZONES
                // [CANCEL & EMIT] Try to cancel view zones out
                var stepOriginalIndex = 0;
                var stepModifiedIndex = 0;
                stepOriginal = stepOriginal.sort(sortMyViewZones);
                stepModified = stepModified.sort(sortMyViewZones);
                while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {
                    var original = stepOriginal[stepOriginalIndex];
                    var modified = stepModified[stepModifiedIndex];
                    var originalDelta = original.afterLineNumber - originalEquivalentLineNumber;
                    var modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;
                    if (originalDelta < modifiedDelta) {
                        addAndCombineIfPossible(result.original, original);
                        stepOriginalIndex++;
                    }
                    else if (modifiedDelta < originalDelta) {
                        addAndCombineIfPossible(result.modified, modified);
                        stepModifiedIndex++;
                    }
                    else if (original.shouldNotShrink) {
                        addAndCombineIfPossible(result.original, original);
                        stepOriginalIndex++;
                    }
                    else if (modified.shouldNotShrink) {
                        addAndCombineIfPossible(result.modified, modified);
                        stepModifiedIndex++;
                    }
                    else {
                        if (original.heightInLines >= modified.heightInLines) {
                            // modified view zone gets removed
                            original.heightInLines -= modified.heightInLines;
                            stepModifiedIndex++;
                        }
                        else {
                            // original view zone gets removed
                            modified.heightInLines -= original.heightInLines;
                            stepOriginalIndex++;
                        }
                    }
                }
                // [EMIT] Remaining original view zones
                while (stepOriginalIndex < stepOriginal.length) {
                    addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);
                    stepOriginalIndex++;
                }
                // [EMIT] Remaining modified view zones
                while (stepModifiedIndex < stepModified.length) {
                    addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);
                    stepModifiedIndex++;
                }
            }
            var ensureDomNode = function (z) {
                if (!z.domNode) {
                    z.domNode = createFakeLinesDiv();
                }
            };
            result.original.forEach(ensureDomNode);
            result.modified.forEach(ensureDomNode);
            return result;
        };
        return ViewZonesComputer;
    }());
    var DiffEdtorWidgetSideBySide = (function (_super) {
        __extends(DiffEdtorWidgetSideBySide, _super);
        function DiffEdtorWidgetSideBySide(dataSource, enableSplitViewResizing) {
            var _this = _super.call(this, dataSource) || this;
            _this._disableSash = (enableSplitViewResizing === false);
            _this._sashRatio = null;
            _this._sashPosition = null;
            _this._sash = new sash_1.Sash(_this._dataSource.getContainerDomNode(), _this);
            if (_this._disableSash) {
                _this._sash.disable();
            }
            _this._sash.addListener2('start', function () { return _this.onSashDragStart(); });
            _this._sash.addListener2('change', function (e) { return _this.onSashDrag(e); });
            _this._sash.addListener2('end', function () { return _this.onSashDragEnd(); });
            _this._sash.addListener2('reset', function () { return _this.onSashReset(); });
            return _this;
        }
        DiffEdtorWidgetSideBySide.prototype.dispose = function () {
            this._sash.dispose();
        };
        DiffEdtorWidgetSideBySide.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
            var newDisableSash = (enableSplitViewResizing === false);
            if (this._disableSash !== newDisableSash) {
                this._disableSash = newDisableSash;
                if (this._disableSash) {
                    this._sash.disable();
                }
                else {
                    this._sash.enable();
                }
            }
        };
        DiffEdtorWidgetSideBySide.prototype.layout = function (sashRatio) {
            if (sashRatio === void 0) { sashRatio = this._sashRatio; }
            var w = this._dataSource.getWidth();
            var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            var sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
            var midPoint = Math.floor(0.5 * contentWidth);
            sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;
            if (contentWidth > DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {
                if (sashPosition < DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                    sashPosition = DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
                }
                if (sashPosition > contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                    sashPosition = contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
                }
            }
            else {
                sashPosition = midPoint;
            }
            if (this._sashPosition !== sashPosition) {
                this._sashPosition = sashPosition;
                this._sash.layout();
            }
            return this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDragStart = function () {
            this._startSashPosition = this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDrag = function (e) {
            var w = this._dataSource.getWidth();
            var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            var sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);
            this._sashRatio = sashPosition / contentWidth;
            this._dataSource.relayoutEditors();
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDragEnd = function () {
            this._sash.layout();
        };
        DiffEdtorWidgetSideBySide.prototype.onSashReset = function () {
            this._sashRatio = 0.5;
            this._dataSource.relayoutEditors();
            this._sash.layout();
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashTop = function (sash) {
            return 0;
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashLeft = function (sash) {
            return this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashHeight = function (sash) {
            return this._dataSource.getHeight();
        };
        DiffEdtorWidgetSideBySide.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
            var c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ);
            return c.getViewZones();
        };
        DiffEdtorWidgetSideBySide.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            };
            var originalModel = originalEditor.getModel();
            for (var i = 0, length_5 = lineChanges.length; i < length_5; i++) {
                var lineChange = lineChanges[i];
                if (isChangeOrDelete(lineChange)) {
                    result.decorations.push({
                        range: new range_1.Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE),
                        options: {
                            className: 'line-delete',
                            linesDecorationsClassName: renderIndicators ? 'delete-sign' : undefined,
                            marginClassName: 'line-delete',
                            isWholeLine: true
                        }
                    });
                    if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {
                        result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE, 'char-delete', true));
                    }
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(255, 0, 0, 0.4)', 'rgba(255, 0, 0, 0.4)'));
                    if (lineChange.charChanges) {
                        for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            var charChange = lineChange.charChanges[j];
                            if (isChangeOrDelete(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (var lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {
                                        var startColumn = void 0;
                                        var endColumn = void 0;
                                        if (lineNumber === charChange.originalStartLineNumber) {
                                            startColumn = charChange.originalStartColumn;
                                        }
                                        else {
                                            startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.originalEndLineNumber) {
                                            endColumn = charChange.originalEndColumn;
                                        }
                                        else {
                                            endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-delete', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, 'char-delete', false));
                                }
                            }
                        }
                    }
                }
            }
            return result;
        };
        DiffEdtorWidgetSideBySide.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            };
            var modifiedModel = modifiedEditor.getModel();
            for (var i = 0, length_6 = lineChanges.length; i < length_6; i++) {
                var lineChange = lineChanges[i];
                if (isChangeOrInsert(lineChange)) {
                    result.decorations.push({
                        range: new range_1.Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE),
                        options: {
                            className: 'line-insert',
                            linesDecorationsClassName: renderIndicators ? 'insert-sign' : undefined,
                            marginClassName: 'line-insert',
                            isWholeLine: true
                        }
                    });
                    if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {
                        result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'char-insert', true));
                    }
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(155, 185, 85, 0.4)', 'rgba(155, 185, 85, 0.4)'));
                    if (lineChange.charChanges) {
                        for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            var charChange = lineChange.charChanges[j];
                            if (isChangeOrInsert(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (var lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                        var startColumn = void 0;
                                        var endColumn = void 0;
                                        if (lineNumber === charChange.modifiedStartLineNumber) {
                                            startColumn = charChange.modifiedStartColumn;
                                        }
                                        else {
                                            startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.modifiedEndLineNumber) {
                                            endColumn = charChange.modifiedEndColumn;
                                        }
                                        else {
                                            endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-insert', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, 'char-insert', false));
                                }
                            }
                        }
                    }
                }
            }
            return result;
        };
        return DiffEdtorWidgetSideBySide;
    }(DiffEditorWidgetStyle));
    DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;
    var SideBySideViewZonesComputer = (function (_super) {
        __extends(SideBySideViewZonesComputer, _super);
        function SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
            return _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ) || this;
        }
        SideBySideViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            if (lineChangeModifiedLength > lineChangeOriginalLength) {
                return {
                    afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
                    heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),
                    domNode: null
                };
            }
            return null;
        };
        SideBySideViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            if (lineChangeOriginalLength > lineChangeModifiedLength) {
                return {
                    afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),
                    heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),
                    domNode: null
                };
            }
            return null;
        };
        return SideBySideViewZonesComputer;
    }(ViewZonesComputer));
    var DiffEdtorWidgetInline = (function (_super) {
        __extends(DiffEdtorWidgetInline, _super);
        function DiffEdtorWidgetInline(dataSource, enableSplitViewResizing) {
            var _this = _super.call(this, dataSource) || this;
            _this.decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;
            _this.toDispose = [];
            _this.toDispose.push(dataSource.getOriginalEditor().onDidLayoutChange(function (layoutInfo) {
                if (_this.decorationsLeft !== layoutInfo.decorationsLeft) {
                    _this.decorationsLeft = layoutInfo.decorationsLeft;
                    dataSource.relayoutEditors();
                }
            }));
            return _this;
        }
        DiffEdtorWidgetInline.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        DiffEdtorWidgetInline.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
            // Nothing to do..
        };
        DiffEdtorWidgetInline.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
            var computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators);
            return computer.getViewZones();
        };
        DiffEdtorWidgetInline.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            };
            for (var i = 0, length_7 = lineChanges.length; i < length_7; i++) {
                var lineChange = lineChanges[i];
                // Add overview zones in the overview ruler
                if (isChangeOrDelete(lineChange)) {
                    result.decorations.push({
                        range: new range_1.Range(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE),
                        options: {
                            marginClassName: 'line-delete',
                        }
                    });
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(255, 0, 0, 0.4)', 'rgba(255, 0, 0, 0.4)'));
                }
            }
            return result;
        };
        DiffEdtorWidgetInline.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, renderIndicators, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            };
            var modifiedModel = modifiedEditor.getModel();
            for (var i = 0, length_8 = lineChanges.length; i < length_8; i++) {
                var lineChange = lineChanges[i];
                // Add decorations & overview zones
                if (isChangeOrInsert(lineChange)) {
                    result.decorations.push({
                        range: new range_1.Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE),
                        options: {
                            className: 'line-insert',
                            linesDecorationsClassName: renderIndicators ? 'insert-sign' : undefined,
                            marginClassName: 'line-insert',
                            isWholeLine: true
                        }
                    });
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(155, 185, 85, 0.4)', 'rgba(155, 185, 85, 0.4)'));
                    if (lineChange.charChanges) {
                        for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            var charChange = lineChange.charChanges[j];
                            if (isChangeOrInsert(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (var lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                        var startColumn = void 0;
                                        var endColumn = void 0;
                                        if (lineNumber === charChange.modifiedStartLineNumber) {
                                            startColumn = charChange.modifiedStartColumn;
                                        }
                                        else {
                                            startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.modifiedEndLineNumber) {
                                            endColumn = charChange.modifiedEndColumn;
                                        }
                                        else {
                                            endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-insert', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, 'char-insert', false));
                                }
                            }
                        }
                    }
                    else {
                        result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'char-insert', true));
                    }
                }
            }
            return result;
        };
        DiffEdtorWidgetInline.prototype.layout = function () {
            // An editor should not be smaller than 5px
            return Math.max(5, this.decorationsLeft);
        };
        return DiffEdtorWidgetInline;
    }(DiffEditorWidgetStyle));
    var InlineViewZonesComputer = (function (_super) {
        __extends(InlineViewZonesComputer, _super);
        function InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor, renderIndicators) {
            var _this = _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ) || this;
            _this.originalModel = originalEditor.getModel();
            _this.modifiedEditorConfiguration = modifiedEditor.getConfiguration();
            _this.modifiedEditorTabSize = modifiedEditor.getModel().getOptions().tabSize;
            _this.renderIndicators = renderIndicators;
            return _this;
        }
        InlineViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            var marginDomNode = document.createElement('div');
            marginDomNode.className = 'inline-added-margin-view-zone';
            configuration_1.Configuration.applyFontInfoSlow(marginDomNode, this.modifiedEditorConfiguration.fontInfo);
            return {
                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
                heightInLines: lineChangeModifiedLength,
                domNode: document.createElement('div'),
                marginDomNode: marginDomNode
            };
        };
        InlineViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            var decorations = [];
            if (lineChange.charChanges) {
                for (var j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                    var charChange = lineChange.charChanges[j];
                    if (isChangeOrDelete(charChange)) {
                        decorations.push(new viewModel_1.InlineDecoration(new range_1.Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete', false));
                    }
                }
            }
            var html = [];
            var marginHTML = [];
            var lineDecorationsWidth = this.modifiedEditorConfiguration.layoutInfo.decorationsWidth;
            var lineHeight = this.modifiedEditorConfiguration.lineHeight;
            for (var lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
                html = html.concat(this.renderOriginalLine(lineNumber - lineChange.originalStartLineNumber, this.originalModel, this.modifiedEditorConfiguration, this.modifiedEditorTabSize, lineNumber, decorations));
                if (this.renderIndicators) {
                    var index = lineNumber - lineChange.originalStartLineNumber;
                    marginHTML = marginHTML.concat([
                        "<div class=\"delete-sign\" style=\"position:absolute;top:" + index * lineHeight + "px;width:" + lineDecorationsWidth + "px;height:" + lineHeight + "px;right:0;\"></div>"
                    ]);
                }
            }
            var domNode = document.createElement('div');
            domNode.className = 'view-lines line-delete';
            domNode.innerHTML = html.join('');
            configuration_1.Configuration.applyFontInfoSlow(domNode, this.modifiedEditorConfiguration.fontInfo);
            var marginDomNode = document.createElement('div');
            marginDomNode.className = 'inline-deleted-margin-view-zone';
            marginDomNode.innerHTML = marginHTML.join('');
            configuration_1.Configuration.applyFontInfoSlow(marginDomNode, this.modifiedEditorConfiguration.fontInfo);
            return {
                shouldNotShrink: true,
                afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),
                heightInLines: lineChangeOriginalLength,
                domNode: domNode,
                marginDomNode: marginDomNode
            };
        };
        InlineViewZonesComputer.prototype.renderOriginalLine = function (count, originalModel, config, tabSize, lineNumber, decorations) {
            var lineContent = originalModel.getLineContent(lineNumber);
            var actualDecorations = viewLineParts_1.Decoration.filter(decorations, lineNumber, 1, lineContent.length + 1);
            var r = viewLineRenderer_1.renderViewLine(new viewLineRenderer_1.RenderLineInput(config.fontInfo.isMonospace, lineContent, originalModel.mightContainRTL(), 0, [new viewLineToken_1.ViewLineToken(lineContent.length, '')], actualDecorations, tabSize, config.fontInfo.spaceWidth, config.viewInfo.stopRenderingLineAfter, config.viewInfo.renderWhitespace, config.viewInfo.renderControlCharacters));
            var myResult = [];
            myResult.push('<div class="view-line');
            if (decorations.length === 0) {
                // No char changes
                myResult.push(' char-delete');
            }
            myResult.push('" style="top:');
            myResult.push(String(count * config.lineHeight));
            myResult.push('px;width:1000000px;">');
            myResult = myResult.concat(r.output);
            myResult.push('</div>');
            return myResult;
        };
        return InlineViewZonesComputer;
    }(ViewZonesComputer));
    function isChangeOrInsert(lineChange) {
        return lineChange.modifiedEndLineNumber > 0;
    }
    function isChangeOrDelete(lineChange) {
        return lineChange.originalEndLineNumber > 0;
    }
    function createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, className, isWholeLine) {
        return {
            range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
            options: {
                className: className,
                isWholeLine: isWholeLine
            }
        };
    }
    function createFakeLinesDiv() {
        var r = document.createElement('div');
        r.className = 'diagonal-fill';
        return r;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[496/*vs/editor/browser/standalone/standaloneCodeEditor*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,58/*vs/platform/contextview/browser/contextView*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,2/*vs/editor/common/editorCommon*/,45/*vs/editor/common/services/codeEditorService*/,52/*vs/editor/common/services/editorWorkerService*/,115/*vs/editor/browser/standalone/simpleServices*/,120/*vs/editor/browser/codeEditor*/,169/*vs/editor/browser/widget/diffEditorWidget*/,78/*vs/editor/common/services/standaloneColorService*/]), function (require, exports, lifecycle_1, contextView_1, instantiation_1, commands_1, keybinding_1, contextkey_1, editorCommon_1, codeEditorService_1, editorWorkerService_1, simpleServices_1, codeEditor_1, diffEditorWidget_1, standaloneColorService_1) {
    'use strict';
    var LAST_GENERATED_COMMAND_ID = 0;
    var StandaloneEditor = (function (_super) {
        __extends(StandaloneEditor, _super);
        function StandaloneEditor(domElement, options, toDispose, instantiationService, codeEditorService, commandService, contextKeyService, keybindingService, contextViewService, standaloneColorService) {
            var _this = this;
            options = options || {};
            if (typeof options.theme === 'string') {
                options.theme = standaloneColorService.setTheme(options.theme);
            }
            _this = _super.call(this, domElement, options, instantiationService, codeEditorService, commandService, contextKeyService) || this;
            _this._standaloneColorService = standaloneColorService;
            if (keybindingService instanceof simpleServices_1.StandaloneKeybindingService) {
                _this._standaloneKeybindingService = keybindingService;
            }
            _this._contextViewService = contextViewService;
            _this._toDispose2 = [toDispose];
            var model = null;
            if (typeof options.model === 'undefined') {
                model = self.monaco.editor.createModel(options.value || '', options.language || 'text/plain');
                _this._ownsModel = true;
            }
            else {
                model = options.model;
                delete options.model;
                _this._ownsModel = false;
            }
            _this._attachModel(model);
            if (model) {
                var e = {
                    oldModelUrl: null,
                    newModelUrl: model.uri
                };
                _this.emit(editorCommon_1.EventType.ModelChanged, e);
            }
            return _this;
        }
        StandaloneEditor.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._toDispose2 = lifecycle_1.dispose(this._toDispose2);
        };
        StandaloneEditor.prototype.destroy = function () {
            this.dispose();
        };
        StandaloneEditor.prototype.updateOptions = function (newOptions) {
            if (typeof newOptions.theme === 'string') {
                newOptions.theme = this._standaloneColorService.setTheme(newOptions.theme);
            }
            _super.prototype.updateOptions.call(this, newOptions);
        };
        StandaloneEditor.prototype.addCommand = function (keybinding, handler, context) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            var commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);
            this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, context);
            return commandId;
        };
        StandaloneEditor.prototype.createContextKey = function (key, defaultValue) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot create context key because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._contextKeyService.createKey(key, defaultValue);
        };
        StandaloneEditor.prototype.addAction = function (descriptor) {
            var _this = this;
            var addedAction = this._addAction(descriptor);
            var toDispose = [addedAction.disposable];
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            if (Array.isArray(descriptor.keybindings)) {
                var handler_1 = function (accessor) {
                    return _this.trigger('keyboard', descriptor.id, null);
                };
                toDispose = toDispose.concat(descriptor.keybindings.map(function (kb) {
                    return _this._standaloneKeybindingService.addDynamicKeybinding(addedAction.uniqueId, kb, handler_1, descriptor.keybindingContext);
                }));
            }
            return lifecycle_1.combinedDisposable(toDispose);
        };
        StandaloneEditor.prototype._attachModel = function (model) {
            _super.prototype._attachModel.call(this, model);
            if (this._view) {
                this._contextViewService.setContainer(this._view.domNode);
            }
        };
        StandaloneEditor.prototype._postDetachModelCleanup = function (detachedModel) {
            _super.prototype._postDetachModelCleanup.call(this, detachedModel);
            if (detachedModel && this._ownsModel) {
                detachedModel.dispose();
                this._ownsModel = false;
            }
        };
        return StandaloneEditor;
    }(codeEditor_1.CodeEditor));
    StandaloneEditor = __decorate([
        __param(3, instantiation_1.IInstantiationService),
        __param(4, codeEditorService_1.ICodeEditorService),
        __param(5, commands_1.ICommandService),
        __param(6, contextkey_1.IContextKeyService),
        __param(7, keybinding_1.IKeybindingService),
        __param(8, contextView_1.IContextViewService),
        __param(9, standaloneColorService_1.IStandaloneColorService)
    ], StandaloneEditor);
    exports.StandaloneEditor = StandaloneEditor;
    var StandaloneDiffEditor = (function (_super) {
        __extends(StandaloneDiffEditor, _super);
        function StandaloneDiffEditor(domElement, options, toDispose, instantiationService, contextKeyService, keybindingService, contextViewService, editorWorkerService) {
            var _this = _super.call(this, domElement, options, editorWorkerService, contextKeyService, instantiationService) || this;
            if (keybindingService instanceof simpleServices_1.StandaloneKeybindingService) {
                _this._standaloneKeybindingService = keybindingService;
            }
            _this._contextViewService = contextViewService;
            _this._toDispose2 = [toDispose];
            _this._contextViewService.setContainer(_this._containerDomElement);
            return _this;
        }
        StandaloneDiffEditor.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._toDispose2 = lifecycle_1.dispose(this._toDispose2);
        };
        StandaloneDiffEditor.prototype.destroy = function () {
            this.dispose();
        };
        StandaloneDiffEditor.prototype.addCommand = function (keybinding, handler, context) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            var commandId = 'DYNAMIC_' + (++LAST_GENERATED_COMMAND_ID);
            this._standaloneKeybindingService.addDynamicKeybinding(commandId, keybinding, handler, context);
            return commandId;
        };
        StandaloneDiffEditor.prototype.createContextKey = function (key, defaultValue) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot create context key because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._contextKeyService.createKey(key, defaultValue);
        };
        StandaloneDiffEditor.prototype.addAction = function (descriptor) {
            var _this = this;
            var addedAction = this._addAction(descriptor);
            var toDispose = [addedAction.disposable];
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            if (Array.isArray(descriptor.keybindings)) {
                var handler_2 = function (ctx) {
                    return _this.trigger('keyboard', descriptor.id, null);
                };
                toDispose = toDispose.concat(descriptor.keybindings.map(function (kb) {
                    return _this._standaloneKeybindingService.addDynamicKeybinding(addedAction.uniqueId, kb, handler_2, descriptor.keybindingContext);
                }));
            }
            return lifecycle_1.combinedDisposable(toDispose);
        };
        return StandaloneDiffEditor;
    }(diffEditorWidget_1.DiffEditorWidget));
    StandaloneDiffEditor = __decorate([
        __param(3, instantiation_1.IInstantiationService),
        __param(4, contextkey_1.IContextKeyService),
        __param(5, keybinding_1.IKeybindingService),
        __param(6, contextView_1.IContextViewService),
        __param(7, editorWorkerService_1.IEditorWorkerService)
    ], StandaloneDiffEditor);
    exports.StandaloneDiffEditor = StandaloneDiffEditor;
});















define(__m[170/*vs/editor/browser/widget/embeddedCodeEditorWidget*/], __M([1/*require*/,0/*exports*/,36/*vs/base/common/objects*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/,18/*vs/platform/contextkey/common/contextkey*/,45/*vs/editor/common/services/codeEditorService*/,120/*vs/editor/browser/codeEditor*/]), function (require, exports, objects, instantiation_1, commands_1, contextkey_1, codeEditorService_1, codeEditor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EmbeddedCodeEditorWidget = (function (_super) {
        __extends(EmbeddedCodeEditorWidget, _super);
        function EmbeddedCodeEditorWidget(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService) {
            var _this = _super.call(this, domElement, parentEditor.getRawConfiguration(), instantiationService, codeEditorService, commandService, contextKeyService) || this;
            _this._parentEditor = parentEditor;
            _this._overwriteOptions = options;
            // Overwrite parent's options
            _super.prototype.updateOptions.call(_this, _this._overwriteOptions);
            _this._lifetimeDispose.push(parentEditor.onDidChangeConfiguration(function (e) { return _this._onParentConfigurationChanged(e); }));
            return _this;
        }
        EmbeddedCodeEditorWidget.prototype.getParentEditor = function () {
            return this._parentEditor;
        };
        EmbeddedCodeEditorWidget.prototype._onParentConfigurationChanged = function (e) {
            _super.prototype.updateOptions.call(this, this._parentEditor.getRawConfiguration());
            _super.prototype.updateOptions.call(this, this._overwriteOptions);
        };
        EmbeddedCodeEditorWidget.prototype.updateOptions = function (newOptions) {
            objects.mixin(this._overwriteOptions, newOptions, true);
            _super.prototype.updateOptions.call(this, this._overwriteOptions);
        };
        return EmbeddedCodeEditorWidget;
    }(codeEditor_1.CodeEditor));
    EmbeddedCodeEditorWidget = __decorate([
        __param(3, instantiation_1.IInstantiationService),
        __param(4, codeEditorService_1.ICodeEditorService),
        __param(5, commands_1.ICommandService),
        __param(6, contextkey_1.IContextKeyService)
    ], EmbeddedCodeEditorWidget);
    exports.EmbeddedCodeEditorWidget = EmbeddedCodeEditorWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[90/*vs/editor/contrib/zoneWidget/browser/peekViewWidget*/], __M([1/*require*/,0/*exports*/,314/*vs/nls!vs/editor/contrib/zoneWidget/browser/peekViewWidget*/,50/*vs/base/common/actions*/,9/*vs/base/common/strings*/,33/*vs/base/browser/builder*/,12/*vs/base/common/event*/,11/*vs/base/browser/dom*/,69/*vs/base/browser/ui/actionbar/actionbar*/,14/*vs/platform/instantiation/common/instantiation*/,45/*vs/editor/common/services/codeEditorService*/,160/*vs/editor/contrib/zoneWidget/browser/zoneWidget*/,170/*vs/editor/browser/widget/embeddedCodeEditorWidget*/,18/*vs/platform/contextkey/common/contextkey*/,417/*vs/css!vs/editor/contrib/zoneWidget/browser/peekViewWidget*/]), function (require, exports, nls, actions_1, strings, builder_1, event_1, dom, actionbar_1, instantiation_1, codeEditorService_1, zoneWidget_1, embeddedCodeEditorWidget_1, contextkey_1) {
    'use strict';
    exports.IPeekViewService = instantiation_1.createDecorator('peekViewService');
    var PeekContext;
    (function (PeekContext) {
        PeekContext.inPeekEditor = new contextkey_1.RawContextKey('inReferenceSearchEditor', true);
        PeekContext.notInPeekEditor = PeekContext.inPeekEditor.toNegated();
    })(PeekContext = exports.PeekContext || (exports.PeekContext = {}));
    exports.NOT_INNER_EDITOR_CONTEXT_KEY = new contextkey_1.RawContextKey('inReferenceSearchEditor', true);
    function getOuterEditor(accessor, args) {
        var editor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (editor instanceof embeddedCodeEditorWidget_1.EmbeddedCodeEditorWidget) {
            return editor.getParentEditor();
        }
        return editor;
    }
    exports.getOuterEditor = getOuterEditor;
    var PeekViewWidget = (function (_super) {
        __extends(PeekViewWidget, _super);
        function PeekViewWidget(editor, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this, editor, options) || this;
            _this._onDidClose = new event_1.Emitter();
            _this._isActive = false;
            return _this;
        }
        PeekViewWidget.prototype.dispose = function () {
            this._isActive = false;
            _super.prototype.dispose.call(this);
            this._onDidClose.fire(this);
        };
        Object.defineProperty(PeekViewWidget.prototype, "onDidClose", {
            get: function () {
                return this._onDidClose.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PeekViewWidget.prototype, "isActive", {
            get: function () {
                return this._isActive;
            },
            enumerable: true,
            configurable: true
        });
        PeekViewWidget.prototype.show = function (where, heightInLines) {
            this._isActive = true;
            this._headElement.style.borderTopColor = this.options.frameColor;
            this._bodyElement.style.borderTopColor = this.options.frameColor;
            this._bodyElement.style.borderBottomColor = this.options.frameColor;
            _super.prototype.show.call(this, where, heightInLines);
        };
        PeekViewWidget.prototype._fillContainer = function (container) {
            builder_1.$(container).addClass('peekview-widget');
            this._headElement = builder_1.$('.head').getHTMLElement();
            this._bodyElement = builder_1.$('.body').getHTMLElement();
            this._fillHead(this._headElement);
            this._fillBody(this._bodyElement);
            container.appendChild(this._headElement);
            container.appendChild(this._bodyElement);
        };
        PeekViewWidget.prototype._fillHead = function (container) {
            var _this = this;
            var titleElement = builder_1.$('.peekview-title').
                on(dom.EventType.CLICK, function (e) { return _this._onTitleClick(e); }).
                appendTo(this._headElement).
                getHTMLElement();
            this._primaryHeading = builder_1.$('span.filename').appendTo(titleElement).getHTMLElement();
            this._secondaryHeading = builder_1.$('span.dirname').appendTo(titleElement).getHTMLElement();
            this._metaHeading = builder_1.$('span.meta').appendTo(titleElement).getHTMLElement();
            this._actionbarWidget = new actionbar_1.ActionBar(builder_1.$('.peekview-actions').
                appendTo(this._headElement));
            this._actionbarWidget.push(new actions_1.Action('peekview.close', nls.localize(0, null), 'close-peekview-action', true, function () {
                _this.dispose();
                return null;
            }), { label: false, icon: true });
        };
        PeekViewWidget.prototype._onTitleClick = function (event) {
            // implement me
        };
        PeekViewWidget.prototype.setTitle = function (primaryHeading, secondaryHeading) {
            builder_1.$(this._primaryHeading).safeInnerHtml(primaryHeading);
            if (secondaryHeading) {
                builder_1.$(this._secondaryHeading).safeInnerHtml(secondaryHeading);
            }
            else {
                dom.clearNode(this._secondaryHeading);
            }
        };
        PeekViewWidget.prototype.setMetaTitle = function (value) {
            if (value) {
                builder_1.$(this._metaHeading).safeInnerHtml(value);
            }
            else {
                dom.clearNode(this._metaHeading);
            }
        };
        PeekViewWidget.prototype._fillBody = function (container) {
            // implement me
        };
        PeekViewWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
            if (heightInPixel < 0) {
                // Looks like the view zone got folded away!
                this.dispose();
                this._onDidClose.fire(this);
                return;
            }
            var headHeight = Math.ceil(this.editor.getConfiguration().lineHeight * 1.2), bodyHeight = heightInPixel - (headHeight + 2 /* the border-top/bottom width*/);
            this._doLayoutHead(headHeight, widthInPixel);
            this._doLayoutBody(bodyHeight, widthInPixel);
        };
        PeekViewWidget.prototype._doLayoutHead = function (heightInPixel, widthInPixel) {
            this._headElement.style.height = strings.format('{0}px', heightInPixel);
            this._headElement.style.lineHeight = this._headElement.style.height;
        };
        PeekViewWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
            this._bodyElement.style.height = strings.format('{0}px', heightInPixel);
        };
        return PeekViewWidget;
    }(zoneWidget_1.ZoneWidget));
    exports.PeekViewWidget = PeekViewWidget;
});

define(__m[97/*vs/platform/workspace/common/workspace*/], __M([1/*require*/,0/*exports*/,27/*vs/base/common/uri*/,14/*vs/platform/instantiation/common/instantiation*/,39/*vs/base/common/paths*/]), function (require, exports, uri_1, instantiation_1, paths) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
    var WorkspaceContextService = (function () {
        function WorkspaceContextService(workspace) {
            this.workspace = workspace;
        }
        WorkspaceContextService.prototype.getWorkspace = function () {
            return this.workspace;
        };
        WorkspaceContextService.prototype.hasWorkspace = function () {
            return !!this.workspace;
        };
        WorkspaceContextService.prototype.isInsideWorkspace = function (resource) {
            if (resource && this.workspace) {
                return paths.isEqualOrParent(resource.fsPath, this.workspace.resource.fsPath);
            }
            return false;
        };
        WorkspaceContextService.prototype.toWorkspaceRelativePath = function (resource) {
            if (this.isInsideWorkspace(resource)) {
                return paths.normalize(paths.relative(this.workspace.resource.fsPath, resource.fsPath));
            }
            return null;
        };
        WorkspaceContextService.prototype.toResource = function (workspaceRelativePath) {
            if (typeof workspaceRelativePath === 'string' && this.workspace) {
                return uri_1.default.file(paths.join(this.workspace.resource.fsPath, workspaceRelativePath));
            }
            return null;
        };
        return WorkspaceContextService;
    }());
    exports.WorkspaceContextService = WorkspaceContextService;
});






define(__m[173/*vs/editor/browser/standalone/standaloneServices*/], __M([1/*require*/,0/*exports*/,3/*vs/base/common/lifecycle*/,27/*vs/base/common/uri*/,56/*vs/platform/configuration/common/configuration*/,320/*vs/platform/contextview/browser/contextMenuService*/,58/*vs/platform/contextview/browser/contextView*/,489/*vs/platform/contextview/browser/contextViewService*/,14/*vs/platform/instantiation/common/instantiation*/,405/*vs/platform/instantiation/common/instantiationService*/,79/*vs/platform/instantiation/common/serviceCollection*/,22/*vs/platform/commands/common/commands*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,410/*vs/platform/markers/common/markerService*/,72/*vs/platform/markers/common/markers*/,49/*vs/platform/message/common/message*/,158/*vs/platform/progress/common/progress*/,159/*vs/platform/storage/common/storage*/,53/*vs/platform/telemetry/common/telemetry*/,97/*vs/platform/workspace/common/workspace*/,45/*vs/editor/common/services/codeEditorService*/,52/*vs/editor/common/services/editorWorkerService*/,128/*vs/editor/common/services/editorWorkerServiceImpl*/,89/*vs/editor/common/services/modeService*/,426/*vs/editor/common/services/modeServiceImpl*/,43/*vs/editor/common/services/modelService*/,421/*vs/editor/common/services/modelServiceImpl*/,336/*vs/editor/browser/services/codeEditorServiceImpl*/,115/*vs/editor/browser/standalone/simpleServices*/,409/*vs/platform/contextkey/browser/contextKeyService*/,59/*vs/platform/actions/common/actions*/,78/*vs/editor/common/services/standaloneColorService*/,199/*vs/editor/browser/services/standaloneColorServiceImpl*/]), function (require, exports, lifecycle_1, uri_1, configuration_1, contextMenuService_1, contextView_1, contextViewService_1, instantiation_1, instantiationService_1, serviceCollection_1, commands_1, keybinding_1, contextkey_1, markerService_1, markers_1, message_1, progress_1, storage_1, telemetry_1, workspace_1, codeEditorService_1, editorWorkerService_1, editorWorkerServiceImpl_1, modeService_1, modeServiceImpl_1, modelService_1, modelServiceImpl_1, codeEditorServiceImpl_1, simpleServices_1, contextKeyService_1, actions_1, standaloneColorService_1, standaloneColorServiceImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var StaticServices;
    (function (StaticServices) {
        var _serviceCollection = new serviceCollection_1.ServiceCollection();
        var LazyStaticService = (function () {
            function LazyStaticService(serviceId, factory) {
                this._serviceId = serviceId;
                this._factory = factory;
                this._value = null;
            }
            Object.defineProperty(LazyStaticService.prototype, "id", {
                get: function () { return this._serviceId; },
                enumerable: true,
                configurable: true
            });
            LazyStaticService.prototype.get = function (overrides) {
                if (!this._value) {
                    if (overrides) {
                        this._value = overrides[this._serviceId.toString()];
                    }
                    if (!this._value) {
                        this._value = this._factory(overrides);
                    }
                    if (!this._value) {
                        throw new Error('Service ' + this._serviceId + ' is missing!');
                    }
                    _serviceCollection.set(this._serviceId, this._value);
                }
                return this._value;
            };
            return LazyStaticService;
        }());
        StaticServices.LazyStaticService = LazyStaticService;
        var _all = [];
        function define(serviceId, factory) {
            var r = new LazyStaticService(serviceId, factory);
            _all.push(r);
            return r;
        }
        function init(overrides) {
            // Create a fresh service collection
            var result = new serviceCollection_1.ServiceCollection();
            // Initialize the service collection with the overrides
            for (var serviceId in overrides) {
                if (overrides.hasOwnProperty(serviceId)) {
                    result.set(instantiation_1.createDecorator(serviceId), overrides[serviceId]);
                }
            }
            // Make sure the same static services are present in all service collections
            _all.forEach(function (service) { return result.set(service.id, service.get(overrides)); });
            // Ensure the collection gets the correct instantiation service
            var instantiationService = new instantiationService_1.InstantiationService(result, true);
            result.set(instantiation_1.IInstantiationService, instantiationService);
            return [result, instantiationService];
        }
        StaticServices.init = init;
        StaticServices.instantiationService = define(instantiation_1.IInstantiationService, function () { return new instantiationService_1.InstantiationService(_serviceCollection, true); });
        StaticServices.contextService = define(workspace_1.IWorkspaceContextService, function () { return new workspace_1.WorkspaceContextService({
            resource: uri_1.default.from({ scheme: 'inmemory', authority: 'model', path: '/' })
        }); });
        StaticServices.telemetryService = define(telemetry_1.ITelemetryService, function () { return new simpleServices_1.StandaloneTelemetryService(); });
        StaticServices.configurationService = define(configuration_1.IConfigurationService, function () { return new simpleServices_1.SimpleConfigurationService(); });
        StaticServices.messageService = define(message_1.IMessageService, function () { return new simpleServices_1.SimpleMessageService(); });
        StaticServices.markerService = define(markers_1.IMarkerService, function () { return new markerService_1.MarkerService(); });
        StaticServices.modeService = define(modeService_1.IModeService, function (o) { return new modeServiceImpl_1.ModeServiceImpl(); });
        StaticServices.modelService = define(modelService_1.IModelService, function (o) { return new modelServiceImpl_1.ModelServiceImpl(StaticServices.markerService.get(o), StaticServices.configurationService.get(o)); });
        StaticServices.editorWorkerService = define(editorWorkerService_1.IEditorWorkerService, function (o) { return new editorWorkerServiceImpl_1.EditorWorkerServiceImpl(StaticServices.modelService.get(o), StaticServices.configurationService.get(o)); });
        StaticServices.codeEditorService = define(codeEditorService_1.ICodeEditorService, function () { return new codeEditorServiceImpl_1.CodeEditorServiceImpl(); });
        StaticServices.progressService = define(progress_1.IProgressService, function () { return new simpleServices_1.SimpleProgressService(); });
        StaticServices.storageService = define(storage_1.IStorageService, function () { return storage_1.NullStorageService; });
        StaticServices.standaloneColorService = define(standaloneColorService_1.IStandaloneColorService, function () { return new standaloneColorServiceImpl_1.StandaloneColorServiceImpl(); });
    })(StaticServices = exports.StaticServices || (exports.StaticServices = {}));
    var DynamicStandaloneServices = (function (_super) {
        __extends(DynamicStandaloneServices, _super);
        function DynamicStandaloneServices(domElement, overrides) {
            var _this = _super.call(this) || this;
            var _a = StaticServices.init(overrides), _serviceCollection = _a[0], _instantiationService = _a[1];
            _this._serviceCollection = _serviceCollection;
            _this._instantiationService = _instantiationService;
            var configurationService = _this.get(configuration_1.IConfigurationService);
            var messageService = _this.get(message_1.IMessageService);
            var telemetryService = _this.get(telemetry_1.ITelemetryService);
            var ensure = function (serviceId, factory) {
                var value = null;
                if (overrides) {
                    value = overrides[serviceId.toString()];
                }
                if (!value) {
                    value = factory();
                }
                _this._serviceCollection.set(serviceId, value);
                return value;
            };
            var contextKeyService = ensure(contextkey_1.IContextKeyService, function () { return _this._register(new contextKeyService_1.ContextKeyService(configurationService)); });
            var commandService = ensure(commands_1.ICommandService, function () { return new simpleServices_1.StandaloneCommandService(_this._instantiationService); });
            ensure(keybinding_1.IKeybindingService, function () { return _this._register(new simpleServices_1.StandaloneKeybindingService(contextKeyService, commandService, messageService, domElement)); });
            var contextViewService = ensure(contextView_1.IContextViewService, function () { return _this._register(new contextViewService_1.ContextViewService(domElement, telemetryService, messageService)); });
            ensure(contextView_1.IContextMenuService, function () { return _this._register(new contextMenuService_1.ContextMenuService(domElement, telemetryService, messageService, contextViewService)); });
            ensure(actions_1.IMenuService, function () { return new simpleServices_1.SimpleMenuService(commandService); });
            return _this;
        }
        DynamicStandaloneServices.prototype.get = function (serviceId) {
            var r = this._serviceCollection.get(serviceId);
            if (!r) {
                throw new Error('Missing service ' + serviceId);
            }
            return r;
        };
        DynamicStandaloneServices.prototype.set = function (serviceId, instance) {
            this._serviceCollection.set(serviceId, instance);
        };
        DynamicStandaloneServices.prototype.has = function (serviceId) {
            return this._serviceCollection.has(serviceId);
        };
        return DynamicStandaloneServices;
    }(lifecycle_1.Disposable));
    exports.DynamicStandaloneServices = DynamicStandaloneServices;
});

define(__m[501/*vs/editor/browser/standalone/standaloneEditor*/], __M([1/*require*/,0/*exports*/,2/*vs/editor/common/editorCommon*/,21/*vs/editor/browser/editorBrowser*/,496/*vs/editor/browser/standalone/standaloneCodeEditor*/,38/*vs/base/common/scrollable*/,173/*vs/editor/browser/standalone/standaloneServices*/,413/*vs/platform/opener/browser/openerService*/,71/*vs/platform/opener/common/opener*/,144/*vs/editor/browser/standalone/colorizer*/,115/*vs/editor/browser/standalone/simpleServices*/,15/*vs/editor/common/modes*/,361/*vs/editor/common/services/webWorker*/,122/*vs/editor/contrib/diffNavigator/common/diffNavigator*/,57/*vs/platform/editor/common/editor*/,22/*vs/platform/commands/common/commands*/,58/*vs/platform/contextview/browser/contextView*/,14/*vs/platform/instantiation/common/instantiation*/,42/*vs/platform/keybinding/common/keybinding*/,18/*vs/platform/contextkey/common/contextkey*/,45/*vs/editor/common/services/codeEditorService*/,52/*vs/editor/common/services/editorWorkerService*/,66/*vs/editor/common/services/resolverService*/,64/*vs/editor/common/modes/nullMode*/,78/*vs/editor/common/services/standaloneColorService*/,107/*vs/editor/common/config/fontInfo*/,323/*vs/css!vs/editor/browser/standalone/media/standalone-tokens*/]), function (require, exports, editorCommon, editorBrowser_1, standaloneCodeEditor_1, scrollable_1, standaloneServices_1, openerService_1, opener_1, colorizer_1, simpleServices_1, modes, webWorker_1, diffNavigator_1, editor_1, commands_1, contextView_1, instantiation_1, keybinding_1, contextkey_1, codeEditorService_1, editorWorkerService_1, resolverService_1, nullMode_1, standaloneColorService_1, fontInfo_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * @internal
     */
    function setupServices(overrides) {
        return standaloneServices_1.StaticServices.init(overrides);
    }
    exports.setupServices = setupServices;
    function withAllStandaloneServices(domElement, override, callback) {
        var services = new standaloneServices_1.DynamicStandaloneServices(domElement, override);
        // The editorService is a lovely beast. It needs to point back to the code editor instance...
        var simpleEditorService = null;
        if (!services.has(editor_1.IEditorService)) {
            simpleEditorService = new simpleServices_1.SimpleEditorService();
            services.set(editor_1.IEditorService, simpleEditorService);
        }
        var simpleEditorModelResolverService = null;
        if (!services.has(resolverService_1.ITextModelResolverService)) {
            simpleEditorModelResolverService = new simpleServices_1.SimpleEditorModelResolverService();
            services.set(resolverService_1.ITextModelResolverService, simpleEditorModelResolverService);
        }
        if (!services.has(opener_1.IOpenerService)) {
            services.set(opener_1.IOpenerService, new openerService_1.OpenerService(services.get(editor_1.IEditorService), services.get(commands_1.ICommandService)));
        }
        var result = callback(services);
        if (simpleEditorService) {
            simpleEditorService.setEditor(result);
        }
        if (simpleEditorModelResolverService) {
            simpleEditorModelResolverService.setEditor(result);
        }
        return result;
    }
    /**
     * Create a new editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function create(domElement, options, override) {
        return withAllStandaloneServices(domElement, override, function (services) {
            return new standaloneCodeEditor_1.StandaloneEditor(domElement, options, services, services.get(instantiation_1.IInstantiationService), services.get(codeEditorService_1.ICodeEditorService), services.get(commands_1.ICommandService), services.get(contextkey_1.IContextKeyService), services.get(keybinding_1.IKeybindingService), services.get(contextView_1.IContextViewService), services.get(standaloneColorService_1.IStandaloneColorService));
        });
    }
    exports.create = create;
    /**
     * Emitted when an editor is created.
     * Creating a diff editor might cause this listener to be invoked with the two editors.
     * @event
     */
    function onDidCreateEditor(listener) {
        return standaloneServices_1.StaticServices.codeEditorService.get().onCodeEditorAdd(function (editor) {
            listener(editor);
        });
    }
    exports.onDidCreateEditor = onDidCreateEditor;
    /**
     * Create a new diff editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function createDiffEditor(domElement, options, override) {
        return withAllStandaloneServices(domElement, override, function (services) {
            return new standaloneCodeEditor_1.StandaloneDiffEditor(domElement, options, services, services.get(instantiation_1.IInstantiationService), services.get(contextkey_1.IContextKeyService), services.get(keybinding_1.IKeybindingService), services.get(contextView_1.IContextViewService), services.get(editorWorkerService_1.IEditorWorkerService));
        });
    }
    exports.createDiffEditor = createDiffEditor;
    function createDiffNavigator(diffEditor, opts) {
        return new diffNavigator_1.DiffNavigator(diffEditor, opts);
    }
    exports.createDiffNavigator = createDiffNavigator;
    function doCreateModel(value, mode, uri) {
        return standaloneServices_1.StaticServices.modelService.get().createModel(value, mode, uri);
    }
    /**
     * Create a new editor model.
     * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
     */
    function createModel(value, language, uri) {
        value = value || '';
        if (!language) {
            var path = uri ? uri.path : null;
            var firstLF = value.indexOf('\n');
            var firstLine = value;
            if (firstLF !== -1) {
                firstLine = value.substring(0, firstLF);
            }
            return doCreateModel(value, standaloneServices_1.StaticServices.modeService.get().getOrCreateModeByFilenameOrFirstLine(path, firstLine), uri);
        }
        return doCreateModel(value, standaloneServices_1.StaticServices.modeService.get().getOrCreateMode(language), uri);
    }
    exports.createModel = createModel;
    /**
     * Change the language for a model.
     */
    function setModelLanguage(model, language) {
        standaloneServices_1.StaticServices.modelService.get().setMode(model, standaloneServices_1.StaticServices.modeService.get().getOrCreateMode(language));
    }
    exports.setModelLanguage = setModelLanguage;
    /**
     * Set the markers for a model.
     */
    function setModelMarkers(model, owner, markers) {
        if (model) {
            standaloneServices_1.StaticServices.markerService.get().changeOne(owner, model.uri, markers);
        }
    }
    exports.setModelMarkers = setModelMarkers;
    /**
     * Get the model that has `uri` if it exists.
     */
    function getModel(uri) {
        return standaloneServices_1.StaticServices.modelService.get().getModel(uri);
    }
    exports.getModel = getModel;
    /**
     * Get all the created models.
     */
    function getModels() {
        return standaloneServices_1.StaticServices.modelService.get().getModels();
    }
    exports.getModels = getModels;
    /**
     * Emitted when a model is created.
     * @event
     */
    function onDidCreateModel(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelAdded(listener);
    }
    exports.onDidCreateModel = onDidCreateModel;
    /**
     * Emitted right before a model is disposed.
     * @event
     */
    function onWillDisposeModel(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelRemoved(listener);
    }
    exports.onWillDisposeModel = onWillDisposeModel;
    /**
     * Emitted when a different language is set to a model.
     * @event
     */
    function onDidChangeModelLanguage(listener) {
        return standaloneServices_1.StaticServices.modelService.get().onModelModeChanged(function (e) {
            listener({
                model: e.model,
                oldLanguage: e.oldModeId
            });
        });
    }
    exports.onDidChangeModelLanguage = onDidChangeModelLanguage;
    /**
     * Create a new web worker that has model syncing capabilities built in.
     * Specify an AMD module to load that will `create` an object that will be proxied.
     */
    function createWebWorker(opts) {
        return webWorker_1.createWebWorker(standaloneServices_1.StaticServices.modelService.get(), opts);
    }
    exports.createWebWorker = createWebWorker;
    /**
     * Colorize the contents of `domNode` using attribute `data-lang`.
     */
    function colorizeElement(domNode, options) {
        return colorizer_1.Colorizer.colorizeElement(standaloneServices_1.StaticServices.standaloneColorService.get(), standaloneServices_1.StaticServices.modeService.get(), domNode, options);
    }
    exports.colorizeElement = colorizeElement;
    /**
     * Colorize `text` using language `languageId`.
     */
    function colorize(text, languageId, options) {
        return colorizer_1.Colorizer.colorize(standaloneServices_1.StaticServices.modeService.get(), text, languageId, options);
    }
    exports.colorize = colorize;
    /**
     * Colorize a line in a model.
     */
    function colorizeModelLine(model, lineNumber, tabSize) {
        if (tabSize === void 0) { tabSize = 4; }
        return colorizer_1.Colorizer.colorizeModelLine(model, lineNumber, tabSize);
    }
    exports.colorizeModelLine = colorizeModelLine;
    /**
     * @internal
     */
    function getSafeTokenizationSupport(languageId) {
        var tokenizationSupport = modes.TokenizationRegistry.get(languageId);
        if (tokenizationSupport) {
            return tokenizationSupport;
        }
        return {
            getInitialState: function () { return nullMode_1.NULL_STATE; },
            tokenize: function (line, state, deltaOffset) { return nullMode_1.nullTokenize(languageId, line, state, deltaOffset); },
            tokenize2: undefined,
        };
    }
    /**
     * Tokenize `text` using language `languageId`
     */
    function tokenize(text, languageId) {
        var modeService = standaloneServices_1.StaticServices.modeService.get();
        // Needed in order to get the mode registered for subsequent look-ups
        modeService.getOrCreateMode(languageId);
        var tokenizationSupport = getSafeTokenizationSupport(languageId);
        var lines = text.split(/\r\n|\r|\n/);
        var result = [];
        var state = tokenizationSupport.getInitialState();
        for (var i = 0, len = lines.length; i < len; i++) {
            var line = lines[i];
            var tokenizationResult = tokenizationSupport.tokenize(line, state, 0);
            result[i] = tokenizationResult.tokens;
            state = tokenizationResult.endState;
        }
        return result;
    }
    exports.tokenize = tokenize;
    /**
     * Define a new theme.
     */
    function defineTheme(themeName, themeData) {
        standaloneServices_1.StaticServices.standaloneColorService.get().defineTheme(themeName, themeData);
    }
    exports.defineTheme = defineTheme;
    /**
     * @internal
     */
    function createMonacoEditorAPI() {
        return {
            // methods
            create: create,
            onDidCreateEditor: onDidCreateEditor,
            createDiffEditor: createDiffEditor,
            createDiffNavigator: createDiffNavigator,
            createModel: createModel,
            setModelLanguage: setModelLanguage,
            setModelMarkers: setModelMarkers,
            getModels: getModels,
            getModel: getModel,
            onDidCreateModel: onDidCreateModel,
            onWillDisposeModel: onWillDisposeModel,
            onDidChangeModelLanguage: onDidChangeModelLanguage,
            createWebWorker: createWebWorker,
            colorizeElement: colorizeElement,
            colorize: colorize,
            colorizeModelLine: colorizeModelLine,
            tokenize: tokenize,
            defineTheme: defineTheme,
            // enums
            ScrollbarVisibility: scrollable_1.ScrollbarVisibility,
            WrappingIndent: editorCommon.WrappingIndent,
            OverviewRulerLane: editorCommon.OverviewRulerLane,
            EndOfLinePreference: editorCommon.EndOfLinePreference,
            DefaultEndOfLine: editorCommon.DefaultEndOfLine,
            EndOfLineSequence: editorCommon.EndOfLineSequence,
            TrackedRangeStickiness: editorCommon.TrackedRangeStickiness,
            CursorChangeReason: editorCommon.CursorChangeReason,
            MouseTargetType: editorCommon.MouseTargetType,
            TextEditorCursorStyle: editorCommon.TextEditorCursorStyle,
            TextEditorCursorBlinkingStyle: editorCommon.TextEditorCursorBlinkingStyle,
            ContentWidgetPositionPreference: editorBrowser_1.ContentWidgetPositionPreference,
            OverlayWidgetPositionPreference: editorBrowser_1.OverlayWidgetPositionPreference,
            // classes
            InternalEditorScrollbarOptions: editorCommon.InternalEditorScrollbarOptions,
            EditorWrappingInfo: editorCommon.EditorWrappingInfo,
            InternalEditorViewOptions: editorCommon.InternalEditorViewOptions,
            EditorContribOptions: editorCommon.EditorContribOptions,
            InternalEditorOptions: editorCommon.InternalEditorOptions,
            OverviewRulerPosition: editorCommon.OverviewRulerPosition,
            EditorLayoutInfo: editorCommon.EditorLayoutInfo,
            BareFontInfo: fontInfo_1.BareFontInfo,
            FontInfo: fontInfo_1.FontInfo,
            TextModelResolvedOptions: editorCommon.TextModelResolvedOptions,
            FindMatch: editorCommon.FindMatch,
            // vars
            EditorType: editorCommon.EditorType,
            CursorMoveByUnit: editorCommon.CursorMoveByUnit,
            CursorMovePosition: editorCommon.CursorMovePosition,
            EditorScrollDirection: editorCommon.EditorScrollDirection,
            EditorScrollByUnit: editorCommon.EditorScrollByUnit,
            RevealLineAtArgument: editorCommon.RevealLineAtArgument,
            Handler: editorCommon.Handler,
        };
    }
    exports.createMonacoEditorAPI = createMonacoEditorAPI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[502/*vs/editor/browser/standalone/standaloneLanguages*/], __M([1/*require*/,0/*exports*/,6/*vs/base/common/winjs.base*/,111/*vs/editor/common/modes/modesRegistry*/,173/*vs/editor/browser/standalone/standaloneServices*/,15/*vs/editor/common/modes*/,54/*vs/editor/common/modes/languageConfiguration*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,17/*vs/base/common/async*/,184/*vs/editor/common/modes/monarch/monarchCompile*/,186/*vs/editor/common/modes/monarch/monarchLexer*/,37/*vs/editor/common/modes/languageConfigurationRegistry*/,82/*vs/editor/common/core/token*/]), function (require, exports, winjs_base_1, modesRegistry_1, standaloneServices_1, modes, languageConfiguration_1, position_1, range_1, async_1, monarchCompile_1, monarchLexer_1, languageConfigurationRegistry_1, token_1) {
    'use strict';
    /**
     * Register information about a new language.
     */
    function register(language) {
        modesRegistry_1.ModesRegistry.registerLanguage(language);
    }
    exports.register = register;
    /**
     * Get the information of all the registered languages.
     */
    function getLanguages() {
        var result = [];
        result = result.concat(modesRegistry_1.ModesRegistry.getLanguages());
        return result;
    }
    exports.getLanguages = getLanguages;
    /**
     * An event emitted when a language is first time needed (e.g. a model has it set).
     * @event
     */
    function onLanguage(languageId, callback) {
        var disposable = standaloneServices_1.StaticServices.modeService.get().onDidCreateMode(function (mode) {
            if (mode.getId() === languageId) {
                // stop listening
                disposable.dispose();
                // invoke actual listener
                callback();
            }
        });
        return disposable;
    }
    exports.onLanguage = onLanguage;
    /**
     * Set the editing configuration for a language.
     */
    function setLanguageConfiguration(languageId, configuration) {
        var languageIdentifier = standaloneServices_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
        if (!languageIdentifier) {
            throw new Error("Cannot set configuration for unknown language " + languageId);
        }
        return languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(languageIdentifier, configuration);
    }
    exports.setLanguageConfiguration = setLanguageConfiguration;
    /**
     * @internal
     */
    var TokenizationSupport2Adapter = (function () {
        function TokenizationSupport2Adapter(standaloneColorService, languageIdentifier, actual) {
            this._standaloneColorService = standaloneColorService;
            this._languageIdentifier = languageIdentifier;
            this._actual = actual;
        }
        TokenizationSupport2Adapter.prototype.getInitialState = function () {
            return this._actual.getInitialState();
        };
        TokenizationSupport2Adapter.prototype._toClassicTokens = function (tokens, language, offsetDelta) {
            var result = [];
            for (var i = 0, len = tokens.length; i < len; i++) {
                var t = tokens[i];
                result[i] = new token_1.Token(t.startIndex + offsetDelta, t.scopes, language);
            }
            return result;
        };
        TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {
            var actualResult = this._actual.tokenize(line, state);
            var tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);
            var endState;
            // try to save an object if possible
            if (actualResult.endState.equals(state)) {
                endState = state;
            }
            else {
                endState = actualResult.endState;
            }
            return new token_1.TokenizationResult(tokens, endState);
        };
        TokenizationSupport2Adapter.prototype._toBinaryTokens = function (tokens, offsetDelta) {
            var languageId = this._languageIdentifier.id;
            var theme = this._standaloneColorService.getTheme();
            var result = [], resultLen = 0;
            for (var i = 0, len = tokens.length; i < len; i++) {
                var t = tokens[i];
                var metadata = theme.match(languageId, t.scopes);
                if (resultLen > 0 && result[resultLen - 1] === metadata) {
                    // same metadata
                    continue;
                }
                result[resultLen++] = t.startIndex;
                result[resultLen++] = metadata;
            }
            var actualResult = new Uint32Array(resultLen);
            for (var i = 0; i < resultLen; i++) {
                actualResult[i] = result[i];
            }
            return actualResult;
        };
        TokenizationSupport2Adapter.prototype.tokenize2 = function (line, state, offsetDelta) {
            var actualResult = this._actual.tokenize(line, state);
            var tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
            var endState;
            // try to save an object if possible
            if (actualResult.endState.equals(state)) {
                endState = state;
            }
            else {
                endState = actualResult.endState;
            }
            return new token_1.TokenizationResult2(tokens, endState);
        };
        return TokenizationSupport2Adapter;
    }());
    exports.TokenizationSupport2Adapter = TokenizationSupport2Adapter;
    /**
     * Set the tokens provider for a language (manual implementation).
     */
    function setTokensProvider(languageId, provider) {
        var languageIdentifier = standaloneServices_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
        if (!languageIdentifier) {
            throw new Error("Cannot set tokens provider for unknown language " + languageId);
        }
        var adapter = new TokenizationSupport2Adapter(standaloneServices_1.StaticServices.standaloneColorService.get(), languageIdentifier, provider);
        return modes.TokenizationRegistry.register(languageId, adapter);
    }
    exports.setTokensProvider = setTokensProvider;
    /**
     * Set the tokens provider for a language (monarch implementation).
     */
    function setMonarchTokensProvider(languageId, languageDef) {
        var lexer = monarchCompile_1.compile(languageId, languageDef);
        var adapter = monarchLexer_1.createTokenizationSupport(standaloneServices_1.StaticServices.modeService.get(), standaloneServices_1.StaticServices.standaloneColorService.get(), languageId, lexer);
        return modes.TokenizationRegistry.register(languageId, adapter);
    }
    exports.setMonarchTokensProvider = setMonarchTokensProvider;
    /**
     * Register a reference provider (used by e.g. reference search).
     */
    function registerReferenceProvider(languageId, provider) {
        return modes.ReferenceProviderRegistry.register(languageId, provider);
    }
    exports.registerReferenceProvider = registerReferenceProvider;
    /**
     * Register a rename provider (used by e.g. rename symbol).
     */
    function registerRenameProvider(languageId, provider) {
        return modes.RenameProviderRegistry.register(languageId, provider);
    }
    exports.registerRenameProvider = registerRenameProvider;
    /**
     * Register a signature help provider (used by e.g. paremeter hints).
     */
    function registerSignatureHelpProvider(languageId, provider) {
        return modes.SignatureHelpProviderRegistry.register(languageId, provider);
    }
    exports.registerSignatureHelpProvider = registerSignatureHelpProvider;
    /**
     * Register a hover provider (used by e.g. editor hover).
     */
    function registerHoverProvider(languageId, provider) {
        return modes.HoverProviderRegistry.register(languageId, {
            provideHover: function (model, position, token) {
                var word = model.getWordAtPosition(position);
                return async_1.toThenable(provider.provideHover(model, position, token)).then(function (value) {
                    if (!value) {
                        return;
                    }
                    if (!value.range && word) {
                        value.range = new range_1.Range(position.lineNumber, word.startColumn, position.column, word.endColumn);
                    }
                    if (!value.range) {
                        value.range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                    }
                    return value;
                });
            }
        });
    }
    exports.registerHoverProvider = registerHoverProvider;
    /**
     * Register a document symbol provider (used by e.g. outline).
     */
    function registerDocumentSymbolProvider(languageId, provider) {
        return modes.DocumentSymbolProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
    /**
     * Register a document highlight provider (used by e.g. highlight occurences).
     */
    function registerDocumentHighlightProvider(languageId, provider) {
        return modes.DocumentHighlightProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentHighlightProvider = registerDocumentHighlightProvider;
    /**
     * Register a definition provider (used by e.g. go to definition).
     */
    function registerDefinitionProvider(languageId, provider) {
        return modes.DefinitionProviderRegistry.register(languageId, provider);
    }
    exports.registerDefinitionProvider = registerDefinitionProvider;
    /**
     * Register a type definition provider (used by e.g. go to implementation).
     */
    function registerTypeDefinitionProvider(languageId, provider) {
        return modes.TypeDefinitionProviderRegistry.register(languageId, provider);
    }
    exports.registerTypeDefinitionProvider = registerTypeDefinitionProvider;
    /**
     * Register a code lens provider (used by e.g. inline code lenses).
     */
    function registerCodeLensProvider(languageId, provider) {
        return modes.CodeLensProviderRegistry.register(languageId, provider);
    }
    exports.registerCodeLensProvider = registerCodeLensProvider;
    /**
     * Register a code action provider (used by e.g. quick fix).
     */
    function registerCodeActionProvider(languageId, provider) {
        return modes.CodeActionProviderRegistry.register(languageId, {
            provideCodeActions: function (model, range, token) {
                var markers = standaloneServices_1.StaticServices.markerService.get().read({ resource: model.uri }).filter(function (m) {
                    return range_1.Range.areIntersectingOrTouching(m, range);
                });
                return provider.provideCodeActions(model, range, { markers: markers }, token);
            }
        });
    }
    exports.registerCodeActionProvider = registerCodeActionProvider;
    /**
     * Register a formatter that can handle only entire models.
     */
    function registerDocumentFormattingEditProvider(languageId, provider) {
        return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentFormattingEditProvider = registerDocumentFormattingEditProvider;
    /**
     * Register a formatter that can handle a range inside a model.
     */
    function registerDocumentRangeFormattingEditProvider(languageId, provider) {
        return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentRangeFormattingEditProvider = registerDocumentRangeFormattingEditProvider;
    /**
     * Register a formatter than can do formatting as the user types.
     */
    function registerOnTypeFormattingEditProvider(languageId, provider) {
        return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerOnTypeFormattingEditProvider = registerOnTypeFormattingEditProvider;
    /**
     * Register a link provider that can find links in text.
     */
    function registerLinkProvider(languageId, provider) {
        return modes.LinkProviderRegistry.register(languageId, provider);
    }
    exports.registerLinkProvider = registerLinkProvider;
    /**
     * Register a completion item provider (use by e.g. suggestions).
     */
    function registerCompletionItemProvider(languageId, provider) {
        var adapter = new SuggestAdapter(provider);
        return modes.SuggestRegistry.register(languageId, {
            triggerCharacters: provider.triggerCharacters,
            provideCompletionItems: function (model, position, token) {
                return adapter.provideCompletionItems(model, position, token);
            },
            resolveCompletionItem: function (model, position, suggestion, token) {
                return adapter.resolveCompletionItem(model, position, suggestion, token);
            }
        });
    }
    exports.registerCompletionItemProvider = registerCompletionItemProvider;
    /**
     * Completion item kinds.
     */
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
        CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
    })(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    function convertKind(kind) {
        switch (kind) {
            case CompletionItemKind.Method: return 'method';
            case CompletionItemKind.Function: return 'function';
            case CompletionItemKind.Constructor: return 'constructor';
            case CompletionItemKind.Field: return 'field';
            case CompletionItemKind.Variable: return 'variable';
            case CompletionItemKind.Class: return 'class';
            case CompletionItemKind.Interface: return 'interface';
            case CompletionItemKind.Module: return 'module';
            case CompletionItemKind.Property: return 'property';
            case CompletionItemKind.Unit: return 'unit';
            case CompletionItemKind.Value: return 'value';
            case CompletionItemKind.Enum: return 'enum';
            case CompletionItemKind.Keyword: return 'keyword';
            case CompletionItemKind.Snippet: return 'snippet';
            case CompletionItemKind.Text: return 'text';
            case CompletionItemKind.Color: return 'color';
            case CompletionItemKind.File: return 'file';
            case CompletionItemKind.Reference: return 'reference';
            case CompletionItemKind.Folder: return 'folder';
        }
        return 'property';
    }
    var SuggestAdapter = (function () {
        function SuggestAdapter(provider) {
            this._provider = provider;
        }
        SuggestAdapter.from = function (item) {
            return {
                _actual: item,
                label: item.label,
                insertText: item.insertText || item.label,
                type: convertKind(item.kind),
                detail: item.detail,
                documentation: item.documentation,
                sortText: item.sortText,
                filterText: item.filterText,
                snippetType: 'internal'
            };
        };
        SuggestAdapter.prototype.provideCompletionItems = function (model, position, token) {
            return async_1.toThenable(this._provider.provideCompletionItems(model, position, token)).then(function (value) {
                var result = {
                    suggestions: []
                };
                // default text edit start
                var wordStartPos = position;
                var word = model.getWordUntilPosition(position);
                if (word) {
                    wordStartPos = new position_1.Position(wordStartPos.lineNumber, word.startColumn);
                }
                var list;
                if (Array.isArray(value)) {
                    list = {
                        items: value,
                        isIncomplete: false
                    };
                }
                else if (typeof value === 'object' && Array.isArray(value.items)) {
                    list = value;
                    result.incomplete = list.isIncomplete;
                }
                else if (!value) {
                    // undefined and null are valid results
                    return;
                }
                else {
                    // warn about everything else
                    console.warn('INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:', value);
                }
                for (var i = 0; i < list.items.length; i++) {
                    var item = list.items[i];
                    var suggestion = SuggestAdapter.from(item);
                    if (item.textEdit) {
                        var editRange = item.textEdit.range;
                        var isSingleLine = (editRange.startLineNumber === editRange.endLineNumber);
                        // invalid text edit
                        if (!isSingleLine || editRange.startLineNumber !== position.lineNumber) {
                            console.warn('INVALID text edit, must be single line and on the same line');
                            continue;
                        }
                        // insert the text of the edit and create a dedicated
                        // suggestion-container with overwrite[Before|After]
                        suggestion.insertText = item.textEdit.text;
                        suggestion.overwriteBefore = position.column - editRange.startColumn;
                        suggestion.overwriteAfter = editRange.endColumn - position.column;
                    }
                    else {
                        suggestion.overwriteBefore = position.column - wordStartPos.column;
                        suggestion.overwriteAfter = 0;
                    }
                    result.suggestions.push(suggestion);
                }
                return result;
            });
        };
        SuggestAdapter.prototype.resolveCompletionItem = function (model, position, suggestion, token) {
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var item = suggestion._actual;
            if (!item) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            return async_1.toThenable(this._provider.resolveCompletionItem(item, token)).then(function (resolvedItem) {
                return SuggestAdapter.from(resolvedItem);
            });
        };
        return SuggestAdapter;
    }());
    /**
     * @internal
     */
    function createMonacoLanguagesAPI() {
        return {
            register: register,
            getLanguages: getLanguages,
            onLanguage: onLanguage,
            // provider methods
            setLanguageConfiguration: setLanguageConfiguration,
            setTokensProvider: setTokensProvider,
            setMonarchTokensProvider: setMonarchTokensProvider,
            registerReferenceProvider: registerReferenceProvider,
            registerRenameProvider: registerRenameProvider,
            registerCompletionItemProvider: registerCompletionItemProvider,
            registerSignatureHelpProvider: registerSignatureHelpProvider,
            registerHoverProvider: registerHoverProvider,
            registerDocumentSymbolProvider: registerDocumentSymbolProvider,
            registerDocumentHighlightProvider: registerDocumentHighlightProvider,
            registerDefinitionProvider: registerDefinitionProvider,
            registerTypeDefinitionProvider: registerTypeDefinitionProvider,
            registerCodeLensProvider: registerCodeLensProvider,
            registerCodeActionProvider: registerCodeActionProvider,
            registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,
            registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,
            registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,
            registerLinkProvider: registerLinkProvider,
            // enums
            DocumentHighlightKind: modes.DocumentHighlightKind,
            CompletionItemKind: CompletionItemKind,
            SymbolKind: modes.SymbolKind,
            IndentAction: languageConfiguration_1.IndentAction,
        };
    }
    exports.createMonacoLanguagesAPI = createMonacoLanguagesAPI;
});















define(__m[503/*vs/editor/contrib/referenceSearch/browser/referencesWidget*/], __M([1/*require*/,0/*exports*/,305/*vs/nls!vs/editor/contrib/referenceSearch/browser/referencesWidget*/,10/*vs/base/common/errors*/,156/*vs/base/common/labels*/,12/*vs/base/common/event*/,3/*vs/base/common/lifecycle*/,70/*vs/base/common/network*/,9/*vs/base/common/strings*/,6/*vs/base/common/winjs.base*/,33/*vs/base/browser/builder*/,11/*vs/base/browser/dom*/,98/*vs/base/browser/ui/sash/sash*/,216/*vs/base/browser/ui/countBadge/countBadge*/,172/*vs/base/browser/ui/iconLabel/iconLabel*/,240/*vs/base/browser/ui/leftRightWidget/leftRightWidget*/,87/*vs/base/parts/tree/browser/treeDefaults*/,139/*vs/base/parts/tree/browser/treeImpl*/,79/*vs/platform/instantiation/common/serviceCollection*/,97/*vs/platform/workspace/common/workspace*/,44/*vs/editor/common/config/defaultConfig*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,126/*vs/editor/common/model/model*/,170/*vs/editor/browser/widget/embeddedCodeEditorWidget*/,90/*vs/editor/contrib/zoneWidget/browser/peekViewWidget*/,92/*vs/editor/contrib/referenceSearch/browser/referencesModel*/,66/*vs/editor/common/services/resolverService*/,408/*vs/css!vs/editor/contrib/referenceSearch/browser/referencesWidget*/]), function (require, exports, nls, errors_1, labels_1, event_1, lifecycle_1, network_1, strings, winjs_base_1, builder_1, dom, sash_1, countBadge_1, iconLabel_1, leftRightWidget_1, treeDefaults_1, treeImpl_1, serviceCollection_1, workspace_1, defaultConfig_1, range_1, editorCommon, model_1, embeddedCodeEditorWidget_1, peekViewWidget_1, referencesModel_1, resolverService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DecorationsManager = (function () {
        function DecorationsManager(_editor, _model) {
            var _this = this;
            this._editor = _editor;
            this._model = _model;
            this._decorations = new Map();
            this._decorationIgnoreSet = new Set();
            this._callOnDispose = [];
            this._callOnModelChange = [];
            this._callOnDispose.push(this._editor.onDidChangeModel(function () { return _this._onModelChanged(); }));
            this._onModelChanged();
        }
        DecorationsManager.prototype.dispose = function () {
            this._callOnModelChange = lifecycle_1.dispose(this._callOnModelChange);
            this._callOnDispose = lifecycle_1.dispose(this._callOnDispose);
            this.removeDecorations();
        };
        DecorationsManager.prototype._onModelChanged = function () {
            this._callOnModelChange = lifecycle_1.dispose(this._callOnModelChange);
            var model = this._editor.getModel();
            if (model) {
                for (var _i = 0, _a = this._model.groups; _i < _a.length; _i++) {
                    var ref = _a[_i];
                    if (ref.uri.toString() === model.uri.toString()) {
                        this._addDecorations(ref);
                        return;
                    }
                }
            }
        };
        DecorationsManager.prototype._addDecorations = function (reference) {
            var _this = this;
            this._callOnModelChange.push(this._editor.getModel().onDidChangeDecorations(function (event) { return _this._onDecorationChanged(event); }));
            this._editor.changeDecorations(function (accessor) {
                var newDecorations = [];
                var newDecorationsActualIndex = [];
                for (var i = 0, len = reference.children.length; i < len; i++) {
                    var oneReference = reference.children[i];
                    if (_this._decorationIgnoreSet.has(oneReference.id)) {
                        continue;
                    }
                    newDecorations.push({
                        range: oneReference.range,
                        options: DecorationsManager.DecorationOptions
                    });
                    newDecorationsActualIndex.push(i);
                }
                var decorations = accessor.deltaDecorations([], newDecorations);
                for (var i = 0; i < decorations.length; i++) {
                    _this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
                }
            });
        };
        DecorationsManager.prototype._onDecorationChanged = function (event) {
            var _this = this;
            var changedDecorations = event.changedDecorations, toRemove = [];
            for (var i = 0, len = changedDecorations.length; i < len; i++) {
                var reference = this._decorations.get(changedDecorations[i]);
                if (!reference) {
                    continue;
                }
                var newRange = this._editor.getModel().getDecorationRange(changedDecorations[i]);
                var ignore = false;
                if (range_1.Range.equalsRange(newRange, reference.range)) {
                    continue;
                }
                else if (range_1.Range.spansMultipleLines(newRange)) {
                    ignore = true;
                }
                else {
                    var lineLength = reference.range.endColumn - reference.range.startColumn;
                    var newLineLength = newRange.endColumn - newRange.startColumn;
                    if (lineLength !== newLineLength) {
                        ignore = true;
                    }
                }
                if (ignore) {
                    this._decorationIgnoreSet.add(reference.id);
                    toRemove.push(changedDecorations[i]);
                }
                else {
                    reference.range = newRange;
                }
            }
            this._editor.changeDecorations(function (accessor) {
                for (var i = 0, len = toRemove.length; i < len; i++) {
                    delete _this._decorations[toRemove[i]];
                }
                accessor.deltaDecorations(toRemove, []);
            });
        };
        DecorationsManager.prototype.removeDecorations = function () {
            var _this = this;
            this._editor.changeDecorations(function (accessor) {
                _this._decorations.forEach(function (value, key) {
                    accessor.removeDecoration(key);
                });
                _this._decorations.clear();
            });
        };
        return DecorationsManager;
    }());
    DecorationsManager.DecorationOptions = {
        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
        className: 'reference-decoration'
    };
    var DataSource = (function () {
        function DataSource(_textModelResolverService) {
            this._textModelResolverService = _textModelResolverService;
            //
        }
        DataSource.prototype.getId = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return 'root';
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                return element.id;
            }
            else if (element instanceof referencesModel_1.OneReference) {
                return element.id;
            }
        };
        DataSource.prototype.hasChildren = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return true;
            }
            if (element instanceof referencesModel_1.FileReferences && !element.failure) {
                return true;
            }
        };
        DataSource.prototype.getChildren = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return winjs_base_1.TPromise.as(element.groups);
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                return element.resolve(this._textModelResolverService).then(function (val) {
                    if (element.failure) {
                        // refresh the element on failure so that
                        // we can update its rendering
                        return tree.refresh(element).then(function () { return val.children; });
                    }
                    return val.children;
                });
            }
            else {
                return winjs_base_1.TPromise.as([]);
            }
        };
        DataSource.prototype.getParent = function (tree, element) {
            var result = null;
            if (element instanceof referencesModel_1.FileReferences) {
                result = element.parent;
            }
            else if (element instanceof referencesModel_1.OneReference) {
                result = element.parent;
            }
            return winjs_base_1.TPromise.as(result);
        };
        return DataSource;
    }());
    DataSource = __decorate([
        __param(0, resolverService_1.ITextModelResolverService)
    ], DataSource);
    var Controller = (function (_super) {
        __extends(Controller, _super);
        function Controller() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Controller.prototype.onTap = function (tree, element, event) {
            if (element instanceof referencesModel_1.FileReferences) {
                event.preventDefault();
                event.stopPropagation();
                return this._expandCollapse(tree, element);
            }
            var result = _super.prototype.onTap.call(this, tree, element, event);
            tree.emit(Controller.Events.FOCUSED, element);
            return result;
        };
        Controller.prototype.onMouseDown = function (tree, element, event) {
            if (event.leftButton) {
                if (element instanceof referencesModel_1.FileReferences) {
                    event.preventDefault();
                    event.stopPropagation();
                    return this._expandCollapse(tree, element);
                }
                var result = _super.prototype.onClick.call(this, tree, element, event);
                if (event.ctrlKey || event.metaKey) {
                    tree.emit(Controller.Events.OPEN_TO_SIDE, element);
                }
                else if (event.detail === 2) {
                    tree.emit(Controller.Events.SELECTED, element);
                }
                else {
                    tree.emit(Controller.Events.FOCUSED, element);
                }
                return result;
            }
            return false;
        };
        Controller.prototype.onClick = function (tree, element, event) {
            if (event.leftButton) {
                return false; // Already handled by onMouseDown
            }
            return _super.prototype.onClick.call(this, tree, element, event);
        };
        Controller.prototype._expandCollapse = function (tree, element) {
            if (tree.isExpanded(element)) {
                tree.collapse(element).done(null, errors_1.onUnexpectedError);
            }
            else {
                tree.expand(element).done(null, errors_1.onUnexpectedError);
            }
            return true;
        };
        Controller.prototype.onEscape = function (tree, event) {
            return false;
        };
        Controller.prototype.onEnter = function (tree, event) {
            var element = tree.getFocus();
            if (element instanceof referencesModel_1.FileReferences) {
                return this._expandCollapse(tree, element);
            }
            var result = _super.prototype.onEnter.call(this, tree, event);
            if (event.ctrlKey || event.metaKey) {
                tree.emit(Controller.Events.OPEN_TO_SIDE, element);
            }
            else {
                tree.emit(Controller.Events.SELECTED, element);
            }
            return result;
        };
        Controller.prototype.onUp = function (tree, event) {
            _super.prototype.onUp.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onPageUp = function (tree, event) {
            _super.prototype.onPageUp.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onLeft = function (tree, event) {
            _super.prototype.onLeft.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onDown = function (tree, event) {
            _super.prototype.onDown.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onPageDown = function (tree, event) {
            _super.prototype.onPageDown.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onRight = function (tree, event) {
            _super.prototype.onRight.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype._fakeFocus = function (tree, event) {
            // focus next item
            var focus = tree.getFocus();
            tree.setSelection([focus]);
            // send out event
            tree.emit(Controller.Events.FOCUSED, focus);
        };
        return Controller;
    }(treeDefaults_1.DefaultController));
    Controller.Events = {
        FOCUSED: 'events/custom/focused',
        SELECTED: 'events/custom/selected',
        OPEN_TO_SIDE: 'events/custom/opentoside'
    };
    var Renderer = (function (_super) {
        __extends(Renderer, _super);
        function Renderer(contextService) {
            var _this = _super.call(this) || this;
            _this._contextService = contextService;
            return _this;
        }
        Renderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        Renderer.prototype.render = function (tree, element, container) {
            var _this = this;
            dom.clearNode(container);
            if (element instanceof referencesModel_1.FileReferences) {
                var fileReferencesContainer = builder_1.$('.reference-file');
                /* tslint:disable:no-unused-expression */
                new leftRightWidget_1.LeftRightWidget(fileReferencesContainer, function (left) {
                    new iconLabel_1.FileLabel(left, element.uri, _this._contextService);
                    return null;
                }, function (right) {
                    var len = element.children.length;
                    var badge = new countBadge_1.CountBadge(right, len);
                    if (element.failure) {
                        badge.setTitleFormat(nls.localize(0, null));
                    }
                    else if (len > 1) {
                        badge.setTitleFormat(nls.localize(1, null, len));
                    }
                    else {
                        badge.setTitleFormat(nls.localize(2, null, len));
                    }
                    return null;
                });
                /* tslint:enable:no-unused-expression */
                fileReferencesContainer.appendTo(container);
            }
            else if (element instanceof referencesModel_1.OneReference) {
                var preview = element.parent.preview.preview(element.range);
                builder_1.$('.reference').innerHtml(strings.format('<span>{0}</span><span class="referenceMatch">{1}</span><span>{2}</span>', strings.escape(preview.before), strings.escape(preview.inside), strings.escape(preview.after))).appendTo(container);
            }
            return null;
        };
        return Renderer;
    }(treeDefaults_1.LegacyRenderer));
    Renderer = __decorate([
        __param(0, workspace_1.IWorkspaceContextService)
    ], Renderer);
    var VSash = (function () {
        function VSash(container, ratio) {
            var _this = this;
            this._disposables = new lifecycle_1.Disposables();
            this._onDidChangePercentages = new event_1.Emitter();
            this._ratio = ratio;
            this._sash = new sash_1.Sash(container, {
                getVerticalSashLeft: function () { return _this._width * _this._ratio; },
                getVerticalSashHeight: function () { return _this._height; }
            });
            // compute the current widget clientX postion since
            // the sash works with clientX when dragging
            var clientX;
            this._disposables.add(this._sash.addListener2('start', function (e) {
                clientX = e.startX - (_this._width * _this.ratio);
            }));
            this._disposables.add(this._sash.addListener2('change', function (e) {
                // compute the new position of the sash and from that
                // compute the new ratio that we are using
                var newLeft = e.currentX - clientX;
                if (newLeft > 20 && newLeft + 20 < _this._width) {
                    _this._ratio = newLeft / _this._width;
                    _this._sash.layout();
                    _this._onDidChangePercentages.fire(_this);
                }
            }));
        }
        VSash.prototype.dispose = function () {
            this._sash.dispose();
            this._onDidChangePercentages.dispose();
            this._disposables.dispose();
        };
        Object.defineProperty(VSash.prototype, "onDidChangePercentages", {
            get: function () {
                return this._onDidChangePercentages.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "width", {
            set: function (value) {
                this._width = value;
                this._sash.layout();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "height", {
            set: function (value) {
                this._height = value;
                this._sash.layout();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "percentages", {
            get: function () {
                var left = 100 * this._ratio;
                var right = 100 - left;
                return [left + "%", right + "%"];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: true,
            configurable: true
        });
        return VSash;
    }());
    /**
     * ZoneWidget that is shown inside the editor
     */
    var ReferenceWidget = (function (_super) {
        __extends(ReferenceWidget, _super);
        function ReferenceWidget(editor, layoutData, _textModelResolverService, _contextService, _instantiationService) {
            var _this = _super.call(this, editor, { frameColor: '#007ACC', showFrame: false, showArrow: true, isResizeable: true }) || this;
            _this.layoutData = layoutData;
            _this._textModelResolverService = _textModelResolverService;
            _this._contextService = _contextService;
            _this._instantiationService = _instantiationService;
            _this._disposeOnNewModel = [];
            _this._onDidSelectReference = new event_1.Emitter();
            _this._previewModelReference = lifecycle_1.empty;
            _this._instantiationService = _this._instantiationService.createChild(new serviceCollection_1.ServiceCollection([peekViewWidget_1.IPeekViewService, _this]));
            _this.create();
            return _this;
        }
        ReferenceWidget.prototype.dispose = function () {
            this.setModel(null);
            lifecycle_1.dispose(this._preview, this._previewNotAvailableMessage, this._tree, this._sash);
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(ReferenceWidget.prototype, "onDidSelectReference", {
            get: function () {
                return this._onDidSelectReference.event;
            },
            enumerable: true,
            configurable: true
        });
        ReferenceWidget.prototype.show = function (where) {
            this.editor.revealRangeInCenterIfOutsideViewport(where);
            _super.prototype.show.call(this, where, this.layoutData.heightInLines || 18);
        };
        ReferenceWidget.prototype.focus = function () {
            this._tree.DOMFocus();
        };
        ReferenceWidget.prototype._onTitleClick = function (e) {
            if (this._preview && this._preview.getModel()) {
                this._onDidSelectReference.fire({
                    element: this._getFocusedReference(),
                    kind: e.ctrlKey || e.metaKey ? 'side' : 'open',
                    source: 'title'
                });
            }
        };
        ReferenceWidget.prototype._fillBody = function (containerElement) {
            var _this = this;
            var container = builder_1.$(containerElement);
            container.addClass('reference-zone-widget');
            // message pane
            container.div({ 'class': 'messages' }, function (div) {
                _this._messageContainer = div.hide();
            });
            // editor
            container.div({ 'class': 'preview inline' }, function (div) {
                var options = {
                    scrollBeyondLastLine: false,
                    scrollbar: defaultConfig_1.DefaultConfig.editor.scrollbar,
                    overviewRulerLanes: 2,
                    fixedOverflowWidgets: true
                };
                _this._preview = _this._instantiationService.createInstance(embeddedCodeEditorWidget_1.EmbeddedCodeEditorWidget, div.getHTMLElement(), options, _this.editor);
                _this._previewContainer = div.hide();
                _this._previewNotAvailableMessage = model_1.Model.createFromString(nls.localize(3, null));
            });
            // sash
            this._sash = new VSash(containerElement, this.layoutData.ratio || .8);
            this._sash.onDidChangePercentages(function () {
                var _a = _this._sash.percentages, left = _a[0], right = _a[1];
                _this._previewContainer.style({ width: left });
                _this._treeContainer.style({ width: right });
                _this._preview.layout();
                _this._tree.layout();
                _this.layoutData.ratio = _this._sash.ratio;
            });
            // tree
            container.div({ 'class': 'ref-tree inline' }, function (div) {
                var config = {
                    dataSource: _this._instantiationService.createInstance(DataSource),
                    renderer: _this._instantiationService.createInstance(Renderer),
                    //sorter: new Sorter(),
                    controller: new Controller()
                };
                var options = {
                    allowHorizontalScroll: false,
                    twistiePixels: 20,
                    ariaLabel: nls.localize(4, null)
                };
                _this._tree = new treeImpl_1.Tree(div.getHTMLElement(), config, options);
                _this._treeContainer = div.hide();
            });
        };
        ReferenceWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
            _super.prototype._doLayoutBody.call(this, heightInPixel, widthInPixel);
            var height = heightInPixel + 'px';
            this._sash.height = heightInPixel;
            this._sash.width = widthInPixel;
            // set height/width
            var _a = this._sash.percentages, left = _a[0], right = _a[1];
            this._previewContainer.style({ height: height, width: left });
            this._treeContainer.style({ height: height, width: right });
            // forward
            this._tree.layout(heightInPixel);
            this._preview.layout();
            // store layout data
            this.layoutData = {
                heightInLines: this._viewZone.heightInLines,
                ratio: this._sash.ratio
            };
        };
        ReferenceWidget.prototype._onWidth = function (widthInPixel) {
            this._sash.width = widthInPixel;
            this._preview.layout();
        };
        ReferenceWidget.prototype.setSelection = function (selection) {
            return this._revealReference(selection);
        };
        ReferenceWidget.prototype.setModel = function (newModel) {
            // clean up
            this._disposeOnNewModel = lifecycle_1.dispose(this._disposeOnNewModel);
            this._model = newModel;
            if (this._model) {
                return this._onNewModel();
            }
        };
        ReferenceWidget.prototype._onNewModel = function () {
            var _this = this;
            if (this._model.empty) {
                this.setTitle('');
                this._messageContainer.innerHtml(nls.localize(5, null)).show();
                return winjs_base_1.TPromise.as(void 0);
            }
            this._messageContainer.hide();
            this._decorationsManager = new DecorationsManager(this._preview, this._model);
            this._disposeOnNewModel.push(this._decorationsManager);
            // listen on model changes
            this._disposeOnNewModel.push(this._model.onDidChangeReferenceRange(function (reference) { return _this._tree.refresh(reference); }));
            // listen on selection and focus
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.FOCUSED, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._revealReference(element);
                    _this._onDidSelectReference.fire({ element: element, kind: 'show', source: 'tree' });
                }
            }));
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.SELECTED, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._onDidSelectReference.fire({ element: element, kind: 'goto', source: 'tree' });
                }
            }));
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.OPEN_TO_SIDE, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._onDidSelectReference.fire({ element: element, kind: 'side', source: 'tree' });
                }
            }));
            // listen on editor
            this._disposeOnNewModel.push(this._preview.onMouseDown(function (e) {
                if (e.event.detail === 2) {
                    _this._onDidSelectReference.fire({
                        element: _this._getFocusedReference(),
                        kind: (e.event.ctrlKey || e.event.metaKey) ? 'side' : 'open',
                        source: 'editor'
                    });
                }
            }));
            // make sure things are rendered
            dom.addClass(this.container, 'results-loaded');
            this._treeContainer.show();
            this._previewContainer.show();
            this._preview.layout();
            this._tree.layout();
            this.focus();
            // pick input and a reference to begin with
            var input = this._model.groups.length === 1 ? this._model.groups[0] : this._model;
            return this._tree.setInput(input);
        };
        ReferenceWidget.prototype._getFocusedReference = function () {
            var element = this._tree.getFocus();
            if (element instanceof referencesModel_1.OneReference) {
                return element;
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                if (element.children.length > 0) {
                    return element.children[0];
                }
            }
        };
        ReferenceWidget.prototype._revealReference = function (reference) {
            var _this = this;
            // Update widget header
            if (reference.uri.scheme !== network_1.Schemas.inMemory) {
                this.setTitle(reference.name, labels_1.getPathLabel(reference.directory, this._contextService));
            }
            else {
                this.setTitle(nls.localize(6, null));
            }
            var promise = this._textModelResolverService.createModelReference(reference.uri);
            return winjs_base_1.TPromise.join([promise, this._tree.reveal(reference)]).then(function (values) {
                var ref = values[0];
                if (!_this._model) {
                    ref.dispose();
                    // disposed
                    return;
                }
                _this._previewModelReference.dispose();
                _this._previewModelReference = lifecycle_1.empty;
                // show in editor
                var model = ref.object;
                if (model) {
                    _this._previewModelReference = ref;
                    _this._preview.setModel(model.textEditorModel);
                    var sel = range_1.Range.lift(reference.range).collapseToStart();
                    _this._preview.setSelection(sel);
                    _this._preview.revealRangeInCenter(sel);
                }
                else {
                    _this._preview.setModel(_this._previewNotAvailableMessage);
                    ref.dispose();
                }
                // show in tree
                _this._tree.setSelection([reference]);
                _this._tree.setFocus(reference);
            }, errors_1.onUnexpectedError);
        };
        return ReferenceWidget;
    }(peekViewWidget_1.PeekViewWidget));
    exports.ReferenceWidget = ReferenceWidget;
});










define(__m[174/*vs/editor/contrib/referenceSearch/browser/referencesController*/], __M([1/*require*/,0/*exports*/,304/*vs/nls!vs/editor/contrib/referenceSearch/browser/referencesController*/,10/*vs/base/common/errors*/,3/*vs/base/common/lifecycle*/,30/*vs/base/common/severity*/,57/*vs/platform/editor/common/editor*/,12/*vs/base/common/event*/,14/*vs/platform/instantiation/common/instantiation*/,18/*vs/platform/contextkey/common/contextkey*/,49/*vs/platform/message/common/message*/,53/*vs/platform/telemetry/common/telemetry*/,56/*vs/platform/configuration/common/configuration*/,97/*vs/platform/workspace/common/workspace*/,159/*vs/platform/storage/common/storage*/,26/*vs/editor/browser/editorBrowserExtensions*/,90/*vs/editor/contrib/zoneWidget/browser/peekViewWidget*/,503/*vs/editor/contrib/referenceSearch/browser/referencesWidget*/,66/*vs/editor/common/services/resolverService*/]), function (require, exports, nls, errors_1, lifecycle_1, severity_1, editor_1, event_1, instantiation_1, contextkey_1, message_1, telemetry_1, configuration_1, workspace_1, storage_1, editorBrowserExtensions_1, peekViewWidget_1, referencesWidget_1, resolverService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ctxReferenceSearchVisible = new contextkey_1.RawContextKey('referenceSearchVisible', false);
    var ReferencesController = ReferencesController_1 = (function () {
        function ReferencesController(editor, contextKeyService, _editorService, _textModelResolverService, _telemetryService, _messageService, _instantiationService, _contextService, _storageService, _configurationService, _peekViewService) {
            this._editorService = _editorService;
            this._textModelResolverService = _textModelResolverService;
            this._telemetryService = _telemetryService;
            this._messageService = _messageService;
            this._instantiationService = _instantiationService;
            this._contextService = _contextService;
            this._storageService = _storageService;
            this._configurationService = _configurationService;
            this._peekViewService = _peekViewService;
            this._requestIdPool = 0;
            this._disposables = [];
            this._ignoreModelChangeEvent = false;
            this._editor = editor;
            this._referenceSearchVisible = exports.ctxReferenceSearchVisible.bindTo(contextKeyService);
        }
        ReferencesController.get = function (editor) {
            return editor.getContribution(ReferencesController_1.ID);
        };
        ReferencesController.prototype.getId = function () {
            return ReferencesController_1.ID;
        };
        ReferencesController.prototype.dispose = function () {
            if (this._widget) {
                this._widget.dispose();
                this._widget = null;
            }
            this._editor = null;
        };
        ReferencesController.prototype.toggleWidget = function (range, modelPromise, options) {
            var _this = this;
            // close current widget and return early is position didn't change
            var widgetPosition;
            if (this._widget) {
                widgetPosition = this._widget.position;
            }
            this.closeWidget();
            if (!!widgetPosition && range.containsPosition(widgetPosition)) {
                return null;
            }
            this._referenceSearchVisible.set(true);
            // close the widget on model/mode changes
            this._disposables.push(this._editor.onDidChangeModelLanguage(function () { _this.closeWidget(); }));
            this._disposables.push(this._editor.onDidChangeModel(function () {
                if (!_this._ignoreModelChangeEvent) {
                    _this.closeWidget();
                }
            }));
            var storageKey = 'peekViewLayout';
            var data = JSON.parse(this._storageService.get(storageKey, undefined, '{}'));
            this._widget = new referencesWidget_1.ReferenceWidget(this._editor, data, this._textModelResolverService, this._contextService, this._instantiationService);
            this._widget.setTitle(nls.localize(0, null));
            this._widget.show(range);
            this._disposables.push(this._widget.onDidClose(function () {
                modelPromise.cancel();
                _this._storageService.store(storageKey, JSON.stringify(_this._widget.layoutData));
                _this._widget = null;
                _this.closeWidget();
            }));
            this._disposables.push(this._widget.onDidSelectReference(function (event) {
                var element = event.element, kind = event.kind;
                switch (kind) {
                    case 'open':
                        if (event.source === 'editor'
                            && _this._configurationService.lookup('editor.stablePeek').value) {
                            // when stable peek is configured we don't close
                            // the peek window on selecting the editor
                            break;
                        }
                    case 'side':
                        _this._openReference(element, kind === 'side');
                        break;
                    case 'goto':
                        if (options.onGoto) {
                            options.onGoto(element);
                        }
                        else {
                            _this._gotoReference(element);
                        }
                        break;
                }
            }));
            var requestId = ++this._requestIdPool;
            var promise = modelPromise.then(function (model) {
                // still current request? widget still open?
                if (requestId !== _this._requestIdPool || !_this._widget) {
                    return;
                }
                if (_this._model) {
                    _this._model.dispose();
                }
                _this._model = model;
                // measure time it stays open
                var startTime = Date.now();
                _this._disposables.push({
                    dispose: function () {
                        _this._telemetryService.publicLog('zoneWidgetShown', {
                            mode: 'reference search',
                            elapsedTime: Date.now() - startTime
                        });
                    }
                });
                // show widget
                return _this._widget.setModel(_this._model).then(function () {
                    // set title
                    _this._widget.setMetaTitle(options.getMetaTitle(_this._model));
                    // set 'best' selection
                    var uri = _this._editor.getModel().uri;
                    var pos = { lineNumber: range.startLineNumber, column: range.startColumn };
                    var selection = _this._model.nearestReference(uri, pos);
                    if (selection) {
                        return _this._widget.setSelection(selection);
                    }
                });
            }, function (error) {
                _this._messageService.show(severity_1.default.Error, error);
            });
            var onDone = event_1.stopwatch(event_1.fromPromise(promise));
            onDone(function (duration) { return _this._telemetryService.publicLog('findReferences', {
                duration: duration,
                mode: _this._editor.getModel().getLanguageIdentifier().language
            }); });
        };
        ReferencesController.prototype.closeWidget = function () {
            if (this._widget) {
                this._widget.dispose();
                this._widget = null;
            }
            this._referenceSearchVisible.reset();
            this._disposables = lifecycle_1.dispose(this._disposables);
            if (this._model) {
                this._model.dispose();
                this._model = null;
            }
            this._editor.focus();
            this._requestIdPool += 1; // Cancel pending requests
        };
        ReferencesController.prototype._gotoReference = function (ref) {
            var _this = this;
            this._widget.hide();
            this._ignoreModelChangeEvent = true;
            var uri = ref.uri, range = ref.range;
            this._editorService.openEditor({
                resource: uri,
                options: { selection: range }
            }).done(function (openedEditor) {
                _this._ignoreModelChangeEvent = false;
                if (!openedEditor || openedEditor.getControl() !== _this._editor) {
                    // TODO@Alex TODO@Joh
                    // when opening the current reference we might end up
                    // in a different editor instance. that means we also have
                    // a different instance of this reference search controller
                    // and cannot hold onto the widget (which likely doesn't
                    // exist). Instead of bailing out we should find the
                    // 'sister' action and pass our current model on to it.
                    _this.closeWidget();
                    return;
                }
                _this._widget.show(range);
                _this._widget.focus();
            }, function (err) {
                _this._ignoreModelChangeEvent = false;
                errors_1.onUnexpectedError(err);
            });
        };
        ReferencesController.prototype._openReference = function (ref, sideBySide) {
            var uri = ref.uri, range = ref.range;
            this._editorService.openEditor({
                resource: uri,
                options: { selection: range }
            }, sideBySide);
            // clear stage
            if (!sideBySide) {
                this.closeWidget();
            }
        };
        return ReferencesController;
    }());
    ReferencesController.ID = 'editor.contrib.referencesController';
    ReferencesController = ReferencesController_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, contextkey_1.IContextKeyService),
        __param(2, editor_1.IEditorService),
        __param(3, resolverService_1.ITextModelResolverService),
        __param(4, telemetry_1.ITelemetryService),
        __param(5, message_1.IMessageService),
        __param(6, instantiation_1.IInstantiationService),
        __param(7, workspace_1.IWorkspaceContextService),
        __param(8, storage_1.IStorageService),
        __param(9, configuration_1.IConfigurationService),
        __param(10, instantiation_1.optional(peekViewWidget_1.IPeekViewService))
    ], ReferencesController);
    exports.ReferencesController = ReferencesController;
    var ReferencesController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[505/*vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/], __M([1/*require*/,0/*exports*/,288/*vs/nls!vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/,17/*vs/base/common/async*/,10/*vs/base/common/errors*/,32/*vs/base/common/keyCodes*/,19/*vs/base/common/platform*/,30/*vs/base/common/severity*/,9/*vs/base/common/strings*/,6/*vs/base/common/winjs.base*/,23/*vs/base/browser/browser*/,57/*vs/platform/editor/common/editor*/,89/*vs/editor/common/services/modeService*/,49/*vs/platform/message/common/message*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,15/*vs/editor/common/modes*/,26/*vs/editor/browser/editorBrowserExtensions*/,456/*vs/editor/contrib/goToDeclaration/common/goToDeclaration*/,174/*vs/editor/contrib/referenceSearch/browser/referencesController*/,92/*vs/editor/contrib/referenceSearch/browser/referencesModel*/,3/*vs/base/common/lifecycle*/,90/*vs/editor/contrib/zoneWidget/browser/peekViewWidget*/,18/*vs/platform/contextkey/common/contextkey*/,66/*vs/editor/common/services/resolverService*/,367/*vs/css!vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/]), function (require, exports, nls, async_1, errors_1, keyCodes_1, platform, severity_1, strings, winjs_base_1, browser, editor_1, modeService_1, message_1, range_1, editorCommon, editorCommonExtensions_1, modes_1, editorBrowserExtensions_1, goToDeclaration_1, referencesController_1, referencesModel_1, lifecycle_1, peekViewWidget_1, contextkey_1, resolverService_1) {
    'use strict';
    var ModeContextKeys = editorCommon.ModeContextKeys;
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var DefinitionActionConfig = (function () {
        function DefinitionActionConfig(openToSide, openInPeek, filterCurrent) {
            if (openToSide === void 0) { openToSide = false; }
            if (openInPeek === void 0) { openInPeek = false; }
            if (filterCurrent === void 0) { filterCurrent = true; }
            this.openToSide = openToSide;
            this.openInPeek = openInPeek;
            this.filterCurrent = filterCurrent;
            //
        }
        return DefinitionActionConfig;
    }());
    exports.DefinitionActionConfig = DefinitionActionConfig;
    var DefinitionAction = (function (_super) {
        __extends(DefinitionAction, _super);
        function DefinitionAction(configuration, opts) {
            var _this = _super.call(this, opts) || this;
            _this._configuration = configuration;
            return _this;
        }
        DefinitionAction.prototype.run = function (accessor, editor) {
            var _this = this;
            var messageService = accessor.get(message_1.IMessageService);
            var editorService = accessor.get(editor_1.IEditorService);
            var model = editor.getModel();
            var pos = editor.getPosition();
            return this.getDeclarationsAtPosition(model, pos).then(function (references) {
                if (!references) {
                    return;
                }
                // * remove falsy references
                // * remove reference at the current pos
                // * collapse ranges to start pos
                var result = [];
                for (var i = 0; i < references.length; i++) {
                    var reference = references[i];
                    if (!reference || !reference.range) {
                        continue;
                    }
                    var uri = reference.uri, range = reference.range;
                    if (!_this._configuration.filterCurrent
                        || uri.toString() !== model.uri.toString()
                        || !range_1.Range.containsPosition(range, pos)) {
                        result.push({
                            uri: uri,
                            range: range_1.Range.collapseToStart(range)
                        });
                    }
                }
                if (result.length === 0) {
                    return;
                }
                return _this._onResult(editorService, editor, new referencesModel_1.ReferencesModel(result));
            }, function (err) {
                // report an error
                messageService.show(severity_1.default.Error, err);
                return false;
            });
        };
        DefinitionAction.prototype.getDeclarationsAtPosition = function (model, position) {
            return goToDeclaration_1.getDeclarationsAtPosition(model, position);
        };
        DefinitionAction.prototype._onResult = function (editorService, editor, model) {
            var _this = this;
            if (this._configuration.openInPeek) {
                this._openInPeek(editorService, editor, model);
            }
            else {
                var next = model.nearestReference(editor.getModel().uri, editor.getPosition());
                this._openReference(editorService, next, this._configuration.openToSide).then(function (editor) {
                    if (editor && model.references.length > 1) {
                        _this._openInPeek(editorService, editor, model);
                    }
                    else {
                        model.dispose();
                    }
                });
            }
        };
        DefinitionAction.prototype._openReference = function (editorService, reference, sideBySide) {
            var uri = reference.uri, range = reference.range;
            return editorService.openEditor({
                resource: uri,
                options: {
                    selection: range,
                    revealIfVisible: !sideBySide
                }
            }, sideBySide).then(function (editor) {
                return editor && editor.getControl();
            });
        };
        DefinitionAction.prototype._openInPeek = function (editorService, target, model) {
            var _this = this;
            var controller = referencesController_1.ReferencesController.get(target);
            if (controller) {
                controller.toggleWidget(target.getSelection(), winjs_base_1.TPromise.as(model), {
                    getMetaTitle: function (model) {
                        return model.references.length > 1 && nls.localize(0, null, model.references.length);
                    },
                    onGoto: function (reference) {
                        controller.closeWidget();
                        return _this._openReference(editorService, reference, false);
                    }
                });
            }
            else {
                model.dispose();
            }
        };
        return DefinitionAction;
    }(editorCommonExtensions_1.EditorAction));
    exports.DefinitionAction = DefinitionAction;
    var goToDeclarationKb = platform.isWeb
        ? 2048 /* CtrlCmd */ | 70 /* F12 */
        : 70 /* F12 */;
    var GoToDefinitionAction = GoToDefinitionAction_1 = (function (_super) {
        __extends(GoToDefinitionAction, _super);
        function GoToDefinitionAction() {
            return _super.call(this, new DefinitionActionConfig(), {
                id: GoToDefinitionAction_1.ID,
                label: nls.localize(1, null),
                alias: 'Go to Definition',
                precondition: ModeContextKeys.hasDefinitionProvider,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: goToDeclarationKb
                },
                menuOpts: {
                    group: 'navigation',
                    order: 1.1
                }
            }) || this;
        }
        return GoToDefinitionAction;
    }(DefinitionAction));
    GoToDefinitionAction.ID = 'editor.action.goToDeclaration';
    GoToDefinitionAction = GoToDefinitionAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], GoToDefinitionAction);
    exports.GoToDefinitionAction = GoToDefinitionAction;
    var OpenDefinitionToSideAction = OpenDefinitionToSideAction_1 = (function (_super) {
        __extends(OpenDefinitionToSideAction, _super);
        function OpenDefinitionToSideAction() {
            return _super.call(this, new DefinitionActionConfig(true), {
                id: OpenDefinitionToSideAction_1.ID,
                label: nls.localize(2, null),
                alias: 'Open Definition to the Side',
                precondition: ModeContextKeys.hasDefinitionProvider,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: keyCodes_1.KeyChord(2048 /* CtrlCmd */ | 41 /* KEY_K */, goToDeclarationKb)
                }
            }) || this;
        }
        return OpenDefinitionToSideAction;
    }(DefinitionAction));
    OpenDefinitionToSideAction.ID = 'editor.action.openDeclarationToTheSide';
    OpenDefinitionToSideAction = OpenDefinitionToSideAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], OpenDefinitionToSideAction);
    exports.OpenDefinitionToSideAction = OpenDefinitionToSideAction;
    var PeekDefinitionAction = (function (_super) {
        __extends(PeekDefinitionAction, _super);
        function PeekDefinitionAction() {
            return _super.call(this, new DefinitionActionConfig(void 0, true, false), {
                id: 'editor.action.previewDeclaration',
                label: nls.localize(3, null),
                alias: 'Peek Definition',
                precondition: contextkey_1.ContextKeyExpr.and(ModeContextKeys.hasDefinitionProvider, peekViewWidget_1.PeekContext.notInPeekEditor),
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 512 /* Alt */ | 70 /* F12 */,
                    linux: { primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 68 /* F10 */ }
                },
                menuOpts: {
                    group: 'navigation',
                    order: 1.2
                }
            }) || this;
        }
        return PeekDefinitionAction;
    }(DefinitionAction));
    PeekDefinitionAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], PeekDefinitionAction);
    exports.PeekDefinitionAction = PeekDefinitionAction;
    var GoToImplementationAction = GoToImplementationAction_1 = (function (_super) {
        __extends(GoToImplementationAction, _super);
        function GoToImplementationAction() {
            return _super.call(this, new DefinitionActionConfig(), {
                id: GoToImplementationAction_1.ID,
                label: nls.localize(4, null),
                alias: 'Go to Implementation',
                precondition: ModeContextKeys.hasTypeDefinitionProvider,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 70 /* F12 */
                },
                menuOpts: {
                    group: 'navigation',
                    order: 1.3
                }
            }) || this;
        }
        GoToImplementationAction.prototype.getDeclarationsAtPosition = function (model, position) {
            return goToDeclaration_1.getTypeDefinitionAtPosition(model, position);
        };
        return GoToImplementationAction;
    }(DefinitionAction));
    GoToImplementationAction.ID = 'editor.action.goToImplementation';
    GoToImplementationAction = GoToImplementationAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], GoToImplementationAction);
    exports.GoToImplementationAction = GoToImplementationAction;
    var PeekImplementationAction = PeekImplementationAction_1 = (function (_super) {
        __extends(PeekImplementationAction, _super);
        function PeekImplementationAction() {
            return _super.call(this, new DefinitionActionConfig(false, true, false), {
                id: PeekImplementationAction_1.ID,
                label: nls.localize(5, null),
                alias: 'Peek Implementation',
                precondition: ModeContextKeys.hasTypeDefinitionProvider,
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 2048 /* CtrlCmd */ | 1024 /* Shift */ | 70 /* F12 */
                },
                menuOpts: {
                    group: 'navigation',
                    order: 1.3
                }
            }) || this;
        }
        PeekImplementationAction.prototype.getDeclarationsAtPosition = function (model, position) {
            return goToDeclaration_1.getTypeDefinitionAtPosition(model, position);
        };
        return PeekImplementationAction;
    }(DefinitionAction));
    PeekImplementationAction.ID = 'editor.action.peekImplementation';
    PeekImplementationAction = PeekImplementationAction_1 = __decorate([
        editorCommonExtensions_1.editorAction
    ], PeekImplementationAction);
    exports.PeekImplementationAction = PeekImplementationAction;
    // --- Editor Contribution to goto definition using the mouse and a modifier key
    var GotoDefinitionWithMouseEditorContribution = GotoDefinitionWithMouseEditorContribution_1 = (function () {
        function GotoDefinitionWithMouseEditorContribution(editor, textModelResolverService, modeService) {
            var _this = this;
            this.textModelResolverService = textModelResolverService;
            this.modeService = modeService;
            this.toUnhook = [];
            this.decorations = [];
            this.editor = editor;
            this.throttler = new async_1.Throttler();
            this.toUnhook.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
            this.toUnhook.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.toUnhook.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
            this.toUnhook.push(this.editor.onKeyDown(function (e) { return _this.onEditorKeyDown(e); }));
            this.toUnhook.push(this.editor.onKeyUp(function (e) { return _this.onEditorKeyUp(e); }));
            this.toUnhook.push(this.editor.onDidChangeCursorSelection(function (e) { return _this.onDidChangeCursorSelection(e); }));
            this.toUnhook.push(this.editor.onDidChangeModel(function (e) { return _this.resetHandler(); }));
            this.toUnhook.push(this.editor.onDidChangeModelContent(function () { return _this.resetHandler(); }));
            this.toUnhook.push(this.editor.onDidScrollChange(function (e) {
                if (e.scrollTopChanged || e.scrollLeftChanged) {
                    _this.resetHandler();
                }
            }));
        }
        GotoDefinitionWithMouseEditorContribution.prototype.onDidChangeCursorSelection = function (e) {
            if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
                this.resetHandler(); // immediately stop this feature if the user starts to select (https://github.com/Microsoft/vscode/issues/7827)
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseMove = function (mouseEvent, withKey) {
            this.lastMouseMoveEvent = mouseEvent;
            this.startFindDefinition(mouseEvent, withKey);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.startFindDefinition = function (mouseEvent, withKey) {
            var _this = this;
            if (!this.isEnabled(mouseEvent, withKey)) {
                this.currentWordUnderMouse = null;
                this.removeDecorations();
                return;
            }
            // Find word at mouse position
            var position = mouseEvent.target.position;
            var word = position ? this.editor.getModel().getWordAtPosition(position) : null;
            if (!word) {
                this.currentWordUnderMouse = null;
                this.removeDecorations();
                return;
            }
            // Return early if word at position is still the same
            if (this.currentWordUnderMouse && this.currentWordUnderMouse.startColumn === word.startColumn && this.currentWordUnderMouse.endColumn === word.endColumn && this.currentWordUnderMouse.word === word.word) {
                return;
            }
            this.currentWordUnderMouse = word;
            // Find definition and decorate word if found
            var state = this.editor.captureState(editorCommon.CodeEditorStateFlag.Position, editorCommon.CodeEditorStateFlag.Value, editorCommon.CodeEditorStateFlag.Selection, editorCommon.CodeEditorStateFlag.Scroll);
            this.throttler.queue(function () {
                return state.validate(_this.editor)
                    ? _this.findDefinition(mouseEvent.target)
                    : winjs_base_1.TPromise.as(null);
            }).then(function (results) {
                if (!results || !results.length || !state.validate(_this.editor)) {
                    _this.removeDecorations();
                    return;
                }
                // Multiple results
                if (results.length > 1) {
                    _this.addDecoration({
                        startLineNumber: position.lineNumber,
                        startColumn: word.startColumn,
                        endLineNumber: position.lineNumber,
                        endColumn: word.endColumn
                    }, nls.localize(6, null, results.length));
                }
                else {
                    var result_1 = results[0];
                    _this.textModelResolverService.createModelReference(result_1.uri).then(function (ref) {
                        var model = ref.object;
                        var hoverMessage;
                        if (model && model.textEditorModel) {
                            var editorModel = model.textEditorModel;
                            var from = Math.max(1, result_1.range.startLineNumber);
                            var to = void 0;
                            // if we have a range, take that into consideration for the "to" position, otherwise fallback to MAX_SOURCE_PREVIEW_LINES
                            if (!range_1.Range.isEmpty(result_1.range)) {
                                to = Math.min(result_1.range.endLineNumber, result_1.range.startLineNumber + GotoDefinitionWithMouseEditorContribution_1.MAX_SOURCE_PREVIEW_LINES, editorModel.getLineCount());
                            }
                            else {
                                to = Math.min(from + GotoDefinitionWithMouseEditorContribution_1.MAX_SOURCE_PREVIEW_LINES, editorModel.getLineCount());
                            }
                            var source = editorModel.getValueInRange({
                                startLineNumber: from,
                                startColumn: 1,
                                endLineNumber: to,
                                endColumn: editorModel.getLineMaxColumn(to)
                            }).trim();
                            // remove common leading whitespace
                            var min = Number.MAX_VALUE, regexp = /^[ \t]*/, match = void 0, contents = void 0;
                            while (from <= to && min > 0) {
                                contents = editorModel.getLineContent(from++);
                                if (contents.trim().length === 0) {
                                    // empty or whitespace only
                                    continue;
                                }
                                match = regexp.exec(contents);
                                min = Math.min(min, match[0].length);
                            }
                            source = source.replace(new RegExp("^([ \\t]{" + min + "})", 'gm'), strings.empty);
                            if (to < editorModel.getLineCount()) {
                                source += '\n\u2026';
                            }
                            var language = _this.modeService.getModeIdByFilenameOrFirstLine(editorModel.uri.fsPath);
                            hoverMessage = {
                                language: language,
                                value: source
                            };
                        }
                        ref.dispose();
                        _this.addDecoration({
                            startLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endLineNumber: position.lineNumber,
                            endColumn: word.endColumn
                        }, hoverMessage);
                    });
                }
            }).done(undefined, errors_1.onUnexpectedError);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.addDecoration = function (range, hoverMessage) {
            var newDecorations = {
                range: range,
                options: {
                    inlineClassName: 'goto-definition-link',
                    hoverMessage: hoverMessage
                }
            };
            this.decorations = this.editor.deltaDecorations(this.decorations, [newDecorations]);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.removeDecorations = function () {
            if (this.decorations.length > 0) {
                this.decorations = this.editor.deltaDecorations(this.decorations, []);
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorKeyDown = function (e) {
            if (this.lastMouseMoveEvent && (e.keyCode === GotoDefinitionWithMouseEditorContribution_1.TRIGGER_KEY_VALUE ||
                e.keyCode === GotoDefinitionWithMouseEditorContribution_1.TRIGGER_SIDEBYSIDE_KEY_VALUE && e[GotoDefinitionWithMouseEditorContribution_1.TRIGGER_MODIFIER] // User pressed Ctrl/Cmd+Alt (goto definition to the side)
            )) {
                this.startFindDefinition(this.lastMouseMoveEvent, e);
            }
            else if (e[GotoDefinitionWithMouseEditorContribution_1.TRIGGER_MODIFIER]) {
                this.removeDecorations(); // remove decorations if user holds another key with ctrl/cmd to prevent accident goto declaration
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.resetHandler = function () {
            this.lastMouseMoveEvent = null;
            this.hasTriggerKeyOnMouseDown = false;
            this.removeDecorations();
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseDown = function (mouseEvent) {
            // We need to record if we had the trigger key on mouse down because someone might select something in the editor
            // holding the mouse down and then while mouse is down start to press Ctrl/Cmd to start a copy operation and then
            // release the mouse button without wanting to do the navigation.
            // With this flag we prevent goto definition if the mouse was down before the trigger key was pressed.
            this.hasTriggerKeyOnMouseDown = !!mouseEvent.event[GotoDefinitionWithMouseEditorContribution_1.TRIGGER_MODIFIER];
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseUp = function (mouseEvent) {
            var _this = this;
            if (this.isEnabled(mouseEvent) && this.hasTriggerKeyOnMouseDown) {
                this.gotoDefinition(mouseEvent.target, mouseEvent.event.altKey).done(function () {
                    _this.removeDecorations();
                }, function (error) {
                    _this.removeDecorations();
                    errors_1.onUnexpectedError(error);
                });
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorKeyUp = function (e) {
            if (e.keyCode === GotoDefinitionWithMouseEditorContribution_1.TRIGGER_KEY_VALUE) {
                this.removeDecorations();
                this.currentWordUnderMouse = null;
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.isEnabled = function (mouseEvent, withKey) {
            return this.editor.getModel() &&
                (browser.isIE || mouseEvent.event.detail <= 1) &&
                mouseEvent.target.type === editorCommon.MouseTargetType.CONTENT_TEXT &&
                (mouseEvent.event[GotoDefinitionWithMouseEditorContribution_1.TRIGGER_MODIFIER] || (withKey && withKey.keyCode === GotoDefinitionWithMouseEditorContribution_1.TRIGGER_KEY_VALUE)) &&
                modes_1.DefinitionProviderRegistry.has(this.editor.getModel());
        };
        GotoDefinitionWithMouseEditorContribution.prototype.findDefinition = function (target) {
            var model = this.editor.getModel();
            if (!model) {
                return winjs_base_1.TPromise.as(null);
            }
            return goToDeclaration_1.getDeclarationsAtPosition(this.editor.getModel(), target.position);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.gotoDefinition = function (target, sideBySide) {
            var targetAction = sideBySide
                ? OpenDefinitionToSideAction.ID
                : GoToDefinitionAction.ID;
            // just run the corresponding action
            this.editor.setPosition(target.position);
            return this.editor.getAction(targetAction).run();
        };
        GotoDefinitionWithMouseEditorContribution.prototype.getId = function () {
            return GotoDefinitionWithMouseEditorContribution_1.ID;
        };
        GotoDefinitionWithMouseEditorContribution.prototype.dispose = function () {
            this.toUnhook = lifecycle_1.dispose(this.toUnhook);
        };
        return GotoDefinitionWithMouseEditorContribution;
    }());
    GotoDefinitionWithMouseEditorContribution.ID = 'editor.contrib.gotodefinitionwithmouse';
    GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
    GotoDefinitionWithMouseEditorContribution.TRIGGER_SIDEBYSIDE_KEY_VALUE = 6 /* Alt */;
    GotoDefinitionWithMouseEditorContribution.TRIGGER_KEY_VALUE = platform.isMacintosh ? 57 /* Meta */ : 5 /* Ctrl */;
    GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES = 7;
    GotoDefinitionWithMouseEditorContribution = GotoDefinitionWithMouseEditorContribution_1 = __decorate([
        editorBrowserExtensions_1.editorContribution,
        __param(1, resolverService_1.ITextModelResolverService),
        __param(2, modeService_1.IModeService)
    ], GotoDefinitionWithMouseEditorContribution);
    var GoToDefinitionAction_1, OpenDefinitionToSideAction_1, GoToImplementationAction_1, PeekImplementationAction_1, GotoDefinitionWithMouseEditorContribution_1;
});















define(__m[226/*vs/editor/contrib/referenceSearch/browser/referenceSearch*/], __M([1/*require*/,0/*exports*/,303/*vs/nls!vs/editor/contrib/referenceSearch/browser/referenceSearch*/,27/*vs/base/common/uri*/,6/*vs/base/common/winjs.base*/,57/*vs/platform/editor/common/editor*/,14/*vs/platform/instantiation/common/instantiation*/,22/*vs/platform/commands/common/commands*/,18/*vs/platform/contextkey/common/contextkey*/,68/*vs/platform/keybinding/common/keybindingsRegistry*/,16/*vs/editor/common/core/position*/,4/*vs/editor/common/core/range*/,2/*vs/editor/common/editorCommon*/,13/*vs/editor/common/editorCommonExtensions*/,90/*vs/editor/contrib/zoneWidget/browser/peekViewWidget*/,477/*vs/editor/contrib/referenceSearch/common/referenceSearch*/,174/*vs/editor/contrib/referenceSearch/browser/referencesController*/,92/*vs/editor/contrib/referenceSearch/browser/referencesModel*/]), function (require, exports, nls, uri_1, winjs_base_1, editor_1, instantiation_1, commands_1, contextkey_1, keybindingsRegistry_1, position_1, range_1, editorCommon, editorCommonExtensions_1, peekViewWidget_1, referenceSearch_1, referencesController_1, referencesModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModeContextKeys = editorCommon.ModeContextKeys;
    var EditorContextKeys = editorCommon.EditorContextKeys;
    var defaultReferenceSearchOptions = {
        getMetaTitle: function (model) {
            return model.references.length > 1 && nls.localize(0, null, model.references.length);
        }
    };
    var ReferenceController = ReferenceController_1 = (function () {
        function ReferenceController(editor, contextKeyService, peekViewService) {
            if (peekViewService) {
                peekViewWidget_1.PeekContext.inPeekEditor.bindTo(contextKeyService);
            }
        }
        ReferenceController.prototype.dispose = function () {
        };
        ReferenceController.prototype.getId = function () {
            return ReferenceController_1.ID;
        };
        return ReferenceController;
    }());
    ReferenceController.ID = 'editor.contrib.referenceController';
    ReferenceController = ReferenceController_1 = __decorate([
        editorCommonExtensions_1.commonEditorContribution,
        __param(1, contextkey_1.IContextKeyService),
        __param(2, instantiation_1.optional(peekViewWidget_1.IPeekViewService))
    ], ReferenceController);
    exports.ReferenceController = ReferenceController;
    var ReferenceAction = (function (_super) {
        __extends(ReferenceAction, _super);
        function ReferenceAction() {
            return _super.call(this, {
                id: 'editor.action.referenceSearch.trigger',
                label: nls.localize(1, null),
                alias: 'Find All References',
                precondition: contextkey_1.ContextKeyExpr.and(ModeContextKeys.hasReferenceProvider, peekViewWidget_1.PeekContext.notInPeekEditor),
                kbOpts: {
                    kbExpr: EditorContextKeys.TextFocus,
                    primary: 1024 /* Shift */ | 70 /* F12 */
                },
                menuOpts: {
                    group: 'navigation',
                    order: 1.3
                }
            }) || this;
        }
        ReferenceAction.prototype.run = function (accessor, editor) {
            var controller = referencesController_1.ReferencesController.get(editor);
            if (!controller) {
                return;
            }
            var range = editor.getSelection();
            var model = editor.getModel();
            var references = referenceSearch_1.provideReferences(model, range.getStartPosition()).then(function (references) { return new referencesModel_1.ReferencesModel(references); });
            controller.toggleWidget(range, references, defaultReferenceSearchOptions);
        };
        return ReferenceAction;
    }(editorCommonExtensions_1.EditorAction));
    ReferenceAction = __decorate([
        editorCommonExtensions_1.editorAction
    ], ReferenceAction);
    exports.ReferenceAction = ReferenceAction;
    var findReferencesCommand = function (accessor, resource, position) {
        if (!(resource instanceof uri_1.default)) {
            throw new Error('illegal argument, uri');
        }
        if (!position) {
            throw new Error('illegal argument, position');
        }
        return accessor.get(editor_1.IEditorService).openEditor({ resource: resource }).then(function (editor) {
            var control = editor.getControl();
            if (!control || typeof control.getEditorType !== 'function') {
                return;
            }
            var controller = referencesController_1.ReferencesController.get(control);
            if (!controller) {
                return;
            }
            var references = referenceSearch_1.provideReferences(control.getModel(), position_1.Position.lift(position)).then(function (references) { return new referencesModel_1.ReferencesModel(references); });
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            return winjs_base_1.TPromise.as(controller.toggleWidget(range, references, defaultReferenceSearchOptions));
        });
    };
    var showReferencesCommand = function (accessor, resource, position, references) {
        if (!(resource instanceof uri_1.default)) {
            throw new Error('illegal argument, uri expected');
        }
        return accessor.get(editor_1.IEditorService).openEditor({ resource: resource }).then(function (editor) {
            var control = editor.getControl();
            if (!control || typeof control.getEditorType !== 'function') {
                return;
            }
            var controller = referencesController_1.ReferencesController.get(control);
            if (!controller) {
                return;
            }
            return winjs_base_1.TPromise.as(controller.toggleWidget(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), winjs_base_1.TPromise.as(new referencesModel_1.ReferencesModel(references)), defaultReferenceSearchOptions)).then(function () { return true; });
        });
    };
    // register commands
    commands_1.CommandsRegistry.registerCommand('editor.action.findReferences', findReferencesCommand);
    commands_1.CommandsRegistry.registerCommand('editor.action.showReferences', {
        handler: showReferencesCommand,
        description: {
            description: 'Show references at a position in a file',
            args: [
                { name: 'uri', description: 'The text document in which to show references', constraint: uri_1.default },
                { name: 'position', description: 'The position at which to show', constraint: position_1.Position.isIPosition },
                { name: 'locations', description: 'An array of locations.', constraint: Array },
            ]
        }
    });
    function closeActiveReferenceSearch(accessor, args) {
        var outerEditor = peekViewWidget_1.getOuterEditor(accessor, args);
        if (!outerEditor) {
            return;
        }
        var controller = referencesController_1.ReferencesController.get(outerEditor);
        if (!controller) {
            return;
        }
        controller.closeWidget();
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'closeReferenceSearch',
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50),
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */],
        when: contextkey_1.ContextKeyExpr.and(referencesController_1.ctxReferenceSearchVisible, contextkey_1.ContextKeyExpr.not('config.editor.stablePeek')),
        handler: closeActiveReferenceSearch
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: 'closeReferenceSearchEditor',
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(-101),
        primary: 9 /* Escape */,
        secondary: [1024 /* Shift */ | 9 /* Escape */],
        when: contextkey_1.ContextKeyExpr.and(peekViewWidget_1.PeekContext.inPeekEditor, contextkey_1.ContextKeyExpr.not('config.editor.stablePeek')),
        handler: closeActiveReferenceSearch
    });
    var ReferenceController_1;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[257/*vs/editor/browser/editor.all*/], __M([1/*require*/,0/*exports*/,167/*vs/editor/browser/widget/codeEditorWidget*/,169/*vs/editor/browser/widget/diffEditorWidget*/,443/*vs/editor/contrib/bracketMatching/common/bracketMatching*/,357/*vs/css!vs/editor/contrib/bracketMatching/browser/bracketMatching*/,445/*vs/editor/contrib/clipboard/browser/clipboard*/,447/*vs/editor/contrib/codelens/browser/codelens*/,448/*vs/editor/contrib/comment/common/comment*/,449/*vs/editor/contrib/contextmenu/browser/contextmenu*/,122/*vs/editor/contrib/diffNavigator/common/diffNavigator*/,452/*vs/editor/contrib/find/browser/find*/,455/*vs/editor/contrib/format/common/formatActions*/,505/*vs/editor/contrib/goToDeclaration/browser/goToDeclaration*/,457/*vs/editor/contrib/gotoError/browser/gotoError*/,460/*vs/editor/contrib/hover/browser/hover*/,373/*vs/css!vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace*/,461/*vs/editor/contrib/inPlaceReplace/common/inPlaceReplace*/,422/*vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard*/,463/*vs/editor/contrib/linesOperations/common/linesOperations*/,444/*vs/editor/contrib/caretOperations/common/caretOperations*/,464/*vs/editor/contrib/links/browser/links*/,465/*vs/editor/contrib/multicursor/common/multicursor*/,423/*vs/editor/contrib/multicursor/browser/menuPreventer*/,468/*vs/editor/contrib/parameterHints/browser/parameterHints*/,471/*vs/editor/contrib/quickFix/browser/quickFix*/,226/*vs/editor/contrib/referenceSearch/browser/referenceSearch*/,479/*vs/editor/contrib/rename/browser/rename*/,480/*vs/editor/contrib/smartSelect/common/smartSelect*/,93/*vs/editor/contrib/snippet/common/snippet*/,235/*vs/editor/contrib/snippet/browser/snippet*/,486/*vs/editor/contrib/suggest/browser/suggestController*/,482/*vs/editor/contrib/suggest/browser/tabCompletion*/,487/*vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode*/,416/*vs/css!vs/editor/contrib/wordHighlighter/browser/wordHighlighter*/,488/*vs/editor/contrib/wordHighlighter/common/wordHighlighter*/,453/*vs/editor/contrib/folding/browser/folding*/]), function (require, exports) {
    'use strict';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[508/*vs/editor/editor.main*/], __M([1/*require*/,0/*exports*/,136/*vs/editor/common/standalone/standaloneBase*/,501/*vs/editor/browser/standalone/standaloneEditor*/,502/*vs/editor/browser/standalone/standaloneLanguages*/,44/*vs/editor/common/config/defaultConfig*/,257/*vs/editor/browser/editor.all*/,476/*vs/editor/contrib/quickOpen/browser/quickOutline*/,473/*vs/editor/contrib/quickOpen/browser/gotoLine*/,474/*vs/editor/contrib/quickOpen/browser/quickCommand*/,462/*vs/editor/contrib/inspectTokens/browser/inspectTokens*/]), function (require, exports, standaloneBase_1, standaloneEditor_1, standaloneLanguages_1, defaultConfig_1) {
    'use strict';
    // Set defaults for standalone editor
    defaultConfig_1.DefaultConfig.editor.wrappingIndent = 'none';
    defaultConfig_1.DefaultConfig.editor.folding = false;
    defaultConfig_1.DefaultConfig.editor.glyphMargin = false;
    var global = self;
    global.monaco = standaloneBase_1.createMonacoBaseAPI();
    global.monaco.editor = standaloneEditor_1.createMonacoEditorAPI();
    global.monaco.languages = standaloneLanguages_1.createMonacoLanguagesAPI();
    if (typeof global.require !== 'undefined' && typeof global.require.config === 'function') {
        global.require.config({
            ignoreDuplicateModules: [
                'vscode-languageserver-types',
                'vscode-languageserver-types/main',
            ]
        });
    }
});

}).call(this);

/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-typescript version: 2.1.1(ab02fc640209fa57ff4703663be59d93c37b2b5b)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-typescript/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
define("vs/language/typescript/src/monaco.contribution",["require","exports","vs/editor/edcore.main"],function(e,t){"use strict";function n(){return new monaco.Promise(function(e,t){r(function(n){n.getTypeScriptWorker().then(e,t)})})}function i(){return new monaco.Promise(function(e,t){r(function(n){n.getJavaScriptWorker().then(e,t)})})}function o(){return{ModuleKind:c,JsxEmit:p,NewLineKind:u,ScriptTarget:f,ModuleResolutionKind:d,typescriptDefaults:S,javascriptDefaults:m,getTypeScriptWorker:n,getJavaScriptWorker:i}}function r(t){e(["vs/language/typescript/src/mode"],t)}var a=monaco.Emitter,s=function(){function e(e,t){this._onDidChange=new a,this._extraLibs=Object.create(null),this._workerMaxIdleTime=12e4,this.setCompilerOptions(e),this.setDiagnosticsOptions(t)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),e.prototype.getExtraLibs=function(){var e=Object.create(null);for(var t in this._extraLibs)e[t]=this._extraLibs[t];return Object.freeze(e)},e.prototype.addExtraLib=function(e,t){var n=this;if("undefined"==typeof t&&(t="ts:extralib-"+Date.now()),this._extraLibs[t])throw new Error(t+" already a extra lib");return this._extraLibs[t]=e,this._onDidChange.fire(this),{dispose:function(){delete n._extraLibs[t]&&n._onDidChange.fire(n)}}},e.prototype.getCompilerOptions=function(){return this._compilerOptions},e.prototype.setCompilerOptions=function(e){this._compilerOptions=e||Object.create(null),this._onDidChange.fire(this)},e.prototype.getDiagnosticsOptions=function(){return this._diagnosticsOptions},e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e.prototype.setMaximunWorkerIdleTime=function(e){this._workerMaxIdleTime=e},e.prototype.getWorkerMaxIdleTime=function(){return this._workerMaxIdleTime},e}();t.LanguageServiceDefaultsImpl=s;var c;!function(e){e[e.None=0]="None",e[e.CommonJS=1]="CommonJS",e[e.AMD=2]="AMD",e[e.UMD=3]="UMD",e[e.System=4]="System",e[e.ES2015=5]="ES2015"}(c||(c={}));var p;!function(e){e[e.None=0]="None",e[e.Preserve=1]="Preserve",e[e.React=2]="React"}(p||(p={}));var u;!function(e){e[e.CarriageReturnLineFeed=0]="CarriageReturnLineFeed",e[e.LineFeed=1]="LineFeed"}(u||(u={}));var l;!function(e){e[e.Unknown=0]="Unknown",e[e.JS=1]="JS",e[e.JSX=2]="JSX",e[e.TS=3]="TS",e[e.TSX=4]="TSX"}(l||(l={}));var f;!function(e){e[e.ES3=0]="ES3",e[e.ES5=1]="ES5",e[e.ES2015=2]="ES2015",e[e.ES2016=3]="ES2016",e[e.ES2017=4]="ES2017",e[e.ESNext=5]="ESNext",e[e.Latest=5]="Latest"}(f||(f={}));var g;!function(e){e[e.Standard=0]="Standard",e[e.JSX=1]="JSX"}(g||(g={}));var d;!function(e){e[e.Classic=1]="Classic",e[e.NodeJs=2]="NodeJs"}(d||(d={}));var S=new s({allowNonTsExtensions:!0,target:f.Latest},{noSemanticValidation:!1,noSyntaxValidation:!1}),m=new s({allowNonTsExtensions:!0,allowJs:!0,target:f.Latest},{noSemanticValidation:!0,noSyntaxValidation:!1});monaco.languages.typescript=o(),monaco.languages.register({id:"typescript",extensions:[".ts",".tsx"],aliases:["TypeScript","ts","typescript"],mimetypes:["text/typescript"]}),monaco.languages.onLanguage("typescript",function(){r(function(e){return e.setupTypeScript(S)})}),monaco.languages.register({id:"javascript",extensions:[".js",".es6",".jsx"],firstLine:"^#!.*\\bnode",filenames:["jakefile"],aliases:["JavaScript","javascript","js"],mimetypes:["text/javascript"]}),monaco.languages.onLanguage("javascript",function(){r(function(e){return e.setupJavaScript(m)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-css version: 1.3.0(6787816d8e12533292fca5e861cc1769c775d1e7)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-css/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
!function(e){if("object"==typeof module&&"object"==typeof module.exports){var n=e(require,exports);void 0!==n&&(module.exports=n)}else"function"==typeof define&&define.amd&&define("vs/language/css/monaco.contribution",["require","exports","vs/editor/edcore.main"],e)}(function(e,n){function o(){return{cssDefaults:a,lessDefaults:g,scssDefaults:u}}function t(n){e(["vs/language/css/cssMode"],n)}var i=monaco.Emitter,r=function(){function e(e,n){this._onDidChange=new i,this._languageId=e,this.setDiagnosticsOptions(n)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"languageId",{get:function(){return this._languageId},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"diagnosticsOptions",{get:function(){return this._diagnosticsOptions},enumerable:!0,configurable:!0}),e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e}();n.LanguageServiceDefaultsImpl=r;var s={validate:!0,lint:{compatibleVendorPrefixes:"ignore",vendorPrefix:"warning",duplicateProperties:"warning",emptyRules:"warning",importStatement:"ignore",boxModel:"ignore",universalSelector:"ignore",zeroUnits:"ignore",fontFaceProperties:"warning",hexColorLength:"error",argumentsInColorFunction:"error",unknownProperties:"warning",ieHack:"ignore",unknownVendorSpecificProperties:"ignore",propertyIgnoredDueToDisplay:"warning",important:"ignore","float":"ignore",idSelector:"ignore"}},a=new r("css",s),u=new r("scss",s),g=new r("less",s);monaco.languages.css=o(),monaco.languages.onLanguage("less",function(){t(function(e){return e.setupMode(g)})}),monaco.languages.onLanguage("scss",function(){t(function(e){return e.setupMode(u)})}),monaco.languages.onLanguage("css",function(){t(function(e){return e.setupMode(a)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-json version: 1.2.0(8b2dab26d2ce177819a0347af6142d2c30309f1f)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-json/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
!function(e){if("object"==typeof module&&"object"==typeof module.exports){var n=e(require,exports);void 0!==n&&(module.exports=n)}else"function"==typeof define&&define.amd&&define("vs/language/json/monaco.contribution",["require","exports","vs/editor/edcore.main"],e)}(function(e,n){function o(){return{jsonDefaults:r}}function t(n){e(["vs/language/json/jsonMode"],n)}var i=monaco.Emitter,s=function(){function e(e,n){this._onDidChange=new i,this._languageId=e,this.setDiagnosticsOptions(n)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"languageId",{get:function(){return this._languageId},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"diagnosticsOptions",{get:function(){return this._diagnosticsOptions},enumerable:!0,configurable:!0}),e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e}();n.LanguageServiceDefaultsImpl=s;var a={validate:!0,allowComments:!0,schemas:[]},r=new s("json",a);monaco.languages.json=o(),monaco.languages.register({id:"json",extensions:[".json",".bowerrc",".jshintrc",".jscsrc",".eslintrc",".babelrc"],aliases:["JSON","json"],mimetypes:["application/json"]}),monaco.languages.onLanguage("json",function(){t(function(e){return e.setupMode(r)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-html version: 1.2.0(04170905b37195921ea16386111f78247530f3cb)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-html/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
!function(e){if("object"==typeof module&&"object"==typeof module.exports){var n=e(require,exports);void 0!==n&&(module.exports=n)}else"function"==typeof define&&define.amd&&define("vs/language/html/monaco.contribution",["require","exports","vs/editor/edcore.main"],e)}(function(e,n){function t(){return{htmlDefaults:m,razorDefaults:p,handlebarDefaults:d}}function o(n){e(["vs/language/html/htmlMode"],n)}var a=monaco.Emitter,r=function(){function e(e,n){this._onDidChange=new a,this._languageId=e,this.setOptions(n)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"languageId",{get:function(){return this._languageId},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"options",{get:function(){return this._options},enumerable:!0,configurable:!0}),e.prototype.setOptions=function(e){this._options=e||Object.create(null),this._onDidChange.fire(this)},e}();n.LanguageServiceDefaultsImpl=r;var i={tabSize:4,insertSpaces:!1,wrapLineLength:120,unformatted:"a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, script, select, small, span, strong, sub, sup, textarea, tt, var",indentInnerHtml:!1,preserveNewLines:!0,maxPreserveNewLines:null,indentHandlebars:!1,endWithNewline:!1,extraLiners:"head, body, /html"},u={format:i,suggest:{html5:!0,angular1:!0,ionic:!0}},s={format:i,suggest:{html5:!0}},l={format:i,suggest:{html5:!0,razor:!0}},g="html",c="handlebars",f="razor",m=new r(g,u),p=new r(c,s),d=new r(f,l);monaco.languages.html=t(),monaco.languages.onLanguage(g,function(){o(function(e){return e.setupMode(m)})}),monaco.languages.onLanguage(c,function(){o(function(e){return e.setupMode(p)})}),monaco.languages.onLanguage(f,function(){o(function(e){return e.setupMode(d)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-languages version: 0.7.0(18916e97a4ff0f1b195d68d01d632631cc84d50e)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-languages/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
define("vs/basic-languages/src/monaco.contribution",["require","exports","vs/editor/edcore.main"],function(e,s){function i(s){var i=l[s].module;return new o.Promise(function(a,t,l){e([i],function(e){o.languages.setMonarchTokensProvider(s,e.language),o.languages.setLanguageConfiguration(s,e.conf),a(void 0)},t)})}function a(e){return n[e]||(n[e]=i(e)),n[e]}function t(e){var s=e.id;l[s]=e,o.languages.register(e),o.languages.onLanguage(s,function(){a(s)})}var o="undefined"==typeof monaco?self.monaco:monaco,l={},n={};s.loadLanguage=a,t({id:"bat",extensions:[".bat",".cmd"],aliases:["Batch","bat"],module:"./bat"}),t({id:"coffeescript",extensions:[".coffee"],aliases:["CoffeeScript","coffeescript","coffee"],mimetypes:["text/x-coffeescript","text/coffeescript"],module:"./coffee"}),t({id:"c",extensions:[".c",".h"],aliases:["C","c"],module:"./cpp"}),t({id:"cpp",extensions:[".cpp",".cc",".cxx",".hpp",".hh",".hxx"],aliases:["C++","Cpp","cpp"],module:"./cpp"}),t({id:"csharp",extensions:[".cs",".csx"],aliases:["C#","csharp"],module:"./csharp"}),t({id:"dockerfile",extensions:[".dockerfile"],filenames:["Dockerfile"],aliases:["Dockerfile"],module:"./dockerfile"}),t({id:"fsharp",extensions:[".fs",".fsi",".ml",".mli",".fsx",".fsscript"],aliases:["F#","FSharp","fsharp"],module:"./fsharp"}),t({id:"go",extensions:[".go"],aliases:["Go"],module:"./go"}),t({id:"handlebars",extensions:[".handlebars",".hbs"],aliases:["Handlebars","handlebars"],mimetypes:["text/x-handlebars-template"],module:"./handlebars"}),t({id:"html",extensions:[".html",".htm",".shtml",".xhtml",".mdoc",".jsp",".asp",".aspx",".jshtm"],aliases:["HTML","htm","html","xhtml"],mimetypes:["text/html","text/x-jshtm","text/template","text/ng-template"],module:"./html"}),t({id:"ini",extensions:[".ini",".properties",".gitconfig"],filenames:["config",".gitattributes",".gitconfig",".editorconfig"],aliases:["Ini","ini"],module:"./ini"}),t({id:"jade",extensions:[".jade",".pug"],aliases:["Jade","jade"],module:"./jade"}),t({id:"java",extensions:[".java",".jav"],aliases:["Java","java"],mimetypes:["text/x-java-source","text/x-java"],module:"./java"}),t({id:"lua",extensions:[".lua"],aliases:["Lua","lua"],module:"./lua"}),t({id:"markdown",extensions:[".md",".markdown",".mdown",".mkdn",".mkd",".mdwn",".mdtxt",".mdtext"],aliases:["Markdown","markdown"],module:"./markdown"}),t({id:"objective-c",extensions:[".m"],aliases:["Objective-C"],module:"./objective-c"}),t({id:"postiats",extensions:[".dats",".sats",".hats"],aliases:["ATS","ATS/Postiats"],module:"./postiats"}),t({id:"php",extensions:[".php",".php4",".php5",".phtml",".ctp"],aliases:["PHP","php"],mimetypes:["application/x-php"],module:"./php"}),t({id:"powershell",extensions:[".ps1",".psm1",".psd1"],aliases:["PowerShell","powershell","ps","ps1"],module:"./powershell"}),t({id:"python",extensions:[".py",".rpy",".pyw",".cpy",".gyp",".gypi"],aliases:["Python","py"],firstLine:"^#!/.*\\bpython[0-9.-]*\\b",module:"./python"}),t({id:"r",extensions:[".r",".rhistory",".rprofile",".rt"],aliases:["R","r"],module:"./r"}),t({id:"razor",extensions:[".cshtml"],aliases:["Razor","razor"],mimetypes:["text/x-cshtml"],module:"./razor"}),t({id:"ruby",extensions:[".rb",".rbx",".rjs",".gemspec",".pp"],filenames:["rakefile"],aliases:["Ruby","rb"],module:"./ruby"}),t({id:"swift",aliases:["Swift","swift"],extensions:[".swift"],mimetypes:["text/swift"],module:"./swift"}),t({id:"sql",extensions:[".sql"],aliases:["SQL"],module:"./sql"}),t({id:"vb",extensions:[".vb"],aliases:["Visual Basic","vb"],module:"./vb"}),t({id:"xml",extensions:[".xml",".dtd",".ascx",".csproj",".config",".wxi",".wxl",".wxs",".xaml",".svg",".svgz"],firstLine:"(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",aliases:["XML","xml"],mimetypes:["text/xml","application/xml","application/xaml+xml","application/xml-dtd"],module:"./xml"}),t({id:"less",extensions:[".less"],aliases:["Less","less"],mimetypes:["text/x-less","text/less"],module:"./less"}),t({id:"scss",extensions:[".scss"],aliases:["Sass","sass","scss"],mimetypes:["text/x-scss","text/scss"],module:"./scss"}),t({id:"css",extensions:[".css"],aliases:["CSS","css"],mimetypes:["text/css"],module:"./css"}),t({id:"yaml",extensions:[".yaml",".yml"],aliases:["YAML","yaml","YML","yml"],mimetypes:["application/x-yaml"],module:"./yaml"})});
define("vs/editor/editor.main", ["vs/editor/edcore.main","vs/language/typescript/src/monaco.contribution","vs/language/css/monaco.contribution","vs/language/json/monaco.contribution","vs/language/html/monaco.contribution","vs/basic-languages/src/monaco.contribution"], function() {});
//# sourceMappingURL=editor.main.js.map
